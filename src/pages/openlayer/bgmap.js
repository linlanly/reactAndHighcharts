!function (t, e) {
  "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).VgoMap = e()
}(this, (function () {
  "use strict";
  const t = HTMLElement.prototype.appendChild;
  HTMLElement.prototype.appendChild = function () {
    var e;
    return (null === (e = arguments[0].src) || void 0 === e ? void 0 : e.includes("amap.com/v3/log/init")) || t.apply(this, arguments),
      this
  }
    ,
    new Function('(function(config){!function(global,factory){"object"==typeof exports&&"undefined"!=typeof module?module.exports=factory():"function"==typeof define&&define.amd?define(factory):(global=global||self).AMap=factory()}(this,function(){"use strict";var shared,worker,AMap;function define(_,chunk){var sharedChunk,workerBundleString;shared?worker?(workerBundleString=\'var sharedChunk = {key:"\'+config[0]+\'",db:"\'+(config[14]||"")+\'",nebulaVersion:"\'+(config[15]||"")+\'",movingDraw:\'+Boolean(window.movingDraw)+\',host:"\'+config[2]+\'",}; (\'+shared+")(sharedChunk); ("+worker+")(sharedChunk);",sharedChunk={key:config[0],movingDraw:window.movingDraw},shared(sharedChunk),sharedChunk=chunk(sharedChunk),workerBundleString="undefined"!=typeof URL?window.URL.createObjectURL(new Blob([workerBundleString],{type:"text/javascript"})):"",(AMap=sharedChunk(config)).getConfig().workerUrl=workerBundleString):worker=chunk:shared=chunk}define(["exports"],function(exports){var extend=function(t){for(var r,n,i=Array.prototype.slice.call(arguments,1),a=0,o=i.length;a<o;a+=1)for(var s in r=i[a]||{})r.hasOwnProperty(s)&&("function"==typeof(n=r[s])&&t.prototype?t.prototype[s]=n:t[s]=n);return t};function isBrowser(){return"undefined"!=typeof window&&"undefined"!=typeof document}function isWasmSuppport(){try{if("object"==typeof WebAssembly&&"function"==typeof WebAssembly.instantiate&&TextDecoder&&TextEncoder){var t=new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0]));if(t instanceof WebAssembly.Module)return new WebAssembly.Instance(t)instanceof WebAssembly.Instance}}catch(t){}return!1}var testWepP=function(t){var e=new Image;e.src="data:image/webp;base64,UklGRi4AAABXRUJQVlA4TCEAAAAvAUAAEB8wAiMwAgSSNtse/cXjxyCCmrYNWPwmHRH9jwMA",e.onload=e.onerror=function(){t(2===e.height)}};function isWorkerEnv(){try{return document,!1}catch(t){return!0}}function getSupport(t){function e(t){return-1!==n.indexOf(t)}var r={runSupport:(new Date).getTime()},U=isWasmSuppport(),n=navigator.userAgent.toLowerCase(),j=!0,i=e("macintosh"),F=e("ipad;")||e("ipad "),a=e("ipod touch;"),o=e("iphone;")||e("iphone "),a=o||F||a,s=(i||a)&&e("safari")&&e("version/"),u=e("macwechat"),c=e("windowswechat"),R={touch:!1,mac:i,Ue:!1,webkit:!1,$e:!1,scale:1,android:!1,DW:isWorkerEnv(),wasm:U,safari:s,AQ:u,gQ:c,amapRunTime:r};if(isBrowser()){var f=window,c=(u=document).documentElement,h=/([a-z0-9]*\\d+[a-z0-9]*)/,D="google swiftshader;microsoft basic render driver;vmware svga 3d;Intel 965GM;Intel B43;Intel G41;Intel G45;Intel G965;Intel GMA 3600;Intel Mobile 4;Intel Mobile 45;Intel Mobile 965".split(";"),l="ActiveXObject"in f,d=0!=window.detectRetina&&("devicePixelRatio"in f&&1<f.devicePixelRatio||l&&"matchMedia"in f&&f.matchMedia("(min-resolution:144dpi)")&&f.matchMedia("(min-resolution:144dpi)").matches),B=e("windows nt"),v=(n.search(/windows nt [1-5]\\./),n.search(/windows nt 5\\.[12]/),e("windows nt 10"),e("windows phone")),G=e("Mb2345Browser"),V=(a&&n.search(/ os [456]_/),a&&n.search(/ os [4-8]_/),a&&n.search(/ os [78]_/),a&&e("os 8_"),a&&e("os 10_")),g=e("android"),p=0,z=(g&&(p=parseInt(n.split("android")[1])||0),g&&p<4),y=(g&&5<=p||n.search(/android 4.4/),g?"android":a?"ios":B?"windows":i?"mac":"other"),p=l&&!f.XMLHttpRequest,W=l&&!u.querySelector,m=l&&!u.addEventListener,H=l&&e("msie 9"),q=l&&e("msie 10"),K=l&&e("rv:11"),Y=m||H,b=e("edge"),T=(e("qtweb"),e("ucbrowser")),X=e("alipay")||g&&T,Z=(e("miuibrowser"),e("micromessenger")),A=e("dingtalk"),J=e("mqqbrowser"),Q=e("baidubrowser"),x=e("crios/"),M=e("chrome/"),x=!((M||x)&&e("chromium"))&&(M&&30<parseInt(n.split("chrome/")[1])||x&&30<parseInt(n.split("crios/")[1])),tt=e("firefox"),S=tt&&27<parseInt(n.split("firefox/")[1]),w=s&&7<parseInt(n.split("version/")[1]),P=(a&&e("aliapp"),g||a||v||e("mobile")),v="ontouchstart"in u,et=f.navigator&&f.navigator.msPointerEnabled&&!!f.navigator.msMaxTouchPoints,rt=f.navigator&&!!f.navigator.maxTouchPoints,nt=!v&&(rt||et),v=v||nt,I=function(){if(!P)return f.devicePixelRatio||1;var t=document.getElementsByTagName("meta");if(window.parent&&window.parent!==window)try{if(window.parent.location.origin!==window.location.origin)return 1;t=window.parent.document.getElementsByTagName("meta")}catch(t){return 1}for(var r,n,e,a=t.length-1;0<=a;--a)if("viewport"===t[a].name)return r=void 0,-1!==(e=t[a].content).indexOf("initial-scale")&&(r=parseFloat(e.split("initial-scale=")[1])),n=-1!==e.indexOf("minimum-scale")?parseFloat(e.split("minimum-scale=")[1]):0,e=-1!==e.indexOf("maximum-scale")?parseFloat(e.split("maximum-scale=")[1]):1/0,r?n<=e?e<r?e:r<n?n:r:(console&&console.log&&console.log("viewport参数不合法"),null):n<=e?1<=n?1:Math.min(e,1):(console&&console.log&&console.log("viewport参数不合法"),null)}(),it=d&&(!P||!!I&&1<=I),at=l&&"transition"in c.style,ot=!!u.createElementNS&&!!u.createElementNS("http://www.w3.org/2000/svg","svg").createSVGRect,C=u.createElement("canvas"),st=!(!C||!C.getContext),u=window.URL||window.webkitURL,ut=!0!==window.disableWorker&&!l&&!(T&&g&&!x)&&window.Worker&&u&&u.createObjectURL&&window.Blob,N="",$="",k=0,u=0!=window.higtQualityRender||!d,ct=window.movingDraw,L={alpha:!0,antialias:u,depth:!0,stencil:!0},O=(u=function(){if(st&&ut)for(var t,r=["webgl","experimental-webgl","moz-webgl"],n=null,i=0;i<r.length;i+=1){try{n=C.getContext(r[i],L)}catch(t){}if(n){if(n.drawingBufferWidth!==C.width||n.drawingBufferHeight!==C.height)return!1;if(!n.getShaderPrecisionFormat||!n.getParameter||!n.getExtension)return!1;if(k=n.getParameter(n.MAX_RENDERBUFFER_SIZE),!(a=n.getParameter(n.MAX_VIEWPORT_DIMS)))return!1;k=Math.min(k,a[0],a[1]),s&&"mac"==y&&(k=Math.min(k,4096));var a=Math.max(screen.width,screen.height);if(it&&(a*=Math.min(2,window.devicePixelRatio||1)),k<a)return!1;if(n.getShaderPrecisionFormat(35632,36338).precision<23||n.getShaderPrecisionFormat(35633,36338).precision<23)return!1;var e=o=a=void 0,o=(t=$=n.getExtension("WEBGL_debug_renderer_info")?n.getParameter(37446):null)?(a=null,0<=(t=(t=(o=(t=t.toLowerCase()).match(/angle \\((.*)\\)/))?(t=o[1]).replace(/\\s*direct3d.*$/,""):t).replace(/\\s*\\([^\\)]*wddm[^\\)]*\\)/,"")).indexOf("intel")?(a=["Intel"],0<=t.indexOf("mobile")&&a.push("Mobile"),(0<=t.indexOf("gma")||0<=t.indexOf("graphics media accelerator"))&&a.push("GMA"),0<=t.indexOf("haswell")?a.push("Haswell"):0<=t.indexOf("ivy")?a.push("HD 4000"):0<=t.indexOf("sandy")?a.push("HD 3000"):0<=t.indexOf("ironlake")?a.push("HD"):(0<=t.indexOf("hd")&&a.push("HD"),(e=t.match(h))&&a.push(e[1].toUpperCase())),a.join(" ")):0<=t.indexOf("nvidia")||0<=t.indexOf("quadro")||0<=t.indexOf("geforce")||0<=t.indexOf("nvs")?(a=["nVidia"],0<=t.indexOf("geforce")&&a.push("geForce"),0<=t.indexOf("quadro")&&a.push("Quadro"),0<=t.indexOf("nvs")&&a.push("NVS"),t.match(/\\bion\\b/)&&a.push("ION"),t.match(/gtx\\b/)?a.push("GTX"):t.match(/gts\\b/)?a.push("GTS"):t.match(/gt\\b/)?a.push("GT"):t.match(/gs\\b/)?a.push("GS"):t.match(/ge\\b/)?a.push("GE"):t.match(/fx\\b/)&&a.push("FX"),(e=t.match(h))&&a.push(e[1].toUpperCase().replace("GS","")),0<=t.indexOf("titan")?a.push("TITAN"):0<=t.indexOf("ti")&&a.push("Ti"),a.join(" ")):0<=t.indexOf("amd")||0<=t.indexOf("ati")||0<=t.indexOf("radeon")||0<=t.indexOf("firegl")||0<=t.indexOf("firepro")?(a=["AMD"],0<=t.indexOf("mobil")&&a.push("Mobility"),0<=(o=t.indexOf("radeon"))&&a.push("Radeon"),0<=t.indexOf("firepro")?a.push("FirePro"):0<=t.indexOf("firegl")&&a.push("FireGL"),0<=t.indexOf("hd")&&a.push("HD"),(e=(t=0<=o?t.substring(o):t).match(h))&&a.push(e[1].toUpperCase().replace("HD","")),a.join(" ")):t.substring(0,100)):null;if(o){if(-1<o.indexOf("google swiftshader"))return j=!1;if(-1!==D.indexOf(o))return!1}return N=r[i],!0}}return!1})(),ft=void 0===t[8]||t[8],O=window.Uint8Array&&ft&&!window.forbidenWebGL&&O&&(window.forceWebGL||(x||S||w||b||Z||A)&&"other"!=y),x=window.forceWebGLBaseRender||O?"w":"d",S=e("webkit"),w="WebKitCSSMatrix"in f&&"m11"in new window.WebKitCSSMatrix,A="MozPerspective"in c.style,c="vV"in c.style,ht=at||w||A||c,t=void 0!==t[12]?t[12]:null,_=!0;try{void 0===f.localStorage?_=!1:(E=(new Date).getTime()+"",f.localStorage.setItem("_test",E),f.localStorage.getItem("_test")!==E&&(_=!1),f.localStorage.removeItem("_test"))}catch(t){_=!1}var E=parseInt(n.split("chrome/")[1]),R={iPad:F,iPhone:o,size:o?100:g?200:500,mac:i,windows:B,ios:a,uT:V,android:g,android23:z,cT:X,plat:y,baidu:Q,qq:J,safari:s,wechat:Z,ie:l,ie6:p,ie7:W,ie9:H,ie10:q,ielt9:m,fT:Y,ie11:K,edge:b,hT:l&&!K,lT:G,RL:_,vT:t,geolocation:P||l&&!m||b,SL:T,uc:T&&!M,chrome:M,gT:!0,firefox:tt,hardwareAccEnabled:j,$e:P,mobileWebkit:P&&S,mobileWebkit3d:P&&w,mobileOpera:P&&f.opera,Ue:d,bT:I,Mr:it,touch:v,msPointer:et,pointer:rt,yT:nt,pT:M&&57<=E,mT:!P&&M&&64<=E,webkit:S,ie3d:at,webkit3d:w,gecko3d:A,opera3d:c,any3d:ht,isSvg:ot,isCanvas:st,isWorker:ut,TT:!1,isWebGL:O,AT:N,xT:L,ST:$,wT:k,MT:!1,movingDraw:ct,baseRender:ft?x:"d",scale:d?2:1,getContext:function(t,e){var r={};return extend(r,L),extend(r,e),t.getContext(N,r)},mH:!1,wasm:U,amapRunTime:r,sY:u};testWepP(function(t){R.mH=t})}return R}var Browser=getSupport("undefined"==typeof config?[]:config),canceledWorkerFetch=("undefined"!=typeof createImageBitmap&&"undefined"!=typeof ImageBitmap&&(Browser.imageBitmap=!0),Boolean(Browser.DW?!Browser.safari&&!Browser.AQ&&!Browser.gQ&&self.fetch&&self.Request&&self.AbortController&&self.Request.prototype.hasOwnProperty("signal"):!Browser.safari&&!Browser.AQ&&!Browser.gQ&&window.fetch&&window.Request&&window.AbortController&&window.Request.prototype.hasOwnProperty("signal"))),freeGlobal=(Browser.LZ=canceledWorkerFetch,Browser.amapRunTime={workerTime:{}},"object"==typeof global&&global&&global.Object===Object&&global),freeSelf="object"==typeof self&&self&&self.Object===Object&&self,root=freeGlobal||freeSelf||Function("return this")(),Symbol$1=root.Symbol,objectProto=Object.prototype,hasOwnProperty=objectProto.hasOwnProperty,nativeObjectToString=objectProto.toString,symToStringTag=Symbol$1?Symbol$1.toStringTag:void 0;function getRawTag(t){var e=hasOwnProperty.call(t,symToStringTag),r=t[symToStringTag];try{var n=!(t[symToStringTag]=void 0)}catch(t){}var i=nativeObjectToString.call(t);return n&&(e?t[symToStringTag]=r:delete t[symToStringTag]),i}var objectProto$1=Object.prototype,nativeObjectToString$1=objectProto$1.toString;function objectToString(t){return nativeObjectToString$1.call(t)}var nullTag="[object Null]",undefinedTag="[object Undefined]",symToStringTag$1=Symbol$1?Symbol$1.toStringTag:void 0;function baseGetTag(t){return null==t?void 0===t?undefinedTag:nullTag:(symToStringTag$1&&symToStringTag$1 in Object(t)?getRawTag:objectToString)(t)}function isObjectLike(t){return null!=t&&"object"==typeof t}var symbolTag="[object Symbol]";function isSymbol(t){return"symbol"==typeof t||isObjectLike(t)&&baseGetTag(t)==symbolTag}function arrayMap(t,e){for(var r=-1,n=null==t?0:t.length,i=Array(n);++r<n;)i[r]=e(t[r],r,t);return i}var isArray=Array.isArray,INFINITY=1/0,symbolProto=Symbol$1?Symbol$1.prototype:void 0,symbolToString=symbolProto?symbolProto.toString:void 0;function baseToString(t){var e;return"string"==typeof t?t:isArray(t)?arrayMap(t,baseToString)+"":isSymbol(t)?symbolToString?symbolToString.call(t):"":"0"==(e=t+"")&&1/t==-INFINITY?"-0":e}var reWhitespace=/\\s/;function trimmedEndIndex(t){for(var e=t.length;e--&&reWhitespace.test(t.charAt(e)););return e}var reTrimStart=/^\\s+/;function baseTrim(t){return t&&t.slice(0,trimmedEndIndex(t)+1).replace(reTrimStart,"")}function isObject(t){var e=typeof t;return null!=t&&("object"==e||"function"==e)}var NAN=NaN,reIsBadHex=/^[-+]0x[0-9a-f]+$/i,reIsBinary=/^0b[01]+$/i,reIsOctal=/^0o[0-7]+$/i,freeParseInt=parseInt;function toNumber(t){if("number"==typeof t)return t;if(isSymbol(t))return NAN;if("string"!=typeof(t=isObject(t)?isObject(e="function"==typeof t.valueOf?t.valueOf():t)?e+"":e:t))return 0===t?t:+t;t=baseTrim(t);var e=reIsBinary.test(t);return e||reIsOctal.test(t)?freeParseInt(t.slice(2),e?2:8):reIsBadHex.test(t)?NAN:+t}var INFINITY$1=1/0,MAX_INTEGER=17976931348623157e292;function toFinite(t){return t?(t=toNumber(t))===INFINITY$1||t===-INFINITY$1?(t<0?-1:1)*MAX_INTEGER:t==t?t:0:0===t?t:0}function toInteger(t){var e=(t=toFinite(t))%1;return t==t?e?t-e:t:0}function identity(t){return t}var asyncTag="[object AsyncFunction]",funcTag="[object Function]",genTag="[object GeneratorFunction]",proxyTag="[object Proxy]";function isFunction(t){return!!isObject(t)&&((t=baseGetTag(t))==funcTag||t==genTag||t==asyncTag||t==proxyTag)}var coreJsData=root["__core-js_shared__"],maskSrcKey=function(){var t=/[^.]+$/.exec(coreJsData&&coreJsData.keys&&coreJsData.keys.Xb||"");return t?"Symbol(src)_1."+t:""}();function isMasked(t){return maskSrcKey&&maskSrcKey in t}var funcProto=Function.prototype,funcToString=funcProto.toString;function toSource(t){if(null!=t){try{return funcToString.call(t)}catch(t){}try{return t+""}catch(t){}}return""}var reRegExpChar=/[\\\\^$.*+?()[\\]{}|]/g,reIsHostCtor=/^\\[object .+?Constructor\\]$/,funcProto$1=Function.prototype,objectProto$2=Object.prototype,funcToString$1=funcProto$1.toString,hasOwnProperty$1=objectProto$2.hasOwnProperty,reIsNative=RegExp("^"+funcToString$1.call(hasOwnProperty$1).replace(reRegExpChar,"\\\\$&").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g,"$1.*?")+"$");function baseIsNative(t){return isObject(t)&&!isMasked(t)&&(isFunction(t)?reIsNative:reIsHostCtor).test(toSource(t))}function getValue(t,e){return null==t?void 0:t[e]}function getNative(t,e){return baseIsNative(t=getValue(t,e))?t:void 0}var WeakMap=getNative(root,"WeakMap"),objectCreate=Object.create,baseCreate=function(){function e(){}return function(t){return isObject(t)?objectCreate?objectCreate(t):(e.prototype=t,t=new e,e.prototype=void 0,t):{}}}();function apply(t,e,r){switch(r.length){case 0:return t.call(e);case 1:return t.call(e,r[0]);case 2:return t.call(e,r[0],r[1]);case 3:return t.call(e,r[0],r[1],r[2])}return t.apply(e,r)}function copyArray(t,e){var r=-1,n=t.length;for(e=e||Array(n);++r<n;)e[r]=t[r];return e}var HOT_COUNT=800,HOT_SPAN=16,nativeNow=Date.now;function shortOut(r){var n=0,i=0;return function(){var t=nativeNow(),e=HOT_SPAN-(t-i);if(i=t,0<e){if(++n>=HOT_COUNT)return arguments[0]}else n=0;return r.apply(void 0,arguments)}}function constant(t){return function(){return t}}var defineProperty=function(){try{var t=getNative(Object,"defineProperty");return t({},"",{}),t}catch(t){}}(),baseSetToString=defineProperty?function(t,e){return defineProperty(t,"toString",{configurable:!0,enumerable:!1,value:constant(e),writable:!0})}:identity,setToString=shortOut(baseSetToString);function arrayEach(t,e){for(var r=-1,n=null==t?0:t.length;++r<n&&!1!==e(t[r],r,t););return t}function baseFindIndex(t,e,r,n){for(var i=t.length,a=r+(n?1:-1);n?a--:++a<i;)if(e(t[a],a,t))return a;return-1}var MAX_SAFE_INTEGER=9007199254740991,reIsUint=/^(?:0|[1-9]\\d*)$/;function isIndex(t,e){var r=typeof t;return!!(e=null==e?MAX_SAFE_INTEGER:e)&&("number"==r||"symbol"!=r&&reIsUint.test(t))&&-1<t&&t%1==0&&t<e}function baseAssignValue(t,e,r){"__proto__"==e&&defineProperty?defineProperty(t,e,{configurable:!0,enumerable:!0,value:r,writable:!0}):t[e]=r}function eq(t,e){return t===e||t!=t&&e!=e}var objectProto$3=Object.prototype,hasOwnProperty$2=objectProto$3.hasOwnProperty;function assignValue(t,e,r){var n=t[e];hasOwnProperty$2.call(t,e)&&eq(n,r)&&(void 0!==r||e in t)||baseAssignValue(t,e,r)}function copyObject(t,e,r,n){for(var i=!r,a=(r=r||{},-1),o=e.length;++a<o;){var s=e[a],u=n?n(r[s],t[s],s,r,t):void 0;(i?baseAssignValue:assignValue)(r,s,void 0===u?t[s]:u)}return r}var nativeMax=Math.max;function overRest(a,o,s){return o=nativeMax(void 0===o?a.length-1:o,0),function(){for(var t=arguments,e=-1,r=nativeMax(t.length-o,0),n=Array(r);++e<r;)n[e]=t[o+e];for(var e=-1,i=Array(o+1);++e<o;)i[e]=t[e];return i[o]=s(n),apply(a,this,i)}}function baseRest(t,e){return setToString(overRest(t,e,identity),t+"")}var MAX_SAFE_INTEGER$1=9007199254740991;function isLength(t){return"number"==typeof t&&-1<t&&t%1==0&&t<=MAX_SAFE_INTEGER$1}function isArrayLike(t){return null!=t&&isLength(t.length)&&!isFunction(t)}function isIterateeCall(t,e,r){var n;return isObject(r)&&("number"==(n=typeof e)?isArrayLike(r)&&isIndex(e,r.length):"string"==n&&e in r)&&eq(r[e],t)}function createAssigner(s){return baseRest(function(t,e){var r=-1,n=e.length,i=1<n?e[n-1]:void 0,a=2<n?e[2]:void 0,i=3<s.length&&"function"==typeof i?(n--,i):void 0;for(a&&isIterateeCall(e[0],e[1],a)&&(i=n<3?void 0:i,n=1),t=Object(t);++r<n;){var o=e[r];o&&s(t,o,r,i)}return t})}var objectProto$4=Object.prototype;function isPrototype(t){var e=t&&t.constructor;return t===("function"==typeof e&&e.prototype||objectProto$4)}function baseTimes(t,e){for(var r=-1,n=Array(t);++r<t;)n[r]=e(r);return n}var argsTag="[object Arguments]";function baseIsArguments(t){return isObjectLike(t)&&baseGetTag(t)==argsTag}var objectProto$5=Object.prototype,hasOwnProperty$3=objectProto$5.hasOwnProperty,propertyIsEnumerable=objectProto$5.propertyIsEnumerable,isArguments=baseIsArguments(function(){return arguments}())?baseIsArguments:function(t){return isObjectLike(t)&&hasOwnProperty$3.call(t,"callee")&&!propertyIsEnumerable.call(t,"callee")};function stubFalse(){return!1}var freeExports="object"==typeof exports&&exports&&!exports.nodeType&&exports,freeModule=freeExports&&"object"==typeof module&&module&&!module.nodeType&&module,moduleExports=freeModule&&freeModule.exports===freeExports,Buffer=moduleExports?root.Zb:void 0,nativeIsBuffer=Buffer?Buffer.isBuffer:void 0,isBuffer=nativeIsBuffer||stubFalse,argsTag$1="[object Arguments]",arrayTag="[object Array]",boolTag="[object Boolean]",dateTag="[object Date]",errorTag="[object Error]",funcTag$1="[object Function]",mapTag="[object Map]",numberTag="[object Number]",objectTag="[object Object]",regexpTag="[object RegExp]",setTag="[object Set]",stringTag="[object String]",weakMapTag="[object WeakMap]",arrayBufferTag="[object ArrayBuffer]",dataViewTag="[object DataView]",float32Tag="[object Float32Array]",float64Tag="[object Float64Array]",int8Tag="[object Int8Array]",int16Tag="[object Int16Array]",int32Tag="[object Int32Array]",uint8Tag="[object Uint8Array]",uint8ClampedTag="[object Uint8ClampedArray]",uint16Tag="[object Uint16Array]",uint32Tag="[object Uint32Array]",typedArrayTags={};function baseIsTypedArray(t){return isObjectLike(t)&&isLength(t.length)&&!!typedArrayTags[baseGetTag(t)]}function baseUnary(e){return function(t){return e(t)}}typedArrayTags[float32Tag]=typedArrayTags[float64Tag]=typedArrayTags[int8Tag]=typedArrayTags[int16Tag]=typedArrayTags[int32Tag]=typedArrayTags[uint8Tag]=typedArrayTags[uint8ClampedTag]=typedArrayTags[uint16Tag]=typedArrayTags[uint32Tag]=!0,typedArrayTags[argsTag$1]=typedArrayTags[arrayTag]=typedArrayTags[arrayBufferTag]=typedArrayTags[boolTag]=typedArrayTags[dataViewTag]=typedArrayTags[dateTag]=typedArrayTags[errorTag]=typedArrayTags[funcTag$1]=typedArrayTags[mapTag]=typedArrayTags[numberTag]=typedArrayTags[objectTag]=typedArrayTags[regexpTag]=typedArrayTags[setTag]=typedArrayTags[stringTag]=typedArrayTags[weakMapTag]=!1;var freeExports$1="object"==typeof exports&&exports&&!exports.nodeType&&exports,freeModule$1=freeExports$1&&"object"==typeof module&&module&&!module.nodeType&&module,moduleExports$1=freeModule$1&&freeModule$1.exports===freeExports$1,freeProcess=moduleExports$1&&freeGlobal.process,nodeUtil=function(){try{var t=freeModule$1&&freeModule$1.Qb&&freeModule$1.Qb("util").types;return t||freeProcess&&freeProcess.tg&&freeProcess.tg("util")}catch(t){}}(),nodeIsTypedArray=nodeUtil&&nodeUtil.rg,isTypedArray=nodeIsTypedArray?baseUnary(nodeIsTypedArray):baseIsTypedArray,objectProto$6=Object.prototype,hasOwnProperty$4=objectProto$6.hasOwnProperty;function arrayLikeKeys(t,e){var r,n=isArray(t),i=!n&&isArguments(t),a=!n&&!i&&isBuffer(t),o=!n&&!i&&!a&&isTypedArray(t),s=n||i||a||o,u=s?baseTimes(t.length,String):[],c=u.length;for(r in t)!e&&!hasOwnProperty$4.call(t,r)||s&&("length"==r||a&&("offset"==r||"parent"==r)||o&&("buffer"==r||"byteLength"==r||"byteOffset"==r)||isIndex(r,c))||u.push(r);return u}function overArg(e,r){return function(t){return e(r(t))}}var nativeKeys=overArg(Object.keys,Object),objectProto$7=Object.prototype,hasOwnProperty$5=objectProto$7.hasOwnProperty;function baseKeys(t){if(!isPrototype(t))return nativeKeys(t);var e,r=[];for(e in Object(t))hasOwnProperty$5.call(t,e)&&"constructor"!=e&&r.push(e);return r}function keys(t){return(isArrayLike(t)?arrayLikeKeys:baseKeys)(t)}var objectProto$8=Object.prototype,hasOwnProperty$6=objectProto$8.hasOwnProperty,assign=createAssigner(function(t,e){if(isPrototype(e)||isArrayLike(e))copyObject(e,keys(e),t);else for(var r in e)hasOwnProperty$6.call(e,r)&&assignValue(t,r,e[r])});function nativeKeysIn(t){var e=[];if(null!=t)for(var r in Object(t))e.push(r);return e}var objectProto$9=Object.prototype,hasOwnProperty$7=objectProto$9.hasOwnProperty;function baseKeysIn(t){if(!isObject(t))return nativeKeysIn(t);var e,r=isPrototype(t),n=[];for(e in t)("constructor"!=e||!r&&hasOwnProperty$7.call(t,e))&&n.push(e);return n}function keysIn(t){return isArrayLike(t)?arrayLikeKeys(t,!0):baseKeysIn(t)}var reIsDeepProp=/\\.|\\[(?:[^[\\]]*|(["\'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,reIsPlainProp=/^\\w*$/;function isKey(t,e){var r;return!isArray(t)&&("number"==(r=typeof t)||"symbol"==r||"boolean"==r||null==t||isSymbol(t)||reIsPlainProp.test(t)||!reIsDeepProp.test(t)||null!=e&&t in Object(e))}var nativeCreate=getNative(Object,"create");function hashClear(){this.ng=nativeCreate?nativeCreate(null):{},this.size=0}function hashDelete(t){return t=this.has(t)&&delete this.ng[t],this.size-=t?1:0,t}var HASH_UNDEFINED="__lodash_hash_undefined__",objectProto$a=Object.prototype,hasOwnProperty$8=objectProto$a.hasOwnProperty;function hashGet(t){var e,r=this.ng;return nativeCreate?(e=r[t])===HASH_UNDEFINED?void 0:e:hasOwnProperty$8.call(r,t)?r[t]:void 0}var objectProto$b=Object.prototype,hasOwnProperty$9=objectProto$b.hasOwnProperty;function hashHas(t){var e=this.ng;return nativeCreate?void 0!==e[t]:hasOwnProperty$9.call(e,t)}var HASH_UNDEFINED$1="__lodash_hash_undefined__";function hashSet(t,e){var r=this.ng;return this.size+=this.has(t)?0:1,r[t]=nativeCreate&&void 0===e?HASH_UNDEFINED$1:e,this}function Hash(t){var e=-1,r=null==t?0:t.length;for(this.clear();++e<r;){var n=t[e];this.set(n[0],n[1])}}function listCacheClear(){this.ng=[],this.size=0}function assocIndexOf(t,e){for(var r=t.length;r--;)if(eq(t[r][0],e))return r;return-1}Hash.prototype.clear=hashClear,Hash.prototype.delete=hashDelete,Hash.prototype.get=hashGet,Hash.prototype.has=hashHas,Hash.prototype.set=hashSet;var arrayProto=Array.prototype,splice=arrayProto.splice;function listCacheDelete(t){var e=this.ng;return!((t=assocIndexOf(e,t))<0||(t==e.length-1?e.pop():splice.call(e,t,1),--this.size,0))}function listCacheGet(t){var e=this.ng;return(t=assocIndexOf(e,t))<0?void 0:e[t][1]}function listCacheHas(t){return-1<assocIndexOf(this.ng,t)}function listCacheSet(t,e){var r=this.ng,n=assocIndexOf(r,t);return n<0?(++this.size,r.push([t,e])):r[n][1]=e,this}function ListCache(t){var e=-1,r=null==t?0:t.length;for(this.clear();++e<r;){var n=t[e];this.set(n[0],n[1])}}ListCache.prototype.clear=listCacheClear,ListCache.prototype.delete=listCacheDelete,ListCache.prototype.get=listCacheGet,ListCache.prototype.has=listCacheHas,ListCache.prototype.set=listCacheSet;var Map=getNative(root,"Map");function mapCacheClear(){this.size=0,this.ng={hash:new Hash,map:new(Map||ListCache),string:new Hash}}function isKeyable(t){var e=typeof t;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==t:null===t}function getMapData(t,e){return t=t.ng,isKeyable(e)?t["string"==typeof e?"string":"hash"]:t.map}function mapCacheDelete(t){return t=getMapData(this,t).delete(t),this.size-=t?1:0,t}function mapCacheGet(t){return getMapData(this,t).get(t)}function mapCacheHas(t){return getMapData(this,t).has(t)}function mapCacheSet(t,e){var r=getMapData(this,t),n=r.size;return r.set(t,e),this.size+=r.size==n?0:1,this}function MapCache(t){var e=-1,r=null==t?0:t.length;for(this.clear();++e<r;){var n=t[e];this.set(n[0],n[1])}}MapCache.prototype.clear=mapCacheClear,MapCache.prototype.delete=mapCacheDelete,MapCache.prototype.get=mapCacheGet,MapCache.prototype.has=mapCacheHas,MapCache.prototype.set=mapCacheSet;var FUNC_ERROR_TEXT="Expected a function";function memoize(n,i){if("function"!=typeof n||null!=i&&"function"!=typeof i)throw new TypeError(FUNC_ERROR_TEXT);function a(){var t=arguments,e=i?i.apply(this,t):t[0],r=a.cache;return r.has(e)?r.get(e):(t=n.apply(this,t),a.cache=r.set(e,t)||r,t)}return a.cache=new(memoize.Cache||MapCache),a}memoize.Cache=MapCache;var MAX_MEMOIZE_SIZE=500;function memoizeCapped(t){var e=(t=memoize(t,function(t){return e.size===MAX_MEMOIZE_SIZE&&e.clear(),t})).cache;return t}var rePropName=/[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|(["\'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g,reEscapeChar=/\\\\(\\\\)?/g,stringToPath=memoizeCapped(function(t){var i=[];return 46===t.charCodeAt(0)&&i.push(""),t.replace(rePropName,function(t,e,r,n){i.push(r?n.replace(reEscapeChar,"$1"):e||t)}),i});function toString(t){return null==t?"":baseToString(t)}function castPath(t,e){return isArray(t)?t:isKey(t,e)?[t]:stringToPath(toString(t))}var INFINITY$2=1/0;function toKey(t){var e;return"string"==typeof t||isSymbol(t)?t:"0"==(e=t+"")&&1/t==-INFINITY$2?"-0":e}function baseGet(t,e){for(var r=0,n=(e=castPath(e,t)).length;null!=t&&r<n;)t=t[toKey(e[r++])];return r&&r==n?t:void 0}function get(t,e,r){return void 0===(t=null==t?void 0:baseGet(t,e))?r:t}function arrayPush(t,e){for(var r=-1,n=e.length,i=t.length;++r<n;)t[i+r]=e[r];return t}var getPrototype=overArg(Object.getPrototypeOf,Object);function stackClear(){this.ng=new ListCache,this.size=0}function stackDelete(t){var e=this.ng,t=e.delete(t);return this.size=e.size,t}function stackGet(t){return this.ng.get(t)}function stackHas(t){return this.ng.has(t)}var LARGE_ARRAY_SIZE=200;function stackSet(t,e){var r=this.ng;if(r instanceof ListCache){var n=r.ng;if(!Map||n.length<LARGE_ARRAY_SIZE-1)return n.push([t,e]),this.size=++r.size,this;r=this.ng=new MapCache(n)}return r.set(t,e),this.size=r.size,this}function Stack(t){t=this.ng=new ListCache(t),this.size=t.size}function baseAssign(t,e){return t&&copyObject(e,keys(e),t)}function baseAssignIn(t,e){return t&&copyObject(e,keysIn(e),t)}Stack.prototype.clear=stackClear,Stack.prototype.delete=stackDelete,Stack.prototype.get=stackGet,Stack.prototype.has=stackHas,Stack.prototype.set=stackSet;var freeExports$2="object"==typeof exports&&exports&&!exports.nodeType&&exports,freeModule$2=freeExports$2&&"object"==typeof module&&module&&!module.nodeType&&module,moduleExports$2=freeModule$2&&freeModule$2.exports===freeExports$2,Buffer$1=moduleExports$2?root.Zb:void 0,allocUnsafe=Buffer$1?Buffer$1.ig:void 0;function cloneBuffer(t,e){return e?t.slice():(e=t.length,e=allocUnsafe?allocUnsafe(e):new t.constructor(e),t.eg(e),e)}function arrayFilter(t,e){for(var r=-1,n=null==t?0:t.length,i=0,a=[];++r<n;){var o=t[r];e(o,r,t)&&(a[i++]=o)}return a}function stubArray(){return[]}var objectProto$c=Object.prototype,propertyIsEnumerable$1=objectProto$c.propertyIsEnumerable,nativeGetSymbols=Object.getOwnPropertySymbols,getSymbols=nativeGetSymbols?function(e){return null==e?[]:(e=Object(e),arrayFilter(nativeGetSymbols(e),function(t){return propertyIsEnumerable$1.call(e,t)}))}:stubArray;function copySymbols(t,e){return copyObject(t,getSymbols(t),e)}var nativeGetSymbols$1=Object.getOwnPropertySymbols,getSymbolsIn=nativeGetSymbols$1?function(t){for(var e=[];t;)arrayPush(e,getSymbols(t)),t=getPrototype(t);return e}:stubArray;function copySymbolsIn(t,e){return copyObject(t,getSymbolsIn(t),e)}function baseGetAllKeys(t,e,r){return e=e(t),isArray(t)?e:arrayPush(e,r(t))}function getAllKeys(t){return baseGetAllKeys(t,keys,getSymbols)}function getAllKeysIn(t){return baseGetAllKeys(t,keysIn,getSymbolsIn)}var DataView=getNative(root,"DataView"),Promise$1=getNative(root,"Promise"),Set=getNative(root,"Set"),mapTag$1="[object Map]",objectTag$1="[object Object]",promiseTag="[object Promise]",setTag$1="[object Set]",weakMapTag$1="[object WeakMap]",dataViewTag$1="[object DataView]",dataViewCtorString=toSource(DataView),mapCtorString=toSource(Map),promiseCtorString=toSource(Promise$1),setCtorString=toSource(Set),weakMapCtorString=toSource(WeakMap),getTag=baseGetTag,getTag$1=((DataView&&getTag(new DataView(new ArrayBuffer(1)))!=dataViewTag$1||Map&&getTag(new Map)!=mapTag$1||Promise$1&&getTag(Promise$1.resolve())!=promiseTag||Set&&getTag(new Set)!=setTag$1||WeakMap&&getTag(new WeakMap)!=weakMapTag$1)&&(getTag=function(t){var e=baseGetTag(t);if(t=(t=e==objectTag$1?t.constructor:void 0)?toSource(t):"")switch(t){case dataViewCtorString:return dataViewTag$1;case mapCtorString:return mapTag$1;case promiseCtorString:return promiseTag;case setCtorString:return setTag$1;case weakMapCtorString:return weakMapTag$1}return e}),getTag),objectProto$d=Object.prototype,hasOwnProperty$a=objectProto$d.hasOwnProperty;function initCloneArray(t){var e=t.length,r=new t.constructor(e);return e&&"string"==typeof t[0]&&hasOwnProperty$a.call(t,"index")&&(r.index=t.index,r.input=t.input),r}var Uint8Array$1=root.Uint8Array;function cloneArrayBuffer(t){var e=new t.constructor(t.byteLength);return new Uint8Array$1(e).set(new Uint8Array$1(t)),e}function cloneDataView(t,e){return e=e?cloneArrayBuffer(t.buffer):t.buffer,new t.constructor(e,t.byteOffset,t.byteLength)}var reFlags=/\\w*$/;function cloneRegExp(t){var e=new t.constructor(t.source,reFlags.exec(t));return e.lastIndex=t.lastIndex,e}var symbolProto$1=Symbol$1?Symbol$1.prototype:void 0,symbolValueOf=symbolProto$1?symbolProto$1.valueOf:void 0;function cloneSymbol(t){return symbolValueOf?Object(symbolValueOf.call(t)):{}}function cloneTypedArray(t,e){return e=e?cloneArrayBuffer(t.buffer):t.buffer,new t.constructor(e,t.byteOffset,t.length)}var boolTag$1="[object Boolean]",dateTag$1="[object Date]",mapTag$2="[object Map]",numberTag$1="[object Number]",regexpTag$1="[object RegExp]",setTag$2="[object Set]",stringTag$1="[object String]",symbolTag$1="[object Symbol]",arrayBufferTag$1="[object ArrayBuffer]",dataViewTag$2="[object DataView]",float32Tag$1="[object Float32Array]",float64Tag$1="[object Float64Array]",int8Tag$1="[object Int8Array]",int16Tag$1="[object Int16Array]",int32Tag$1="[object Int32Array]",uint8Tag$1="[object Uint8Array]",uint8ClampedTag$1="[object Uint8ClampedArray]",uint16Tag$1="[object Uint16Array]",uint32Tag$1="[object Uint32Array]";function initCloneByTag(t,e,r){var n=t.constructor;switch(e){case arrayBufferTag$1:return cloneArrayBuffer(t);case boolTag$1:case dateTag$1:return new n(+t);case dataViewTag$2:return cloneDataView(t,r);case float32Tag$1:case float64Tag$1:case int8Tag$1:case int16Tag$1:case int32Tag$1:case uint8Tag$1:case uint8ClampedTag$1:case uint16Tag$1:case uint32Tag$1:return cloneTypedArray(t,r);case mapTag$2:return new n;case numberTag$1:case stringTag$1:return new n(t);case regexpTag$1:return cloneRegExp(t);case setTag$2:return new n;case symbolTag$1:return cloneSymbol(t)}}function initCloneObject(t){return"function"!=typeof t.constructor||isPrototype(t)?{}:baseCreate(getPrototype(t))}var mapTag$3="[object Map]";function baseIsMap(t){return isObjectLike(t)&&getTag$1(t)==mapTag$3}var nodeIsMap=nodeUtil&&nodeUtil.isMap,isMap=nodeIsMap?baseUnary(nodeIsMap):baseIsMap,setTag$3="[object Set]";function baseIsSet(t){return isObjectLike(t)&&getTag$1(t)==setTag$3}var nodeIsSet=nodeUtil&&nodeUtil.og,isSet=nodeIsSet?baseUnary(nodeIsSet):baseIsSet,CLONE_DEEP_FLAG=1,CLONE_FLAT_FLAG=2,CLONE_SYMBOLS_FLAG=4,argsTag$2="[object Arguments]",arrayTag$1="[object Array]",boolTag$2="[object Boolean]",dateTag$2="[object Date]",errorTag$1="[object Error]",funcTag$2="[object Function]",genTag$1="[object GeneratorFunction]",mapTag$4="[object Map]",numberTag$2="[object Number]",objectTag$2="[object Object]",regexpTag$2="[object RegExp]",setTag$4="[object Set]",stringTag$2="[object String]",symbolTag$2="[object Symbol]",weakMapTag$2="[object WeakMap]",arrayBufferTag$2="[object ArrayBuffer]",dataViewTag$3="[object DataView]",float32Tag$2="[object Float32Array]",float64Tag$2="[object Float64Array]",int8Tag$2="[object Int8Array]",int16Tag$2="[object Int16Array]",int32Tag$2="[object Int32Array]",uint8Tag$2="[object Uint8Array]",uint8ClampedTag$2="[object Uint8ClampedArray]",uint16Tag$2="[object Uint16Array]",uint32Tag$2="[object Uint32Array]",cloneableTags={};function baseClone(r,n,i,t,e,a){var o,s=n&CLONE_DEEP_FLAG,u=n&CLONE_FLAT_FLAG,c=n&CLONE_SYMBOLS_FLAG;if(void 0===(o=i?e?i(r,t,e,a):i(r):o)){if(!isObject(r))return r;if(t=isArray(r)){if(o=initCloneArray(r),!s)return copyArray(r,o)}else{var f=getTag$1(r),h=f==funcTag$2||f==genTag$1;if(isBuffer(r))return cloneBuffer(r,s);if(f==objectTag$2||f==argsTag$2||h&&!e){if(o=u||h?{}:initCloneObject(r),!s)return u?copySymbolsIn(r,baseAssignIn(o,r)):copySymbols(r,baseAssign(o,r))}else{if(!cloneableTags[f])return e?r:{};o=initCloneByTag(r,f,s)}}if(h=(a=a||new Stack).get(r))return h;a.set(r,o),isSet(r)?r.forEach(function(t){o.add(baseClone(t,n,i,t,r,a))}):isMap(r)&&r.forEach(function(t,e){o.set(e,baseClone(t,n,i,e,r,a))});var l=t?void 0:(c?u?getAllKeysIn:getAllKeys:u?keysIn:keys)(r);arrayEach(l||r,function(t,e){l&&(t=r[e=t]),assignValue(o,e,baseClone(t,n,i,e,r,a))})}return o}cloneableTags[argsTag$2]=cloneableTags[arrayTag$1]=cloneableTags[arrayBufferTag$2]=cloneableTags[dataViewTag$3]=cloneableTags[boolTag$2]=cloneableTags[dateTag$2]=cloneableTags[float32Tag$2]=cloneableTags[float64Tag$2]=cloneableTags[int8Tag$2]=cloneableTags[int16Tag$2]=cloneableTags[int32Tag$2]=cloneableTags[mapTag$4]=cloneableTags[numberTag$2]=cloneableTags[objectTag$2]=cloneableTags[regexpTag$2]=cloneableTags[setTag$4]=cloneableTags[stringTag$2]=cloneableTags[symbolTag$2]=cloneableTags[uint8Tag$2]=cloneableTags[uint8ClampedTag$2]=cloneableTags[uint16Tag$2]=cloneableTags[uint32Tag$2]=!0,cloneableTags[errorTag$1]=cloneableTags[funcTag$2]=cloneableTags[weakMapTag$2]=!1;var CLONE_SYMBOLS_FLAG$1=4;function clone(t){return baseClone(t,CLONE_SYMBOLS_FLAG$1)}var CLONE_DEEP_FLAG$1=1,CLONE_SYMBOLS_FLAG$2=4;function cloneDeep(t){return baseClone(t,CLONE_DEEP_FLAG$1|CLONE_SYMBOLS_FLAG$2)}var HASH_UNDEFINED$2="__lodash_hash_undefined__";function setCacheAdd(t){return this.ng.set(t,HASH_UNDEFINED$2),this}function setCacheHas(t){return this.ng.has(t)}function SetCache(t){var e=-1,r=null==t?0:t.length;for(this.ng=new MapCache;++e<r;)this.add(t[e])}function arraySome(t,e){for(var r=-1,n=null==t?0:t.length;++r<n;)if(e(t[r],r,t))return!0;return!1}function cacheHas(t,e){return t.has(e)}SetCache.prototype.add=SetCache.prototype.push=setCacheAdd,SetCache.prototype.has=setCacheHas;var COMPARE_PARTIAL_FLAG=1,COMPARE_UNORDERED_FLAG=2;function equalArrays(t,e,r,n,i,a){var o=r&COMPARE_PARTIAL_FLAG,s=t.length;if(s!=(u=e.length)&&!(o&&s<u))return!1;var u=a.get(t),c=a.get(e);if(u&&c)return u==e&&c==t;var f=-1,h=!0,l=r&COMPARE_UNORDERED_FLAG?new SetCache:void 0;for(a.set(t,e),a.set(e,t);++f<s;){var d,v=t[f],g=e[f];if(void 0!==(d=n?o?n(g,v,f,e,t,a):n(v,g,f,t,e,a):d)){if(d)continue;h=!1;break}if(l){if(!arraySome(e,function(t,e){if(!cacheHas(l,e)&&(v===t||i(v,t,r,n,a)))return l.push(e)})){h=!1;break}}else if(v!==g&&!i(v,g,r,n,a)){h=!1;break}}return a.delete(t),a.delete(e),h}function mapToArray(t){var r=-1,n=Array(t.size);return t.forEach(function(t,e){n[++r]=[e,t]}),n}function setToArray(t){var e=-1,r=Array(t.size);return t.forEach(function(t){r[++e]=t}),r}var COMPARE_PARTIAL_FLAG$1=1,COMPARE_UNORDERED_FLAG$1=2,boolTag$3="[object Boolean]",dateTag$3="[object Date]",errorTag$2="[object Error]",mapTag$5="[object Map]",numberTag$3="[object Number]",regexpTag$3="[object RegExp]",setTag$5="[object Set]",stringTag$3="[object String]",symbolTag$3="[object Symbol]",arrayBufferTag$3="[object ArrayBuffer]",dataViewTag$4="[object DataView]",symbolProto$2=Symbol$1?Symbol$1.prototype:void 0,symbolValueOf$1=symbolProto$2?symbolProto$2.valueOf:void 0;function equalByTag(t,e,r,n,i,a,o){switch(r){case dataViewTag$4:if(t.byteLength!=e.byteLength||t.byteOffset!=e.byteOffset)return!1;t=t.buffer,e=e.buffer;case arrayBufferTag$3:return!(t.byteLength!=e.byteLength||!a(new Uint8Array$1(t),new Uint8Array$1(e)));case boolTag$3:case dateTag$3:case numberTag$3:return eq(+t,+e);case errorTag$2:return t.name==e.name&&t.message==e.message;case regexpTag$3:case stringTag$3:return t==e+"";case mapTag$5:var s=mapToArray;case setTag$5:var u,s=s||setToArray;return t.size==e.size||n&COMPARE_PARTIAL_FLAG$1?(u=o.get(t))?u==e:(n|=COMPARE_UNORDERED_FLAG$1,o.set(t,e),u=equalArrays(s(t),s(e),n,i,a,o),o.delete(t),u):!1;case symbolTag$3:if(symbolValueOf$1)return symbolValueOf$1.call(t)==symbolValueOf$1.call(e)}return!1}var COMPARE_PARTIAL_FLAG$2=1,objectProto$e=Object.prototype,hasOwnProperty$b=objectProto$e.hasOwnProperty;function equalObjects(t,e,r,n,i,a){var o=r&COMPARE_PARTIAL_FLAG$2,s=getAllKeys(t),u=s.length;if(u!=getAllKeys(e).length&&!o)return!1;for(var c=u;c--;){var f=s[c];if(!(o?f in e:hasOwnProperty$b.call(e,f)))return!1}var h=a.get(t),l=a.get(e);if(h&&l)return h==e&&l==t;for(var d=!0,v=(a.set(t,e),a.set(e,t),o);++c<u;){var g,p=t[f=s[c]],y=e[f];if(!(void 0===(g=n?o?n(y,p,f,e,t,a):n(p,y,f,t,e,a):g)?p===y||i(p,y,r,n,a):g)){d=!1;break}v=v||"constructor"==f}return d&&!v&&(h=t.constructor)!=(l=e.constructor)&&"constructor"in t&&"constructor"in e&&!("function"==typeof h&&h instanceof h&&"function"==typeof l&&l instanceof l)&&(d=!1),a.delete(t),a.delete(e),d}var COMPARE_PARTIAL_FLAG$3=1,argsTag$3="[object Arguments]",arrayTag$2="[object Array]",objectTag$3="[object Object]",objectProto$f=Object.prototype,hasOwnProperty$c=objectProto$f.hasOwnProperty;function baseIsEqualDeep(t,e,r,n,i,a){var o=isArray(t),s=isArray(e),u=o?arrayTag$2:getTag$1(t),s=s?arrayTag$2:getTag$1(e),c=(u=u==argsTag$3?objectTag$3:u)==objectTag$3,f=(s=s==argsTag$3?objectTag$3:s)==objectTag$3;if((s=u==s)&&isBuffer(t)){if(!isBuffer(e))return!1;c=!(o=!0)}return s&&!c?(a=a||new Stack,o||isTypedArray(t)?equalArrays(t,e,r,n,i,a):equalByTag(t,e,u,r,n,i,a)):r&COMPARE_PARTIAL_FLAG$3||(o=c&&hasOwnProperty$c.call(t,"__wrapped__"),u=f&&hasOwnProperty$c.call(e,"__wrapped__"),!o&&!u)?s&&equalObjects(t,e,r,n,i,a=a||new Stack):i(o?t.value():t,u?e.value():e,r,n,a=a||new Stack)}function baseIsEqual(t,e,r,n,i){return t===e||(null==t||null==e||!isObjectLike(t)&&!isObjectLike(e)?t!=t&&e!=e:baseIsEqualDeep(t,e,r,n,baseIsEqual,i))}var COMPARE_PARTIAL_FLAG$4=1,COMPARE_UNORDERED_FLAG$2=2;function baseIsMatch(t,e,r,n){var i=r.length,a=i,o=!n;if(null==t)return!a;for(t=Object(t);i--;){var s=r[i];if(o&&s[2]?s[1]!==t[s[0]]:!(s[0]in t))return!1}for(;++i<a;){var u=(s=r[i])[0],c=t[u],f=s[1];if(o&&s[2]){if(void 0===c&&!(u in t))return!1}else{var h,l=new Stack;if(!(void 0===(h=n?n(c,f,u,t,e,l):h)?baseIsEqual(f,c,COMPARE_PARTIAL_FLAG$4|COMPARE_UNORDERED_FLAG$2,n,l):h))return!1}}return!0}function isStrictComparable(t){return t==t&&!isObject(t)}function getMatchData(t){for(var e=keys(t),r=e.length;r--;){var n=e[r],i=t[n];e[r]=[n,i,isStrictComparable(i)]}return e}function matchesStrictComparable(e,r){return function(t){return null!=t&&t[e]===r&&(void 0!==r||e in Object(t))}}function baseMatches(e){var r=getMatchData(e);return 1==r.length&&r[0][2]?matchesStrictComparable(r[0][0],r[0][1]):function(t){return t===e||baseIsMatch(t,e,r)}}function baseHasIn(t,e){return null!=t&&e in Object(t)}function hasPath(t,e,r){for(var n=-1,i=(e=castPath(e,t)).length,a=!1;++n<i;){var o=toKey(e[n]);if(!(a=null!=t&&r(t,o)))break;t=t[o]}return a||++n!=i?a:!!(i=null==t?0:t.length)&&isLength(i)&&isIndex(o,i)&&(isArray(t)||isArguments(t))}function hasIn(t,e){return null!=t&&hasPath(t,e,baseHasIn)}var COMPARE_PARTIAL_FLAG$5=1,COMPARE_UNORDERED_FLAG$3=2;function baseMatchesProperty(r,n){return isKey(r)&&isStrictComparable(n)?matchesStrictComparable(toKey(r),n):function(t){var e=get(t,r);return void 0===e&&e===n?hasIn(t,r):baseIsEqual(n,e,COMPARE_PARTIAL_FLAG$5|COMPARE_UNORDERED_FLAG$3)}}function baseProperty(e){return function(t){return null==t?void 0:t[e]}}function basePropertyDeep(e){return function(t){return baseGet(t,e)}}function property(t){return isKey(t)?baseProperty(toKey(t)):basePropertyDeep(t)}function baseIteratee(t){return"function"==typeof t?t:null==t?identity:"object"==typeof t?isArray(t)?baseMatchesProperty(t[0],t[1]):baseMatches(t):property(t)}function createBaseFor(u){return function(t,e,r){for(var n=-1,i=Object(t),a=r(t),o=a.length;o--;){var s=a[u?o:++n];if(!1===e(i[s],s,i))break}return t}}var baseFor=createBaseFor();function baseForOwn(t,e){return t&&baseFor(t,e,keys)}function createBaseEach(a,o){return function(t,e){if(null!=t){if(!isArrayLike(t))return a(t,e);for(var r=t.length,n=o?r:-1,i=Object(t);(o?n--:++n<r)&&!1!==e(i[n],n,i););}return t}}var baseEach=createBaseEach(baseForOwn);function castFunction(t){return"function"==typeof t?t:identity}function forEach(t,e){return(isArray(t)?arrayEach:baseEach)(t,castFunction(e))}function arrayEvery(t,e){for(var r=-1,n=null==t?0:t.length;++r<n;)if(!e(t[r],r,t))return!1;return!0}function baseEvery(t,n){var i=!0;return baseEach(t,function(t,e,r){return i=!!n(t,e,r)}),i}function every(t,e,r){return(isArray(t)?arrayEvery:baseEvery)(t,baseIteratee(e=r&&isIterateeCall(t,e,r)?void 0:e))}function baseFilter(t,n){var i=[];return baseEach(t,function(t,e,r){n(t,e,r)&&i.push(t)}),i}function filter(t,e){return(isArray(t)?arrayFilter:baseFilter)(t,baseIteratee(e))}function createFind(a){return function(t,e,r){var n,i=Object(t);return isArrayLike(t)||(n=baseIteratee(e),t=keys(t),e=function(t){return n(i[t],t,i)}),-1<(e=a(t,e,r))?i[n?t[e]:e]:void 0}}var nativeMax$1=Math.max;function findIndex(t,e,r){var n=null==t?0:t.length;return n?((r=null==r?0:toInteger(r))<0&&(r=nativeMax$1(n+r,0)),baseFindIndex(t,baseIteratee(e),r)):-1}var find=createFind(findIndex);function baseMap(t,n){var i=-1,a=isArrayLike(t)?Array(t.length):[];return baseEach(t,function(t,e,r){a[++i]=n(t,e,r)}),a}function map(t,e){return(isArray(t)?arrayMap:baseMap)(t,baseIteratee(e))}function forIn(t,e){return null==t?t:baseFor(t,castFunction(e),keysIn)}var mapTag$6="[object Map]",setTag$6="[object Set]",objectProto$g=Object.prototype,hasOwnProperty$d=objectProto$g.hasOwnProperty;function isEmpty(t){if(null!=t){if(isArrayLike(t)&&(isArray(t)||"string"==typeof t||"function"==typeof t.splice||isBuffer(t)||isTypedArray(t)||isArguments(t)))return!t.length;var e,r=getTag$1(t);if(r==mapTag$6||r==setTag$6)return!t.size;if(isPrototype(t))return!baseKeys(t).length;for(e in t)if(hasOwnProperty$d.call(t,e))return!1}return!0}function isEqual(t,e){return baseIsEqual(t,e)}function isUndefined(t){return void 0===t}function baseSome(t,n){var i;return baseEach(t,function(t,e,r){return!(i=n(t,e,r))}),!!i}function some(t,e,r){return(isArray(t)?arraySome:baseSome)(t,baseIteratee(e=r&&isIterateeCall(t,e,r)?void 0:e))}var projections={},Projection=function(){function t(t,e,r,n){this.project=e,this.unproject=r,this.getResolution=n,projections[t]=this}return t.prototype.moveWithPixel=function(t,e,r){var r=this.getResolution(r),n=e[0]*r,e=e[1]*r,r=this.project(t[0],t[1]);return this.unproject(r[0]+n,r[1]+e)},t.prototype.moveWithPos=function(t,e){return t=[(t=this.project(t[0],t[1]))[0]+e[0],t[1]+e[1]],this.unproject(t[0],t[1])},t}(),ProjectionManager={getProjection:function(t){return projections[t]}},LngLat=new Projection("EPSG:4326",function(t,e){return[t,e]},function(t,e){return[t,e]},function(t){return.703125/Math.pow(2,t)}),SphericalMercator=function(){var n=Math.PI/180,r=180/Math.PI,i=6378137;return new Projection("EPSG:3857",function(t,e){var r=85.0511287798,r=(e=Math.max(Math.min(r,e),-r),t*n),t=e*n,t=Math.log(Math.tan(Math.PI/4+t/2));return[r*i,t*i]},function(t,e){return[t/i*r,(2*Math.atan(Math.exp(e/i))-Math.PI/2)*r]},function(t){return 156543.03392804097/Math.pow(2,t)})}(),LCS=function(){function t(){this.hg=[-20037508.342789244,-20037508.342789244,20037508.342789244,20037508.342789244],this.cg=128,this.vg=128,this.lg=(this.hg[2]-this.hg[0])/this.cg,this.dg=(this.hg[3]-this.hg[1])/this.vg}return t.prototype.setMap=function(t){this.map=t},t.prototype.getSize=function(){return[this.lg,this.dg]},t.prototype.getNum=function(){return[this.cg,this.vg]},t.prototype.getLocalByLnglat=function(t){var e=(e=ProjectionManager.getProjection("EPSG:3857")).project.apply(e,t);return this.getLocalByCoord(e)},t.prototype.getLocalByCoord=function(t){var e=Math.floor(t[0]/this.lg),r=Math.floor(t[1]/this.dg),n=this.getLocalCenterByXY(e,r);return{Sa:[t[0]-n.center[0],t[1]-n.center[1]],x:e,y:r,center:n.center,Ro:n.Ro}},t.prototype.getLocalCenterByXY=function(t,e){var r={x:t,y:e,center:[0,0],Ro:[0,0,0,0]};return r.center=[(t+.5)*this.lg,(e+.5)*this.dg],r.Ro=[t*this.lg,e*this.dg,(t+1)*this.lg,(e+1)*this.dg],r},t.prototype.getDeltaCoord=function(t){var e=this.getLocalByCoord(t);return[t[0]-e.center[0],t[1]-e.center[1]]},t}(),lcs=new LCS,E4326=ProjectionManager.getProjection("EPSG:4326"),E3857=ProjectionManager.getProjection("EPSG:3857"),HALF_WORLD_SIZE=20037508.342789244,LngLat$1={Ro:[-180,-90,180,90],project:function(t,e,r){return t=E4326.project(t,e),this.transform(t[0],t[1],r)},unproject:function(t,e,r){return t=this.Xs(t,e,r),E4326.unproject(t[0],t[1])},transform:function(t,e,r){var r=void 0===r?180:256<<r,i=this.Ro[2]-this.Ro[0],a=this.Ro[3]-this.Ro[1];return[t=(t-this.Ro[0])/i*(2*r),e=r-(e-this.Ro[1])/a*r]},Xs:function(t,e,r){return[t=360*(t/(2*(r=void 0===r?180:256<<r))-.5),e=180*-(e/r-.5)]},nt:function(t,e,r){return this.Xs(t,e,r)},wu:function(t,e,r){return this.Xs(t,e,r)},yo:function(t,e,r){var n=0<t/this.Ro[3]?Math.abs(Math.floor(t/this.Ro[3])):Math.abs(Math.ceil(t/this.Ro[3])),i=0<e/this.Ro[3]?Math.abs(Math.floor(e/this.Ro[3])):Math.abs(Math.ceil(e/this.Ro[3])),a=t%this.Ro[3],o=e%this.Ro[3],a=this.transform(a,o,r),o=(t=this.wu(t,t,r)[0]*n+a[0],e=this.wu(e,e,r)[1]*i+a[1],this.transform(0,0,r));return[t-o[0],e-o[1]]},Bb:function(t,e,r){return r.X(t,e)},qb:function(t,e,r){return r.H(t,e)},Gd:function(t,e,r,n){var i=n.X(t[0],t[1]);return[(n=n.X(t[0]+e,t[1]+r))[0]-i[0],n[1]-i[1]]}},SphericalMercator$1={Ro:[-20037508.342789244,-20037508.342789244,20037508.342789244,20037508.342789244],project:function(t,e,r){return t=E3857.project(t,e),this.transform(t[0],t[1],r)},unproject:function(t,e,r){return t=this.Xs(t,e,r),E3857.unproject(t[0],t[1])},transform:function(t,e,r){t=Math.min(20037508.342789244,Math.max(t,-20037508.342789244)),e=Math.min(20037508.342789244,Math.max(e,-20037508.342789244)),r=void 0===r?40075016.68557849:256*Math.pow(2,r);var n=this.Ro[2]-this.Ro[0],i=this.Ro[3]-this.Ro[1];return[t=(t-this.Ro[0])/n*r,e=r-(e-this.Ro[1])/i*r]},Xs:function(t,e,r){return[t=(t/(r=void 0===r?40075016.68557849:256*Math.pow(2,r))-.5)*this.Ro[2]*2,e=-(e/r-.5)*this.Ro[2]*2]},nt:function(t,e,r,n){return[t=this.Xs(t,e,r)[0]-this.Ro[0],e=this.Ro[2]-this.Xs(t,e,r)[1]]},wu:function(t,e,r,n){var i=n.center,a=n.size,n=(n.rotation||0)/180*Math.PI,e=(t=this.transform(t,e,r))[0],t=t[1],r=e-(i=this.transform(i[0],i[1],r))[0],e=t-i[1],t=Math.sqrt(Math.pow(r,2)+Math.pow(e,2)),i=0==e?Math.PI/2:Math.atan(Math.abs(r/e)),i=r*e<=0?i+n:i-n,n=0<e?1:-1;return[a[0]/2+t*Math.sin(0<r?i:-i),a[1]/2+t*Math.cos(i)*n]},yo:function(t,e,r,n){var i=0<t/this.Ro[3]?Math.abs(Math.floor(t/this.Ro[3])):Math.abs(Math.ceil(t/this.Ro[3])),a=0<e/this.Ro[3]?Math.abs(Math.floor(e/this.Ro[3])):Math.abs(Math.ceil(e/this.Ro[3])),o=t%this.Ro[3],s=e%this.Ro[3],o=this.transform(o,s,r),r=(s=this.transform(0,0,r))[0],s=s[1];return[(t=r*i+o[0])-r,(e=s*a+o[1])-s]},Bb:function(t,e,r){return r.X(t,e)},qb:function(t,e,r){return r.H(t,e)},Gd:function(t,e,r,n){var i=n.X(t[0],t[1]);return[(n=n.X(t[0]+e,t[1]+r))[0]-i[0],n[1]-i[1]]}},transform={"EPSG:4326":LngLat$1,"EPSG:3857":SphericalMercator$1},LocalZoom=13,LocalTileZoom=12,AMapStyleSource="",zoomRange=[2,26],CONSTS={ID:"__id__",Rp:zoomRange[1],Mp:zoomRange[0],jp:.8,Pp:.2,YM:5,KM:{dom:"div",id:"_amap_custom_labellayer_div_",className:"amap-layer",style:{cssText:"position:absolute;top:0;left:0;",zIndex:"",width:"",height:"",visible:""}},Dp:{Op:180,Ad:70,Td:360,t1:300,e1:30,Bd:Math.PI/10},XM:{top:3,right:3,bottom:3,left:3},JM:{ZM:"top",QM:"right",tj:"bottom",LEFT:"left",nj:"middle",ij:"center",ej:"alphabetic"},oj:{CLICK:"click",MOUSEOVER:"mouseover",MOUSEOUT:"mouseout",MOUSEMOVE:"mousemove",MOUSEDOWN:"mousedown",MOUSEUP:"mouseup",aj:"touchstart",uj:"touchend"},sj:{rank:1,angle:0,opacity:1,offset:[0,0],zooms:zoomRange,icon:{type:"image",image:"://visuallocal.amap.com/public/poi-marker.png",clipOrigin:[0,0],clipSize:[36,36],size:[36,36],anchor:"bottom-center",angel:0,retina:!0,zooms:zoomRange},text:{type:"billboard",direction:"top",offset:[0,0],zooms:zoomRange,style:{fj:6,fontFamily:"sans-serif",fontSize:12,fontWeight:"normal",fillColor:[0,0,0,1],strokeWidth:0,strokeColor:[.988,.988,.988,1],borderColor:"transparent",padding:[3,3,3,3],backgroundColor:""}}},hj:{cj:{opacity:.2},vj:"fadeIn",lj:"fadeOut",dj:{bj:"start",RUNNING:"running",pj:"complete"},yj:{mj:"opacity",gj:"size"}},_d:3,wj:"_AMap_sdf_com_words",Mj:128,pc:["://sdf.amap.com","://sdf01.amap.com","://sdf02.amap.com","://sdf03.amap.com","://sdf04.amap.com"],sp:4,Cd:.78125,Ld:205/256,Aj:{kj:"纹理加载失败，请重试",Oj:"资源加载失败，请重试"},xj:"bufferChanged",Ij:"frameBufferChanged",Tj:"combineFrameBufferChanged",ic:1,ud:13,Cj:12,Ej:"__icon_combination",Nj:"__text_combination",Lj:{file:{0:"://vdata.amap.com/style_icon/2.0/icon-normal-big.png",1:"://vdata.amap.com/style_icon/2.0/icon-biz-big.png"},size:[40,40],Rj:10},Kp:{buffer:3,family:"ios9",size:24},_n:{Uj:[0,0,0,1],Gp:[0,0,0,0]},gH:"sdf",RB:"sdfJson",FN:"version"},DangerousFontSize=(function(t){t.nebula="nebula",t.nebulaLabel="nebulaLabel"}(exports.n0||(exports.n0={})),24),EnumLabelFragType=(function(t){t[t.dynamic=0]="dynamic",t[t.icon=1]="icon"}(exports.cY||(exports.cY={})),{icon:0,bg:6,tq:8,text:2}),defaultCap=["butt","butt"],tmp1=(function(t){t.BLOB="blob",t.TOLOAD="toload",t.LOADING="loading",t.LOADED="loaded",t.UNLOADED="unloaded",t.ERROR="error",t.RELOADING="reloading",t.UNCOMBINED="uncombined",t.COMBINING="combining",t.COMBINED="combined"}(exports.uc||(exports.uc={})),4294901760),tmp2=65535;function getUploadName(t,e){return((t=tmp1-(t<<16))+(e=tmp2-e)).toString(16)}function staticSDFTileKeyToKey(t){var e=(t=map(t.split(","),function(t){return parseInt(t,10)}))[1],r=t[2];return t[0]<10?"lesszoom10":(10!==t[0]&&(12===t[0]?(e=Math.floor(e/4),r=Math.floor(r/4)):14===t[0]?(e=Math.floor(e/16),r=Math.floor(r/16)):15===t[0]&&(e=Math.floor(e/32),r=Math.floor(r/32))),getUploadName(e,r))}var labelsUtil={Bj:function(t){var e,r={};for(e in t=void 0===t?{}:t)t.hasOwnProperty(e)&&(r[e]=1);return r},zj:function(t,e){t.gs=e,t.qj=e.options||{},t.Wj=e.Wj||{},t.Fs=e.Fs||{},t.Gj=e.Gj||{},t.Hj=e.Hj||{},t.Vj=e.Vj||{},t.$j=e.$j||0},Yj:function(t,e){void 0===t&&(t=[NaN,NaN,NaN,NaN]),void 0===e&&(e=[0,0,0,1]);for(var r=0;r<t.length;r++){var n=t[r];isNaN(n)&&(t[r]=e[r])}return t},Kj:function(t){return[((16711680&t)>>16)/255,((65280&t)>>8)/255,(255&t)/255,1]},Xj:function(t,e){for(var r=[],n=(e=void 0===e?{}:e).qw,i=e.Aw,a=e.complete,o=0,s=t;o<s.length;o++){var u=s[o],u=new Promise(u);r.push(u)}var c=0;Promise.all(r).then(function(){n&&n.apply(void 0,arguments),a&&!c&&(c=1,a.apply(void 0,arguments))}).catch(function(){i&&i.apply(void 0,arguments),a&&!c&&(c=1,a.apply(void 0,arguments))})},Jj:function(t,e){var r=t[0],n=void 0===(n=t[1])?0:n,i=e[0],a=void 0===(a=e[1])?0:a;return(void 0===r?0:r)<=(i=void 0===i?0:i)?i<=n?a<n?[i,a]:[i,n]:null:labelsUtil.Jj(e,t)},measureText:function(t,e,r,n){if(void 0===e&&(e=""),"3D"===(n=void 0===n?"3D":n))return t.measureText(e,r)},lnglatToContainer:function(t,e){return(void 0===(e=e.zoom)?20:e)<LocalZoom?t:(e=lcs.getLocalByCoord(t),vector.Ip(t,e.center))},Sd:function(t,e){var r=t[0],t=void 0===(t=t[1])?0:t,n=e[0],e=void 0===(e=e[1])?0:e,n=Math.abs((void 0===n?0:n)-(void 0===r?0:r)),r=Math.abs(e-t);return Math.sqrt(Math.pow(n,2)+Math.pow(r,2))},getAngle:function(t,e){var r=t[0],t=t[1],n=(void 0===(n=e[0])?0:n)-(void 0===r?0:r),r=(void 0===(e=e[1])?0:e)-(void 0===t?0:t);return 0==n?r<0?3*Math.PI/2:Math.PI/2:0===(e=Math.atan(r/n))||0<e?0<=n?e:e+Math.PI:0<n?2*Math.PI+e:Math.PI+e},Fd:function(t,e,r){for(var n=t[0],i=void 0===n?0:n,a=void 0===(n=t[1])?0:n,o=(void 0===(t=e[0])?0:t)-i,s=(void 0===(n=e[1])?0:n)-a,u=[],c=0;c<r;)u.push([i+o/(r+1)*(c+1),a+s/(r+1)*(c+1)]),c++;return u},OG:function(t,e,r){return 0!==r?[t[0]+(e[0]-t[0])*r,t[1]+(e[1]-t[1])*r]:t},Ed:function(t,e){void 0===e&&(e="ch");var r,n,i,a=(t=void 0===t?[]:t).length;return!!a&&(r=t[0],t=t[4<=a?Math.floor(a/4*3):a-1],a=r[0],r=r[1],i=[(n=t[0])-a,(t=t[1])-r],("ch"===e&&1<Math.abs((t-r)/(n-a))?vector.Zj(i,[0,1]):vector.Zj(i,[1,0]))<0)},Nd:function(t,e,r){var n,i=t[0],t=t[1],a=e[0],o=((e=e[1])-t)/(a-i),a=[a-i,e-t];return 1<Math.abs(o)&&"x"!==r?(n=0<vector.Zj(a,[0,-1])?vector.Qj(a,[0,-1]):vector.Qj(a,[0,1]),0<o&&(n=-n)):(n=0<vector.Zj(a,[1,0])?vector.Qj(a,[1,0]):vector.Qj(a,[-1,0]),o<0&&(n=-n)),n},Od:function(t,e,r){var n=r*Math.sin(e),r=r*Math.cos(e);return[t[0]+r,t[1]+n]},jd:function(t,e,r,n){var t=vector.Ip(t,e),i=vector.length(t),r=vector.Ip(r,e),a=vector.length(r),t=vector.Zj(t,r),t=Math.acos(t/(i*a)),a=Math.PI-t,t=i*Math.sin(a),i=i*Math.cos(a),a=Math.sqrt(Math.pow(n,2)-Math.pow(t,2))-i,n=0===r[0]?0<r[1]?Math.PI/2:-Math.PI/2:Math.atan(r[1]/r[0]),t=Math.abs(a*Math.sin(n)),i=a*Math.cos(n),a=vector.Zj(r,[1,0]),n=vector.Zj(r,[0,1]);return vector.add(e,[0<=a?i:-i,0<=n?t:-t])},rank:function(t){for(var e=[],r=0;r<t.length;r++){var n=parseFloat(t[r]);n<0?(t.splice(r--,1),e.push(n)):t[r]=n}return t.sort(function(t,e){return t-e}),e.concat(t)},$p:function(t){var e=CONSTS.Mp,r=CONSTS.Rp;return t[1]>=zoomRange[1]&&(t[1]=r),t[0]<=zoomRange[0]&&(t[0]=e),t},toString:function(t,e){void 0===e&&(e=4);var r="";if(t)for(var n=0,i=t;n<i.length;n++){var a=i[n];r+=(a+"").length<e?a:a.toFixed(e)}return r},xf:function(t,e){var r,n,i,a=[],o=e.ja,s=e.Fa,u=e.Oa,c=e.Ea;for(r in t)t.hasOwnProperty(r)&&r!==CONSTS.gH&&r!==CONSTS.FN&&r!==CONSTS.RB&&("shields"===r||!o||(i=r.split("-"),n=parseInt(i[1],10),i=parseInt(i[2],10),o<=n&&n<=u&&s<=i&&i<=c))&&a.push(t[r]);return a.length?a:t},EQ:function(t,e){for(var r=[],n=e.length,i=0;i<n-1;i++){var a=t.substring(e[i],e[i+1]);r.push(a)}return n?r:t.split("")},aQ:function(t){for(var e=[],r=0;r<t.length;r++){for(var n=t[r],i=[],a=0;a<n.length;a++){var o=n.charCodeAt(a);i.push(o)}var s=i.join("|");e.push(s)}return e},tQ:function(t,e,r){var n="",i=[],a="";if(t.name){if(t.JQ&&0<t.JQ.length)n=getSpiltLineWithSpiltIndex(t.name,t.JQ);else if(r){var o=r.lineBreak(t.name,{from:"labelsLayer",CO:[]}),s=0,u="";if(2<=o.oQ.length){for(var c=1,f=o.oQ.length-1;c<f;c++)u+=t.name.slice(s,o.oQ[c])+" ",s=o.oQ[c];u+=t.name.slice(s)}else u=t.name;n=u}else n=t.name;a="ch"}else{switch(e){case"en":n=t.name_en,i=t.iQ,a="en";break;case"local":n=t.QQ,i=t.$G,a=t.CQ;break;default:n=t.BQ,a="ch"}n||(t.name_en?(n=t.name_en,i=t.iQ,a="en"):t.QQ&&(n=t.QQ,i=t.$G,a=t.QQ))}return{name:n,$G:i,type:a}}},vector={add:function(t,e){for(var r=[],n=0;n<t.length;n++)r[n]=t[n]+e[n];return r},Ip:function(t,e){for(var r=[],n=0;n<t.length;n++)r.push(t[n]-e[n]);return r},multiply:function(t,e){for(var r=[],n=0,i=t;n<i.length;n++){var a=i[n];r.push(a*e)}return r},Up:function(t,e){for(var r=[],n=0;n<t.length;n++)r[n]=t[n]/e;return r},tA:function(t){return this.multiply(t,-1)},Zj:function(t,e){var r=t[0],t=t[1],n=e[0];return(void 0===r?0:r)*(void 0===n?0:n)+(void 0===t?0:t)*(void 0===(e=e[1])?0:e)},Qj:function(t,e){var r=vector.Zj(t,e),t=vector.length(t),e=vector.length(e);return Math.acos(r/(t*e))},length:function(t){var e=t[0],t=t[1];return Math.sqrt(Math.pow(e,2)+Math.pow(t,2))}},noop=function(t){};function getSpiltLineWithSpiltIndex(t,e){if(e.shift(),0===e.length)return t;for(var r="",n=0,i=0,a=e.length;i<a;i++)r+=t.substr(n,e[i]-n)+" ",n=e[i];return r+t.substr(e[e.length-1])}var XHR={send:function(t,e){void 0===e&&(e={});var r=new XMLHttpRequest,i=void 0===(n=e.qw)?noop:n,a=void 0===(n=e.Aw)?noop:n,n=e.Me,o=e.method,e=e.content;return r.onreadystatechange=function(){if(4===r.readyState&&200===r.status){var t=r.response;try{i(t)}catch(t){a(t)}}else 404===r.status&&(r.abort(),a(Error("404")))},r.onerror=function(t){r.abort(),a(t)},r.open(o||"GET",t,!0),r.responseType=n||"json",r.send(e||void 0),r}},scale=Browser.scale,LabelsRenderUtil={getBounds:function(t,e){var r=(e=void 0===e?{}:e).zoom,n=e.centerCoord,i=(e.view,[150*scale,150*scale,150*scale,150*scale]),a=(t=t.boundsCoord)[0],o=t[1],s=t[2],t=t[3],u=this.nt(0,0,r,e),c=vector.Ip(this.nt(i[0],i[1],r,e),u),i=vector.Ip(this.nt(i[2],i[3],r,e),u),u=(e=LocalZoom<=r?n:[0,0])[0],r=e[1];return[[a-u-Math.abs(i[1]),o-r-Math.abs(i[0])],[s-u+Math.abs(c[1]),t-r+Math.abs(c[0])]]},gz:function(t,e){var r=e[0],e=e[1],n=t[0],t=t[1],i=n-r[0],r=t-r[1],n=e[0]-n,e=e[1]-t;return 0<=i&&0<=r&&0<=n&&0<=e},getRank:function(t,e){var r=(e=void 0===e?{}:e).forceShow,e=e._z,t=(t.data||{}).rank||1;return void 0!==r&&r?t-1e5:(void 0===e?0:e)/100*2e5+t},wu:function(t,e,r,n){var i,a,o,s,u,c;if(void 0===t&&(t=0),void 0===e&&(e=0),n)return u=n.viewState,s=n.size,i=n.transform,a=n.view,o=n.viewMode,c=n.centerCoord,n=void 0===(n=n.positionType)?"relative":n,"2D"===o?(o={center:u.centerCoord,rotation:u.rotation,size:s},u=(s=u.optimalZoom>=LocalZoom?c:[0,0])[0],c=s[1],i.wu(t+u,e+c,r,o)):"relative"===n?a.H(t,e):a._u(t,e)},r0:function(t,e,r,n,i){var a,o,s,u,c,f;if(void 0===t&&(t=0),void 0===e&&(e=0),void 0===r&&(r=0),i)return c=i.viewState,u=i.size,a=i.transform,o=i.view,s=i.viewMode,f=i.centerCoord,i=void 0===(i=i.positionType)?"relative":i,"2D"===s?(s={center:c.centerCoord,rotation:c.rotation,size:u},c=(u=c.optimalZoom>=LocalZoom?f:[0,0])[0],f=u[1],a.wu(t+c,e+f,n,s)):"relative"===i?o.H(t,e,r):o._u(t,e,r)},kz:function(t,e,r,n){if(void 0===t&&(t=[]),n=(n=void 0===n?{}:n).centerCoord,e<LocalZoom&&LocalZoom<=r){for(var i=n[0],a=n[1],o=[],s=0,u=t;s<u.length;s++){var c=u[s];o.push([c[0]-i,c[1]-a])}return o}return t},nt:function(t,e,r,n){void 0===t&&(t=0),void 0===e&&(e=0);var i=n.view,a=n.transform;return"2D"===n.viewMode?a.nt(t,e,r):i.X(t,e)},MG:function(t,e){return t<LocalZoom-1?[0,0]:e}};function isLngLat(t){return t&&"AMap.LngLat"===t.className}function isPixel(t){return t&&"AMap.Pixel"===t.className}function isSize(t){return t&&"AMap.Size"===t.className}function isLayer(t){return Boolean(t&&t.el&&"AMap.Layer"===t.el)}function isVectorLayer(t){return t&&"AMap.VectorLayer"===t.CLASS_NAME}function isOverlay(t){return t&&t.className&&Util.startsWith(t.className,"Overlay")}function isOverlayGroup(t){return t&&("Overlay.OverlayGroup"===t.className||"Overlay.GeoJSON"===t.className)}function isCircleMarker(t){return t&&t.className&&"Overlay.CircleMarker"===t.className}function isPolyline(t){return t&&t.className&&"Overlay.Polyline"===t.className}function isBezierCurve(t){return t&&t.className&&"Overlay.BezierCurve"===t.className}function isBounds(t){return t&&"AMap.Bounds"===t.className}function isNumber(t){return"number"==typeof(t=+t)&&!isNaN(t)}function isNumberArray(t){return Array.isArray(t)&&isNumber(t[0])}function isNumberArrayArray(t){return Array.isArray(t)&&isNumberArray(t[0])}function isNumberArrayArrayArray(t){return Array.isArray(t)&&isNumberArrayArray(t[0])}function isNumberArrayArrayArrayArray(t){return Array.isArray(t)&&isNumberArrayArrayArray(t[0])}function isLnglatLike(t){return isLngLat(t)||isNumberArray(t)}function isLnglatLikeArray(t){return Array.isArray(t)&&isLnglatLike(t[0])}function isLnglatLikeArrayArray(t){return Array.isArray(t)&&isLnglatLikeArray(t[0])}function isLnglatLikeArrayArrayArray(t){return Array.isArray(t)&&isLnglatLikeArrayArray(t[0])}function isInnerLabelsLayer(t){return t&&"AMap.Inner.LabelsLayer"===t.CLASS_NAME}function isUndefined$1(t){return void 0===t}function calcTileMectorBounds(t,e,r){var n=ProjectionManager.getProjection("EPSG:3857"),a=180/(t=Math.pow(2,t)),i=(e=(i=360/t)*e-180)+i,r=(t=a*(t-r-1)-90)+a;return[e=(a=n.project(e,t))[0],t=a[1],(a=n.project(i,r))[0],a[1]]}function parseLngLatData(t){if(Array.isArray(t)){var e;if(!Array.isArray(t[0]))return"string"==(e=typeof t[0])||"number"==e?new LngLat$2(t[0],t[1]):t;for(var r=0;r<t.length;r+=1)t[r]=parseLngLatData(t[r])}return t}function jsonLngLatData(t){if(isLngLat(t))return[t.getLng(),t.getLat()];if(Array.isArray(t)){for(var e=t.slice(0),r=0;r<e.length;r+=1)e[r]=jsonLngLatData(e[r]);return e}return t}var Coordinate={lr:function(t,e){for(var r=1/0,n=0,i=1,a=e.length;i<a;n=i,i+=1)r=Math.min(r,this.ur(t,[e[n],e[i]]));return Math.sqrt(r)},ur:function(t,e){return this.cr(t,this.closestOnSegment(t,e))},cr:function(t,e){var r=t[0]-e[0];return r*r+(t=t[1]-e[1])*t},pr:function(t,e,r,n){var i,a;return n=n||1e-6,r[0]===e[0]?(i=Math.min(e[1],r[1]),a=Math.max(e[1],r[1]),Math.abs(t[0]-r[0])<n&&t[1]>=i&&t[1]<=a):(i=Math.min(e[0],r[0]),a=Math.max(e[0],r[0]),r=(r[1]-e[1])/(r[0]-e[0])*(t[0]-e[0])+e[1],Math.abs(r-t[1])<n&&t[0]>=i&&t[0]<=a)},closestOnSegment:function(t,e){var r,n=t[0],t=t[1],i=e[0],e=e[1],a=i[0],i=i[1],o=e[0],s=o-a,u=(e=e[1])-i,t=(n=0==s&&0==u?0:(s*(n-a)+u*(t-i))/(s*s+u*u||0))<=0?(r=a,i):1<=n?(r=o,e):(r=a+n*s,i+n*u);return[r,t]},isClockwise:function(t){for(var e,r,n=t.length,i=0,a=t[n-1],o=a[0],s=a[1],u=0;u<n;u+=1)i+=((e=(r=t[u])[0])-o)*((r=r[1])+s),o=e,s=r;return 0<i},ss:function(t,e,r){for(var n=t[0],i=t[1],a=!1,o=e.length,s=0,u=o-1;s<o;u=s,s+=1){var c=!1,f=e[s][0],h=e[s][1],l=e[u][0],d=e[u][1];if(f===n&&h===i||l===n&&d===i)return!!r;if(h<i==i<=d){if(n===(l=(l-f)*(i-h)/(d-h)+f))return!!r;c=n<l}c&&(a=!a)}return a},dr:function(t,e){for(var r,n=function(t,e,r){return(r[0]-e[0])*(t[1]-e[1])>(r[1]-e[1])*(t[0]-e[0])},i=function(t,e,r,n){var i=[t[0]-e[0],t[1]-e[1]],a=[r[0]-n[0],r[1]-n[1]],t=t[0]*e[1]-t[1]*e[0],e=r[0]*n[1]-r[1]*n[0],r=1/(i[0]*a[1]-i[1]*a[0]);return[(t*a[0]-e*i[0])*r,(t*a[1]-e*i[1])*r]},a=t,o=e[e.length-2],s=0,u=e.length-1;s<u;s++){for(var c=e[s],f=a,a=[],h=f[f.length-1],l=0,d=f.length;l<d;l++)n(r=f[l],o,c)?(n(h,o,c)||a.push(i(o,c,h,r)),a.push(r)):n(h,o,c)&&a.push(i(o,c,h,r)),h=r;o=c}return a.length<3?[]:(a.push(a[0]),a)}},Pixel=function(){function r(t,e,r){if(void 0===r&&(r=!1),this.className="AMap.Pixel",(isNaN(t)||isNaN(e))&&!window._AMapConfig)throw Error("Invalid Object: Pixel("+t+", "+e+")");this.x=r?Math.round(t):Number(t),this.y=r?Math.round(e):Number(e)}return r.prototype.getX=function(){return this.x},r.prototype.round=function(){return new r(Math.round(this.x),Math.round(this.y))},r.prototype.getY=function(){return this.y},r.prototype.toString=function(){return this.x+","+this.y},r.prototype.equals=function(t){return t instanceof r&&Math.max(Math.abs(this.x-t.x),Math.abs(this.y-t.y))<=1e-9},r.prototype.toArray=function(){return[this.x,this.y]},r.prototype.subtract=function(t,e){return new r(this.x-t.x,this.y-t.y,e)},r.prototype.multiplyBy=function(t,e){return new r(this.x*t,this.y*t,e)},r.prototype.direction=function(){var t,e=this.x,r=this.y;return 0===e&&0===r?null:0===e?0<r?90:270:(t=180*Math.atan(r/e)/Math.PI,e<0&&0<r||e<0&&r<0?180+t:0<e&&r<0?360+t:t)},r.prototype.toJSON=function(){return[this.x,this.y]},r}(),commonjsGlobal="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function unwrapExports(t){return t&&t.gP&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}function createCommonjsModule(t,e){return t(e={exports:{}},e.exports),e.exports}var dist=createCommonjsModule(function(u,t){function c(t,e){return e<t?1:t<e?-1:0}function y(t,e,r){null===e?(t.PP=!1,t.OP=!0):(t._P===e._P?(t.PP=!e.PP,t.OP=e.OP):(t.PP=!e.OP,t.OP=e.NP()?!e.PP:e.PP),e&&(t.CP=!n(e,r)||e.NP()?e.CP:e)),e=n(t,r),t.hN=e?function(t,e){var r,n=!t.PP,i=!t.OP;switch(e){case w:r=n&&i;break;case P:r=n||i;break;case N:r=n^i;break;case C:r=t._P?n&&!i:i&&!n}return r?1:-1}(t,r):0}function n(t,e){switch(t.type){case o:switch(e){case w:return!t.OP;case P:return t.OP;case C:return t._P&&t.OP||!t._P&&!t.OP;case N:return!0}break;case M:return e===w||e===P;case S:return e===C;case x:return!1}return!1}function v(t,e){return t[0]===e[0]&&t[1]===e[1]}function I(t,e,r,n,i){var a,o,s,u,c=e[0],f=n[0],h=0,l=0,d=(c<f==-c<f?(a=c,c=e[++h]):(a=f,f=n[++l]),0);if(h<t&&l<r)for(c<f==-c<f?(s=a-((o=c+a)-c),c=e[++h]):(s=a-((o=f+a)-f),f=n[++l]),a=o,0!==s&&(i[d++]=s);h<t&&l<r;)c<f==-c<f?(s=a-((o=a+c)-(u=o-a))+(c-u),c=e[++h]):(s=a-((o=a+f)-(u=o-a))+(f-u),f=n[++l]),a=o,0!==s&&(i[d++]=s);for(;h<t;)s=a-((o=a+c)-(u=o-a))+(c-u),c=e[++h],a=o,0!==s&&(i[d++]=s);for(;l<r;)s=a-((o=a+f)-(u=o-a))+(f-u),f=n[++l],a=o,0!==s&&(i[d++]=s);return 0===a&&0!==d||(i[d++]=a),d}function e(t){return new(commonjsGlobal.Float64Array?Float64Array:Array)(t)}function i(t,e,r){n=t[0],t=t[1],i=e[0],e=e[1];var n,i,a,o,s,a=r[0],s=(o=(t-(r=r[1]))*(i-a))-(u=(n-a)*(e-r)),u=0==o||0==u||0<o!=0<u||(o=Math.abs(o+u),Math.abs(s)>=33306690738754716e-32*o)?s:-function(t,e,r,n,i,a,o){var s,u,c,f,h,l,d,v,g,p,y=t-i,m=r-i,b=e-a,T=n-a,A=y*T,x=$*y,M=x-(x-y),S=y-M,w=(k[0]=(d=S*(c=T-(u=(x=$*T)-(x-T)))-(A-M*u-S*u-M*c))-((f=d-(g=(S=b-(M=(x=$*b)-(x-b)))*(c=m-(u=(x=$*m)-(x-m)))-((v=b*m)-M*u-S*u-M*c)))+(s=d-f))+(s-g),k[1]=(l=A-((h=A+f)-(s=h-A))+(f-s))-((f=l-v)+(s=l-f))+(s-v),k[2]=h-((p=h+f)-(s=p-h))+(f-s),k[3]=p,function(e){for(var r=e[0],n=1;n<4;n++)r+=e[n];return r}(k)),P=22204460492503146e-32*o;return P<=w||P<=-w||(t=t-(y+(s=t-y))+(s-i),r=r-(m+(s=r-m))+(s-i),i=e-(b+(s=e-b))+(s-a),e=n-(T+(s=n-T))+(s-a),0==t&&0==i&&0==r&&0==e)||(P=11093356479670487e-47*o+33306690738754706e-32*Math.abs(w))<=(w+=y*e+T*t-(b*r+m*i))||P<=-w?w:(E[0]=(d=(S=t-(M=(x=$*t)-(x-t)))*(c=T-(u=(x=$*T)-(x-T)))-((A=t*T)-M*u-S*u-M*c))-((f=d-(g=(S=i-(M=(x=$*i)-(x-i)))*(c=m-(u=(x=$*m)-(x-m)))-((v=i*m)-M*u-S*u-M*c)))+(s=d-f))+(s-g),E[1]=(l=A-((h=A+f)-(s=h-A))+(f-s))-((f=l-v)+(s=l-f))+(s-v),E[2]=h-((p=h+f)-(s=p-h))+(f-s),E[3]=p,n=I(4,k,4,E,L),E[0]=(d=(S=y-(M=(x=$*y)-(x-y)))*(c=e-(u=(x=$*e)-(x-e)))-((A=y*e)-M*u-S*u-M*c))-((f=d-(g=(S=b-(M=(x=$*b)-(x-b)))*(c=r-(u=(x=$*r)-(x-r)))-((v=b*r)-M*u-S*u-M*c)))+(s=d-f))+(s-g),E[1]=(l=A-((h=A+f)-(s=h-A))+(f-s))-((f=l-v)+(s=l-f))+(s-v),E[2]=h-((p=h+f)-(s=p-h))+(f-s),E[3]=p,a=I(n,L,4,E,O),E[0]=(d=(S=t-(M=(x=$*t)-(x-t)))*(c=e-(u=(x=$*e)-(x-e)))-((A=t*e)-M*u-S*u-M*c))-((f=d-(g=(S=i-(M=(x=$*i)-(x-i)))*(c=r-(u=(x=$*r)-(x-r)))-((v=i*r)-M*u-S*u-M*c)))+(s=d-f))+(s-g),E[1]=(l=A-((h=A+f)-(s=h-A))+(f-s))-((f=l-v)+(s=l-f))+(s-v),E[2]=h-((p=h+f)-(s=p-h))+(f-s),E[3]=p,o=I(a,O,4,E,_),_[o-1])}(n,t,i,e,a,r,o);return 0<u?-1:u<0?1:0}function m(t,e){var r=t.point,n=e.point;return r[0]>n[0]?1:r[0]<n[0]?-1:r[1]!==n[1]?r[1]>n[1]?1:-1:(n=e,e=r,(r=t).left===n.left?0===i(e,r.IP.point,n.IP.point)?!r._P&&n._P?1:-1:r.FP(n.IP.point)?-1:1:r.left?1:-1)}function g(t,e,r){var n=new l(e,!1,t,t._P),e=new l(e,!0,t.IP,t._P);v(t.point,t.IP.point)&&console.warn("what is that, a collapsed segment?",t),n.UP=e.UP=t.UP,0<m(e,t.IP)&&(t.IP.left=!0,e.left=!1),t.IP.IP=e,t.IP=n,r.push(e),r.push(n)}function p(t,e){return t[0]*e[1]-t[1]*e[0]}function b(t,e){return t[0]*e[0]+t[1]*e[1]}function T(t,e,r){n=t.point,i=t.IP.point,h=e.point,d=e.IP.point;var n,i,o,s,u,f,h,l,d,i=[i[0]-n[0],i[1]-n[1]],d=[d[0]-h[0],d[1]-h[1]],u=[h[0]-n[0],h[1]-n[1]],s=p(i,d),f=b(i,i);function c(t,e,r){return[t[0]+e*r[0],t[1]+e*r[1]]}return 0===(d=(u=0<s*s?(o=p(u,d)/s)<0||1<o||(l=p(u,i)/s)<0||1<l?null:0!=o&&1!=o&&(0==l||1==l)?[c(h,l,d)]:[c(n,o,i)]:!(0<(s=p(u,i))*s)&&(l=(h=b(i,u)/f)+b(i,d)/f,o=Math.min(h,l),s=Math.max(h,l),o<=1)&&0<=s?1===o?[c(n,0<o?o:0,i)]:0===s?[c(n,s<1?s:1,i)]:[c(n,0<o?o:0,i),c(n,s<1?s:1,i)]:null)?u.length:0)||1===d&&(v(t.point,e.point)||v(t.IP.point,e.IP.point))||2===d&&t._P===e._P?0:1===d?(v(t.point,u[0])||v(t.IP.point,u[0])||g(t,u[0],r),v(e.point,u[0])||v(e.IP.point,u[0])||g(e,u[0],r),1):(l=h=!(f=[]),v(t.point,e.point)?h=!0:1===m(t,e)?f.push(e,t):f.push(t,e),v(t.IP.point,e.IP.point)?l=!0:1===m(t.IP,e.IP)?f.push(e.IP,t.IP):f.push(t.IP,e.IP),h&&l||h?(e.type=x,t.type=e.PP===t.PP?M:S,h&&!l&&g(f[1].IP,f[0].point,r),2):(l?g(f[0],f[1].point,r):f[0]!==f[3].IP?(g(f[0],f[1].point,r),g(f[1],f[2].point,r)):(g(f[0],f[1].point,r),g(f[3].IP,f[2].point,r)),3))}function D(t,e){var r,n;return t===e?0:0!==i(t.point,t.IP.point,e.point)||0!==i(t.point,t.IP.point,e.IP.point)?v(t.point,e.point)?t.FP(e.IP.point)?-1:1:t.point[0]===e.point[0]?t.point[1]<e.point[1]?-1:1:1===m(t,e)?e.RP(t.point)?-1:1:t.FP(e.point)?-1:1:t._P!==e._P?t._P?-1:1:(r=t.point,n=e.point,r[0]===n[0]&&r[1]===n[1]?(r=t.IP.point,n=e.IP.point,r[0]===n[0]&&r[1]===n[1]?0:t.UP>e.UP?1:-1):1===m(t,e)?1:-1)}function h(t,e){return t<e?-1:e<t?1:0}function G(t,e,r,n,i,a){for(var o=0,s=t.length-1;o<s;o++){var u=t[o],c=t[o+1],f=new l(u,!1,void 0,e),h=new l(c,!1,f,e);f.IP=h,u[0]===c[0]&&u[1]===c[1]||(f.UP=h.UP=r,a||(f.DP=!1,h.DP=!1),0<m(f,h)?h.left=!0:f.left=!0,c=u[0],u=u[1],i[0]=j(i[0],c),i[1]=j(i[1],u),i[2]=d(i[2],c),i[3]=d(i[3],u),n.push(f),n.push(h))}}function r(t,e,r){if("number"==typeof t[0][0][0]&&(t=[t]),u=e="number"==typeof e[0][0][0]?[e]:e,n=null,(c=t).length*u.length==0&&(r===w?n=R:r===C?n=c:r!==P&&r!==N||(n=0===c.length?u:c)),n)return n===R?null:n;var o,s=[1/0,1/0,-1/0,-1/0],u=[1/0,1/0,-1/0,-1/0],c=function(t,e,r,n,i){for(var a,o,s,u,c=new U(null,m),f=0,h=t.length;f<h;f++)for(s=0,u=(a=t[f]).length;s<u;s++)(o=0===s)&&F++,G(a[s],!0,F,c,r,o);for(f=0,h=e.length;f<h;f++)for(s=0,u=(a=e[f]).length;s<u;s++)o=0===s,(o=i!==C&&o)&&F++,G(a[s],!1,F,c,n,o);return c}(t,e,s,u,r),n=t;if(t=e,e=r,o=null,(s[0]>u[2]||s[2]<u[0]||u[3]<s[1]||s[3]<u[1])&&(e===w?o=R:e===C?o=n:e!==P&&e!==N||(o=n.concat(t))),o)return o===R?null:o;for(var f=function(t){for(var f=function(t){for(var e,r,n=[],i=0,a=t.length;i<a;i++)((e=t[i]).left&&e.EP||!e.left&&e.IP.EP)&&n.push(e);for(var o=!1;!o;)for(o=!0,i=0,a=n.length;i<a;i++)i+1<a&&1===m(n[i],n[i+1])&&(r=n[i],n[i]=n[i+1],n[i+1]=r,o=!1);for(i=0,a=n.length;i<a;i++)(e=n[i]).lN=i;for(i=0,a=n.length;i<a;i++)(e=n[i]).left||(r=e.lN,e.lN=e.IP.lN,e.IP.lN=r);return n}(t),h={},l=[],d=0,r=f.length;d<r;d++)!function(){if(!h[d]){var t,e,r,n,i=l.length,a=(c=f[d],t=l,e=i,n=new V,null!=c.CP?(r=(c=c.CP).dN,0<c.hN?null!=(c=t[r]).gN?(t[c=c.gN].vN.push(e),n.gN=c,n.depth=t[r].depth):(t[r].vN.push(e),n.gN=r,n.depth=t[r].depth+1):(n.gN=null,n.depth=t[r].depth)):(n.gN=null,n.depth=0),n),o=function(t){h[t]=!0,f[t].dN=i},s=d,u=d,c=f[d].point;for(a.points.push(c);o(s),o(s=f[s].lN),a.points.push(f[s].point),(s=function(t,e,r,n){var i,a=t+1,o=e[t].point,s=e.length;for(a<s&&(i=e[a].point);a<s&&i[0]===o[0]&&i[1]===o[1];){if(!r[a])return a;i=e[++a].point}for(a=t-1;r[a]&&n<a;)a--;return a}(s,f,h,u))!=u;);l.push(a)}}();return l}(function(t,e,r,n){for(var i=new A(D),a=[],o=Math.min(e[2],r[2]);0!==t.length;){var s,u,c,f,h,l=t.pop();if(a.push(l),n===w&&l.point[0]>o||n===C&&l.point[0]>e[2])break;l.left?(c=u=i.Xc(l),u=u!==(s=i.MP())?i.NM(u):null,c=i.next(c),y(l,f=u?u.key:null,n),c&&2===T(l,c.key,t)&&(y(l,f,n),y(l,c.key,n)),u&&2===T(u.key,l,t)&&(y(f,(h=(h=u)!==s?i.NM(h):null)?h.key:null,n),y(l,f,n))):(l=l.IP,c=u=i.find(l),u&&c&&(u=u!==s?i.NM(u):null,c=i.next(c),i.remove(l),c)&&u&&T(u.key,c.key,t))}return a}(c,s,u,r)),h=[],l=0;l<f.length;l++){var d=f[l];if(d.pN()){for(var v=[d.points],g=0;g<d.vN.length;g++){var p=d.vN[g];v.push(f[p].points)}h.push(v)}}return h}var A,o,x,M,S,w,P,C,N,l,$,k,L,O,_,E,V,U,d,j,F,R,s={size:{configurable:!0}};(A=function(t,e){void 0===e&&(e=!1),this.bP=t=void 0===t?c:t,this.yP=null,this._size=0,this.mP=!!e}).prototype.TP=function(t){var e=t.right;e&&(t.right=e.left,e.left&&(e.left.parent=t),e.parent=t.parent),t.parent?t===t.parent.left?t.parent.left=e:t.parent.right=e:this.yP=e,e&&(e.left=t),t.parent=e},A.prototype.wP=function(t){var e=t.left;e&&(t.left=e.right,e.right&&(e.right.parent=t),e.parent=t.parent),t.parent?t===t.parent.left?t.parent.left=e:t.parent.right=e:this.yP=e,e&&(e.right=t),t.parent=e},A.prototype.AP=function(t){for(;t.parent;){var e=t.parent;e.parent?e.left===t&&e.parent.left===e?(this.wP(e.parent),this.wP(e)):e.right===t&&e.parent.right===e?(this.TP(e.parent),this.TP(e)):e.left===t&&e.parent.right===e?(this.wP(e),this.TP(e)):(this.TP(e),this.wP(e)):e.left===t?this.wP(e):this.TP(e)}},A.prototype.xP=function(t){for(var e,r,n,i;t.parent;)(r=(e=t.parent).parent)&&r.parent?((n=r.parent).left===r?n.left=t:n.right=t,t.parent=n):(t.parent=null,this.yP=t),n=t.left,i=t.right,t===e.left?(r&&(r.left===e?(e.right?(r.left=e.right,r.left.parent=r):r.left=null,(e.right=r).parent=e):(n?(r.right=n).parent=r:r.right=null,(t.left=r).parent=t)),i?(e.left=i).parent=e:e.left=null,(t.right=e).parent=t):(r&&(r.right===e?(e.left?(r.right=e.left,r.right.parent=r):r.right=null,(e.left=r).parent=e):(i?(r.left=i).parent=r:r.left=null,(t.right=r).parent=t)),n?(e.right=n).parent=e:e.right=null,(t.left=e).parent=t)},A.prototype.replace=function(t,e){t.parent?t===t.parent.left?t.parent.left=e:t.parent.right=e:this.yP=e,e&&(e.parent=t.parent)},A.prototype.MP=function(t){if(t=void 0===t?this.yP:t)for(;t.left;)t=t.left;return t},A.prototype.SP=function(t){if(t=void 0===t?this.yP:t)for(;t.right;)t=t.right;return t},A.prototype.Xc=function(t,e){var r=this.yP,n=null,i=this.bP;if(this.mP)for(;r;){if(0===i((n=r).key,t))return;r=i(r.key,t)<0?r.right:r.left}else for(;r;)r=i((n=r).key,t)<0?r.right:r.left;return r={key:t,data:e,left:null,right:null,parent:n},n?i(n.key,r.key)<0?n.right=r:n.left=r:this.yP=r,this.xP(r),this._size++,r},A.prototype.find=function(t){for(var e=this.yP,r=this.bP;e;){var n=r(e.key,t);if(n<0)e=e.right;else{if(!(0<n))return e;e=e.left}}return null},A.prototype.contains=function(t){for(var e=this.yP,r=this.bP;e;){var n=r(t,e.key);if(0===n)return!0;e=n<0?e.left:e.right}return!1},A.prototype.remove=function(t){var e;return!!(t=this.find(t))&&(this.xP(t),t.left?t.right?((e=this.MP(t.right)).parent!==t&&(this.replace(e,e.right),e.right=t.right,e.right.parent=e),this.replace(t,e),e.left=t.left,e.left.parent=e):this.replace(t,t.left):this.replace(t,t.right),this._size--,!0)},A.prototype.removeNode=function(t){var e;return!!t&&(this.xP(t),t.left?t.right?((e=this.MP(t.right)).parent!==t&&(this.replace(e,e.right),e.right=t.right,e.right.parent=e),this.replace(t,e),e.left=t.left,e.left.parent=e):this.replace(t,t.left):this.replace(t,t.right),this._size--,!0)},A.prototype.$P=function(t){var e,r;(t=this.find(t))&&(this.xP(t),e=t.left,t=t.right,r=null,e&&(e.parent=null,r=this.SP(e),this.xP(r),this.yP=r),t&&(e?r.right=t:this.yP=t,t.parent=r),this._size--)},A.prototype.pop=function(){var t=this.yP,e=null;if(t){for(;t.left;)t=t.left;e={key:t.key,data:t.data},this.remove(t.key)}return e},A.prototype.next=function(t){var e=t;if(e)if(e.right)for(e=e.right;e&&e.left;)e=e.left;else for(e=t.parent;e&&e.right===t;)e=(t=e).parent;return e},A.prototype.NM=function(t){var e=t;if(e)if(e.left)for(e=e.left;e&&e.right;)e=e.right;else for(e=t.parent;e&&e.left===t;)e=(t=e).parent;return e},A.prototype.forEach=function(t){for(var e=this.yP,r=[],n=!1,i=0;!n;)e?(r.push(e),e=e.left):0<r.length?(t(e=r.pop(),i++),e=e.right):n=!0;return this},A.prototype.range=function(t,e,r,n){for(var i=[],a=this.bP,o=this.yP;0!==i.length||o;)if(o)i.push(o),o=o.left;else{if(0<a((o=i.pop()).key,e))break;if(0<=a(o.key,t)&&r.call(n,o))return this;o=o.right}return this},A.prototype.keys=function(){for(var t=this.yP,e=[],r=[],n=!1;!n;)t?(e.push(t),t=t.left):0<e.length?(t=e.pop(),r.push(t.key),t=t.right):n=!0;return r},A.prototype.values=function(){for(var t=this.yP,e=[],r=[],n=!1;!n;)t?(e.push(t),t=t.left):0<e.length?(t=e.pop(),r.push(t.data),t=t.right):n=!0;return r},A.prototype.at=function(t){for(var e=this.yP,r=[],n=!1,i=0;!n;)if(e)r.push(e),e=e.left;else if(0<r.length){if(e=r.pop(),i===t)return e;i++,e=e.right}else n=!0;return null},A.prototype.load=function(t,e,r){if(void 0===t&&(t=[]),void 0===e&&(e=[]),void 0===r&&(r=!1),0!==this._size)throw new Error("bulk-load: tree is not empty");var n=t.length;return r&&function t(e,r,n,i,a){if(!(i<=n)){for(var o=e[n+i>>1],s=n-1,u=i+1;;){for(;a(e[++s],o)<0;);for(;0<a(e[--u],o););if(u<=s)break;var c=e[s];e[s]=e[u],e[u]=c,c=r[s],r[s]=r[u],r[u]=c}t(e,r,n,u,a),t(e,r,u+1,i,a)}}(t,e,0,n-1,this.bP),this.yP=function t(e,r,n,i,a){var u,o=a-i;return 0<o?((u={key:u=r[o=i+Math.floor(o/2)],data:n[o],parent:e}).left=t(u,r,n,i,o),u.right=t(u,r,n,o+1,a),u):null}(null,t,e,0,n),this._size=n,this},A.prototype.min=function(){var t=this.MP(this.yP);return t?t.key:null},A.prototype.max=function(){var t=this.SP(this.yP);return t?t.key:null},A.prototype.isEmpty=function(){return null===this.yP},s.size.get=function(){return this._size},A.LP=function(t,e,r,n,i){return new A(r,i).load(t,e,n)},Object.defineProperties(A.prototype,s),P=x=1,C=M=2,N=S=3,s={EP:{configurable:!(w=o=0)}},(l=function(t,e,r,n,i){this.left=e,this.point=t,this.IP=r,this._P=n,this.type=i||o,this.PP=!1,this.OP=!1,this.CP=null,this.hN=0,this.lN=-1,this.dN=-1,this.DP=!0}).prototype.FP=function(t){var e=this.point,r=this.IP.point;return this.left?0<(e[0]-t[0])*(r[1]-t[1])-(r[0]-t[0])*(e[1]-t[1]):0<(r[0]-t[0])*(e[1]-t[1])-(e[0]-t[0])*(r[1]-t[1])},l.prototype.RP=function(t){return!this.FP(t)},l.prototype.NP=function(){return this.point[0]===this.IP.point[0]},s.EP.get=function(){return 0!==this.hN},l.prototype.clone=function(){var t=new l(this.point,this.left,this.IP,this._P,this.type);return t.UP=this.UP,t.hN=this.hN,t.CP=this.CP,t.DP=this.DP,t.PP=this.PP,t.OP=this.OP,t},Object.defineProperties(l.prototype,s),$=134217729,k=e(4),L=e(8),O=e(12),_=e(16),E=e(4),(V=function(){this.points=[],this.vN=[],this.gN=null,this.depth=null}).prototype.pN=function(){return null==this.gN},(s=U=function a(t,e){if(!(this instanceof a))return new a(t,e);if(this.data=t||[],this.length=this.data.length,this.compare=e||h,0<this.length)for(var r=(this.length>>1)-1;0<=r;r--)this.zP(r)}).prototype={push:function(t){this.data.push(t),this.length++,this.El(this.length-1)},pop:function(){var t;if(0!==this.length)return t=this.data[0],this.length--,0<this.length&&(this.data[0]=this.data[this.length],this.zP(0)),this.data.pop(),t},GP:function(){return this.data[0]},El:function(t){for(var e=this.data,r=this.compare,n=e[t];0<t;){var i=t-1>>1,a=e[i];if(0<=r(n,a))break;e[t]=a,t=i}e[t]=n},zP:function(t){for(var e=this.data,r=this.compare,n=this.length>>1,i=e[t];t<n;){var a=1+(t<<1),o=a+1,s=e[a];if(o<this.length&&r(e[o],s)<0&&(s=e[a=o]),0<=r(s,i))break;e[t]=s,t=a}e[t]=i}},U.default=s,d=Math.max,j=Math.min,F=0,R=[],s={VP:P,BP:C,HP:w,WP:N},t.ZP=function(t,e){return r(t,e,C)},t.qP=function(t,e){return r(t,e,w)},t.YP=s,t.union=function(t,e){return r(t,e,P)},t.xor=function(t,e){return r(t,e,N)},Object.defineProperty(t,"gP",{value:!0})}),martinez=unwrapExports(dist),Const={vr:Math.PI/180,mr:180/Math.PI,yr:6378137};function getSphericalCrs(t,e){var r=function(t){switch(t){case"EPSG3857":return ProjectionManager.getProjection("EPSG:3857");case"EPSG4326":return ProjectionManager.getProjection("EPSG:4326")}return ProjectionManager.getProjection("EPSG3857")}(t);return{project:function(t){return Util.isArray(t)&&(t=new LngLat$2(t[0],t[1])),r.project(t.lng,t.lat)},unproject:function(t){return Util.isArray(t)&&(t=new Pixel(t[0],t[1])),r.unproject(t.x,t.y)},normalizePoint:function(t){return Util.parseLngLatData(t)},distance:function(t,e){if(e=this.normalizePoint(e),Util.isArray(e))return this.distanceToLine(t,e);t=this.normalizePoint(t);var r=Const.vr,n=Math.cos,i=t.lat*r,t=t.lng*r,a=e.lat*r,e=e.lng*r,r=2*Const.yr,e=e-t,t=(1-n(a-i)+(1-n(e))*n(i)*n(a))/2;return r*Math.asin(Math.sqrt(t))},ringArea:function(t){t=this.normalizeLine(t);var e=Const.yr*Const.vr,r=0,n=t,i=n.length;if(i<3)return 0;for(var a=0;a<i-1;a+=1){var o=n[a],s=n[a+1],u=o.lng*e*Math.cos(o.lat*Const.vr),o=o.lat*e,c=s.lng*e*Math.cos(s.lat*Const.vr);r+=u*(s.lat*e)-c*o}var t=n[a],f=n[0],h=t.lng*e*Math.cos(t.lat*Const.vr),t=t.lat*e,l=f.lng*e*Math.cos(f.lat*Const.vr);return r+=h*(f.lat*e)-l*t,.5*Math.abs(r)},sphericalCalotteArea:function(t){var e=Const.yr,t=e-e*Math.cos(t/e);return 2*Math.PI*e*t}}}function getPlanarCrs(){return{normalizePoint:function(t){return t&&t.x&&t.y?[t.x,t.y]:t},distance:function(t,e){var r=t[0]-e[0],t=t[1]-e[1];return Math.sqrt(r*r+t*t)},project:function(t){return t},unproject:function(t){return t},ringArea:function(t){for(var e=[0,0],r=[0,0],n=0,i=t[0],a=t.length,o=2;o<a;o++){var s=t[o-1],u=t[o];e[0]=i[0]-u[0],e[1]=i[1]-u[1],r[0]=i[0]-s[0],r[1]=i[1]-s[1],n+=e[0]*r[1]-e[1]*r[0]}return n/2}}}function isClockwise(t){for(var e=0,r=t.length,n=0;n<r-1;n++){var i,a=t[n];e+=((i=t[n+1])[0]-a[0])*(i[1]+a[1])}return t[r-1][0]===t[0][0]&&t[r-1][1]===t[0][1]||(a=t[r-1],e+=((i=t[0])[0]-a[0])*(i[1]+a[1])),0<e}var GeometryUtilCls=function(){function e(t){this.CLASS_NAME="AMap.GeometryUtil",this._opts=assign({onSegmentTolerance:5,crs:"EPSG3857",maxZoom:zoomRange[1]},t),this.setCrs(this._opts.crs)}return e.prototype.clone=function(t){return new e(assign({},this._opts,t))},e.prototype.isPoint=function(t){return t&&(t instanceof LngLat$2||Util.isArray(t)&&!isNaN(t[0]))},e.prototype.normalizePoint=function(t){return t},e.prototype.normalizeLine=function(t){for(var e=[],r=0,n=t.length;r<n;r++)e.push(this.normalizePoint(t[r]));return e},e.prototype.normalizeMultiLines=function(t){for(var e=[],r=0,n=(t=Util.isArray(t)&&this.isPoint(t[0])?[t]:t).length;r<n;r++)e.push(this.normalizeLine(t[r]));return e},e.prototype.setCrs=function(t){t=t&&t.project&&t.unproject?t:"plane"===t?getPlanarCrs():getSphericalCrs(t,this._opts.maxZoom),assign(this,t)},e.prototype.distance=function(t,e){throw new Error("distance Not implemented!")},e.prototype.xr=function(t,e){t=this.normalizeLine(t);for(var r=[],n=0,i=(t=this.isPoint(t[0])?t:t[0]).length;n<i;n++)r.push(this.project(t[n]));return!0===e?r=this.makesureClockwise(r):!1===e&&(r=this.makesureClockwise(r)).reverse(),r},e.prototype.br=function(t){for(var e=[],r=0,n=t.length;r<n;r++)e.push(this.unproject(t[r]));return e},e.prototype.closestOnSegment=function(t,e,r){return t=Coordinate.closestOnSegment(this.project(t),this.xr([e,r])),this.unproject(t)},e.prototype.closestOnLine=function(t,e){for(var r,n=1/0,i=0,a=(e=this.normalizeLine(e)).length;i<a-1;i++){var o=this.closestOnSegment(t,e[i],e[i+1]),s=this.distance(t,o);s<n&&(n=s,r=o)}return r},e.prototype.distanceToSegment=function(t,e,r){return this.distanceToLine(t,[e,r])},e.prototype.distanceToLine=function(t,e){e=this.normalizeLine(e);for(var r=1/0,n=0,i=(e=this.isPoint(e[0])?e:e[0]).length;n<i-1;n++)var a=this.closestOnSegment(t,e[n],e[n+1]),r=Math.min(r,this.distance(t,a));return r},e.prototype.distanceToPolygon=function(t,e){return this.isPointInRing(t,e)?0:this.distanceToLine(t,e)},e.prototype.isPointOnSegment=function(t,e,r,n){return(!n&&0!==n||n<0)&&(n=this._opts.onSegmentTolerance),this.distanceToSegment(t,e,r)<=n},e.prototype.isPointOnLine=function(t,e,r){for(var n=0,i=(e=this.normalizeLine(e)).length;n<i-1;n++)if(this.isPointOnSegment(t,e[n],e[n+1],r))return!0;return!1},e.prototype.isPointOnRing=function(t,e,r){for(var n=0,i=(e=this.normalizeLine(e)).length;n<i;n++)if(this.isPointOnSegment(t,e[n],e[n===i-1?0:n+1],r))return!0;return!1},e.prototype.isPointOnPolygon=function(t,e,r){for(var n=0,i=(e=this.normalizeMultiLines(e)).length;n<i;n++)if(this.isPointOnRing(t,e[n],r))return!0;return!1},e.prototype.makesureClockwise=function(t){return isClockwise(t)||(t=[].concat(t)).reverse(),t},e.prototype.makesureAntiClockwise=function(t){return isClockwise(t)&&(t=[].concat(t)).reverse(),t},e.prototype.pointInRing=function(t,e,r){for(var n=!1,i=0;i<e.length&&!n;i++)if(s(t,e[i][0],r)){for(var a=!1,o=1;o<e[i].length&&!a;)s(t,e[i][o],!r)&&(a=!0),o++;a||(n=!0)}function s(t,e,r){for(var n=!1,i=0,a=(e=e[0][0]===e[e.length-1][0]&&e[0][1]===e[e.length-1][1]?e.slice(0,e.length-1):e).length-1;i<e.length;a=i++){var o=e[i][0],s=e[i][1],u=e[a][0],c=e[a][1];if(t[1]*(o-u)+s*(u-t[0])+c*(t[0]-o)==0&&(o-t[0])*(u-t[0])<=0&&(s-t[1])*(c-t[1])<=0)return!r;s>t[1]!=c>t[1]&&t[0]<(u-o)*(t[1]-s)/(c-s)+o&&(n=!n)}return n}return n},e.prototype.isPointInBbox=function(t,e){for(var r=1/0,n=1/0,i=-1/0,a=-1/0,o=0;o<e.length;o++)var s=e[o],r=Math.min(r,s[0]),i=Math.max(i,s[0]),n=Math.min(n,s[1]),a=Math.max(a,s[1]);return t[0]>r&&t[0]<i&&t[1]>n&&t[1]<a},e.prototype.isPointInRing=function(t,e){return e=this.normalizeLine(e),e=this.xr(e,!0),Coordinate.ss(this.project(t),e,!1)},e.prototype.isRingInRing=function(t,e){for(var r=0,n=t.length;r<n;r++)if(!this.isPointInRing(t[r],e))return!1;return!0},e.prototype.isRingInRingByOutsea=function(t,e){for(var r=0,n=t.length;r<n;r++)if(this.isPointInRing(t[r],e))return!0;for(r=0,n=e.length;r<n;r++)if(this.isPointInRing(e[r],t))return!0;return!1},e.prototype.isRingInRingByMapbox=function(t,e){for(var r=0,n=t.length;r<n;r++)if(!this.isPointInRing(t[r],e))return!1;return!0},e.prototype.isRingInRingByMapboxB=function(t,e){for(var r=0,n=t.length;r<n;r++)if(this.isPointInRing(t[r],e))return!0;return!1},e.prototype.isPixelRingInRing=function(t,e){for(var r=0,n=t.length;r<n;r++)if(Coordinate.ss(t[r],e,!1))return!0;return!1},e.prototype.isPointInPolygon=function(t,e){for(var r,n=0,i=(e=this.normalizeMultiLines(e)).length;n<i&&(r=this.isPointInRing(t,e[n]),r=0<n?!r:r);n+=1);return Boolean(r)},e.prototype.isPointInPolygons=function(t,e){for(var r=0;r<e.length;r++){for(var n=e[r],i=void 0,a=0,o=(n=this.normalizeMultiLines(n)).length;a<o&&(i=this.isPointInRing(t,n[a]),i=0<a?!i:i);a+=1);if(i)return!0}return!1},e.prototype.doesSegmentsIntersect=function(t,e,r,n){t=(i=this.xr([t,e,r,n]))[0],e=i[1],r=i[2];var i=((n=i[3])[0]-r[0])*(t[1]-r[1])-(n[1]-r[1])*(t[0]-r[0]),o=(e[0]-t[0])*(t[1]-r[1])-(e[1]-t[1])*(t[0]-r[0]);return 0!=(n=(n[1]-r[1])*(e[0]-t[0])-(n[0]-r[0])*(e[1]-t[1]))&&(r=o/n,0<=(e=i/n))&&e<=1&&0<=r&&r<=1},e.prototype.doesSegmentLineIntersect=function(t,e,r){for(var n=0,i=(r=this.normalizeLine(r)).length;n<i-1;n++)if(this.doesSegmentsIntersect(t,e,r[n],r[n+1]))return!0;return!1},e.prototype.doesSegmentRingIntersect=function(t,e,r){for(var n=0,i=(r=this.normalizeLine(r)).length;n<i;n++)if(this.doesSegmentsIntersect(t,e,r[n],r[n===i-1?0:n+1]))return!0;return!1},e.prototype.doesSegmentPolygonIntersect=function(t,e,r){for(var n=0,i=(r=this.normalizeMultiLines(r)).length;n<i;n++)if(this.doesSegmentRingIntersect(t,e,r[n]))return!0;return!1},e.prototype.doesLineLineIntersect=function(t,e){for(var r=0,n=(t=this.normalizeLine(t)).length;r<n-1;r++)if(this.doesSegmentLineIntersect(t[r],t[r+1],e))return!0;return!1},e.prototype.doesLineRingIntersect=function(t,e){for(var r=0,n=(t=this.normalizeLine(t)).length;r<n-1;r++)if(this.doesSegmentRingIntersect(t[r],t[r+1],e))return!0;return!1},e.prototype.doesPolygonPolygonIntersect=function(t,e){return!!(this.doesRingRingIntersect(e,t)||this.isRingInRing(t,e)||this.isRingInRing(e,t))},e.prototype.doesRingRingIntersect=function(t,e){for(var r=0,n=(t=this.normalizeLine(t)).length;r<n;r++)if(this.doesSegmentRingIntersect(t[r],t[r===n-1?0:r+1],e))return!0;return!1},e.prototype.along=function(t,e){for(var r=0,n=0;n<t.length-1;n+=1){var i,a=this.distance(t[n],t[n+1]);if(!(a+r<e))return[t[n][0]+(i=(e-r)/a)*(t[n+1][0]-t[n][0]),t[n][1]+i*(t[n+1][1]-t[n][1]),n];r+=a}return null},e.prototype.gr=function(t,e){for(var a,r=function(t){return(c[0]-o[0])*(t[1]-o[1])>(c[1]-o[1])*(t[0]-o[0])},n=function(){var t=[o[0]-c[0],o[1]-c[1]],e=[h[0]-a[0],h[1]-a[1]],r=o[0]*c[1]-o[1]*c[0],n=h[0]*a[1]-h[1]*a[0],i=1/(t[0]*e[1]-t[1]*e[0]);return[(r*e[0]-n*t[0])*i,(r*e[1]-n*t[1])*i]},i=t=this.makesureAntiClockwise(t),o=(e=this.makesureClockwise(e))[e.length-1],s=0,u=e.length;s<u;s++){for(var c=e[s],f=i,i=[],h=f[f.length-1],l=0,d=f.length;l<d;l++)r(a=f[l])?(r(h)||i.push(n()),i.push(a)):r(h)&&i.push(n()),h=a;o=c}return i},e.prototype.ringRingClip=function(t,e){return t=this.xr(t),e=this.xr(e),isEqual(t[0],t[t.length-1])||t.push(t[0].slice()),isEqual(e[0],e[e.length-1])||e.push(e[0].slice()),(t=martinez.qP([t],[e]))&&t[0]&&t[0][0]?this.br(t[0][0]):[]},e.prototype.ringArea=function(t){throw new Error("distance Not implemented!")},e.prototype.distanceOfLine=function(t){for(var e=0,r=0,n=(t=this.normalizeLine(t)).length;r<n-1;r++)e+=this.distance(t[r],t[r+1]);return e},e.prototype.isClockwise=function(t){return isClockwise(t=this.xr(t))},e.prototype.typePolygon=function(t){return isArray(t)&&isArray(t[0])?2===t[0][0].length||t[0][0]instanceof LngLat$2?"Polygon":2<t[0][0].length&&(2===t[0][0][0].length||t[0][0][0]instanceof LngLat$2)?"MultiPolygon":"never":"never"},e}(),GeometryUtilInstance=new GeometryUtilCls({}),PlaneGeometryUtilInstance=new GeometryUtilCls({}),GeometryUtil=(PlaneGeometryUtilInstance.setCrs("plane"),{distance:GeometryUtilInstance.distance.bind(GeometryUtilInstance),ringArea:GeometryUtilInstance.ringArea.bind(GeometryUtilInstance),isClockwise:GeometryUtilInstance.isClockwise.bind(GeometryUtilInstance),typePolygon:GeometryUtilInstance.typePolygon.bind(GeometryUtilInstance),makesureClockwise:GeometryUtilInstance.makesureClockwise.bind(GeometryUtilInstance),makesureAntiClockwise:GeometryUtilInstance.makesureAntiClockwise.bind(GeometryUtilInstance),distanceOfLine:GeometryUtilInstance.distanceOfLine.bind(GeometryUtilInstance),ringRingClip:GeometryUtilInstance.ringRingClip.bind(GeometryUtilInstance),doesSegmentsIntersect:GeometryUtilInstance.doesSegmentsIntersect.bind(GeometryUtilInstance),doesSegmentLineIntersect:GeometryUtilInstance.doesSegmentLineIntersect.bind(GeometryUtilInstance),doesSegmentRingIntersect:GeometryUtilInstance.doesSegmentRingIntersect.bind(GeometryUtilInstance),doesSegmentPolygonIntersect:GeometryUtilInstance.doesSegmentPolygonIntersect.bind(GeometryUtilInstance),doesLineLineIntersect:GeometryUtilInstance.doesLineLineIntersect.bind(GeometryUtilInstance),doesLineRingIntersect:GeometryUtilInstance.doesLineRingIntersect.bind(GeometryUtilInstance),doesRingRingIntersect:GeometryUtilInstance.doesRingRingIntersect.bind(GeometryUtilInstance),pointInRing:GeometryUtilInstance.pointInRing.bind(GeometryUtilInstance),isPointInRing:GeometryUtilInstance.isPointInRing.bind(GeometryUtilInstance),isPointInBbox:GeometryUtilInstance.isPointInBbox.bind(GeometryUtilInstance),isRingInRing:GeometryUtilInstance.isRingInRing.bind(GeometryUtilInstance),isPointInPolygon:GeometryUtilInstance.isPointInPolygon.bind(GeometryUtilInstance),isPointInPolygons:GeometryUtilInstance.isPointInPolygons.bind(GeometryUtilInstance),isPointOnSegment:GeometryUtilInstance.isPointOnSegment.bind(GeometryUtilInstance),isPointOnLine:GeometryUtilInstance.isPointOnLine.bind(GeometryUtilInstance),isPointOnRing:GeometryUtilInstance.isPointOnRing.bind(GeometryUtilInstance),isPointOnPolygon:GeometryUtilInstance.isPointOnPolygon.bind(GeometryUtilInstance),closestOnSegment:GeometryUtilInstance.closestOnSegment.bind(GeometryUtilInstance),closestOnLine:GeometryUtilInstance.closestOnLine.bind(GeometryUtilInstance),distanceToSegment:GeometryUtilInstance.distanceToSegment.bind(GeometryUtilInstance),distanceToLine:GeometryUtilInstance.distanceToLine.bind(GeometryUtilInstance)}),PlaneGeometryUtil={distance:PlaneGeometryUtilInstance.distance.bind(PlaneGeometryUtilInstance),ringArea:PlaneGeometryUtilInstance.ringArea.bind(PlaneGeometryUtilInstance),isClockwise:PlaneGeometryUtilInstance.isClockwise.bind(PlaneGeometryUtilInstance),typePolygon:PlaneGeometryUtilInstance.typePolygon.bind(PlaneGeometryUtilInstance),makesureClockwise:PlaneGeometryUtilInstance.makesureClockwise.bind(PlaneGeometryUtilInstance),makesureAntiClockwise:PlaneGeometryUtilInstance.makesureAntiClockwise.bind(PlaneGeometryUtilInstance),distanceOfLine:PlaneGeometryUtilInstance.distanceOfLine.bind(PlaneGeometryUtilInstance),ringRingClip:PlaneGeometryUtilInstance.ringRingClip.bind(PlaneGeometryUtilInstance),doesSegmentsIntersect:PlaneGeometryUtilInstance.doesSegmentsIntersect.bind(PlaneGeometryUtilInstance),doesSegmentLineIntersect:PlaneGeometryUtilInstance.doesSegmentLineIntersect.bind(PlaneGeometryUtilInstance),doesSegmentRingIntersect:PlaneGeometryUtilInstance.doesSegmentRingIntersect.bind(PlaneGeometryUtilInstance),doesSegmentPolygonIntersect:PlaneGeometryUtilInstance.doesSegmentPolygonIntersect.bind(PlaneGeometryUtilInstance),doesLineLineIntersect:PlaneGeometryUtilInstance.doesLineLineIntersect.bind(PlaneGeometryUtilInstance),doesLineRingIntersect:PlaneGeometryUtilInstance.doesLineRingIntersect.bind(PlaneGeometryUtilInstance),doesRingRingIntersect:PlaneGeometryUtilInstance.doesRingRingIntersect.bind(PlaneGeometryUtilInstance),pointInRing:PlaneGeometryUtilInstance.pointInRing.bind(PlaneGeometryUtilInstance),isPointInRing:PlaneGeometryUtilInstance.isPointInRing.bind(PlaneGeometryUtilInstance),isPointInBbox:PlaneGeometryUtilInstance.isPointInBbox.bind(PlaneGeometryUtilInstance),isRingInRing:PlaneGeometryUtilInstance.isRingInRing.bind(PlaneGeometryUtilInstance),isPointInPolygon:PlaneGeometryUtilInstance.isPointInPolygon.bind(PlaneGeometryUtilInstance),isPointInPolygons:PlaneGeometryUtilInstance.isPointInPolygons.bind(PlaneGeometryUtilInstance),isPointOnSegment:PlaneGeometryUtilInstance.isPointOnSegment.bind(PlaneGeometryUtilInstance),isPointOnLine:PlaneGeometryUtilInstance.isPointOnLine.bind(PlaneGeometryUtilInstance),isPointOnRing:PlaneGeometryUtilInstance.isPointOnRing.bind(PlaneGeometryUtilInstance),isPointOnPolygon:PlaneGeometryUtilInstance.isPointOnPolygon.bind(PlaneGeometryUtilInstance),closestOnSegment:PlaneGeometryUtilInstance.closestOnSegment.bind(PlaneGeometryUtilInstance),closestOnLine:PlaneGeometryUtilInstance.closestOnLine.bind(PlaneGeometryUtilInstance),distanceToSegment:PlaneGeometryUtilInstance.distanceToSegment.bind(PlaneGeometryUtilInstance),distanceToLine:PlaneGeometryUtilInstance.distanceToLine.bind(PlaneGeometryUtilInstance)},LngLat$2=function(){function r(t,e,r){if(void 0===r&&(r=!1),this.className="AMap.LngLat",isNumberArray(t)?(t=parseFloat(t[0]),e=parseFloat(t[1])):(e=parseFloat(e),t=parseFloat(t)),(isNaN(t)||isNaN(e))&&!window._AMapConfig)throw Error("Invalid Object: LngLat("+t+", "+e+")");!0!==r&&(e=Math.max(Math.min(e,90),-90),t=(t+180)%360+(t<-180||180===t?180:-180)),this.kT=e,this.KL=t,this.lng=Math.round(1e6*t)/1e6,this.lat=Math.round(1e6*e)/1e6,this.pos=ProjectionManager.getProjection("EPSG:3857").project(t,e)}return r.from=function(t){return isLngLat(t)?new r(t.KL,t.kT):new r(t[0],t[1])},r.prototype.setLng=function(t){return this.KL=t,this.lng=Math.round(1e6*t)/1e6,this},r.prototype.setLat=function(t){return this.kT=t,this.lat=Math.round(1e6*t)/1e6,this},r.prototype.getLng=function(){return this.lng},r.prototype.getLat=function(){return this.lat},r.prototype.equals=function(t){return(t=parseLngLatData(t))instanceof r&&Math.max(Math.abs(this.kT-t.kT),Math.abs(this.KL-t.KL))<=1e-9},r.prototype.add=function(t,e){return new r(this.KL+t.KL,this.kT+t.kT,e)},r.prototype.subtract=function(t,e){return new r(this.KL-t.KL,this.kT-t.kT,e)},r.prototype.divideBy=function(t,e){return new r(this.KL/t,this.kT/t,e)},r.prototype.multiplyBy=function(t,e){return new r(this.KL*t,this.kT*t,e)},r.prototype.offset=function(t,e){if(isNaN(t)||isNaN(e))throw Error("valid offset args, require number");return t=2*Math.asin(Math.sin(Math.round(t)/12756274)/Math.cos(this.kT*Math.PI/180)),t=this.KL+180*t/Math.PI,e=2*Math.asin(Math.round(e)/12756274),new r(t,this.kT+180*e/Math.PI)},r.prototype.toString=function(){return this.lng+","+this.lat},r.prototype.toArray=function(){return[this.lng,this.lat]},r.prototype.toJSON=function(){return[this.lng,this.lat]},r.prototype.distanceTo=function(t){return GeometryUtil.distance(this,t)},r.prototype.distance=function(t){return GeometryUtil.distance(this,t)},r}(),Size=function(){function t(t,e,r){if(void 0===r&&(r=!1),this.className="AMap.Size",isNaN(t)||isNaN(e))throw new Error("Invalid Object: Pixel("+t+", "+e+")");this.width=r?Math.round(t):Number(t),this.height=r?Math.round(e):Number(e)}return t.prototype.getWidth=function(){return this.width},t.prototype.getHeight=function(){return this.height},t.prototype.toString=function(){return this.width+","+this.height},t.prototype.toArray=function(){return[this.width,this.height]},t}(),easing=function(){var o={},s="function"==typeof Float32Array;function n(t,e){return 1-3*e+3*t}function w(t,e,r){return((n(e,r)*t+(3*r-6*e))*t+3*e)*t}function P(t,e,r){return 3*n(e,r)*t*t+2*(3*r-6*e)*t+3*e}function u(t){return t}return function(b,e,T,r){if(!(0<=b&&b<=1&&0<=T&&T<=1))throw new Error("bezier x values must be in [0, 1] range");var t=arguments.toString();if(o[t])return o[t];if(b===e&&T===r)return u;for(var A=new(s?Float32Array:Array)(11),n=0;n<11;++n)A[n]=w(.1*n,b,T);return o[t]=function(t){return 0===t?0:1===t?1:w(function(t){for(var e=0,r=1;10!==r&&A[r]<=t;++r)e+=.1;var n=e+(t-A[--r])/(A[r+1]-A[r])*.1,i=P(n,b,T);if(.001<=i){for(var a=t,o=n,s=b,u=T,c=0;c<4;++c){var f=P(o,s,u);if(0===f)return o;o-=(w(o,s,u)-a)/f}return o}if(0===i)return n;for(var h,l,d=t,v=e,g=e+.1,p=b,y=T,m=0;0<(h=w(l=v+(g-v)/2,p,y)-d)?g=l:v=l,1e-7<Math.abs(h)&&++m<10;);return l}(t),e,r)}}}();function getQuadBezierValue(t,e,r,n){var i;return 1<=t?n:(i=1-t)*i*e+2*i*t*r+t*t*n}function cubic(t,e,r,n,i){var a,o,s,u;return 1<=t?i:(a=3*(r.pos[0]-e.pos[0]),o=3*(n.pos[0]-r.pos[0])-a,u=i.pos[0]-e.pos[0]-a-o,s=3*(r.pos[1]-e.pos[1]),n=3*(n.pos[1]-r.pos[1])-s,r=i.pos[1]-e.pos[1]-s-n,i=u*Math.pow(t,3)+o*Math.pow(t,2)+a*t+e.pos[0],u=r*Math.pow(t,3)+n*Math.pow(t,2)+s*t+e.pos[1],ProjectionManager.getProjection("EPSG:3857").unproject(i,u))}function quad(t,e,r,n){return ProjectionManager.getProjection("EPSG:3857").unproject(getQuadBezierValue(t,e.pos[0],r.pos[0],n.pos[0]),getQuadBezierValue(t,e.pos[1],r.pos[1],n.pos[1]))}function p20CoordsToLngLat(t,e){return Array.isArray(e)&&(e=new Pixel(e[0],e[1])),t.containerTolnglat(e,20)}function getSplitNum(t,e){for(var n=[3,300],r=Math.max(2,4),i=0,a=0,o=0,s=t.length;o<s-1;o++){var u=t[o],c=t[o+1];i+=Math.abs(c.pos[0]-u.pos[0]),a+=Math.abs(c.pos[1]-u.pos[1])}return Math.min(n[1],Math.max(n[0],Math.round(Math.max(i,a)/e/r)))}function interpolateCoords(t,e){var r=null;switch(e.length){case 3:r=quad;break;case 4:r=cubic;break;default:return null}for(var n=[],i=[0].concat(e),a=1;a<t-2;a++)i[0]=a/t,n.push(r.apply(null,i));return n.push(e[e.length-1]),n}function getCoordsWithControlPoints(t,e,r,n){var i=null;return t&&r&&r.length&&((t=[t]).push.apply(t,r),t.push(e),i=interpolateCoords(getSplitNum(t,n),t)),i||[e]}var BezierUtil={ag:quad,ug:cubic,sg:easing,xb:function(t,e){for(var r=[],n=0,i=t.length;n<i;n+=1)r.push.apply(r,getCoordsWithControlPoints(t[n-1],t[n],t[n].controlPoints,e));return r},fg:function(t,e,r,n){for(var i=this.xb(t,e,r,n),a=[],o=0,s=i.length;o<s;o++)a.push(p20CoordsToLngLat(e,i[o]));return a}},globalInstance=self,TagMap=(function(t){t.LITE="lite",t.LEFT="left",t.ALL="all",t.NONE=""}(exports.zB||(exports.zB={})),{2:"all",3:"all",4:"all",5:"all",6:"lite",7:"all",8:"lite",9:"all",10:"lite",11:"lite",12:"all",13:"all",14:"all",15:"lite",16:"lite",17:"all",18:"all",19:"all",20:"all"}),colorNameDist={aliceblue:"#f0f8ff",antiquewhite:"#faebd7",aqua:"#00ffff",aquamarine:"#7fffd4",azure:"#f0ffff",beige:"#f5f5dc",bisque:"#ffe4c4",black:"#000000",blanchedalmond:"#ffebcd",blue:"#0000ff",blueviolet:"#8a2be2",brown:"#a52a2a",burlywood:"#deb887",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",cornflowerblue:"#6495ed",cornsilk:"#fff8dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkgray:"#a9a9a9",darkgreen:"#006400",darkkhaki:"#bdb76b",darkmagenta:"#8b008b",darkolivegreen:"#556b2f",darkorange:"#ff8c00",darkorchid:"#9932cc",darkred:"#8b0000",darksalmon:"#e9967a",darkseagreen:"#8fbc8f",darkslateblue:"#483d8b",darkslategray:"#2f4f4f",darkturquoise:"#00ced1",darkviolet:"#9400d3",deeppink:"#ff1493",deepskyblue:"#00bfff",dimgray:"#696969",dodgerblue:"#1e90ff",firebrick:"#b22222",floralwhite:"#fffaf0",forestgreen:"#228b22",fuchsia:"#ff00ff",gainsboro:"#dcdcdc",ghostwhite:"#f8f8ff",gold:"#ffd700",goldenrod:"#daa520",grey:"#808080",gray:"#808080",green:"#008000",greenyellow:"#adff2f",honeydew:"#f0fff0",hotpink:"#ff69b4",indianred:"#cd5c5c",indigo:"#4b0082",ivory:"#fffff0",khaki:"#f0e68c",lavender:"#e6e6fa",lavenderblush:"#fff0f5",lawngreen:"#7cfc00",lemonchiffon:"#fffacd",lightblue:"#add8e6",lightcoral:"#f08080",lightcyan:"#e0ffff",lightgoldenrodyellow:"#fafad2",lightgrey:"#d3d3d3",lightgreen:"#90ee90",lightpink:"#ffb6c1",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",lightskyblue:"#87cefa",lightslategray:"#778899",lightsteelblue:"#b0c4de",lightyellow:"#ffffe0",lime:"#00ff00",limegreen:"#32cd32",linen:"#faf0e6",magenta:"#ff00ff",maroon:"#800000",mediumaquamarine:"#66cdaa",mediumblue:"#0000cd",mediumorchid:"#ba55d3",mediumpurple:"#9370d8",mediumseagreen:"#3cb371",mediumslateblue:"#7b68ee",mediumspringgreen:"#00fa9a",mediumturquoise:"#48d1cc",mediumvioletred:"#c71585",midnightblue:"#191970",mintcream:"#f5fffa",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",navajowhite:"#ffdead",navy:"#000080",oldlace:"#fdf5e6",olive:"#808000",olivedrab:"#6b8e23",orange:"#ffa500",orangered:"#ff4500",orchid:"#da70d6",palegoldenrod:"#eee8aa",palegreen:"#98fb98",paleturquoise:"#afeeee",palevioletred:"#d87093",papayawhip:"#ffefd5",peachpuff:"#ffdab9",peru:"#cd853f",pink:"#ffc0cb",plum:"#dda0dd",powderblue:"#b0e0e6",purple:"#800080",rebeccapurple:"#663399",red:"#ff0000",rosybrown:"#bc8f8f",royalblue:"#4169e1",saddlebrown:"#8b4513",salmon:"#fa8072",sandybrown:"#f4a460",seagreen:"#2e8b57",seashell:"#fff5ee",sienna:"#a0522d",silver:"#c0c0c0",skyblue:"#87ceeb",slateblue:"#6a5acd",slategray:"#708090",snow:"#fffafa",springgreen:"#00ff7f",steelblue:"#4682b4",tan:"#d2b48c",teal:"#008080",thistle:"#d8bfd8",tomato:"#ff6347",turquoise:"#40e0d0",violet:"#ee82ee",wheat:"#f5deb3",white:"#ffffff",whitesmoke:"#f5f5f5",yellow:"#ffff00",yellowgreen:"#9acd32"},Util=function(){var n,o,e,r,i,a,s,u,c,f,t={CLASS_NAME:"AMap.Util",WorldAxesCenter:{x:0,y:0},Single:{},stamp:(e=!0===Browser.DW,r=1e5,i="_amap_id",function(t){return t[i]=e?++r:--r,t[i]}),singlton:function(t){return v.Single[t]||new t},getOptimalZoom:function(t){return t<Math.floor(t)+.8?Math.floor(t):Math.ceil(t)},join:function(t,e){if(t.join)return t.join(e);var r,n=[];for(r in t)t.hasOwnProperty(r)&&n.push(r+"="+(t[r]||""));return n.join(e)},getGuid:function(t,e){return void 0===e&&(e=10),(t||"")+Math.round(Math.random()*Math.pow(10,e))+"_"+(new Date).getTime()},uuid:(o="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),function(t,e){var r,a,n=o,i=[];if(e=(e=void 0===e?62:e)||n.length,t=void 0===t?0:t)for(r=0;r<t;r++)i[r]=n[0|Math.random()*e];else for(i[8]=i[13]=i[18]=i[23]="-",i[14]="4",r=0;r<36;r++)i[r]||(a=0|16*Math.random(),i[r]=n[19===r?3&a|8:a]);return i.join("")}),endsWith:function(t,e){return t.endsWith?t.endsWith(e):!(t.length<e.length)&&t.substr(t.length-e.length)===e},mg:[],gg:268435456,wg:[215440491,106744817],Mg:{start:function(e){e.startTime=new Date,e.jg=[];var n=(new Date).getTime();e.id=v.requestAnimFrame(function r(){var t=(new Date).getTime();e.jg.push(t-n),n=t,e.id=v.requestAnimFrame(r)})},cancel:function(t){t.id&&v.cancelAnimFrame(t.id)},stop:function(t){t.Ag=Date.now()-t.startTime,this.cancel(t),t.Mg=Math.round(1e3/(t.Ag/(t.jg.length+1)))}},kg:function(t,e,r,n,i){if(void 0===i&&(i=!1),t===e)return e;switch(n=void 0===n?"linear":n){case"ease":r=BezierUtil.sg(.25,.1,.25,1)(r);break;case"ease-in":r=BezierUtil.sg(.42,0,1,1)(r);break;case"ease-out":r=BezierUtil.sg(0,0,.58,1)(r);break;case"ease-in-out":r=BezierUtil.sg(.42,0,.58,1)(r)}return n=t+(e-t)*r,i&&(n>>=0),n},createObjectURL:function(t,e){void 0===e&&(e="text/javascript; charset=utf-8");var r=null;try{r=(globalInstance.URL||globalInstance.webkitURL).createObjectURL(new Blob([t],{type:e}))}catch(t){r=null}return r},revokeObjectURL:function(t){try{(globalInstance.URL||globalInstance.webkitURL).revokeObjectURL(t)}catch(t){}},Og:function(t){for(var e={},r=0,n=t.length;r<n;r++)e[t[r]]=r;return e},EV:function(t,e){var r=180/(e=Math.pow(2,e));return[Math.floor(t[0]/(360/e))+e/2,e/2-Math.ceil(t[1]/r)]},WY:function(t,e,r){void 0===r&&(r=!1);var n=[t[0],t[3]],t=[t[2],t[1]],n=this.EV(n,e),t=this.EV(t,e),i=n[0],a=n[1],o=t[0],s=t[1];if(r)return{ja:i,Fa:a,Oa:o,Ea:s,z:e};this.Pa={ja:i,Fa:a,Oa:o,Ea:s,z:e};for(var u=[],c=i;c<=o;c+=1)for(var f=a;f<=s;f+=1)u.push([e,c,f]);return u},xg:function(t){var e={};if(v.is(t,"object"))for(var r in t)t.hasOwnProperty(r)&&(e[t[r]]=r);return e},Ig:function(t,e){if(e.length<5e4)t.push.apply(t,e);else for(var r=0,n=e.length;r<n;r+=1)t.push(e[r])},clone:function(t){if("object"!=typeof t||null===t)return t;if(t.Tg||this.is(t,"Float32Array")||this.is(t,"Uint16Array"))return t;var e,r=this.isArray(t)?[]:{};for(e in t)t.hasOwnProperty(e)&&(r[e]=v.clone(t[e]));return r},isInteger:function(t){return(0|t)===t},vB:function(t){return!isNaN(t)},setPrototypeOf:"function"==typeof Object.setPrototypeOf?Object.setPrototypeOf:function(t,e){for(var r in e)t[r]=e[r]},isFunction:function(t){return"function"==typeof t},_g:function(t,e){if(void 0===e&&(e="webgl"),!t)return t;for(var r=[],n=0,i=t.length;n<i;n+=2){var a=parseInt(t.substr(n,2),16);("webgl"===e||"rgba"===e&&0===n)&&(a=this.format(a/255,3)),r.push(a)}return r.push(r.shift()),r},Sg:function(){},keys:"function"==typeof Object.keys?Object.keys:function(t){var e,r=[];for(e in t)t.hasOwnProperty(e)&&r.push(e);return r},map:function(r,n,i){void 0===i&&(i=null);var a=[];return r&&r.length?(v.Cg(r,function(){for(var t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];a[t[1]]=n.apply(i||r,t)}),a):r},forEach:function(t,e){if(t&&t.length){var r=t.length;if(0<r&&(e(t[0],0),1<r)){e(t[1],1);for(var n=2;n<r;n++)e(t[n],n)}}},Cg:function(t,e,r){if(void 0===r&&(r=null),t&&t.length)for(var n=0,i=t.length;n<i&&!1!==e.call(r,t[n],n,t);n++);},find:function(t,e,r){void 0===r&&(r=null);for(var n=0,i=t.length;n<i;n++)if("function"==typeof e){if(e.call(r,t[n],n,t))return t[n]}else if(t[n]===e)return t[n];return null},isDOM:function(t){return"object"==typeof HTMLElement?t instanceof HTMLElement:t&&"object"==typeof t&&1===t.nodeType&&"string"==typeof t.nodeName},Eg:function(t,e){for(var r,n,i="ASDFGHJKLQWERTYUIO!sdfghjkleiu3~yr5-P&mq9`%zCN*b=8@^xpVM",a="v5"<(e=e||"v5")?(r=i.length,512):(i=i.substr(0,r=27),333),o=[],s=NaN,u=0,c=t.length;u<c;u++)n=t[u],n=i.indexOf(n),s=isNaN(s)?n*r:(o.push(s+n-a),NaN);return o},Ng:function(t,e){for(var r=512<e.length?Math.round(Math.pow(e.length,.5)):e.length,n=Math.ceil(e.length/r),i=0;i<n;i+=1){var a=r*i,o=a+r;o>e.length&&(o=e.length);for(var s=a;s<o;s+=1)t(e[s])}},Lg:function(t){var e;return/^rgba\\(/.test(t)?this.Dg(t):("#"===(e=t=this.colorNameToHex(t))[0]&&(3===(t=t.substring(1)).length&&(t=t.replace(/./g,function(t){return t+t})),e=this.argbHex2Rgba(8===t.length?t:"ff"+t)),this.Dg(e))},colorNameToHex:function(t){return"string"==typeof(t=(t=void 0===t?"":t).toLowerCase())&&colorNameDist[t]||t},Rg:function(t,e,r){var n=Math.floor(r/2),i=r-n;return[r,t&(n=(1<<n)-1<<i)|e&(i=(1<<i)-1),e&n|t&i]},Pg:function(t){return t?encodeURIComponent(t):""},getStyle:function(t,e,r,n){var i=t[e].i[r];if(void 0===i)return null;if(r=t[e].s,"number"==typeof i)return r[i];for(;void 0===i[n.toString()]&&!(--n<3););return"number"==typeof(t=i[n.toString()])?r[t]:null},Dg:function(t){return(t=t.split(","))[0]=parseFloat(t[0].split("rgba(")[1])/255,t[1]=parseFloat(t[1])/255,t[2]=parseFloat(t[2])/255,t[3]=parseFloat(t[3]),t},Ug:function(t){return(t=t.split(","))[0]=parseFloat(t[0].split("rgb(")[1])/255,t[1]=parseFloat(t[1])/255,t[2]=parseFloat(t[2])/255,t},Bg:function(t){return"rgba("+255*t[0]+","+255*t[1]+","+255*t[2]+","+t[3]+")"},color2Rgba:function(t){return this.Bg(this.color2RgbaArray(t))},color2RgbaArray:function(t){var e,r,n,i,a,o,s;return t instanceof Array?(3==t.length&&t.push(1),t):0==(e=this.colorNameToHex(t)).indexOf("rgb(")?((r=this.Ug(e)).push(1),r):0==e.indexOf("rgba(")?this.Dg(e):0==e.indexOf("#")?4===e.length?(s=e.substr(1).replace(/./g,function(t){return t+t}),this.zg(s)):7==e.length?this.zg(e.substr(1)):9==e.length?(r=e.substr(1),this.qg(r)):void 0:0===e.indexOf("hsla")?(n=t.substr(5).split(","),i=parseInt(n[0],10)/360,a=parseInt(n[1],10)/100,o=parseInt(n[2],10)/100,r=parseFloat(n[3]),this.GQ(i,a,o,r)):0===e.indexOf("hsl")?(n=t.substr(4).split(","),i=parseInt(n[0],10)/360,a=parseInt(n[1],10)/100,o=parseInt(n[2],10)/100,this.GQ(i,a,o,1)):3===e.length?(s=e.replace(/./g,function(t){return t+t}),this.zg(s)):6==e.length?this.zg(e):8==e.length?this.qg(e):void 0},GQ:function(t,e,r,n){var i,a,o;return 0===e?i=a=o=r:(i=this.uQ(e=2*r-(r=r<.5?r*(1+e):r+e-r*e),r,t+1/3),a=this.uQ(e,r,t),o=this.uQ(e,r,t-1/3)),[i,a,o,n]},uQ:function(t,e,r){return r<0&&(r+=1),1<r&&--r,r<1/6?t+6*(e-t)*r:r<.5?e:r<2/3?t+(e-t)*(2/3-r)*6:t},rgbHex2Rgba:function(t){return t.startsWith("#")&&(t=t.slice(1)),v.argbHex2Rgba("ff"+t)},argbHex2Rgba:function(t){for(var e=[],r=0,n=(t=t.startsWith("#")?t.slice(1):t).length;r<n;r+=2)e.push(parseInt(t.substr(r,2),16));return e.push((e.shift()/255).toFixed(2)),"rgba("+e.join(",")+")"},Opacity2Rgba:function(t,e){var r=e;return e&&e[3]&&t&&(e[3]=Math.floor(255*t)),r},Hex2Rgba:function(t){if("string"!=typeof t)return!1;for(var e=[],r=0,n=t.length;r<n;r+=2)e.push(parseInt(t.substr(r,2),16));return e.push(parseInt(e.shift())),e},zg:function(t){return this.uE(t+"ff")},qg:function(t){for(var e=[],r=0,n=t.length;r<n;r+=2)e.push(parseInt(t.substr(r,2),16)/255);return e.push(e.shift()),e},uE:function(t){return[((t=parseInt(t,16))>>24&255)/255,(t>>16&255)/255,(t>>8&255)/255,(255&t)/255]},isEmpty:function(t){for(var e in t)if(t.hasOwnProperty(e))return!1;return!0},Wg:function(t,e){return 0<=e&&t.splice(e,1),t},startsWith:function(t,e){return t.startsWith?t.startsWith(e):t.substr(0,e.length)===e},deleteItemFromArray:function(t,e){return e=v.indexOf(t,e),v.Wg(t,e)},deleteItemFromArrayByIndex:function(t,e){return v.Wg(t,e)},filter:function(t,r,n){var i=[];return v.Cg(t,function(t,e){r.call(n,t,e)&&i.push(t)}),i},indexOf:function(t,e){if(t&&t.length){if(t.indexOf)return t.indexOf(e);for(var r=0;r<t.length;r+=1)if(t[r]===e)return r}return-1},Gg:function(t,e){return t.endsWith?t.endsWith(e):!(t.length<e.length)&&t.substr(t.length-e.length)==e},bind:(n=!1,Boolean(Function.prototype.bind)&&(n=!0),function(t,e){var r=2<arguments.length?Array.prototype.slice.call(arguments,2):null;return n?r?(r.unshift(e),t.bind.apply(t,r)):t.bind(e):function(){return t.apply(e,r||arguments)}}),setOptions:function(t,e){return t.opts=assign({},t.opts,e=e||{}),t.opts},yn:function(t,e,r){return"function"==typeof e?this.Hg(t,!0,this.Vg(e,r,1)):this.Hg(t,!0)},Hg:function(r,n,i,t,e,a,o){var s;if(void 0===(s=i?e?i(r,t,e):i(r):s)){if(!this.$g(r))return r;if(t=this.isArray(r)){if(s=this.Yg(r),!n)return this.Kg(r,s)}else{var u=Object.prototype.toString.call(r),c="[object Function]"==u;if("[object Object]"!=u&&"[object Arguments]"!=u&&(!c||e))return e?r:{};if(s=this.Xg(c?{}:r),!n)return this.baseAssign(s,r)}o=o||[];for(var f=(a=a||[]).length;f--;)if(a[f]==r)return o[f];a.push(r),o.push(s),(t?this.Zg:this.Qg)(r,function(t,e){s[e]=v.Hg(t,n,i,e,r,a,o)})}return s},baseAssign:function(t,e){return null==e?t:this.tM(e,Object.keys(e),t)},$g:function(t){var e=typeof t;return!!t&&("object"==e||"function"==e)},rM:function(t){return!!t&&"object"==typeof t},nM:function(t){return"number"==typeof t&&-1<t&&t%1==0&&t<=9007199254740991},Yg:function(t){var e=t.length,r=new Array(e);return e&&"string"==typeof t[0]&&Object.hasOwnProperty.call(t,"index")&&(r.index=t.index,r.input=t.input),r},Kg:function(t,e){var r=-1,n=t.length;for(e=e||Array(n);++r<n;)e[r]=t[r];return e},Xg:function(t){return new(t="function"==typeof(t=t.constructor)&&t instanceof t?t:Object)},Vg:function(a,o,t){if("function"!=typeof a)return this.identity;if(void 0===o)return a;switch(t){case 1:return function(t){return a.call(o,t)};case 3:return function(t,e,r){return a.call(o,t,e,r)};case 4:return function(t,e,r,n){return a.call(o,t,e,r,n)};case 5:return function(t,e,r,n,i){return a.call(o,t,e,r,n,i)}}return function(){return a.apply(o,arguments)}},Zg:function(t,e){for(var r=-1,n=t.length;++r<n&&!1!==e(t[r],r,t););return t},identity:function(t){return t},iM:function(u){return function(t,e,r){for(var n=v.eM(t),i=r(t),a=i.length,o=u?a:-1;u?o--:++o<a;){var s=i[o];if(!1===e(n[s],s,n))break}return t}},Qg:function(t,e){return v.iM()(t,e,Object.keys)},eM:function(t){return v.$g(t)?t:Object(t)},tM:function(t,e,r){r=r||{};for(var n=-1,i=e.length;++n<i;){var a=e[n];r[a]=t[a]}return r},oM:function(){return!1},aM:"data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=",uM:Date.now?function(){return Date.now()}:function(){return(new Date).getTime()},sM:function(t,e,r,n){var i,a,o,s,u,c,f;return s=n?(i=0,o=this.uM,function(){if((a=o())-i<e)return!1;i=a,t.apply(r,arguments)}):(f=function(){u=!1,c&&(s.apply(r,c),c=!1)},function(){u?c=arguments:(u=!0,t.apply(r,arguments),setTimeout(f,e))})},format:function(t,e){return t===t<<0?t:+parseFloat(t+"").toFixed(e||0)},isArray:Array.isArray||function(t){return this.is(t,"array")},is:function(t,e){return Object.prototype.toString.call(t).split(" ")[1].slice(0,-1).toLowerCase()===e.toLowerCase()},includes:"function"==typeof Array.prototype.includes?function(t,e){return t.includes(e)}:function(t,e){return-1!==this.indexOf(t,e)},fM:function(t){var e=0;if(0!==t.length)for(var r=0,n=t.length;r<n;r+=1)e=(e<<5)-e+t.charCodeAt(r),e&=e;return e},hM:function(t,e){e=e?Math.ceil(parseInt(e.substr(6))/24):1;for(var r="",n=0,i=t.length;n<i;n++)r+=String.fromCharCode((t.charCodeAt(n)-256-e+65535)%65535);return r},cM:function(t,e){var r=(t+"").slice(-2),n=(e+"").slice(-2),i=(t=t.slice(0,-2),e=e.slice(0,-2),parseInt((n+r).slice(1))),a=Math.ceil(i/250)%2?1:-1,i=1<i/500?1:-1;return t-=parseInt("1"+r)/3e3*a,e-=parseInt("1"+n)/3e3*i,new LngLat$2(parseFloat(t).toFixed(5),parseFloat(e).toFixed(5))},vM:function(t){return"undefined"!=typeof JSON&&JSON.stringify?v.fM(JSON.stringify(t)):null},lM:function(t,e){var r="_amap_hash";return!e&&t.hasOwnProperty(r)||(e=v.vM(t))&&(t[r]=e),t[r]},parseLngLatData:function(t){if(v.isArray(t)){var e;if(!v.isArray(t[0]))return"string"==(e=typeof t[0])||"number"==e?new LngLat$2(t[0],t[1]):t;for(var r=0;r<t.length;r+=1)t[r]=v.parseLngLatData(t[r])}return t},dM:function(t){for(var e=[],r=0,n=t.length;r<n;r+=1)e[r]=[t[r].x,t[r].y];return e},bM:function(t){return v.isArray(t)?new Size(t[0],t[1]):t},hp:function(t,e){var r,n=[0,0],i=v.getOptimalZoom(e.viewState.zoom);return t&&LocalZoom<=i?(i=lcs.getSize(),e=e.viewState.centerCoord,e=lcs.getLocalByCoord([e[0],e[1]]),r=t.x-e.x,e=t.y-e.y,0!=r&&(r*=i[0],n[0]=r),0!=e&&(e*=i[1],n[1]=e)):t&&(n[0]+=t.center[0],n[1]+=t.center[1]),n},dS:function(t,e){return t>=e[0]&&t<=e[1]},kD:function(t,e,r){return void 0===r&&(r=!1),t=(t=void 0===t?"":t).split(",")[0]||"",!r&&t&&e&&TagMap[e]||"all"},VF:function(t,e,r){return!(r=void 0!==r&&r)&&t&&e&&TagMap[e]||"all"},LD:function(t,e){return!(!t||!e)&&(t=this.iN(t),this.iN(e)<=t)},SD:function(t){var e;switch(t=void 0===t?"all":t){case"lite":e=0;break;case"left":e=1;break;default:e=2}return e},pW:function(t){var e;switch(t=void 0===t?2:t){case 0:e=exports.zB.LITE;break;case 1:e=exports.zB.LEFT;break;default:e=exports.zB.ALL}return e},iN:function(t){var e=0;switch(t){case"lite":e=0;break;case"left":e=1;break;case"all":e=2}return e},loadBaxia:function(){return new Promise(function(t,e){var r,n;window||e({code:"0",I8t:"霸下加载失败"}),window.__AMap_web_baxia__?t({code:"2",I8t:"霸下已加载，无需重复加载"}):(window.__AMap_web_baxia__=!0,r=document.body||document.head,(n=document.createElement("script")).type="text/javascript",n.src="//g.alicdn.com/??AWSC/AWSC/awsc.js,sd/baxia-entry/baxiaCommon.js",n.onerror=function(t){window.__AMap_web_baxia__=!1,e({code:"0",I8t:"霸下加载失败"})},n.onload=function(){t({code:"1",I8t:"霸下加载成功"})},r.appendChild(n))})},getMarkUrl:function(){return"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEABAMAAACuXLVVAAAAGFBMVEUAAABOVWNOVWVNVWJOVWNNVV9OVWNOVWT0TI68AAAACHRSTlMAIwkPFQQbHt8aTjEAAAVJSURBVHja7MGBAAAAAICg/akXqQIAAAAAAAAAYHbqXrlNIArD8MvCipbD8tOCoyQtZCzSQpKx2sX2xC1IdtSyiSLffpyZ3AKoCE9zyvNW32q1Wq1Wq9VqtVqt/lPvKq7H8jDKxNUEUShZE3ElFj8OvrK5VkATobNnd60A1UnLXrKyvUaAqh4l206cnN2k4cDigqj/ud8MMB5V3rcsSxcoc2P6zz8qRF5qV7AkfesitpLWjUiLGBPIogFbJ5eYWrYu/xK0KkutloTF+KPITiVQPxr7sGcTGwLjEstCNtmurMigvPzai9hwyigHXwbmd4O6s36MdxwFysTLdid0MWqx+BXzc43kVif3nWRj4UukX+8NUH8wLEFvRQzg/p6+DZ5jynwC+m8tC9g6OT6m76A73hv6CW3QIpeBoGAJ9XG030UKyop8LylceDK3PwZm58eqAChf5Vy29Ie95N8MdP5C++NNYWKhkfPNIRwIJR8LEpR7+s0i6kp3BrrdnXKXiMDYvuIVlWhm93AH5OjPMlDfGNWdY4KUcPiYg2Vuai85BPHWyfNA/zkTKRKClCDqX5idaiT/UkApkhRAKO6T154IIlTF/AKRceKEestANRVBWvNxqm04MTtVgH8sglQn8NXqRmRAxf0oB2eXWH1vwLIpfBPE/zbwQwRJ+FyEv5idP+Ad9oYno5NwAuRc4MdwAjTz840qRQ5oVzn1vqkYAZVAbZmftiiR8VxWsBm6W5GWrkDtc7hnfltX+SLHrvIq4NbJuYBy10juWMC78e2hGie61Gt5GMX9BvAk/2ots3t7mI0FBOn2NfNa6my3iQA2iWUBWuQnZQu+yEvdVdyDHwNL7F7QPrzwKZzwJlB5E22kAFAJS7D8Yb/eldMGwiiO/9GNlk+rSytxS4uMZVqJxFa7IDtutcaOW+Tg8PoJSV5BotHvBfbM7MyePc8ib+CEeOG8ILJDV+65iOiBFVQSJAuwFEuRhrOrLPmXYEoPHHWaRkaBGxuJczAEY38jCd3TuGtGTW3i8Ad1KVF+BgznrOnl3bPVbRtQLsrNjW/IolZTajg/imj6MJdoC7/S8vEkr+zJ/v65iUY/X+jBzMTbfaXZlzs5LeafXALsGizl0r154cZf91VsVnC28z9h7qFMGE/gic7NjEzQSzk8ZQ2W1EZUXUALTkj3ls/x9tGHdDVvT4n25O4wi5wAOwCXHhjPvxMFIwnymSnGm+abP19nxSikczXgBracFhE4eW2i6ug6E3Xi3Uq6L50nsluDF1rBzERQV/F274TYvl8aRffcoDZy0OnWlz8n31+G/oNMFW4UOl813atF2k+N7UzW++pS/rkc0iKAX/Tii0jurAMYNXcSmJkeFdHMfESwoGtzgGW+1OOm1GTHHze1kcSbmHibKnpQ6noLh13hTJYvtKFVSdtghzONpelB+i4KTMyjyIsdqDbOx0csRQ+m/3c24MU7kQS3iaby5k3gJ93bxNDG1QSgLL/l0gCG+sP0M7I38QrW2vatB8VpFCIBkCXwSvdGr2ez4gmw4ssl6DJwg/IFdiv64Jgoz/ZVgHsrojRY6t1Wjnzg9RVgM01FEoy8S5zArsm+hCx9+mJKSd8yzW2ya6so4VlnbQGavrTt56ZIV0CZFplsceRMnxbfRVbOCiw1Probhffh0qc7UenMHGE3cUJI6Nvr4lTFDyFum1iKa1jKQS8VngLFNaTF3EQBbsGVjCS62QvX4/mX4tdcjR3LIdFcjxsnXFfOYDAYDAaDwWAwGAwGg9/twYEAAAAAgCB/60GuAAAAAAAAAOAnLYvrtEzzqQMAAAAASUVORK5CYII="}};function h(t){var e=+new Date,r=Math.max(0,(Browser.android?50:20)-(e-a));return a=e+r,globalInstance.setTimeout(t,50)}function l(t){globalInstance.clearTimeout(t)}function d(t){for(var e,r=["webkit","moz","o","ms"],n=0;n<r.length&&!e;n+=1)e=globalInstance[r[n]+t];return e}a=0,Browser.DW?(s=h,u=l,t.requestAnimFrame=function(t,e,r,n){if(!r)return s(function(){e?v.bind(t,e).call(e,n):t()});e?v.bind(t,e).call(e,n):t()},t.cancelAnimFrame=function(t){t&&u.call(globalInstance,t)}):(c=globalInstance.requestAnimationFrame||d("RequestAnimationFrame")||h,f=globalInstance.cancelAnimationFrame||d("CancelAnimationFrame")||d("CancelRequestAnimationFrame")||l,t.requestAnimFrame=function(t,e,r,n){if(!r)return c(function(){e?v.bind(t,e).call(e,n):t()});e?v.bind(t,e).call(e,n):t()},t.cancelAnimFrame=function(t){t&&f.call(globalInstance,t)}),Browser.DW||(t.requestIdleCallback=globalInstance.requestIdleCallback?function(t,e){return globalInstance.requestIdleCallback(t,e)}:function(t,e){void 0===e&&(e={});var r=v.uM();return setTimeout(function(){t({didTimeout:!1,timeRemaining:function(){return Math.max(0,70-(v.uM()-r))}})},e.timeout||0)},t.cancelIdleCallback=globalInstance.cancelIdleCallback?function(t){return globalInstance.cancelIdleCallback(t)}:function(t){clearTimeout(t)});var v=t;return v}(),extendStatics=function(t,e){return(extendStatics=Object.setPrototypeOf||({__proto__:[]}instanceof Array?function(t,e){t.__proto__=e}:function(t,e){for(var r in e)e.hasOwnProperty(r)&&(t[r]=e[r])}))(t,e)};function __extends(t,e){function r(){this.constructor=t}extendStatics(t,e),t.prototype=null===e?Object.create(e):(r.prototype=e.prototype,new r)}function __decorate(t,e,r,n){var i,a=arguments.length,o=a<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.yV)o=Reflect.yV(t,e,r,n);else for(var s=t.length-1;0<=s;s--)(i=t[s])&&(o=(a<3?i(o):3<a?i(e,r,o):i(e,r))||o);return 3<a&&o&&Object.defineProperty(e,r,o),o}function __awaiter(t,o,s,u){return new(s=s||Promise)(function(r,e){function n(t){try{a(u.next(t))}catch(t){e(t)}}function i(t){try{a(u.throw(t))}catch(t){e(t)}}function a(t){var e;t.done?r(t.value):((e=t.value)instanceof s?e:new s(function(t){t(e)})).then(n,i)}a((u=u.apply(t,o||[])).next())})}function __generator(n,i){var a,o,s,u={label:0,y8t:function(){if(1&s[0])throw s[1];return s[1]},m8t:[],b8t:[]},t={next:e(0),throw:e(1),return:e(2)};return"function"==typeof Symbol&&(t[Symbol.iterator]=function(){return this}),t;function e(r){return function(t){var e=[r,t];if(a)throw new TypeError("Generator is already executing.");for(;u;)try{if(a=1,o&&(s=2&e[0]?o.return:e[0]?o.throw||((s=o.return)&&s.call(o),0):o.next)&&!(s=s.call(o,e[1])).done)return s;switch(o=0,(e=s?[2&e[0],s.value]:e)[0]){case 0:case 1:s=e;break;case 4:return u.label++,{value:e[1],done:!1};case 5:u.label++,o=e[1],e=[0];continue;case 7:e=u.b8t.pop(),u.m8t.pop();continue;default:if(!(s=0<(s=u.m8t).length&&s[s.length-1])&&(6===e[0]||2===e[0])){u=0;continue}if(3===e[0]&&(!s||e[1]>s[0]&&e[1]<s[3]))u.label=e[1];else if(6===e[0]&&u.label<s[1])u.label=s[1],s=e;else{if(!(s&&u.label<s[2])){s[2]&&u.b8t.pop(),u.m8t.pop();continue}u.label=s[2],u.b8t.push(e)}}e=i.call(n,u)}catch(t){e=[6,t],o=0}finally{a=s=0}if(5&e[0])throw e[1];return{value:e[0]?e[1]:void 0,done:!0}}}}function __spreadArrays(){for(var t=0,e=0,r=arguments.length;e<r;e++)t+=arguments[e].length;for(var n=Array(t),i=0,e=0;e<r;e++)for(var a=arguments[e],o=0,s=a.length;o<s;o++,i++)n[i]=a[o];return n}exports.Ln=function(){return exports.Ln=Object.assign||function(t){for(var e,r=1,n=arguments.length;r<n;r++)for(var i in e=arguments[r])Object.prototype.hasOwnProperty.call(e,i)&&(t[i]=e[i]);return t},exports.Ln.apply(this,arguments)};var LabelFormat=function(){function t(){this.Fs={},this.Es={},this.Ts=[]}return t.prototype.Ns=function(t,e){e.lang&&(this.lang=e.lang)},t.prototype.rV=function(t,e){return t},t.prototype.Ws=function(t,e){for(var r=this.Es,t=labelsUtil.EQ(t=void 0===t?"":t,e=void 0===e?[]:e),n=labelsUtil.aQ(t),i=0;i<n.length;i++)r[n[i]]=1},t.id="labelFormat",t}();function noop$1(){}var URLObject="undefined"!=typeof window?window.URL||window.webkitURL||{createObjectURL:function(){console.error("URL not exist, please use more popular browser")}}:URL||webkitURL||{createObjectURL:function(){console.error("URL not exist, please use more popular browser")}},MockMap=function(){function t(){this.gV={}}return t.prototype.has=function(t){return Boolean(this.gV[t])},t.prototype.set=function(t,e){return this.gV[t]=e},t.prototype.get=function(t){return this.gV[t]},t.prototype.pV=function(t){delete this.gV[t]},t.prototype.clear=function(){this.gV={}},t.prototype.forEach=function(t){for(var e in this.gV)this.gV.hasOwnProperty(e)&&t(this.gV[e])},t}(),AdaptorMap=globalInstance.Map||MockMap,SmartTypedArray=function(){function t(t,e){void 0===e&&(e=1024),this.type=t,this.length=0,this.uf=0,this.value=this.cf(e)}return t.prototype.set=function(t){this.check(t)&&(t.length<this.uf?this.value.set(t):(this.cf(t.length),this.value.set(t),this.length=t.length))},t.prototype.check=function(t){if(Array.isArray(t))return!0;var e=!1;switch(this.type){case"uint8":e=t instanceof Uint8Array;break;case"int8":e=t instanceof Int8Array;break;case"uint16":e=t instanceof Uint16Array;break;case"int16":e=t instanceof Int16Array;break;case"uint32":e=t instanceof Uint32Array;break;case"int32":e=t instanceof Int32Array;break;case"float32":e=t instanceof Float32Array;break;case"float64":e=t instanceof Float64Array;break;default:e=!1}return e},t.prototype.subarray=function(t,e){return this.value.subarray(t,e)},t.prototype.ff=function(t){this.uf<t&&this.cf(t),this.length=t},t.prototype.cf=function(t){var e=this.pf(),r=this.value;return this.value=new e(t),r&&this.value.set(r),this.uf=t,this.value},t.prototype.pf=function(){var t=Float32Array;switch(this.type){case"uint8":t=Uint8Array;break;case"int8":t=Int8Array;break;case"uint16":t=Uint16Array;break;case"int16":t=Int16Array;break;case"uint32":t=Uint32Array;break;case"int32":t=Int32Array;break;case"float32":t=Float32Array;break;case"float64":t=Float64Array;break;default:t=Float32Array}return t},__decorate([InnerClass("SmartTypedArray")],t)}(),INF=(function(t){t[t.fontWidth=0]="fontWidth",t[t.fontHeight=1]="fontHeight",t[t.horiBearingX=2]="horiBearingX",t[t.horiBearingY=3]="horiBearingY",t[t.horiAdvance=4]="horiAdvance",t[t.posX=5]="posX",t[t.posY=6]="posY",t[t.iconWidth=7]="iconWidth",t[t.iconHeight=8]="iconHeight"}(exports.dY||(exports.dY={})),1e20),ControlChars=[[0,31],[127,159]],ZeroWidthChars=[[8203,8207]],f=new SmartTypedArray("float64",4096),d=new SmartTypedArray("float64",4096),z=new SmartTypedArray("float64",4096),v=new SmartTypedArray("float64",4096),ua=navigator.userAgent,TinySDF=function(){function t(t,e,r,n,i,a,o){this.fontSize=t||24,this.buffer=void 0===r?3:r,this.MU=i||.25,this.fontFamily=a||"sans-serif",this.fontWeight=o||"lighter",this.radius=n||8,this.size=e,this.xU(),t=e[0]*e[1],this.TU=new SmartTypedArray("float64",t),this.AU=new SmartTypedArray("float64",t),r=0<=ua.indexOf("Gecko/")||0<=ua.indexOf("Windows"),this.wU=Math.round(e[1]/2*(r?1.2:1))}return t.prototype.bU=function(t){this.size=t||[],this.xU(),this.mU()},t.prototype.Ce=function(t){var e=this.size,r=e[0],n=r*(e=e[1]);if(i=this.Nz){i.clearRect(0,0,r,e),i.fillText(t,this.buffer,this.wU);var a=i.getImageData(0,0,r,e),o=new Uint8ClampedArray(n),s=((i=new Array(9).fill(0))[0]=1,i[1]=1,t.charCodeAt(0));if(this.RU(s))return{bitmap:o,info:i};for(var u=INF,c=INF,f=0,h=0,l=0;l<n;l++){var d,v=l-(d=Math.floor(l/r))*r,g=a.data[4*l+3]/255;0<g&&(d<u&&(u=d),v<c&&(c=v),f<d&&(f=d),h<v)&&(h=v),this.TU.value[l]=1==g?0:0==g?INF:Math.pow(Math.max(0,.5-g),2),this.AU.value[l]=1==g?INF:0==g?0:Math.pow(Math.max(0,g-.5),2)}var i=this.buffer,t=this.getWidth(t,h-c),s=32===s?[6,6,0,-21,9,0,0,r,e]:[t,f-u,c,-u+i,t,c-3,u-3,r,e];for(edt(this.TU.value,r,e),edt(this.AU.value,r,e),l=0;l<n;l++){var y=this.TU.value[l]-this.AU.value[l],y=Math.max(0,Math.min(255,Math.round(255-255*(y/this.radius+this.MU))));o[l]=y}return{bitmap:o,info:s}}return{}},t.prototype.getWidth=function(t,e){var r;switch(t){case"y":case"A":case"T":case"V":case"W":case"Y":r=e;break;default:r=e+2}return r},t.prototype.measureText=function(t){return this.Nz.measureText(t)},t.prototype.xU=function(){var t=this.size;this.canvas||(this.canvas=document.createElement("canvas")),this.canvas.width=t[0],this.canvas.height=t[1],this.Nz=this.canvas.getContext("2d"),this.Nz&&(this.Nz.font=this.fontWeight+" "+this.fontSize+"px "+this.fontFamily,this.Nz.textBaseline="middle",this.Nz.fillStyle="black")},t.prototype.mU=function(){var t=this.size,e=((e=t[0]*(t=t[1]))>this.AU.uf&&(this.AU.ff(e),this.TU.ff(e)),0<=ua.indexOf("Gecko/")||0<=ua.indexOf("Windows"));this.wU=Math.round(t/2*(e?1.2:1))},t.prototype.RU=function(t){var e=this.SU(t,ControlChars),t=this.SU(t,ZeroWidthChars);return e||t},t.prototype.SU=function(t,e){for(var r=0,n=e;r<n.length;r++){var i=n[r];if(t>=i[0]&&t<=i[1])return!0}},t}();function expandTypeArray(t){f.ff(t),d.ff(t),z.ff(t),v.ff(t)}function edt(t,e,r){f.uf<r&&expandTypeArray(r);for(var n=0;n<e;n++){for(var i=0;i<r;i++)f.value[i]=t[i*e+n];for(edt1d(f.value,d.value,v.value,z.value,r),i=0;i<r;i++)t[i*e+n]=d.value[i]}for(f.uf<e&&expandTypeArray(r),i=0;i<r;i++){for(n=0;n<e;n++)f.value[n]=t[i*e+n];for(edt1d(f.value,d.value,v.value,z.value,e),n=0;n<e;n++)t[i*e+n]=Math.sqrt(d.value[n])}}function edt1d(t,e,r,n,i){n[r[0]=0]=-INF,n[1]=+INF;for(var a=1,o=0;a<i;a++){for(var s=(t[a]+a*a-(t[r[o]]+r[o]*r[o]))/(2*a-2*r[o]);s<=n[o];)o--,s=(t[a]+a*a-(t[r[o]]+r[o]*r[o]))/(2*a-2*r[o]);r[++o]=a,n[o]=s,n[o+1]=+INF}for(o=a=0;a<i;a++){for(;n[o+1]<a;)o++;e[a]=(a-r[o])*(a-r[o])+t[r[o]]}}var LangConf={ch:{type:"ch",size:[32,32],fontSize:24,name:"中文简体"},en:{type:"en",size:[32,32],fontSize:24,name:"英文"},th:{type:"th",size:[32,32],fontSize:24,name:"泰语"},my:{type:"my",size:[56,56],fontSize:24,name:"缅甸语"},ja:{type:"ja",size:[32,32],fontSize:24,name:"日文"},km:{type:"km",size:[40,40],fontSize:24,name:"高棉语"},PU:{type:"lao",size:[40,40],fontSize:24,name:"老挝语"},$U:{type:"arabic",size:[40,40],fontSize:24,name:"阿拉伯语"},default:{type:"ch",size:[32,32],fontSize:24,name:"汉语"}},Lang=function(){function t(t){var e=(t=this.CU=t).type,r=t.size,t=t.fontSize,e=(this.type=e,this.width=r[0]),r=this.height=r[1];this.NU=new TinySDF(t,[e,r],(e-t)/2,8,.25,"PingFang SC","normal")}return t.prototype.Ce=function(t){return this.type===LangConf.PU.type?(this.width=10*Math.floor(this.NU.measureText(t).width/10)+10+LangConf.PU.fontSize/2,this.NU.bU([this.width,this.height])):(this.type===LangConf.my.type||this.type===LangConf.PU.type||this.type===LangConf.th.type||this.type===LangConf.$U.type||this.type===LangConf.km.type)&&1<t.length&&(this.width=Math.floor(this.CU.size[0]*t.length*.5),this.NU.bU([this.width,this.height])),this.NU.Ce(t)},t}(),LangManager=function(){function n(){this.OU={}}return n.gG=function(t){return t=t.split("|"),t=parseInt(t[0],10),this.IU(t)},n.kU=function(t){for(var e=[],r=0;r<t.length;r++)e.push(t.charCodeAt(r));return n.gG(e.join("|"))},n.LU=function(t){return t=n.kU(t),-1!==n.EU.indexOf(t)},n.IU=function(t){return 32<t&&t<591?"en":4096<=t&&t<=4255?"my":3584<=t&&t<=3711?"th":6016<=t&&t<=6143?"km":3712<=t&&t<=3839?"lao":1536<=t&&t<=1791?"arabic":"ch"},n.prototype.D$=function(t){var e,r=this.OU[t=void 0===t?"ch":t];return r||(e=LangConf[t]||LangConf.default,r=new Lang(e),this.OU[t]=r),r},n.EU=[LangConf.my.type,LangConf.km.type,LangConf.PU.type],n}(),CHN=[["90.398619","47.62125"],["90.493569","47.512157"],["90.491338","47.430787"],["90.552986","47.391174"],["90.522859","47.318461"],["90.584915","47.224989"],["90.782025","47.019194"],["90.923517","46.97996"],["90.986624","46.807403"],["91.082926","46.722064"],["91.051812","46.596604"],["91.100242","46.564068"],["91.102624","46.537196"],["90.935125","46.300398"],["91.032801","46.126363"],["91.055181","46.011658"],["90.741148","45.713536"],["90.699563","45.544726"],["90.700228","45.504993"],["90.795887","45.449956"],["90.832257","45.31629"],["90.919719","45.26871"],["90.920899","45.225065"],["91.136978","45.244316"],["91.253943","45.164928"],["91.372068","45.142003"],["91.45689","45.18485"],["91.624753","45.098124"],["92.062061","45.11548"],["92.497694","45.030848"],["92.887666","45.075869"],["93.513157","44.997233"],["94.22699","44.694971"],["94.374082","44.542037"],["94.620202","44.47394"],["94.737532","44.366876"],["95.002041","44.282908"],["95.42701","44.324539"],["95.440292","44.292217"],["95.365491","44.054053"],["95.549126","44.026335"],["95.883651","43.431746"],["95.911953","43.287656"],["96.385653","42.919774"],["96.41151","42.75927"],["97.176454","42.824161"],["98.198333","42.682435"],["99.505985","42.597497"],["99.964106","42.676693"],["100.259793","42.666107"],["100.320604","42.718863"],["100.867753","42.700052"],["101.814637","42.530852"],["102.090733","42.250567"],["102.451458","42.173439"],["102.716911","42.181644"],["103.426452","41.910629"],["103.858223","41.830321"],["104.537873","41.903108"],["104.55755","41.881352"],["104.554117","41.69046"],["104.929798","41.682608"],["105.010371","41.620463"],["105.220141","41.778353"],["105.732529","41.977008"],["106.776853","42.319288"],["107.167833","42.354897"],["107.458928","42.487147"],["107.937949","42.433308"],["108.241189","42.489425"],["108.84269","42.425722"],["109.022141","42.487574"],["109.290662","42.465227"],["109.534657","42.500548"],["109.723763","42.60669"],["110.100045","42.671172"],["110.420666","42.80617"],["111.005001","43.354829"],["111.446257","43.521761"],["111.555004","43.519925"],["111.780481","43.697712"],["111.925235","43.719055"],["111.936243","43.796237"],["111.863286","43.902314"],["111.643689","44.039247"],["111.386948","44.360034"],["111.610923","44.793044"],["111.742544","44.988614"],["111.9942","45.118751"],["112.435906","45.103062"],["112.61512","44.956037"],["112.806373","44.882816"],["113.624854","44.775834"],["113.896701","44.9424"],["114.104283","44.984106"],["114.437113","45.233044"],["114.543629","45.41585"],["114.742713","45.46746"],["114.977202","45.40645"],["115.36123","45.421513"],["115.688202","45.487095"],["116.023886","45.712008"],["116.163919","45.717567"],["116.251037","45.785617"],["116.213851","45.874652"],["116.246574","45.98171"],["116.56904","46.316673"],["116.83033","46.413023"],["117.353361","46.390324"],["117.41533","46.528251"],["117.39222","46.582448"],["117.411768","46.610108"],["117.618878","46.628442"],["117.72387","46.549579"],["118.312433","46.768455"],["118.774374","46.71799"],["118.828619","46.795917"],["118.912926","46.804113"],["118.941979","46.764971"],["119.028625","46.769292"],["119.119864","46.669494"],["119.724391","46.623078"],["119.791059","46.707882"],["119.884572","46.701717"],["119.896224","46.880494"],["119.836485","46.899381"],["119.742007","47.13776"],["119.30249","47.404711"],["119.315214","47.461827"],["119.134262","47.517476"],["119.10804","47.64174"],["118.755577","47.747779"],["118.55396","47.96464"],["118.177657","48.02096"],["117.82558","47.987997"],["117.388809","47.612384"],["117.082887","47.796869"],["116.816533","47.867783"],["116.452289","47.808327"],["116.270714","47.845797"],["115.938377","47.653883"],["115.559971","47.900966"],["115.500727","48.161305"],["115.791907","48.279437"],["115.776629","48.537807"],["116.042275","48.826715"],["116.024444","48.890046"],["116.709459","49.880215"],["117.07866","49.723328"],["117.482128","49.648667"],["117.801998","49.554185"],["117.858689","49.620567"],["118.068073","49.643304"],["118.210831","49.759243"],["118.358674","49.80286"],["118.37378","49.853853"],["118.468623","49.857768"],["118.559926","49.957101"],["119.082034","50.01451"],["119.311051","50.169532"],["119.328389","50.327724"],["119.175332","50.320094"],["119.103534","50.373674"],["119.103642","50.409488"],["119.224019","50.469114"],["119.262214","50.625767"],["119.470096","50.763554"],["119.480245","50.910299"],["119.734497","51.106944"],["119.73542","51.228925"],["119.789064","51.243368"],["119.787948","51.298691"],["119.896417","51.365189"],["119.889615","51.410731"],["119.950318","51.426267"],["120.067241","51.699773"],["120.632029","51.963004"],["120.755196","52.16206"],["120.733974","52.23734"],["120.60276","52.318868"],["120.688398","52.529211"],["120.459208","52.615218"],["120.046556","52.554881"],["120.004778","52.785297"],["120.275145","52.889292"],["120.877526","53.323248"],["121.231921","53.310391"],["122.338707","53.534212"],["122.443142","53.474191"],["122.84101","53.486577"],["123.278553","53.592823"],["123.480492","53.533829"],["123.518364","53.587614"],["123.901491","53.509565"],["124.129157","53.379309"],["124.260864","53.404185"],["124.447374","53.252351"],["124.696798","53.233398"],["124.854212","53.143501"],["124.877429","53.19179"],["125.14374","53.233437"],["125.500989","53.129213"],["125.53472","53.084642"],["125.631731","53.108131"],["125.776978","53.000452"],["125.732839","52.906456"],["125.842016","52.927481"],["125.973551","52.795444"],["126.049747","52.829373"],["126.137295","52.788424"],["126.136093","52.7501"],["126.082878","52.727183"],["126.094744","52.66376"],["126.01078","52.632295"],["126.225078","52.557751"],["126.227546","52.502887"],["126.28664","52.498733"],["126.378071","52.405299"],["126.365626","52.334723"],["126.460233","52.313556"],["126.457937","52.278438"],["126.370797","52.21752"],["126.587327","52.146539"],["126.544647","52.022831"],["126.483493","52.004144"],["126.489866","51.963387"],["126.757379","51.72942"],["126.769931","51.638237"],["126.737959","51.604012"],["126.870396","51.541384"],["126.8313","51.449554"],["126.939726","51.411373"],["126.952021","51.35238"],["127.007918","51.339647"],["126.930671","51.194554"],["126.950047","51.077214"],["127.328668","50.761993"],["127.324612","50.674039"],["127.399564","50.585975"],["127.336199","50.480736"],["127.39435","50.441709"],["127.374866","50.346296"],["127.622938","50.242265"],["127.624762","50.159938"],["127.524126","50.053819"],["127.569466","49.832087"],["127.686474","49.798414"],["127.716987","49.69577"],["127.838395","49.617717"],["128.185065","49.56898"],["128.533065","49.633229"],["128.791094","49.618148"],["128.84167","49.562161"],["128.811865","49.506248"],["129.022107","49.485245"],["129.11165","49.389985"],["129.230032","49.429552"],["129.343135","49.392234"],["129.383497","49.461849"],["129.526126","49.451932"],["129.593332","49.316758"],["129.745059","49.313625"],["129.972146","49.057136"],["130.243692","48.89923"],["130.444579","48.939218"],["130.526934","48.889044"],["130.693552","48.907086"],["130.705612","48.869994"],["130.580449","48.630526"],["130.630317","48.609845"],["130.648105","48.52472"],["130.790884","48.525345"],["130.778868","48.413864"],["130.875106","48.300724"],["130.708423","48.108792"],["130.914073","47.945556"],["131.01546","47.736076"],["131.552374","47.750448"],["131.621768","47.692216"],["131.711934","47.740348"],["131.958075","47.703033"],["131.995368","47.741041"],["132.235458","47.739381"],["132.340472","47.796162"],["132.546873","47.750881"],["132.655685","47.89209"],["132.654505","47.979308"],["132.811511","47.967327"],["133.097413","48.158185"],["133.473394","48.128346"],["133.728504","48.281365"],["134.199908","48.411499"],["134.519091","48.448618"],["134.797053","48.402511"],["134.903462","48.476549"],["135.111473","48.465979"],["135.087461","48.366044"],["134.70854","48.235879"],["134.705815","48.142967"],["134.587133","47.991745"],["134.802439","47.732613"],["134.805079","47.701502"],["134.584837","47.454022"],["134.327302","47.405829"],["134.203448","47.309543"],["134.189801","47.25835"],["134.258273","47.190339"],["134.25029","47.096963"],["134.160018","47.066453"],["134.091868","46.968583"],["134.042215","46.633997"],["133.892806","46.477753"],["133.978872","46.404235"],["133.938468","46.35728"],["133.943124","46.251663"],["133.734856","46.143924"],["133.77584","46.068467"],["133.698828","45.924364"],["133.509421","45.823745"],["133.533154","45.779212"],["133.488886","45.719859"],["133.513906","45.69461"],["133.496869","45.599732"],["133.229721","45.489276"],["133.168674","45.414886"],["133.124621","45.258199"],["133.158975","45.105773"],["132.946351","44.989767"],["131.996377","45.226214"],["131.893723","45.301592"],["131.80903","45.186922"],["131.72307","45.208468"],["131.688416","45.166214"],["131.716461","45.107939"],["131.507506","44.942491"],["131.131804","44.90387"],["131.021662","44.839439"],["131.137726","44.723122"],["131.338398","44.056058"],["131.273661","43.974086"],["131.248341","43.566337"],["131.344342","43.514183"],["131.346252","43.391702"],["131.236002","43.22857"],["131.242955","43.131057"],["131.13749","43.018486"],["131.168904","42.923466"],["131.065779","42.901952"],["131.05005","42.834641"],["130.673962","42.819219"],["130.46123","42.731347"],["130.617421","42.685874"],["130.650616","42.595365"],["130.604267","42.509264"],["130.661752","42.412289"],["130.553477","42.421191"],["130.507536","42.571366"],["130.42958","42.523293"],["130.416105","42.590452"],["130.235238","42.692151"],["130.237405","42.873951"],["130.125611","42.876169"],["130.075765","42.911319"],["130.092008","42.956423"],["129.933178","42.975108"],["129.878311","42.92378"],["129.795163","42.719399"],["129.815032","42.601778"],["129.735103","42.411401"],["129.607751","42.418118"],["129.55415","42.330996"],["129.383025","42.403749"],["129.268527","42.323223"],["129.222093","42.257635"],["129.2434","42.19201"],["128.992774","42.075243"],["128.959644","41.997184"],["128.121765","41.974471"],["128.183949","41.746614"],["128.336234","41.608881"],["128.268621","41.434008"],["128.127944","41.337429"],["128.00482","41.417516"],["127.65285","41.377517"],["127.537794","41.447986"],["127.248116","41.454805"],["127.234962","41.492217"],["127.08566","41.544545"],["127.128081","41.592273"],["127.012339","41.679643"],["127.035706","41.702541"],["126.914964","41.778689"],["126.809177","41.669562"],["126.74607","41.691325"],["126.612003","41.629975"],["126.529799","41.412013"],["126.562243","41.368516"],["126.557908","41.33825"],["126.45328","41.325763"],["126.3043","41.139979"],["126.148946","41.070584"],["126.132917","40.990783"],["126.041744","40.924117"],["126.041787","40.876401"],["125.721896","40.840697"],["125.681319","40.80754"],["125.712733","40.774611"],["125.686641","40.761853"],["125.582743","40.75319"],["125.423162","40.624246"],["125.310595","40.636606"],["125.022783","40.521123"],["125.06057","40.46396"],["124.907556","40.445935"],["124.374311","40.078794"],["124.388452","39.905638"],["123.741782","39.10294"],["123.282201","38.058466"],["124.24299","31.368588"],["124.714351","29.508006"],["125.072136","25.859069"],["124.935837","25.676612"],["123.836839","25.5127"],["122.751321","24.515956"],["121.947788","22.070621"],["121.867355","21.383021"],["119.827087","18.177352"],["119.026527","16.873489"],["119.11665","15.951676"],["119.101406","14.063252"],["119.100623","12.209516"],["119.07742","11.23357"],["116.011301","7.678721"],["114.941852","6.182877"],["114.229887","5.47862"],["113.86269","4.692236"],["112.795642","3.695169"],["111.953841","3.231846"],["109.894631","3.714037"],["108.659956","4.748032"],["107.925439","5.91737"],["107.96348","6.895899"],["108.555028","9.28242"],["110.128544","11.338543"],["109.983314","12.44102"],["109.806102","13.535124"],["109.636428","14.636855"],["109.78629","15.402577"],["109.449813","15.723154"],["108.117871","17.258818"],["107.310076","18.842045"],["107.374728","19.467179"],["108.051095","20.114414"],["108.328478","21.187373"],["108.278139","21.403412"],["108.107378","21.47839"],["107.943356","21.509097"],["107.849844","21.619412"],["107.547355","21.55724"],["107.470751","21.571209"],["107.451932","21.615722"],["107.357798","21.570152"],["107.289755","21.702532"],["107.207551","21.682454"],["106.998789","21.79714"],["107.015655","21.907972"],["106.951239","21.893876"],["106.768184","21.978429"],["106.703854","21.935422"],["106.674027","21.941175"],["106.664565","22.266461"],["106.643493","22.30484"],["106.538715","22.328641"],["106.53142","22.460275"],["106.592939","22.622033"],["106.708553","22.615477"],["106.793547","22.794758"],["106.548972","22.899047"],["106.304634","22.830954"],["106.190543","22.951201"],["106.088791","22.966118"],["105.867991","22.889816"],["105.712488","23.033058"],["105.550311","23.045755"],["105.530806","23.163759"],["105.330691","23.346393"],["105.249667","23.237422"],["105.089657","23.231409"],["104.951169","23.149476"],["104.843495","23.101267"],["104.893084","22.94393"],["104.747257","22.79551"],["104.567764","22.813411"],["104.371855","22.65974"],["104.249053","22.720536"],["104.237015","22.806132"],["104.137495","22.783462"],["104.078336","22.740585"],["104.017096","22.520843"],["103.962035","22.492019"],["103.666692","22.741534"],["103.525093","22.580551"],["103.458703","22.648987"],["103.394201","22.751092"],["103.341286","22.767397"],["103.306804","22.661878"],["103.215652","22.621855"],["103.205309","22.536362"],["103.107505","22.486567"],["103.076606","22.416444"],["102.91784","22.456309"],["102.840786","22.583305"],["102.610223","22.696625"],["102.558017","22.673838"],["102.493515","22.738071"],["102.424293","22.676273"],["102.446694","22.621241"],["102.327948","22.511268"],["102.278531","22.386786"],["102.142661","22.36867"],["102.03475","22.427651"],["101.942096","22.415036"],["101.8765","22.355136"],["101.764791","22.472926"],["101.700847","22.453176"],["101.694624","22.349917"],["101.579332","22.223979"],["101.631925","21.988099"],["101.718335","21.962549"],["101.79863","21.848016"],["101.778824","21.73654"],["101.856952","21.62392"],["101.847124","21.595911"],["101.773932","21.558438"],["101.760328","21.349162"],["101.862724","21.239522"],["101.764727","21.115389"],["101.663511","21.164623"],["101.587808","21.146813"],["101.574161","21.209359"],["101.53264","21.221881"],["101.293538","21.149214"],["101.203866","21.206559"],["101.216612","21.289294"],["101.114173","21.403592"],["101.183052","21.497378"],["101.111941","21.560533"],["101.095719","21.734009"],["100.901892","21.659343"],["100.747526","21.494902"],["100.586185","21.423588"],["100.468576","21.433695"],["100.414267","21.504705"],["100.248806","21.434534"],["100.115855","21.481604"],["100.078626","21.591362"],["100.11579","21.654357"],["100.010068","21.666462"],["99.916813","21.811046"],["99.968591","21.972539"],["99.950867","22.023392"],["99.699748","22.008512"],["99.585378","22.083453"],["99.19384","22.094388"],["99.129961","22.147006"],["99.24403","22.347694"],["99.226069","22.407775"],["99.348979","22.505302"],["99.289627","22.751963"],["99.429595","22.858203"],["99.422858","22.95454"],["99.521735","22.955884"],["99.488432","23.051046"],["99.336512","23.101188"],["99.258964","23.048934"],["99.10449","23.057463"],["98.99924","23.151389"],["98.858693","23.167152"],["98.89811","23.292382"],["98.844295","23.323341"],["98.878284","23.4184"],["98.821571","23.466061"],["98.773527","23.530055"],["98.849638","23.617887"],["98.774085","23.751823"],["98.656368","23.775684"],["98.63961","23.801661"],["98.649909","23.978332"],["98.828974","24.077833"],["98.83893","24.109859"],["98.594849","24.051324"],["98.534853","24.098401"],["98.118939","24.06406"],["97.652578","23.812007"],["97.500916","23.916402"],["97.507889","23.946076"],["97.703905","24.12772"],["97.7321","24.242073"],["97.646012","24.307132"],["97.678134","24.384313"],["97.653759","24.420913"],["97.528617","24.403523"],["97.504349","24.421636"],["97.520614","24.750904"],["97.686181","24.867223"],["97.726886","24.872596"],["97.701159","24.901891"],["97.691374","25.085579"],["97.816257","25.289948"],["97.844152","25.297669"],["97.93803","25.249897"],["98.122308","25.413237"],["98.152177","25.643055"],["98.313818","25.589382"],["98.380058","25.615679"],["98.510756","25.863626"],["98.635018","25.83211"],["98.668857","25.860517"],["98.546226","26.121072"],["98.648708","26.171346"],["98.686366","26.138757"],["98.648","26.279486"],["98.751404","26.620222"],["98.701365","26.849746"],["98.733852","27.033154"],["98.685272","27.065508"],["98.663149","27.194049"],["98.708661","27.325701"],["98.657935","27.422786"],["98.67244","27.532116"],["98.574979","27.540164"],["98.537407","27.61841"],["98.464022","27.631357"],["98.417695","27.512725"],["98.29766","27.498051"],["98.144388","27.832814"],["98.155954","27.920407"],["98.109477","27.953809"],["98.111","28.123353"],["97.991245","28.182664"],["97.984571","28.253152"],["97.904449","28.328541"],["97.775702","28.306704"],["97.650433","28.498038"],["97.537651","28.471615"],["97.537544","28.300942"],["97.374809","28.215134"],["97.340262","28.085365"],["97.441328","28.020526"],["97.41045","27.866111"],["97.271254","27.865238"],["97.104206","27.710621"],["97.074959","27.716851"],["96.959302","27.833554"],["96.799979","27.862962"],["96.485238","28.041967"],["96.435456","28.122218"],["96.282742","28.11548"],["96.254032","28.195619"],["96.011753","28.160892"],["95.866721","28.266533"],["95.747824","28.246895"],["95.417182","28.118906"],["95.304315","27.916842"],["94.898787","27.716889"],["94.531603","27.567615"],["94.290032","27.552854"],["93.888688","27.17204"],["93.845987","27.008916"],["93.571308","26.909059"],["92.944937","26.862668"],["92.647405","26.922873"],["92.093539","26.830122"],["92.094247","26.952103"],["91.998589","27.089524"],["92.083004","27.299047"],["92.034273","27.387239"],["91.995907","27.444668"],["91.729424","27.433927"],["91.566002","27.518015"],["91.534996","27.644815"],["91.602566","27.75719"],["91.514804","27.82382"],["91.562676","27.867913"],["91.468799","27.914302"],["91.441784","27.98019"],["91.319818","28.026891"],["91.09123","27.815659"],["90.700164","28.042914"],["90.592875","27.992071"],["90.457885","28.016188"],["90.284765","28.126494"],["90.15898","28.149257"],["90.026414","28.108761"],["89.808083","28.209972"],["89.741178","28.14466"],["89.620585","28.133666"],["89.394701","27.853894"],["89.261577","27.776101"],["89.129934","27.494282"],["89.208705","27.359876"],["89.003119","27.183627"],["88.914757","27.261172"],["88.754318","27.459692"],["88.742559","27.575756"],["88.824484","27.683585"],["88.858366","27.84585"],["88.817167","27.989323"],["88.749833","28.04227"],["88.643789","28.079175"],["88.414536","27.948938"],["88.164768","27.927649"],["88.119621","27.836742"],["87.844298","27.914245"],["87.731731","27.773994"],["87.596998","27.78341"],["87.555606","27.832169"],["87.226918","27.783961"],["87.114007","27.809055"],["87.017899","27.921014"],["86.741974","28.007834"],["86.699681","28.06541"],["86.621253","28.036683"],["86.583402","28.057988"],["86.53626","27.935498"],["86.410089","27.875861"],["86.21079","27.953771"],["86.168518","28.117581"],["86.115561","28.075237"],["86.149271","27.905693"],["85.994046","27.879218"],["85.944521","27.932939"],["85.832512","28.151055"],["85.730202","28.210313"],["85.701256","28.320003"],["85.608344","28.222546"],["85.501399","28.296408"],["85.379283","28.245137"],["85.108273","28.308745"],["85.080035","28.467918"],["85.159664","28.55567"],["85.153999","28.618263"],["85.06716","28.641711"],["84.995663","28.560816"],["84.851232","28.539159"],["84.68178","28.609315"],["84.624424","28.696084"],["84.465938","28.711423"],["84.389849","28.828396"],["84.202845","28.880867"],["84.21602","29.009754"],["84.163899","29.035197"],["84.138279","29.170731"],["84.156046","29.210987"],["84.110534","29.218441"],["84.085858","29.266484"],["83.922973","29.294016"],["83.658078","29.134976"],["83.571818","29.151918"],["83.232014","29.552591"],["83.070545","29.578981"],["82.920063","29.684809"],["82.816744","29.661877"],["82.675381","29.739992"],["82.684436","29.800693"],["82.605515","29.811846"],["82.541184","29.930689"],["82.159367","30.045582"],["82.174859","30.141657"],["82.084479","30.216893"],["82.077913","30.310431"],["81.993091","30.291904"],["81.637645","30.413095"],["81.562006","30.34101"],["81.44238","30.380465"],["81.419613","30.185719"],["81.306617","30.138261"],["81.279452","29.994378"],["81.11603","30.010804"],["80.995588","30.23662"],["80.302677","30.539587"],["80.0878","30.543727"],["79.94236","30.672449"],["79.868267","30.834188"],["79.825373","30.839126"],["79.673774","30.945519"],["79.593372","30.894565"],["79.4033","31.036535"],["79.346716","31.001927"],["79.336288","30.933391"],["79.224193","30.920174"],["79.170227","30.981969"],["79.092743","30.963258"],["78.986249","31.027673"],["78.96668","31.157988"],["78.856924","31.281503"],["78.783796","31.274131"],["78.728542","31.344273"],["78.757918","31.433515"],["78.697536","31.51499"],["78.804524","31.611708"],["78.62458","31.82264"],["78.722126","31.927562"],["78.578596","31.999524"],["78.497701","32.11424"],["78.432641","32.118838"],["78.402622","32.220389"],["78.4762","32.31131"],["78.36638","32.528271"],["78.381336","32.554898"],["78.75176","32.731065"],["78.809223","32.496551"],["78.976872","32.364195"],["79.005883","32.376536"],["79.080126","32.394077"],["79.114029","32.491665"],["79.279168","32.61355"],["79.272795","32.713951"],["79.195912","32.779409"],["79.222884","32.93039"],["79.135616","33.001861"],["79.1289","33.16414"],["78.818901","33.407102"],["78.715496","33.540948"],["78.723736","33.604683"],["78.656015","33.65053"],["78.749506","33.746395"],["78.715582","33.972994"],["78.631468","34.014908"],["78.635867","34.100789"],["78.894839","34.171104"],["78.97243","34.341399"],["78.867137","34.336615"],["78.698266","34.491737"],["78.566988","34.478543"],["78.527312","34.539705"],["78.430667","34.514354"],["78.403587","34.570207"],["78.247139","34.615374"],["78.238835","34.685346"],["78.179204","34.722162"],["78.172767","34.964414"],["78.056982","35.102584"],["77.985699","35.231108"],["77.986279","35.376996"],["78.060694","35.455461"],["77.904546","35.435236"],["77.815948","35.484733"],["77.688854","35.41908"],["77.389219","35.439747"],["77.300084","35.509365"],["77.189727","35.490691"],["76.844516","35.637645"],["76.746969","35.630442"],["76.675837","35.721674"],["76.57151","35.752903"],["76.552477","35.878323"],["76.372211","35.795695"],["76.149781","35.797227"],["76.124933","35.947734"],["75.922673","36.058952"],["75.911558","36.150212"],["76.037836","36.25097"],["75.962627","36.325913"],["75.987883","36.449905"],["75.852334","36.642976"],["75.645268","36.740208"],["75.442793","36.696296"],["75.389578","36.92691"],["75.229053","36.936669"],["75.144038","36.993436"],["74.896481","36.905551"],["74.830134","37.022531"],["74.731107","36.999897"],["74.690745","37.052831"],["74.559724","37.004866"],["74.481919","37.046871"],["74.437845","37.120308"],["74.499922","37.266966"],["74.739861","37.314987"],["74.866312","37.253902"],["75.109062","37.372562"],["75.102367","37.44057"],["74.921629","37.536802"],["74.864573","37.654148"],["74.964759","37.773242"],["74.890065","37.834937"],["74.908884","37.982278"],["74.777327","38.153069"],["74.761705","38.335766"],["74.838288","38.415972"],["74.834661","38.466073"],["74.630191","38.571841"],["74.373536","38.625873"],["74.159667","38.646204"],["74.103234","38.581"],["74.111817","38.521998"],["74.000838","38.494528"],["73.77285","38.599147"],["73.670411","38.8621"],["73.725193","38.95749"],["73.802719","38.951449"],["73.807654","38.986017"],["73.72221","39.008697"],["73.473516","39.38863"],["73.616295","39.498494"],["73.852308","39.511093"],["73.918183","39.600828"],["73.897347","39.705585"],["73.808942","39.800228"],["73.93934","39.994893"],["73.923182","40.040084"],["74.206402","40.150079"],["74.349396","40.120697"],["74.57305","40.295485"],["74.65313","40.30568"],["74.68538","40.371234"],["74.834146","40.370645"],["74.764109","40.445837"],["74.82522","40.547706"],["74.991968","40.485604"],["75.234225","40.478276"],["75.595829","40.68866"],["75.623209","40.675235"],["75.670288","40.537172"],["75.761075","40.482617"],["75.702088","40.361506"],["75.718331","40.319244"],["75.831778","40.356634"],["75.909498","40.327457"],["75.962198","40.405801"],["76.169136","40.4108"],["76.276231","40.468254"],["76.350474","40.381058"],["76.518981","40.485522"],["76.629574","40.63177"],["76.618888","40.769281"],["76.705191","40.836687"],["76.738064","40.970777"],["76.866853","41.052415"],["77.002079","41.102703"],["77.174621","41.038594"],["77.761016","41.051719"],["77.819595","41.177071"],["78.104789","41.252161"],["78.153155","41.41058"],["78.633699","41.494773"],["78.691227","41.573398"],["79.204752","41.752489"],["79.314144","41.836204"],["79.760721","41.919283"],["79.886034","42.062214"],["80.133162","42.067184"],["80.141101","42.212865"],["80.253518","42.271926"],["80.176806","42.427971"],["80.233755","42.509043"],["80.134728","42.629333"],["80.233669","42.836907"],["80.527124","42.908804"],["80.358446","43.012006"],["80.363209","43.05597"],["80.77054","43.196057"],["80.751915","43.283969"],["80.657952","43.321619"],["80.722024","43.489763"],["80.498157","43.799783"],["80.367136","44.112086"],["80.382199","44.282371"],["80.320637","44.484489"],["80.375676","44.600628"],["80.200903","44.711915"],["80.153825","44.809898"],["79.982829","44.769908"],["79.863417","44.896027"],["79.863911","44.925979"],["80.099001","45.081976"],["80.380783","45.073778"],["80.472493","45.151008"],["80.593643","45.1361"],["80.723355","45.20611"],["80.897505","45.157969"],["81.777248","45.412611"],["81.933761","45.262246"],["82.295816","45.254845"],["82.544253","45.206065"],["82.569401","45.340669"],["82.52743","45.402307"],["82.265496","45.514783"],["82.238288","45.626914"],["82.311373","45.780155"],["82.319655","45.956177"],["82.440763","46.003982"],["82.822452","46.775333"],["83.012309","47.24291"],["83.148286","47.241861"],["83.371532","47.179737"],["83.583899","47.087891"],["83.927865","46.999324"],["84.753106","47.038661"],["84.955001","46.896507"],["85.227256","47.083274"],["85.529079","47.087102"],["85.670679","47.295094"],["85.656817","47.416255"],["85.581307","47.505664"],["85.500433","48.023314"],["85.564678","48.210504"],["85.778117","48.445159"],["86.21609","48.461326"],["86.297393","48.520485"],["86.571493","48.56921"],["86.745751","48.738276"],["86.72689","48.79468"],["86.785169","48.850936"],["86.706676","48.980358"],["86.708565","49.011387"],["86.889625","49.162344"],["87.145572","49.183316"],["87.435358","49.10582"],["87.476878","49.120484"],["87.490826","49.169134"],["87.836187","49.198616"],["87.895432","49.115877"],["87.87024","49.056222"],["87.9406","48.974696"],["87.803872","48.87904"],["88.125672","48.72326"],["88.023491","48.591881"],["88.35763","48.495848"],["88.450756","48.423234"],["88.527102","48.435337"],["88.631537","48.352171"],["88.608513","48.280466"],["88.657844","48.207172"],["88.828926","48.136652"],["88.942652","48.146274"],["89.088199","48.017358"],["89.571383","48.066881"],["89.777999","47.863838"],["90.077548","47.910676"],["90.155997","47.747389"],["90.399628","47.669347"],["90.413575","47.647046"],["90.398619","47.62125"]],JPN=[["145.824681","43.408601"],["145.802708","43.198731"],["145.188847","43.068449"],["144.992667","42.907867"],["143.970938","42.890345"],["143.384543","42.351736"],["143.299399","41.875506"],["142.95333","42.100071"],["142.391844","42.272669"],["141.369501","42.535185"],["140.832544","42.147648"],["141.028863","41.945699"],["141.296655","41.765675"],["141.564447","41.265171"],["141.675004","40.481173"],["141.829516","40.300647"],["141.982619","40.122464"],["142.142627","39.594221"],["142.025897","39.368452"],["142.021777","39.317473"],["141.850783","38.901626"],["140.939308","35.65669"],["139.436268","34.193845"],["137.347075","34.1603"],["135.63835","33.29272"],["133.488103","32.70897"],["131.614016","31.325292"],["130.633951","28.842845"],["127.785048","25.789008"],["126.597333","26.344784"],["128.404011","28.563857"],["128.940636","30.856318"],["128.544464","32.79621"],["129.194642","34.475467"],["129.324698","34.765641"],["129.502255","34.700627"],["129.480282","33.855809"],["130.439605","33.915587"],["130.801388","34.159716"],["130.791882","34.445506"],["131.121471","34.437578"],["131.298124","34.567727"],["132.535148","35.287335"],["132.978675","36.154847"],["133.268559","36.366209"],["134.710796","35.708808"],["135.303308","35.794165"],["136.404389","36.456814"],["136.612743","37.37546"],["137.409252","37.580348"],["137.291471","36.906421"],["137.982237","37.126821"],["138.504087","37.383552"],["138.758146","37.83898"],["139.207212","38.04151"],["139.310081","38.315743"],["139.737028","38.85997"],["139.403318","39.234917"],["139.952634","39.328459"],["140.002073","39.745742"],["139.695586","39.824208"],["139.679107","40.025361"],["139.935912","40.077921"],["140.001079","40.309807"],["139.922802","40.434311"],["139.828954","40.646676"],["139.95008","40.766604"],["139.957833","41.432491"],["140.001779","42.027933"],["139.389291","42.038134"],["139.346719","42.242877"],["139.63099","42.291658"],["139.72712","42.641155"],["139.942098","42.710048"],["140.194783","42.842098"],["140.30396","42.856193"],["140.309453","43.306551"],["140.393224","43.399418"],["140.61976","43.355264"],["140.788732","43.238558"],["140.923314","43.24556"],["141.029058","43.24356"],["141.083989","43.216544"],["141.141667","43.185513"],["141.336675","43.240561"],["141.328435","43.731771"],["141.350408","43.792272"],["141.594854","43.937818"],["141.565334","44.291761"],["141.70541","44.45177"],["141.708157","44.742196"],["141.683437","45.002047"],["141.226594","45.076599"],["141.053559","45.165748"],["140.987641","45.335905"],["140.943696","45.481498"],["141.201589","45.501064"],["141.972005","45.52416"],["142.341996","45.204477"],["142.567215","45.014513"],["142.747966","44.801094"],["143.487122","44.343678"],["144.463587","44.078617"],["144.874201","44.098345"],["145.125513","44.222478"],["145.300832","44.391445"],["145.487445","44.320885"],["145.111163","43.848378"],["145.420933","43.545126"],["145.451146","43.393635"]],EAST=[["73.757316","29.95798"],["73.045185","28.989136"],["72.434431","28.60931"],["72.060098","28.097836"],["71.631749","27.60702"],["70.67236","27.593264"],["69.82743","27.041579"],["70.337045","26.566045"],["70.070655","26.098932"],["70.070655","25.85946"],["70.290717","25.713457"],["70.626599","25.671708"],["70.68451","25.201036"],["70.974064","24.791642"],["70.811914","24.612763"],["70.139151","24.465923"],["69.268014","24.435423"],["68.313114","24.267539"],["67.911051","23.808548"],["68.547651","23.00912"],["69.11724","22.684917"],["68.748682","22.406416"],["69.301519","21.536417"],["70.153052","20.55461"],["71.170222","20.332219"],["72.234349","21.204506"],["72.501752","21.087142"],["72.627589","19.003767"],["72.973641","16.878922"],["74.267757","13.888898"],["75.369075","10.48118"],["76.976429","7.781262"],["78.374805","8.242836"],["79.427902","9.641233"],["80.513091","10.734685"],["80.254133","11.953377"],["80.702994","13.082541"],["80.402232","15.312175"],["82.991824","16.887862"],["85.259974","19.051683"],["87.784208","21.10679"],["89.263244","21.658877"],["89.121009","23.437218"],["88.869364","23.717994"],["88.93501","24.317619"],["88.267603","24.596482"],["88.727129","25.073086"],["89.186656","25.132532"],["88.891246","25.626788"],["88.650542","25.666241"],["88.201956","25.892841"],["88.420778","26.12883"],["88.54113","26.285892"],["89.241361","26.020727"],["89.613359","25.863309"],["89.657124","25.330477"],["90.190932","25.070998"],["91.175632","25.051175"],["91.811935","25.05221"],["92.234344","24.983507"],["92.104658","24.649259"],["91.844714","24.363456"],["91.46563","24.215373"],["90.999897","23.839459"],["91.216517","23.054471"],["91.389672","22.300847"],["92.125338","20.623521"],["93.946113","18.753448"],["92.823675","16.135717"],["91.224276","9.998681"],["93.522355","5.752403"],["96.409859","0.991383"],["100.048825","-3.72227"],["104.60328","-7.736835"],["114.01025","-9.967468"],["123.433702","-11.032285"],["123.717523","-10.536628"],["124.427075","-10.257467"],["125.004217","-9.79418"],["125.026253","-9.527403"],["125.12788","-9.406056"],["125.031601","-9.358561"],["124.946021","-9.216037"],["125.026253","-9.168516"],["125.192065","-9.13155"],["125.181368","-8.982538"],["124.999509","-8.987821"],["124.919277","-8.924418"],["125.095787","-8.596662"],["125.555784","-8.088612"],["125.721597","-8.120384"],["127.292232","-8.326419"],["132.424841","-8.447132"],["139.646777","-8.512957"],["141.039618","-9.209048"],["141.025347","-6.894209"],["140.978655","-6.887392"],["140.92235","-6.851943"],["140.912737","-6.791946"],["140.905871","-6.737397"],["140.850939","-6.695117"],["140.903124","-6.59554"],["140.945696","-6.509588"],["141.000442","-6.341825"],["140.971754","-2.322171"],["131.63417","2.671779"],["125.182746","17.665698"],["120.512231","19.243264"],["119.486602","16.550429"],["119.820154","12.379244"],["115.293339","5.77989"],["114.675587","4.850295"],["114.550618","4.735342"],["113.923024","4.60805"],["113.581092","3.881824"],["113.423754","3.763395"],["113.138025","3.427757"],["112.798973","3.119213"],["111.886744","2.960093"],["109.608393","3.016867"],["108.771364","3.935896"],["107.181008","7.101455"],["110.509765","12.398562"],["108.171244","18.449712"],["108.482399","21.923911"],["106.042422","23.36869"],["103.861684","23.500971"],["101.853026","22.51803"],["101.964992","22.453371"],["102.079606","22.467488"],["102.100842","22.366033"],["102.192713","22.264854"],["102.457234","22.052786"],["102.482552","21.991854"],["102.505944","21.933096"],["102.598494","21.858522"],["102.635027","21.768076"],["102.625285","21.706993"],["102.652076","21.663993"],["102.749497","21.641356"],["102.798208","21.673047"],["102.841349","21.836472"],["102.857688","21.688772"],["102.936435","21.684707"],["102.971433","21.587108"],["102.897061","21.530145"],["102.831439","21.416153"],["102.853313","21.363197"],["102.770191","21.249074"],["102.905811","20.975636"],["103.219101","20.747931"],["103.517772","20.714677"],["103.809332","20.581588"],["103.928404","20.796397"],["104.17602","20.868718"],["104.456453","20.674762"],["104.597217","20.649539"],["104.494205","20.561152"],["104.33078","20.448774"],["104.574769","20.381484"],["104.658948","20.213054"],["104.76838","20.149846"],["104.838529","20.181454"],["104.938282","20.043215"],["104.745932","19.888842"],["104.790827","19.817585"],["104.656142","19.725166"],["104.580381","19.643265"],["104.41625","19.738372"],["104.315236","19.711959"],["104.004834","19.776374"],["103.978829","19.601517"],["104.057089","19.487272"],["103.795479","19.292317"],["104.05618","19.205901"],["104.303857","19.041792"],["104.509718","18.953592"],["104.638381","18.819682"],["104.82816","18.734411"],["105.081179","18.714495"],["105.090265","18.561021"],["105.010482","18.494337"],["105.215532","18.232365"],["105.507333","18.022503"],["105.673181","17.706155"],["105.959258","17.411042"],["106.393016","16.974064"],["106.530565","16.907086"],["106.511314","16.705452"],["106.610307","16.485756"],["106.704089","16.360817"],["106.855183","16.430793"],["106.917705","16.245803"],["107.074009","16.275813"],["107.178212","16.130721"],["107.386617","15.975505"],["107.256364","15.895346"],["107.157745","15.729918"],["107.270294","15.538977"],["107.541111","15.371176"],["107.598724","15.119441"],["107.495192","15.087312"],["107.421241","14.973038"],["107.491494","14.719275"],["107.439728","14.558285"],["107.365777","14.619117"],["107.28443","14.576179"],["107.125343","14.454386"],["107.058787","14.468707"],["106.862816","14.336197"],["106.714913","14.443644"],["106.640961","14.525985"],["106.467176","14.622607"],["106.385829","14.475868"],["106.219438","14.500928"],["106.189858","14.42932"],["106.104814","14.407834"],["105.956911","14.346944"],["105.993887","14.192854"],["106.138092","14.056594"],["106.067838","13.984846"],["105.938423","13.948964"],["105.860774","14.067355"],["105.570516","14.196239"],["105.40579","14.123984"],["105.307739","14.207645"],["105.23322","14.257067"],["105.284207","14.321679"],["105.397946","14.336879"],["105.499919","14.435654"],["105.550906","14.617894"],["105.535217","14.773437"],["105.660723","14.90613"],["105.629347","15.019802"],["105.511685","15.118269"],["105.543062","15.182626"],["105.660723","15.2848"],["105.543062","15.368016"],["105.641113","15.40205"],["105.652879","15.526792"],["105.672489","15.723201"],["105.433244","15.866611"],["105.419865","16.077323"],["105.134284","16.158015"],["105.05029","16.303179"],["104.798307","16.56635"],["104.815106","16.791639"],["104.807079","17.064937"],["104.834545","17.357467"],["104.746654","17.518618"],["104.392993","17.569592"],["104.221867","17.790865"],["104.071113","18.043041"],["103.989584","18.196169"],["103.880878","18.236734"],["103.692584","18.269917"],["103.616878","18.310466"],["103.546996","18.349162"],["103.428584","18.336313"],["103.370348","18.277339"],["103.302336","18.221647"],["103.237773","18.102183"],["103.207191","18.040806"],["103.105249","17.937384"],["102.938746","17.875949"],["102.914959","17.827432"],["102.813018","17.765959"],["102.687291","17.753015"],["102.568359","17.830667"],["102.510593","17.840371"],["102.422244","17.921219"],["102.310109","17.960013"],["102.204769","17.995566"],["102.143605","18.066652"],["101.987295","17.966477"],["101.868364","17.927685"],["101.647491","17.811257"],["101.148809","17.535022"],["101.023374","17.599797"],["101.039054","17.808912"],["101.175591","17.993048"],["101.212078","18.10208"],["101.219896","18.173904"],["101.206865","18.240749"],["101.212078","18.344679"],["101.107829","18.394147"],["101.092192","18.45349"],["101.206865","18.578877"],["101.31372","18.655442"],["101.272021","18.741845"],["101.272021","18.830671"],["101.311114","18.939171"],["101.370997","19.079681"],["101.298023","19.148632"],["101.279779","19.212632"],["101.22818","19.375675"],["101.230424","19.441269"],["101.295484","19.487804"],["101.29997","19.591402"],["101.239397","19.633668"],["101.145173","19.587175"],["101.093574","19.629442"],["100.94102","19.650571"],["100.893907","19.65691"],["100.864742","19.616763"],["100.835578","19.570265"],["100.770518","19.534326"],["100.611233","19.574493"],["100.584312","19.52164"],["100.525983","19.540669"],["100.46541","19.637894"],["100.436245","19.777288"],["100.541687","19.91867"],["100.597773","20.190526"],["100.502946","20.195053"],["100.428788","20.262059"],["100.379218","20.36601"],["100.329779","20.413638"],["100.244635","20.387895"],["100.173224","20.317079"],["100.160865","20.244943"],["100.114789","20.260301"],["100.107922","20.315689"],["100.155988","20.507461"],["100.211891","20.650056"],["100.290818","20.736459"],["100.399973","20.811825"],["100.562866","20.788277"],["100.673701","20.899705"],["100.59616","20.954029"],["100.751867","21.254036"],["100.998402","21.338663"],["101.211622","21.580378"],["101.209043","21.846211"],["100.909901","21.894492"],["100.207565","21.580378"],["100.051491","22.159742"],["99.466212","22.436515"],["99.71333","23.024318"],["99.352488","23.281431"],["99.03983","24.3247"],["98.101855","24.95993"],["98.855913","25.608485"],["98.911088","26.812993"],["98.892697","27.483968"],["98.340947","27.826069"],["98.120247","28.377665"],["97.586888","28.733061"],["97.108705","28.329109"],["96.658506","27.787659"],["96.296725","28.010502"],["95.847241","28.136253"],["95.288126","27.787659"],["94.685158","27.233428"],["93.281889","26.647032"],["92.037851","26.720259"],["90.141229","26.820605"],["88.984724","26.833974"],["88.731159","27.080308"],["88.794435","27.331629"],["88.741186","27.914582"],["88.223484","27.953015"],["88.169108","27.50057"],["87.774017","27.262697"],["88.215457","26.870398"],["87.783036","26.535989"],["87.047344","26.702224"],["84.777332","27.310285"],["83.539214","27.665305"],["82.385985","27.880248"],["81.010299","28.662263"],["80.547568","29.001896"],["81.345045","30.304903"],["80.749935","31.185747"],["80.056967","31.015739"],["79.215234","31.178494"],["78.991224","31.346766"],["79.254658","31.656243"],["78.835019","31.979804"],["78.65109","32.12011"],["78.595912","32.240756"],["78.591313","32.400075"],["78.669483","32.54361"],["78.739513","32.426665"],["78.84424","32.288005"],["79.067657","32.24668"],["79.277111","32.470789"],["79.395802","32.676713"],["79.235221","33.233259"],["79.011803","33.47819"],["78.84424","33.681772"],["79.182009","34.336185"],["78.821102","34.565916"],["78.428537","34.758609"],["78.294895","34.940474"],["78.23791","35.530039"],["77.722544","35.628785"],["77.294994","35.609184"],["76.821489","35.701892"],["76.684572","35.988603"],["76.399329","35.919333"],["76.159724","35.933192"],["76.165429","36.20986"],["76.074151","36.366207"],["75.999987","36.641347"],["75.714744","36.787688"],["75.562518","36.805399"],["75.481245","36.811057"],["75.45651","36.950968"],["75.253968","37.023882"],["75.084541","37.066268"],["74.894884","37.084426"],["74.735572","37.122745"],["74.643309","37.074934"],["74.566145","37.033976"],["74.549925","36.938948"],["74.491692","37.015218"],["74.377803","36.998366"],["74.261908","36.915016"],["74.132106","36.91687"],["74.057933","36.840851"],["73.967535","36.853836"],["73.925813","36.892775"],["73.808039","36.908632"],["73.728388","36.920709"],["73.639124","36.911926"],["73.699986","36.820121"],["73.765904","36.814624"],["73.833196","36.776135"],["73.853795","36.743128"],["73.834569","36.711208"],["73.735692","36.736525"],["73.657414","36.707906"],["73.599736","36.711208"],["73.57227","36.735425"],["73.517339","36.729922"],["73.397862","36.757433"],["73.319585","36.738726"],["73.241307","36.720664"],["73.175389","36.732772"],["73.112218","36.71516"],["73.032567","36.686532"],["73.039433","36.651284"],["73.060033","36.609405"],["73.036687","36.564195"],["73.002355","36.529994"],["72.958409","36.507921"],["72.944676","36.475904"],["72.886998","36.474799"],["72.855412","36.448292"],["72.848546","36.400777"],["72.832334","36.374217"],["72.796629","36.362053"],["72.685258","36.303681"],["72.663286","36.274901"],["72.574022","36.267151"],["72.461412","36.175196"],["73.530389","35.809316"],["74.170542","35.420826"],["74.340245","35.055408"],["73.9237","34.612198"],["73.676858","34.332391"],["73.880481","33.422673"],["74.651862","32.906095"],["75.747223","32.542685"],["75.623802","32.256112"],["74.975842","31.968632"],["74.759855","31.732749"],["74.759855","30.955369"],["74.327882","30.584206"],["74.18929","30.224947"],["74.035013","29.864372"]],getOutseaData=function(t){return t&&"mapbox"===t?{boundsP16:[[CHN]],nebulaOutSea:[]}:{boundsP16:[[CHN],[JPN],[EAST]],nebulaOutSea:[[JPN],[EAST]]}},geoUtil=new GeometryUtilCls({}),CONSTS$1={sV:"https://webapi.amap.com/style_icon/sprite_v8@2x.png",EU:[LangConf.my.type,LangConf.km.type,LangConf.PU.type,LangConf.th.type,LangConf.$U.type]},MapboxLabelFormat=function(r){function t(t){var e=r.call(this)||this;return e.kQ={},e}return __extends(t,r),t.prototype.Ns=function(t,e){return r.prototype.Ns.call(this,t,e),this.rV(t,e)},t.prototype.rV=function(t,e){var r,n,i=(t.data||{}).poilabel||[],a=t.road||[],o={},s=this.hV(t);for(r in i)i.hasOwnProperty(r)&&(n=i[r],n=this.nV(n,s,e.zoom,e.VQ),o[r]=n);return this.oV(a,{}),o},t.prototype.nV=function(t,e,r,n){for(var i=[],a=this.kQ,o=0,s=t;o<s.length;o++){var u,c,f,h,l,d,v,g,p,m=(y=s[o]).name,b=y.position,T=y.id,A=y.minzoom,x=y.maxzoom,y=void 0===(y=y.style)?{}:y;"mapbox"!==n&&9<=r&&e&&!this.uV(b[0])||(u=y.lV,c=y.th,f=y.ih,d=y.nh,g=y.qU,v=y.eh,h=void 0===(h=y.textAnchor)?"bottom":h,l=y.rh,y.sh,p=y.Kr,y=y.Qr,A=[A,x],x=null,d&&g&&v&&(this.Fs[CONSTS$1.sV]=1,x=[{image:CONSTS$1.sV,size:[g[6]/2,g[7]/2],clipOrigin:[g[4],g[5]],clipSize:[g[6],g[7]]}]),d=null,m&&p&&(a[p]||(a[p]=Util.color2RgbaArray(p)),v=a[p],g=void 0,p=0,a[y]||(a[y]=Util.color2RgbaArray(y||"")),a[y]&&(g=a[y],p=3),y=this.fV(m)?[0,m.length]:[],this.Ws(m,y),d={txt:m,$G:y,direction:h||"center",offset:[0,0],style:{fontSize:l,fillColor:v,strokeColor:g,strokeWidth:p,fold:!1}}),y={data:{id:T,name:m,txt:m,position:b[0],positionType:"relative",zooms:[c,f],extData:{id:T,type:"poi"}},opts:{zIndex:u,zooms:A,visible:!0}},x&&(y.opts.icon=x),d&&(y.opts.text=d),(y.opts.text||y.opts.icon)&&i.push(y))}return i},t.prototype.oV=function(t,e){for(var r=0,n=t;r<n.length;r++){var i=n[r].name,a=this.fV(i)?[0,i.length]:[];i&&this.Ws(i,a)}},t.prototype.DQ=function(t,e){for(var r=[],n=0,i=t;n<i.length;n++){var o=(a=i[n]).path,s=a.name||"",u=labelsUtil.aQ(s.split("")),c=a.distance||1e5;a.style&&a.style[1];var f=void 0===(f=(a=a.style||{}).th)?zoomRange[0]:f,h=void 0===(h=a.ih)?zoomRange[1]:h,l=a.Kr,d=a.Qr,v=a.rh,g=a.zIndex,a=a.Hr;s&&o&&o.length&&r.push({path:o,positionType:"absolute",name:s,$G:[],CO:u,rank:g,BG:void 0===a?"name_en":a,distance:c,zooms:[f,h],style:{fontSize:v||12,fillColor:l,strokeColor:d}})}return r},t.prototype.fV=function(t){return t=LangManager.kU(t),-1!==CONSTS$1.EU.indexOf(t)},t.prototype.uV=function(t){for(var e=ProjectionManager.getProjection("EPSG:3857").unproject(t[0],t[1]),r=getOutseaData("mapbox").boundsP16,n=0;n<r.length;n++){var i=r[n];if(geoUtil.isPointInPolygon(e,i[0]))return!1}return!0},t.prototype.hV=function(t){return t=[[(t=t.Ro)[0],t[1]],[t[2],t[1]],[t[2],t[3]],[t[0],t[3]]],this.cV(t)},t.prototype.cV=function(t){for(var e=[],r=0;r<t.length;r++){var n=t[r],n=ProjectionManager.getProjection("EPSG:3857").unproject(n[0],n[1]);e.push(n)}for(var i=getOutseaData("mapbox").boundsP16,a=0;a<i.length;a++){var o=i[a];if(geoUtil.isRingInRingByMapboxB(e,o[0]))return!0}return!1},t.id="mapbox",t}(LabelFormat),Color=function(){function t(t){this.type="AMap.Color",this.rgba=[],this.Vb(t)}var e=t;return t.Wb=function(t,e){return{rgba:t.rgba}},t.Gb=function(t){return new e(t.rgba)},t.FV=function(t,e){var r=(t=this.DV(t[0],t[1],t[2],t[3]))[0],n=t[1],i=t[2],t=t[3];return this.GQ(r+=(.5<r?-.5:.5)*e*.35,n-=(n-.5)*e*.35*5,i-=(i-.5)*e*.35,t)},t.DV=function(t,e,r,n){var i,a,o,s=Math.max(t,e,r),u=Math.min(t,e,r),c=(s+u)/2;if(s===u)i=a=0;else{switch(o=s-u,a=.5<c?o/(2-s-u):o/(s+u),s){case t:i=(e-r)/o+(e<r?6:0);break;case e:i=(r-t)/o+2;break;case r:i=(t-e)/o+4}i/=6}return[i,a,c,n]},t.uQ=function(t,e,r){return r<0&&(r+=1),1<r&&--r,r<1/6?t+6*(e-t)*r:r<.5?e:r<2/3?t+(e-t)*(2/3-r)*6:t},t.GQ=function(t,e,r,n){var i,a,o;return 0===e?i=a=o=r:(i=this.uQ(e=2*r-(r=r<.5?r*(1+e):r+e-r*e),r,t+1/3),a=this.uQ(e,r,t),o=this.uQ(e,r,t-1/3)),[i,a,o,n]},t.Hb=function(t,e){void 0===e&&(e=[]);for(var r=0,n=t.length;r<n;r+=2)e[r/2]=parseInt(t.substr(r,2),16);return e},t.Yx=function(t){return t.startsWith("#")&&(t=t.substr(1)),colorNames[t]?e.Hb(colorNames[t].substr(1)):1===t.length?e.Hb(t+t+t+t+t+t):3===t.length?e.Hb(t[0]+t[0]+t[1]+t[1]+t[2]+t[2]):6===t.length?e.Hb(t):[0,0,0]},t.normalize=function(t){for(var e=[],r=0,n=t.length;r<n;r++)e[r]=t[r]/255;return e},t.create=function(t){return t?new e(t):null},t.prototype.normalize=function(){return[this.rgba[0]/255,this.rgba[1]/255,this.rgba[2]/255,this.rgba[3]/255]},t.prototype.Vb=function(t){"string"==typeof t?colorNames[t]?this.Hb(colorNames[t].substr(1)):0!==t.length&&(1===(t=t.startsWith("#")?t.substr(1):t).length?this.Hb(t+t+t+t+t+t):3===t.length?this.Hb(t[0]+t[0]+t[1]+t[1]+t[2]+t[2]):6===t.length?this.Hb(t):8===t.length?this.$b(t):t.startsWith("rgba(")?this.Yb(colorNames[t].substr(1)):t.startsWith("rgb(")&&this.Kb(colorNames[t].substr(1))):t instanceof Array&&(this.rgba[0]=t[0],this.rgba[1]=t[1],this.rgba[2]=t[2],this.rgba[3]=t[3]||255)},t.prototype.Hb=function(t){this.$b(t+"FF")},t.prototype.$b=function(t){for(var e=0,r=t.length;e<r;e+=2)this.rgba[e/2]=parseInt(t.substr(e,2),16)},t.prototype.Kb=function(t){t=t.split(","),this.rgba[0]=parseInt(t[0].substr(4),10),this.rgba[1]=parseInt(t[1],10),this.rgba[2]=parseInt(t[2],10),this.rgba[3]=255},t.prototype.Yb=function(t){t=t.split(","),this.rgba[0]=parseInt(t[0].substr(5),10),this.rgba[1]=parseInt(t[1],10),this.rgba[2]=parseInt(t[2],10),this.rgba[3]=255*parseFloat(t[3])<<0},e=__decorate([InnerClass("Color")],t)}(),colorNames={aliceblue:"#f0f8ff",antiquewhite:"#faebd7",aqua:"#00ffff",aquamarine:"#7fffd4",azure:"#f0ffff",beige:"#f5f5dc",bisque:"#ffe4c4",black:"#000000",blanchedalmond:"#ffebcd",blue:"#0000ff",blueviolet:"#8a2be2",brown:"#a52a2a",burlywood:"#deb887",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",cornflowerblue:"#6495ed",cornsilk:"#fff8dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkgray:"#a9a9a9",darkgreen:"#006400",darkkhaki:"#bdb76b",darkmagenta:"#8b008b",darkolivegreen:"#556b2f",darkorange:"#ff8c00",darkorchid:"#9932cc",darkred:"#8b0000",darksalmon:"#e9967a",darkseagreen:"#8fbc8f",darkslateblue:"#483d8b",darkslategray:"#2f4f4f",darkturquoise:"#00ced1",darkviolet:"#9400d3",deeppink:"#ff1493",deepskyblue:"#00bfff",dimgray:"#696969",dodgerblue:"#1e90ff",firebrick:"#b22222",floralwhite:"#fffaf0",forestgreen:"#228b22",fuchsia:"#ff00ff",gainsboro:"#dcdcdc",ghostwhite:"#f8f8ff",gold:"#ffd700",goldenrod:"#daa520",gray:"#808080",green:"#008000",greenyellow:"#adff2f",honeydew:"#f0fff0",hotpink:"#ff69b4",indianred:"#cd5c5c",indigo:"#4b0082",ivory:"#fffff0",khaki:"#f0e68c",lavender:"#e6e6fa",lavenderblush:"#fff0f5",lawngreen:"#7cfc00",lemonchiffon:"#fffacd",lightblue:"#add8e6",lightcoral:"#f08080",lightcyan:"#e0ffff",lightgoldenrodyellow:"#fafad2",lightgrey:"#d3d3d3",lightgreen:"#90ee90",lightpink:"#ffb6c1",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",lightskyblue:"#87cefa",lightslategray:"#778899",lightsteelblue:"#b0c4de",lightyellow:"#ffffe0",lime:"#00ff00",limegreen:"#32cd32",linen:"#faf0e6",magenta:"#ff00ff",maroon:"#800000",mediumaquamarine:"#66cdaa",mediumblue:"#0000cd",mediumorchid:"#ba55d3",mediumpurple:"#9370d8",mediumseagreen:"#3cb371",mediumslateblue:"#7b68ee",mediumspringgreen:"#00fa9a",mediumturquoise:"#48d1cc",mediumvioletred:"#c71585",midnightblue:"#191970",mintcream:"#f5fffa",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",navajowhite:"#ffdead",navy:"#000080",oldlace:"#fdf5e6",olive:"#808000",olivedrab:"#6b8e23",orange:"#ffa500",orangered:"#ff4500",orchid:"#da70d6",palegoldenrod:"#eee8aa",palegreen:"#98fb98",paleturquoise:"#afeeee",palevioletred:"#d87093",papayawhip:"#ffefd5",peachpuff:"#ffdab9",peru:"#cd853f",pink:"#ffc0cb",plum:"#dda0dd",powderblue:"#b0e0e6",purple:"#800080",rebeccapurple:"#663399",red:"#ff0000",rosybrown:"#bc8f8f",royalblue:"#4169e1",saddlebrown:"#8b4513",salmon:"#fa8072",sandybrown:"#f4a460",seagreen:"#2e8b57",seashell:"#fff5ee",sienna:"#a0522d",silver:"#c0c0c0",skyblue:"#87ceeb",slateblue:"#6a5acd",slategray:"#708090",snow:"#fffafa",springgreen:"#00ff7f",steelblue:"#4682b4",tan:"#d2b48c",teal:"#008080",thistle:"#d8bfd8",tomato:"#ff6347",turquoise:"#40e0d0",violet:"#ee82ee",wheat:"#f5deb3",white:"#ffffff",whitesmoke:"#f5f5f5",yellow:"#ffff00",yellowgreen:"#9acd32"},NebulaLabelFormat=function(r){function t(t){var e=r.call(this)||this;return e.bt=20,e.WW=20,e._opts={},e.uA={},e.vn=t.vn,e}return __extends(t,r),t.prototype.Ns=function(t,e){return e.lang&&(this.lang=e.lang),this._opts=e,this.bt=e.zoom,this.WW=e.ZL,this.rV(t,e.R_)},t.prototype.rV=function(t,e){var r,n,i=t.data||{},a=i.poilabel||[],o={},s=t.cQ;for(r in a)a.hasOwnProperty(r)&&(n=this.nV(a[r],{aV:t.zo.z<10,cQ:s,R_:e}),o[r]=n);return i=i.roadName||[],i=this.oV(i,{R_:e}),o.eA=i,o},t.prototype.nV=function(U,t){for(var e,r,n,i,a,o,s,u,c,f,h,l,d=CONSTS.Lj,j=d.file,F=d.size,R=CONSTS.Mp,D=CONSTS.Pp,B=CONSTS.jp,G=this._opts.scale,V=(t=void 0===t?{}:t).aV,v=t.cQ,z=this.bt,W=[],H=this.lang,q=!v&&5<=z,g=0,K=U;g<K.length;g++){var p=K[g],y=p.cw,m=p.ew,b=p.pos,T=(E=labelsUtil.tQ(p,H,q?t.R_:void 0)).name,Y=E.$G||[],A=p.rank,x=p.minzoom||R,M=(V?zoomRange[1]:p.maxzoom,p.Fp),S=p.Ep;if(3===x&&(x=2),(10002!==M||28!==S)&&(e=this.oA(M,S,this.WW))&&(r=1<G||9<e.fontSize?e.fontSize:9,o=e.iconFile,s=e.showMode,u=e.forceShow,c=e.zIndex,p=e.zooms,w=labelsUtil.Jj([x,zoomRange[1]],p))){for(var w,P=(w=labelsUtil.$p(w))[0],I=[],C={};P<=w[1];){var N=this.vn.dn(M,S,P);N&&"0"!==N.iconID&&(O=N.iconID,-1===I.indexOf(O)&&(I.push(O),C[O]=[]),C[O].push(P)),P++}(10002!==M||20!==S&&18!==S)&&16<r&&(r=15);for(var $,x=[w[0]-D,w[1]+B],k=(10002===M&&(13===S||18===S)&&x[0]<=3&&(x[0]=2.5),f=o&&"https"+j[o],p={data:{id:y?y+S:"",position:b,name:T,txt:T,rank:A,BG:E.type,extData:{Lp:M,Ap:S,id:y,type:"poi",bz:m}},opts:{type:"billboard",angle:0,forceShow:u,zIndex:c,visible:!0,zooms:x}},h=e.xOffset||0,l=e.yOffset||0,[]),b=void 0,A=[0,0],L=0;L<I.length;L++){var O=I[L],X=o&&this.aA(parseInt(O,10)),Z=F,_=labelsUtil.$p(C[O]),J=1;!T||"152"!==O&&"153"!==O&&"154"!==O||(J=T.length<=2?1:T.length/2),$=vector.Up(Z,2),f&&k.push({type:"image",image:f,clipOrigin:vector.add(X,[0,0]),clipSize:Z,size:[$[0]*J,$[1]],anchor:[10-20*h/24,10-20*l/24],angle:0,retina:!0,zooms:[_[0]-D,_[_.length-1]+B]})}T&&(A="曾母暗沙"===T?(b="top",[0,5]):k.length&&k[0].image?(O=I[0],v&&(b="bottom",A=[0,0]),"北京"===T?(b="top",[0,3]):"澳门"===T?(b="left",[0,-2]):"合肥"===T||"太原"===T||"西安"===T||"郑州"===T||"杭州"===T||"台北"===T||"加德满都"===T?(b="bottom",[0,-3]):10002!==M||31!==S&&32!==S&&34!==S&&5!==S?1===s||"152"!==O&&"153"!==O&&"154"!==O?(b="right",[0,-2]):(b="center",[0,-1]):(b="right",[-3,-3])):(b="center",[h,l]));var E=""+M+S;(y=this.uA[E])?(n=y.faceColor,i=y.borderColor,a=y.holoColor):(n=e.faceColor&&Color.normalize(e.faceColor.rgba),i=e.borderColor&&Color.normalize(e.borderColor.rgba),a=3===e.showMode?e.holoColor&&Color.normalize(e.holoColor.rgba):null,this.uA[E]={faceColor:n,borderColor:i,holoColor:a}),m=T?{direction:b,offset:A,$G:Y,style:{fontSize:r,strokeWidth:2,padding:[0,1,0,1],fold:!v&&5<=z}}:{},p.opts&&(p.opts.icon=k,p.opts.text=m),f&&(this.Fs[f]=1),T&&this.Ws(T,Y),W.push(p)}}return W},t.prototype.oV=function(t,e){for(var r=CONSTS.Lj,n=r.file,i=r.size,a=CONSTS.Mp,o=CONSTS.Rp,s=CONSTS.Pp,u=CONSTS.jp,c=[],f=this._opts.scale,h=this.lang,l=(e=void 0===e?{}:e)&&e.R_&&e.R_.protocol||"https",d=0,v=t;d<v.length;d++){var g,p,y=v[d],m=y.path,b=y.rank,T=y.minzoom||a,A=y.maxzoom||o,x=y.shield,M=y.shieldType,S=(y=labelsUtil.tQ(y,h)).name,w=y.$G;S&&this.Ws(S,w),!x||(w=Math.floor(m.length/2))<1||(m=[m[w-1],m[w]],(M=this.oA(40001,w=M,this.WW))&&(g=1<f||9<M.fontSize?M.fontSize:9,p=M.faceColor,M=M.iconID,m={data:{id:Util.stamp(this),position:m,positionType:"relative",name:S,txt:x,rank:b,BG:y.type,extData:{type:"shield",Lp:40001,Ap:w}},opts:{type:"billboard",angle:0,zooms:[T-s,A+u],visible:!0}},S=this.aA(parseInt(M,10)),b=1<x.length/4?x.length/4:1,y={type:"image",image:l+n[0],clipOrigin:S,clipSize:i,size:[24*(1<f?b:9*b/7),24],anchor:"center",angle:0,retina:!0},w=x?{direction:"center",offset:[0,0],style:{fontSize:g,fillColor:p&&Color.normalize(p.rgba),strokeWidth:0,padding:[0,1,0,1]}}:{},m.opts&&(m.opts.text=w,m.opts.icon=[y]),x&&this.Ws(x),c.push(m)))}return c},t.prototype.DQ=function(t,e){for(var r=CONSTS.Mp,n=CONSTS.Rp,i=CONSTS.Pp,a=CONSTS.jp,o=this.WW=e.zoom,s=0,u=[],c=this.lang,f=0,h=t;f<h.length;f++){var l,d,v,g,p,y,m,b,T,A,x,M=h[f],S=M.id,w=(l=labelsUtil.tQ(M,c)).name,P=l.$G||[];w&&(l=l.type,d=labelsUtil.EQ(w,P),d=labelsUtil.aQ(d),v=M.rank,g=M.Fp,p=M.Ep,s=M.distance||0,y=M.minzoom||r,m=M.maxzoom||n,b=(A=(A=this.vn.dn(g,p,o))&&A[1]||{}).fontSize,T=A.faceColor,A=A.borderColor,y=(x=labelsUtil.$p([y,m]))[0],m=20<=(m=x[1])?zoomRange[1]:m,w)&&S&&b&&T&&(x={id:S,positionType:"relative",name:w,$G:P,CO:d,rank:v,BG:l,distance:s,zooms:[y-i,m+a],path:0<M.path.length?M.path:void 0,style:{fontSize:b,fillColor:vector.Up(T.rgba,255),strokeColor:A&&vector.Up(A.rgba,255)},extData:{mainkey:g,subkey:p}},u.push(x))}return u},t.prototype.aA=function(t){var r=(e=CONSTS.Lj).Rj,e=e.size,n=Math.floor(t/r);return t%10==0&&--n,[(t-r*n-1)*e[0],n*e[1]]},t.prototype.oA=function(t,e,r){var n=[3,20],i=this.vn.dn(t,e,r),a=this.vn.mn(t,e);if(!i)for(var o=1;(n[0]<=r-o||r+o<=n[1])&&!(i=(i=this.vn.dn(t,e,r-o))||this.vn.dn(t,e,r+o));)o++;return i&&(i.zooms=a),i},t.prototype.mN=function(t,e){var r=[0,0];if("0"===t)switch(e){case"3":r=[6,6];break;case"4":case"5":case"6":r=[9,9]}return r},t.prototype.TN=function(t,e,r){var n=r=void 0===r?[0,0]:r;if("0"===t)switch(e){case"3":n=[30,30];break;case"4":case"5":case"6":n=[20,20]}return n},t.id=exports.n0.nebulaLabel,t}(LabelFormat),TileCoord=(function(t){t.TOLOAD="toload",t.LOADING="loading",t.LOADED="loaded",t.UNLOADED="unloaded",t.ERROR="error",t.RELOADING="reloading"}(exports.TileState||(exports.TileState={})),function(){function t(t,e,r){this.x=e,this.y=r,this.z=t,this.key=t+","+e+","+r}var n=t;return t.prototype.s0=function(t){var e=t-this.z,r=Math.floor(Math.pow(2,e)*this.x),e=Math.floor(Math.pow(2,e)*this.y);return new n(t,r,e)},n=__decorate([InnerClass("TileCoord")],t)}()),Tile=function(){function t(t){this.type="tile",this.Ro=[0,0,0,0],this.stamp=0,this.zo=t,this.status=exports.TileState.TOLOAD,this._v=null,this.data={}}return t.YH=function(t){return t.status===exports.TileState.LOADED||t.status===exports.TileState.RELOADING},t.prototype.destroy=function(){},t.prototype.nG=function(t){this.type=t},__decorate([InnerClass("Tile")],t)}(),NebulaTile=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.type="nebula",t.region="world",t.aN=exports.zB.NONE,t.BN=exports.zB.NONE,t}return __extends(t,e),Object.defineProperty(t.prototype,"tag",{get:function(){return this.nN},set:function(t){this.aN=this.tag,this.nN=t},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"gB",{get:function(){return this.VN},set:function(t){this.BN=this.gB,this.VN=t},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"data",{get:function(){var t=[];return this.qc&&this.qc.Dc?t.push(this.qc):(this.sN&&t.push(this.sN),this.uN&&t.push(this.uN)),this.lU&&this.lU.Dc?t.push(this.lU):(this.fU&&t.push(this.fU),this.cU&&t.push(this.cU)),this.zN&&this.zN.labels?t.push(this.zN):(this.HN&&t.push(this.HN),this.WN&&t.push(this.WN)),this.dU&&this.dU.labels?t.push(this.dU):(this.vU&&t.push(this.vU),this.gU&&t.push(this.gU)),t},set:function(t){},enumerable:!1,configurable:!0}),t.prototype.xa=function(t,e){if(void 0===e&&(e=exports.zB.ALL),Object.keys(t))switch(e){case exports.zB.LITE:this.uN=exports.Ln(exports.Ln({},this.uN),t);break;case exports.zB.LEFT:this.sN=exports.Ln(exports.Ln({},this.sN),t);break;default:exports.zB.ALL,this.qc=exports.Ln(exports.Ln({},this.qc),t)}},t.prototype.JE=function(t,e){if(void 0===e&&(e=exports.zB.ALL),Object.keys(t))switch(e){case exports.zB.LITE:this.cU=exports.Ln(exports.Ln({},this.cU),t);break;case exports.zB.LEFT:this.fU=exports.Ln(exports.Ln({},this.fU),t);break;default:exports.zB.ALL,this.lU=exports.Ln(exports.Ln({},this.lU),t)}},t.prototype.rO=function(t,e){if(void 0===e&&(e=exports.zB.ALL),Object.keys(t))switch(e){case exports.zB.LITE:this.WN=exports.Ln(exports.Ln({},this.WN),t);break;case exports.zB.LEFT:this.HN=exports.Ln(exports.Ln({},this.HN),t);break;default:exports.zB.ALL,this.zN=exports.Ln(exports.Ln({},this.zN),t)}},t.prototype.qE=function(t,e){if(void 0===e&&(e=exports.zB.ALL),Object.keys(t))switch(e){case exports.zB.LITE:this.gU=exports.Ln(exports.Ln({},this.gU),t);break;case exports.zB.LEFT:this.vU=exports.Ln(exports.Ln({},this.vU),t);break;default:exports.zB.ALL,this.dU=exports.Ln(exports.Ln({},this.dU),t)}},t.prototype.ID=function(t){t&&(t.uN&&(this.uN=t.uN),t.sN&&(this.sN=t.sN),t.qc&&(this.qc=t.qc),t.WN&&(this.WN=t.WN),t.HN&&(this.HN=t.HN),t.zN)&&(this.zN=t.zN)},t.prototype.rN=function(){this.aN?this.nN=this.aN:this.nN=exports.zB.NONE,this.BN&&(this.VN=this.BN,this.nN=exports.zB.NONE)},t.prototype.AB=function(){var t=[];return this.qc&&this.qc.road&&this.zN&&this.zN.labels?t.push(this.qc):(this.sN&&this.sN.road&&this.HN&&this.HN.labels&&t.push(this.sN),this.uN&&this.uN.road&&this.WN&&this.WN.labels&&t.push(this.uN)),t},t.prototype.LY=function(t,e){for(var r=0,n=this.data;r<n.length;r++){var i=n[r];i.Dc&&i.Dc.upload(t,!0),i.$c&&i.$c.upload(t,!0),i.A_&&i.A_.upload(t,!0),i.FD&&i.FD.upload(t,!0)}},t.prototype.destroy=function(){var t=this.data;if(t)for(var e=0,r=t;e<r.length;e++){var n=r[e];if(n.Dc&&(n.Dc.destroy(),delete n.Dc),n.$c&&(n.$c.destroy(),delete n.$c),n.labels){for(var i=0,a=n.labels;i<a.length;i++)a[i].destroy();delete n.labels}n.Ta=!1,delete n.gf}},t.prototype.KE=function(t){for(var e,r=this.data,n=[],i=0,a=t;i<a.length;i++)(o=a[i]).road&&n.push(o.road);for(var o,s=0,u=r;s<u.length;s++)(o=u[s]).XE&&(e=o.XE,this.pU(n,e))},t.prototype.reload=function(){delete this.lU,delete this.cU,delete this.fU,delete this.zN,delete this.WN,delete this.HN,delete this.VN,this.BN=exports.zB.NONE},t.prototype.pU=function(t,e){for(var r=0,n=e;r<n.length;r++){var i=n[r],a=i.id;if(i.path)break;for(var o=0,s=t;o<s.length;o++){var u=s[o];i.path=this.yU(u,a)}}},t.prototype.yU=function(t,e){for(var r=0,n=t;r<n.length;r++){var i=n[r];if(i.id===e)return i.path}},t.prototype.oN=function(){var t=this.qc;return!!(t=Object.keys(t||{})).length&&(1!==t.length||"sdfLoaded"!==t[0])},__decorate([InnerClass("NebulaTile")],t)}(Tile),RasterTile=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.type="raster",t}return __extends(t,e),t.prototype.destroy=function(){var t=this.data;t&&(t.texture&&(t.texture.destroy(),delete t.texture),t.zs&&(t.zs.context.deleteBuffer(t.zs),delete t.zs),t.Js)&&(t.Js.destroy(),delete t.Js)},t}(Tile),VectorTile=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.type="vector",t}return __extends(t,e),t.prototype.destroy=function(){var t=this.data;t&&(t.$c&&(t.$c.destroy(),delete t.$c),t.Uc)&&delete t.Uc},__decorate([InnerClass("VectorTile")],t)}(Tile);function quickselect(t,e,r,n,i){quickselectStep(t,e,r||0,n||t.length-1,i||defaultCompare)}function quickselectStep(t,e,r,n,i){for(;r<n;){600<n-r&&(a=n-r+1,o=e-r+1,u=Math.log(a),s=.5*Math.exp(2*u/3),u=.5*Math.sqrt(u*s*(a-s)/a)*(o-a/2<0?-1:1),quickselectStep(t,e,Math.max(r,Math.floor(e-o*s/a+u)),Math.min(n,Math.floor(e+(a-o)*s/a+u)),i));var a,o,s,u,c=t[e],f=r,h=n;for(swap(t,r,e),0<i(t[n],c)&&swap(t,r,n);f<h;){for(swap(t,f,h),f++,h--;i(t[f],c)<0;)f++;for(;0<i(t[h],c);)h--}0===i(t[r],c)?swap(t,r,h):swap(t,++h,n),h<=e&&(r=h+1),e<=h&&(n=h-1)}}function swap(t,e,r){var n=t[e];t[e]=t[r],t[r]=n}function defaultCompare(t,e){return t<e?-1:e<t?1:0}var _rbush_2_0_2_rbush=rbush,default_1=rbush,Status,M;function rbush(t,e){if(!(this instanceof rbush))return new rbush(t,e);this.Bc=Math.max(4,t||9),this.Wc=Math.max(2,Math.ceil(.4*this.Bc)),e&&this.Gc(e),this.clear()}function findItem(t,e,r){if(!r)return e.indexOf(t);for(var n=0;n<e.length;n++)if(r(t,e[n]))return n;return-1}function calcBBox(t,e){distBBox(t,0,t.children.length,e,t)}function distBBox(t,e,r,n,i){(i=i||createNode(null)).ja=1/0,i.Fa=1/0,i.Oa=-1/0,i.Ea=-1/0;for(var a,o=e;o<r;o++)a=t.children[o],extend$1(i,t.Zc?n(a):a);return i}function extend$1(t,e){t.ja=Math.min(t.ja,e.ja),t.Fa=Math.min(t.Fa,e.Fa),t.Oa=Math.max(t.Oa,e.Oa),t.Ea=Math.max(t.Ea,e.Ea)}function compareNodeMinX(t,e){return t.ja-e.ja}function compareNodeMinY(t,e){return t.Fa-e.Fa}function bboxArea(t){return(t.Oa-t.ja)*(t.Ea-t.Fa)}function bboxMargin(t){return t.Oa-t.ja+(t.Ea-t.Fa)}function enlargedArea(t,e){return(Math.max(e.Oa,t.Oa)-Math.min(e.ja,t.ja))*(Math.max(e.Ea,t.Ea)-Math.min(e.Fa,t.Fa))}function intersectionArea(t,e){var r=Math.max(t.ja,e.ja),n=Math.max(t.Fa,e.Fa),i=Math.min(t.Oa,e.Oa),t=Math.min(t.Ea,e.Ea);return Math.max(0,i-r)*Math.max(0,t-n)}function contains(t,e){return t.ja<=e.ja&&t.Fa<=e.Fa&&e.Oa<=t.Oa&&e.Ea<=t.Ea}function intersects(t,e){return e.ja<=t.Oa&&e.Fa<=t.Ea&&e.Oa>=t.ja&&e.Ea>=t.Fa}function createNode(t){return{children:t,height:1,Zc:!0,ja:1/0,Fa:1/0,Oa:-1/0,Ea:-1/0}}function multiSelect(t,e,r,n,i){for(var a,o=[e,r];o.length;)(r=o.pop())-(e=o.pop())<=n||(quickselect(t,a=e+Math.ceil((r-e)/n/2)*n,e,r,i),o.push(e,a,a,r))}function getModule(){return M=M||{nS:function(clsName,clsText){try{eval(clsText)}catch(e){throw e}},eS:{iS:"1699967635311",BY:!Browser.DW&&config[13]}},M}rbush.prototype={all:function(){return this.qc(this.data,[])},search:function(t){var e=this.data,r=[],n=this.Yc;if(intersects(t,e))for(var i,a,o,s,u=[];e;){for(i=0,a=e.children.length;i<a;i++)o=e.children[i],intersects(t,s=e.Zc?n(o):o)&&(e.Zc?r.push(o):contains(t,s)?this.qc(o,r):u.push(o));e=u.pop()}return r},Vc:function(t){var e=this.data,r=this.Yc;if(intersects(t,e))for(var n,i,a,o,s=[];e;){for(n=0,i=e.children.length;n<i;n++)if(a=e.children[n],intersects(t,o=e.Zc?r(a):a)){if(e.Zc||contains(t,o))return!0;s.push(a)}e=s.pop()}return!1},load:function(t){if(t&&t.length)if(t.length<this.Wc)for(var e=0,r=t.length;e<r;e++)this.Xc(t[e]);else{var n,i=this.Hc(t.slice(),0,t.length-1,0);this.data.children.length?this.data.height===i.height?this.Jc(this.data,i):(this.data.height<i.height&&(n=this.data,this.data=i,i=n),this.Kc(i,this.data.height-i.height-1,!0)):this.data=i}return this},Xc:function(t){return t&&this.Kc(t,this.data.height-1),this},clear:function(){return this.data=createNode([]),this},remove:function(t,e){if(t)for(var r,n,i,a,o=this.data,s=this.Yc(t),u=[],c=[];o||u.length;){if(o||(o=u.pop(),n=u[u.length-1],r=c.pop(),a=!0),o.Zc&&-1!==(i=findItem(t,o.children,e)))return o.children.splice(i,1),u.push(o),this.Qc(u),this;a||o.Zc||!contains(o,s)?n?(r++,o=n.children[r],a=!1):o=null:(u.push(o),c.push(r),o=(n=o).children[r=0])}return this},Yc:function(t){return t},tf:compareNodeMinX,if:compareNodeMinY,toJSON:function(){return this.data},ef:function(t){return this.data=t,this},qc:function(t,e){for(var r=[];t;)t.Zc?e.push.apply(e,t.children):r.push.apply(r,t.children),t=r.pop();return e},Hc:function(t,e,r,n){var i,a=r-e+1,o=this.Bc;if(a<=o)calcBBox(i=createNode(t.slice(e,r+1)),this.Yc);else{n||(n=Math.ceil(Math.log(a)/Math.log(o)),o=Math.ceil(a/Math.pow(o,n-1))),(i=createNode([])).Zc=!1,i.height=n;var s,u,c,f,h=Math.ceil(a/o),l=h*Math.ceil(Math.sqrt(o));for(multiSelect(t,e,r,l,this.tf),s=e;s<=r;s+=l)for(multiSelect(t,s,c=Math.min(s+l-1,r),h,this.if),u=s;u<=c;u+=h)f=Math.min(u+h-1,c),i.children.push(this.Hc(t,u,f,n-1));calcBBox(i,this.Yc)}return i},nf:function(t,e,r,n){for(var i,a,o,s,u,c,f,h;n.push(e),!e.Zc&&n.length-1!==r;){for(f=h=1/0,i=0,a=e.children.length;i<a;i++)u=bboxArea(o=e.children[i]),(c=enlargedArea(t,o)-u)<h?(h=c,f=u<f?u:f,s=o):c===h&&u<f&&(f=u,s=o);e=s||e.children[0]}return e},Kc:function(t,e,r){var n=this.Yc,r=r?t:n(t),i=[];for((n=this.nf(r,this.data,e,i)).children.push(t),extend$1(n,r);0<=e&&i[e].children.length>this.Bc;)this.af(i,e),e--;this.sf(r,i,e)},af:function(t,e){var r=t[e],n=r.children.length,i=this.Wc,i=(this.rf(r,i,n),this.hf(r,i,n));(n=createNode(r.children.splice(i,r.children.length-i))).height=r.height,n.Zc=r.Zc,calcBBox(r,this.Yc),calcBBox(n,this.Yc),e?t[e-1].children.push(n):this.Jc(r,n)},Jc:function(t,e){this.data=createNode([t,e]),this.data.height=t.height+1,this.data.Zc=!1,calcBBox(this.data,this.Yc)},hf:function(t,e,r){for(var n,i,a,o,s,u=o=1/0,c=e;c<=r-e;c++)i=intersectionArea(a=distBBox(t,0,c,this.Yc),n=distBBox(t,c,r,this.Yc)),a=bboxArea(a)+bboxArea(n),i<u?(u=i,s=c,o=a<o?a:o):i===u&&a<o&&(o=a,s=c);return s},rf:function(t,e,r){var n=t.Zc?this.tf:compareNodeMinX,i=t.Zc?this.if:compareNodeMinY;this.lf(t,e,r,n)<this.lf(t,e,r,i)&&t.children.sort(n)},lf:function(t,e,r,n){t.children.sort(n);for(var i,a=this.Yc,o=distBBox(t,0,e,a),s=distBBox(t,r-e,r,a),u=bboxMargin(o)+bboxMargin(s),c=e;c<r-e;c++)i=t.children[c],extend$1(o,t.Zc?a(i):i),u+=bboxMargin(o);for(c=r-e-1;e<=c;c--)i=t.children[c],extend$1(s,t.Zc?a(i):i),u+=bboxMargin(s);return u},sf:function(t,e,r){for(var n=r;0<=n;n--)extend$1(e[n],t)},Qc:function(t){for(var e,r=t.length-1;0<=r;r--)0===t[r].children.length?0<r?(e=t[r-1].children).splice(e.indexOf(t[r]),1):this.clear():calcBBox(t[r],this.Yc)},Gc:function(t){var e=["return a"," - b",";"];this.tf=new Function("a","b",e.join(t[0])),this.if=new Function("a","b",e.join(t[1])),this.Yc=new Function("a","return {minX: a"+t[0]+", minY: a"+t[1]+", maxX: a"+t[2]+", maxY: a"+t[3]+"};")}},_rbush_2_0_2_rbush.default=default_1,function(t){t.loading="loading",t.loaded="loaded"}(Status=Status||{});var M=getModule(),Queue=function(){function t(){this.tT={}}return t.prototype.add=function(t,e){for(var r=t.length,n=0,i=function(){(n+=1)===r&&e&&e()},a=0,o=t;a<o.length;a++){var s=o[a];this._add(s,i)}},t.prototype.has=function(t){return(t=this.tT[t])&&t.status===Status.loaded},t.prototype.finish=function(t){if(t=this.tT[t]){t.status=Status.loaded;for(var e=0,r=t.pI;e<r.length;e++){var n=r[e];n&&n()}}},t.prototype._add=function(t,e){var r=this.tT[t];r?r.status===Status.loading?r.pI.push(e):e():this.tT[t]={pI:[e],status:Status.loading}},t}(),Module=getModule();function InnerClass(e){return function(t){getModule()[e]=t}}getModule().MapboxLabelFormat=MapboxLabelFormat,getModule().NebulaLabelFormat=NebulaLabelFormat,getModule()._LocalZoom={Ra:13,za:12,Ge:""},getModule().Support=Browser,getModule().geo={lcs:lcs,ProjectionManager:ProjectionManager},getModule().transform=transform,getModule().Util=Util,getModule().TileState=exports.TileState,getModule().assign=assign,getModule().labelsUtil=labelsUtil,getModule().LabelsRenderUtil=LabelsRenderUtil,getModule().vector=vector,getModule().rbush=_rbush_2_0_2_rbush,getModule().lodash={map:map,find:find,assign:assign,every:every,some:some};var isSupportFloat32Array="undefined"!=typeof Float32Array,EPSILON=(isSupportFloat32Array||(window.Float32Array=void 0,setMatrixArrayType(Array)),1e-6),ARRAY_TYPE="undefined"!=typeof Float32Array?Float32Array:Array;function setMatrixArrayType(t){ARRAY_TYPE=t}function fromValues(t,e,r,n){var i=new ARRAY_TYPE(4);return i[0]=t,i[1]=e,i[2]=r,i[3]=n,i}function create(){var t=new ARRAY_TYPE(16);return ARRAY_TYPE!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0),t[0]=1,t[5]=1,t[10]=1,t[15]=1,t}function identity$1(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function invert(t,e){var r=e[0],n=e[1],i=e[2],a=e[3],o=e[4],s=e[5],u=e[6],c=e[7],f=e[8],h=e[9],l=e[10],d=e[11],v=e[12],g=e[13],p=e[14],y=r*s-n*o,m=r*u-i*o,b=r*c-a*o,T=n*u-i*s,A=n*c-a*s,x=i*c-a*u,M=f*g-h*v,S=f*p-l*v,w=f*(e=e[15])-d*v,P=h*p-l*g,I=h*e-d*g,C=l*e-d*p,N=y*C-m*I+b*P+T*w-A*S+x*M;return N?(t[0]=(s*C-u*I+c*P)*(N=1/N),t[1]=(i*I-n*C-a*P)*N,t[2]=(g*x-p*A+e*T)*N,t[3]=(l*A-h*x-d*T)*N,t[4]=(u*w-o*C-c*S)*N,t[5]=(r*C-i*w+a*S)*N,t[6]=(p*b-v*x-e*m)*N,t[7]=(f*x-l*b+d*m)*N,t[8]=(o*I-s*w+c*M)*N,t[9]=(n*w-r*I-a*M)*N,t[10]=(v*A-g*b+e*y)*N,t[11]=(h*b-f*A-d*y)*N,t[12]=(s*S-o*P-u*M)*N,t[13]=(r*P-n*S+i*M)*N,t[14]=(g*m-v*T-p*y)*N,t[15]=(f*T-h*m+l*y)*N,t):null}function multiply(t,e,r){var n=e[0],i=e[1],a=e[2],o=e[3],s=e[4],u=e[5],c=e[6],f=e[7],h=e[8],l=e[9],d=e[10],v=e[11],g=e[12],p=e[13],y=e[14],e=e[15],m=r[0],b=r[1],T=r[2],A=r[3];return t[0]=m*n+b*s+T*h+A*g,t[1]=m*i+b*u+T*l+A*p,t[2]=m*a+b*c+T*d+A*y,t[3]=m*o+b*f+T*v+A*e,m=r[4],b=r[5],T=r[6],A=r[7],t[4]=m*n+b*s+T*h+A*g,t[5]=m*i+b*u+T*l+A*p,t[6]=m*a+b*c+T*d+A*y,t[7]=m*o+b*f+T*v+A*e,m=r[8],b=r[9],T=r[10],A=r[11],t[8]=m*n+b*s+T*h+A*g,t[9]=m*i+b*u+T*l+A*p,t[10]=m*a+b*c+T*d+A*y,t[11]=m*o+b*f+T*v+A*e,m=r[12],b=r[13],T=r[14],A=r[15],t[12]=m*n+b*s+T*h+A*g,t[13]=m*i+b*u+T*l+A*p,t[14]=m*a+b*c+T*d+A*y,t[15]=m*o+b*f+T*v+A*e,t}function getTranslation(t,e){return t[0]=e[12],t[1]=e[13],t[2]=e[14],t}function perspective(t,e,r,n,i){return e=1/Math.tan(e/2),t[0]=e/r,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=e,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=-1,t[12]=0,t[13]=0,t[15]=0,null!=i&&i!==1/0?(t[10]=(i+n)*(r=1/(n-i)),t[14]=2*i*n*r):(t[10]=-1,t[14]=-2*n),t}function ortho(t,e,r,n,i,a,o){var s=1/(e-r),u=1/(n-i),c=1/(a-o);return t[0]=-2*s,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=-2*u,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=2*c,t[11]=0,t[12]=(e+r)*s,t[13]=(i+n)*u,t[14]=(o+a)*c,t[15]=1,t}function lookAt(t,e,r,n){var i,a,o,s,u=e[0],c=e[1],e=e[2],f=n[0],h=n[1],n=n[2],l=r[0],d=r[1],r=r[2];return Math.abs(u-l)<EPSILON&&Math.abs(c-d)<EPSILON&&Math.abs(e-r)<EPSILON?identity$1(t):(l=u-l,d=c-d,r=e-r,i=h*(r*=s=1/Math.hypot(l,d,r))-n*(d*=s),n=n*(l*=s)-f*r,f=f*d-h*l,(s=Math.hypot(i,n,f))?(i*=s=1/s,n*=s,f*=s):f=n=i=0,h=d*f-r*n,a=r*i-l*f,o=l*n-d*i,(s=Math.hypot(h,a,o))?(h*=s=1/s,a*=s,o*=s):o=a=h=0,t[0]=i,t[1]=h,t[2]=l,t[3]=0,t[4]=n,t[5]=a,t[6]=d,t[7]=0,t[8]=f,t[9]=o,t[10]=r,t[11]=0,t[12]=-(i*u+n*c+f*e),t[13]=-(h*u+a*c+o*e),t[14]=-(l*u+d*c+r*e),t[15]=1,t)}function equals(t,e){var r=t[0],n=t[1],i=t[2],a=t[3],o=t[4],s=t[5],u=t[6],c=t[7],f=t[8],h=t[9],l=t[10],d=t[11],v=t[12],g=t[13],p=t[14],t=t[15],y=e[0],m=e[1],b=e[2],T=e[3],A=e[4],x=e[5],M=e[6],S=e[7],w=e[8],P=e[9],I=e[10],C=e[11],N=e[12],$=e[13],k=e[14],e=e[15];return Math.abs(r-y)<=EPSILON*Math.max(1,Math.abs(r),Math.abs(y))&&Math.abs(n-m)<=EPSILON*Math.max(1,Math.abs(n),Math.abs(m))&&Math.abs(i-b)<=EPSILON*Math.max(1,Math.abs(i),Math.abs(b))&&Math.abs(a-T)<=EPSILON*Math.max(1,Math.abs(a),Math.abs(T))&&Math.abs(o-A)<=EPSILON*Math.max(1,Math.abs(o),Math.abs(A))&&Math.abs(s-x)<=EPSILON*Math.max(1,Math.abs(s),Math.abs(x))&&Math.abs(u-M)<=EPSILON*Math.max(1,Math.abs(u),Math.abs(M))&&Math.abs(c-S)<=EPSILON*Math.max(1,Math.abs(c),Math.abs(S))&&Math.abs(f-w)<=EPSILON*Math.max(1,Math.abs(f),Math.abs(w))&&Math.abs(h-P)<=EPSILON*Math.max(1,Math.abs(h),Math.abs(P))&&Math.abs(l-I)<=EPSILON*Math.max(1,Math.abs(l),Math.abs(I))&&Math.abs(d-C)<=EPSILON*Math.max(1,Math.abs(d),Math.abs(C))&&Math.abs(v-N)<=EPSILON*Math.max(1,Math.abs(v),Math.abs(N))&&Math.abs(g-$)<=EPSILON*Math.max(1,Math.abs(g),Math.abs($))&&Math.abs(p-k)<=EPSILON*Math.max(1,Math.abs(p),Math.abs(k))&&Math.abs(t-e)<=EPSILON*Math.max(1,Math.abs(t),Math.abs(e))}function create$1(){var t=new ARRAY_TYPE(3);return ARRAY_TYPE!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t}function fromValues$1(t,e,r){var n=new ARRAY_TYPE(3);return n[0]=t,n[1]=e,n[2]=r,n}function copy(t,e){t[0]=e[0],t[1]=e[1],t[2]=e[2]}function set(t,e,r,n){return t[0]=e,t[1]=r,t[2]=n,t}function subtract(t,e,r){return t[0]=e[0]-r[0],t[1]=e[1]-r[1],t[2]=e[2]-r[2],t}function cross(t,e,r){var n=e[0],i=e[1],e=e[2],a=r[0],o=r[1],r=r[2];t[0]=i*r-e*o,t[1]=e*a-n*r,t[2]=n*o-i*a}Math.hypot||(Math.hypot=function(){for(var t=0,e=arguments.length;e--;)t+=arguments[e]*arguments[e];return Math.sqrt(t)});var sub=subtract,forEach$1=function(){var u=create$1();return function(t,e,r,n,i,a){var o,s;for(e=e||3,r=r||0,s=n?Math.min(n*e+r,t.length):t.length,o=r;o<s;o+=e)u[0]=t[o],u[1]=t[o+1],u[2]=t[o+2],i(u,u,a),t[o]=u[0],t[o+1]=u[1],t[o+2]=u[2];return t}}();function create$2(){var t=new ARRAY_TYPE(4);return ARRAY_TYPE!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0,t[3]=0),t}function fromValues$2(t,e,r,n){var i=new ARRAY_TYPE(4);return i[0]=t,i[1]=e,i[2]=r,i[3]=n,i}function scale$1(t,e,r){return t[0]=e[0]*r,t[1]=e[1]*r,t[2]=e[2]*r,t[3]=e[3]*r,t}function transformMat4(t,e,r){var n=e[0],i=e[1],a=e[2],e=e[3];return t[0]=r[0]*n+r[4]*i+r[8]*a+r[12]*e,t[1]=r[1]*n+r[5]*i+r[9]*a+r[13]*e,t[2]=r[2]*n+r[6]*i+r[10]*a+r[14]*e,t[3]=r[3]*n+r[7]*i+r[11]*a+r[15]*e,t}var forEach$2=function(){var u=create$2();return function(t,e,r,n,i,a){var o,s;for(e=e||4,r=r||0,s=n?Math.min(n*e+r,t.length):t.length,o=r;o<s;o+=e)u[0]=t[o],u[1]=t[o+1],u[2]=t[o+2],u[3]=t[o+3],i(u,u,a),t[o]=u[0],t[o+1]=u[1],t[o+2]=u[2],t[o+3]=u[3];return t}}();function create$3(){var t=new ARRAY_TYPE(2);return ARRAY_TYPE!=Float32Array&&(t[0]=0,t[1]=0),t}function clone$1(t){var e=new ARRAY_TYPE(2);return e[0]=t[0],e[1]=t[1],e}function fromValues$3(t,e){var r=new ARRAY_TYPE(2);return r[0]=t,r[1]=e,r}function copy$1(t,e){t[0]=e[0],t[1]=e[1]}function set$1(t,e,r){return t[0]=e,t[1]=r,t}function add(t,e,r){t[0]=e[0]+r[0],t[1]=e[1]+r[1]}function subtract$1(t,e,r){return t[0]=e[0]-r[0],t[1]=e[1]-r[1],t}function multiply$1(t,e,r){return t[0]=e[0]*r[0],t[1]=e[1]*r[1],t}function scale$2(t,e,r){t[0]=e[0]*r,t[1]=e[1]*r}function distance(t,e){var r=e[0]-t[0],e=e[1]-t[1];return Math.hypot(r,e)}function negate(t,e){t[0]=-e[0],t[1]=-e[1]}function normalize(t,e){var r=e[0],n=e[1];0<(r=r*r+n*n)&&(r=1/Math.sqrt(r)),t[0]=e[0]*r,t[1]=e[1]*r}function dot(t,e){return t[0]*e[0]+t[1]*e[1]}function cross$1(t,e,r){e=e[0]*r[1]-e[1]*r[0],t[0]=t[1]=0,t[2]=e}function transformMat2(t,e,r){var n=e[0],e=e[1];t[0]=r[0]*n+r[2]*e,t[1]=r[1]*n+r[3]*e}function rotate(t,e,r,n){var i=e[0]-r[0],e=e[1]-r[1],a=Math.sin(n),n=Math.cos(n);t[0]=i*n-e*a+r[0],t[1]=i*a+e*n+r[1]}function angle(t,e){var r=t[0],t=t[1],n=e[0],i=r*r+t*t,a=n*n+(e=e[1])*e;return 1<(r=(r*n+t*e)*(0<i?1/Math.sqrt(i):i)*(0<a?1/Math.sqrt(a):a))?0:r<-1?Math.PI:Math.acos(r)}function equals$1(t,e){var r=t[0],t=t[1],n=e[0],e=e[1];return Math.abs(r-n)<=EPSILON*Math.max(1,Math.abs(r),Math.abs(n))&&Math.abs(t-e)<=EPSILON*Math.max(1,Math.abs(t),Math.abs(e))}var sub$1=subtract$1,mul=multiply$1,dist$1=distance,forEach$3=function(){var u=create$3();return function(t,e,r,n,i,a){var o,s;for(e=e||2,r=r||0,s=n?Math.min(n*e+r,t.length):t.length,o=r;o<s;o+=e)u[0]=t[o],u[1]=t[o+1],i(u,u,a),t[o]=u[0],t[o+1]=u[1];return t}}(),Event=function(){function t(){this.vI={}}return t.addListener=function(t,e,r){t.on(e,r)},t.trigger=function(t,e,r){t.emit(e,r)},t.clearListeners=function(t,e){t.clearEvents(e)},t.addDomListener=function(t,e,r){t.addEventListener(e,r)},t.extend=function(t,r,n){forEach(t="string"==typeof t?[t]:t,function(e){r.on(e,function(t){n.emit(e,t)})})},t.prototype.on=function(t,e,r,n){void 0===r&&(r=this),void 0===n&&(n=!1);for(var i=0,a=Array.isArray(t)?t:[t];i<a.length;i++){var o=a[i];this._on(o,e,r,n)}return this},t.prototype.off=function(t,e,r){void 0===r&&(r=this);var n=this.vI;if(t in n)for(var i=0;i<n[t].length;i+=1)if(n[t][i].fn===e&&n[t][i].context===r)return n[t].splice(i,1),this;return this},t.prototype.hasEvents=function(t,e,r){void 0===r&&(r=this);var n=this.vI;if(t&&e&&t in n)for(var i=0;i<n[t].length;i+=1)if(n[t][i].fn===e&&n[t][i].context===r)return!0;return!1},t.prototype.clearEvents=function(t){return t?this.vI[t]&&delete this.vI[t]:this.vI={},this},t.prototype.emit=function(t,e){if(void 0===e&&(e={}),t in this.vI){for(var r=exports.Ln(exports.Ln({},e),{type:t}),n=this.vI[t],i=0,a=n.length;i<a;i+=1){var o=n[i];o&&o.fn&&(o.fn.call(o.context,r),o.once)&&(this.vI[t].splice(i,1),--i,--a)}0===n.length&&delete this.vI[t]}return this},t.prototype.getEvents=function(){return this.vI},t.prototype._on=function(t,e,r,n){var i;return void 0===n&&(n=!1),this.hasEvents(t,e,r=void 0===r?this:r)||((i=this.vI)[t]=i[t]||[],i[t].push({fn:e,context:r||this,once:n})),this},t}(),NebulaTileCoord=function(){var o=[-180,-90],s=[180,90],u=s[0]-o[0],c=s[1]-o[1];return{ga:function(t,e,r,n){void 0===n&&(n="lnglat");var r=Math.pow(2,r),i=u/r,r=c/r,a=ProjectionManager.getProjection("EPSG:3857");return"lnglat"===n?[t*i+o[0],s[1]-e*r,(t+1)*i+o[0],s[1]-(e+1)*r]:"EPSG:3857"===n?(n=a.project(t*i+o[0],s[1]-e*r),a=a.project((t+1)*i+o[0],s[1]-(e+1)*r),[n[0],n[1],a[0],a[1]]):[0,0,0,0]}}}(),ComputeTileRange=function(){function t(){}return t.ha=function(t,e){for(var r=[t[0],t[3]],t=[t[2],t[1]],r=this.Ga(r,e),t=this.Ga(t,e),n=r[0],i=r[1],a=t[0],o=t[1],s=[],u=n;u<=a;u+=1)for(var c=i;c<=o;c+=1)s.push([e,u,c]);return s},t.Ga=function(t,e){var r=180/(e=Math.pow(2,e));return[Math.floor(t[0]/(360/e))+e/2,e/2-Math.ceil(t[1]/r)]},t.ra=function(t){return{2:3,3:3,4:3,5:3,6:6,7:6,8:8,9:8,10:10,11:10,12:10,13:12,14:12,15:14,16:14,17:14,18:14,19:14,20:14,21:14,22:14}[t]},t}(),Task=function(){function t(t){var r=this;this.xN=t,this.cancel=function(){r.xN&&r.xN.cancel();for(var t=0,e=r.children;t<e.length;t++)e[t].cancel.apply(r)},this.children=[]}return t.prototype._H=function(t){this.children.push(t)},t}(),LabelPlacement=function(){function t(t){this.options={},this.Gj={},this.Hj={},this.Vj={},this.Wj={},this.$j=0,this.render=null,this.NO={},this.ac=t.z_,this.Mf=t.R_,this.io=t.canvas,this.NT=t.Nz}return t.prototype.nO=function(t,e){this.iO=(e=void 0===e?{}:e).from||"inner",labelsUtil.zj(this,t),this.eO(e)},t.prototype.destroy=function(){},t.prototype.oO=function(){return this.gs.aO()},t.prototype.uO=function(){return this.oO().viewMode,!0},t.prototype.eO=function(t){var e,r,n,i,a,o=(t=void 0===t?{}:t).center,s=this.Gj||{},u=this.Vj||{},c=this.Hj||{},f=this.iO,h=0;for(e in s)s.hasOwnProperty(e)&&e&&(a=s[e]||{},c[e]=this.sO(e,a),u[e]=this.fO(e,a,c[e],{from:f,center:o}),r=a.data.txt,n=(i=a.opts).icon,i=i.text||{},a=a.CO,r&&a&&(h+=a.length+1,i.style)&&i.style.borderWidth&&(h+=4),n)&&n.length&&n[0].image&&(h+=n.length);this.$j=h,this.Vj=u,this.Hj=c},t.prototype.hO=function(t,e){var r=CONSTS.Mp,n=CONSTS.Rp,i=(t=void 0===t?[]:t)[0]||r,t=t[1]||n;return[(r=(e=void 0===e?[]:e)[0]||r)<i?i:r,t<(e=e[1]||n)?t:e]},t.prototype.cO=function(t,e){var r={};return r.type=(t=void 0===t?{}:t).type||e.type,r.image=t.image||"",r.clipOrigin=t.clipOrigin||e.clipOrigin,r.clipSize=t.clipSize,r.size=t.size,r.offset=t.offset,r.anchor=t.anchor||e.anchor,r.angel=t.angel||e.angel,r.retina=t.retina||e.retina,r.zooms=t.zooms||e.zooms,r},t.prototype.vO=function(t,e){var r={},e=(r.type=(t=void 0===t?{}:t).type||e.type,r.direction=t.direction||e.direction,r.offset=t.offset||e.offset,r.zooms=t.zooms||e.zooms,e.style),t=t.style||{},n=(r.style={},r.style.fontFamily=t.fontFamily||e.fontFamily,r.style.fontSize=t.fontSize||e.fontSize,r.style.fontWeight=t.fontWeight||e.fontWeight,r.style.fillColor=t.fillColor||e.fillColor,t.strokeColor),i=t.strokeWidth;return isUndefined(i)&&isUndefined(n)?r.style.strokeWidth=e.strokeWidth:isUndefined(i)&&!isUndefined(n)?r.style.strokeWidth=1:r.style.strokeWidth=t.strokeWidth,r.style.borderColor=t.borderColor,r.style.borderWidth=t.borderWidth,r.style.strokeColor=t.strokeColor||e.strokeColor,r.style.borderColor=t.borderColor||e.borderColor,r.style.backgroundColor=t.backgroundColor,r.style.padding=t.padding||e.padding,r.style.fold=void 0!==t.fold&&t.fold,r},t.prototype.lO=function(t){return[(t=(this.ac.Fs||{})[t]||{}).width||36,t.height||36]},t.prototype.dO=function(t,e){var r=CONSTS.sj,e=((r=this.cO(t,r.icon)).zooms=t.zooms||e.bO,this.hO(e.zooms,r.zooms));return r.zooms=e,r.size&&r.clipSize||(t=(e=this.lO(t.image||""))[0]||0,e=e[1]||0,r.size||(r.size=[t,e]),r.clipSize)||(r.clipSize=[t,e]),r},t.prototype.pO=function(t,e){var r=CONSTS.sj,t=((r=this.vO(t=void 0===t?{}:t,r.text)).zooms=t.zooms||e.bO,r.direction),n=e.yO,n=(t=this.mO(t||"",n)).textAlign,t=t.verticalAlign,n=(r.style&&(r.style.textAlign=n,r.style.verticalAlign=t),this.hO(e.zooms,r.zooms));return r.zooms=n,r},t.prototype.sO=function(t,e){var r=(r=e.data)&&r.txt,n=(e=e.opts||{}).angle||0,i=isUndefined(e.opacity)?1:e.opacity,a=e.icon,o=e.text,s=e.zooms,e=e.visible,u={angle:n,opacity:i,zooms:this.options.zooms,bO:s},c=[];if(a)for(var f=0,h=a;f<h.length;f++){var l=h[f];c.push(this.dO(l,u))}return u.yO=!!a,(n=r?this.pO(o,u):null)&&(n.txt=r),i={icon:c,text:n,visible:e},"labelsLayer"===this.iO&&(i.showText=1,i.showIcon=1),i},t.prototype.gO=function(t){var e;return this.oO().zoom<LocalZoom?t:(e=lcs.getLocalByCoord(t),vector.Ip(t,e.center))},t.prototype.wO=function(t,e){var r,n;return e&&e.image?(n=CONSTS.sj.icon,r=e.size||this.lO(e.image),e=e.anchor||n.anchor,{size:r,origin:t,anchorOffset:n=this._getAnchorOffset(r,e),coords:vector.add(t,n)}):{size:[0,0],origin:t,anchorOffset:[0,0],coords:t}},t.prototype.MO=function(t,e,r){var n,i,a,o,s,u;return"text"===(t=void 0===t?"icon":t)?(t=e.origin,e.start,o=r.padding,u=r.c,r=void 0,n=o.offsetX,i=o.offsetY,a=o.w,o=o.h,s=(this.uO()?(r=u[0],u):(r=t[0],t))[1],{x:r+n,y:s+i,width:a,height:o}):(t=e.size,e.coords,{x:(u=e.c)[0],y:u[1],width:(r=void 0===t?[]:t)[0]||0,height:r[1]||0})},t.prototype._getAnchorOffset=function(t,e){var r=CONSTS.JM,n=t[0]||0,i=t[1]||0;if("[object Array]"===Object.prototype.toString.apply(e)){var t=e[0],a=e[1];if("number"==typeof t&&"number"==typeof a)return vector.tA(e)}else if("string"==typeof e){var a=(t=e.split("-"))[0],e=t[1],o=0,s=0;switch(a!==r.ij||e||(a=r.nj,e=r.ij),e){case r.LEFT:o=0;break;case r.ij:o=-n/2;break;case r.QM:o=-n;break;default:o=0}switch(a){case r.ZM:s=0;break;case r.nj:s=-i/2;break;case r.tj:s=-i;break;default:s=0}return[o,s]}return[0,0]},t.prototype.jO=function(t){return this._getAnchorOffset(t.size||[0,0],"middle-center")},t.prototype.AO=function(t,e,r,n){var i,o=CONSTS.JM,u=void 0===(s=(n=void 0===n?{}:n).kO)?0:s,c=void 0!==(s=n.yO)&&s,s=n.padding,f=n.lines,h=(n=this.jO(t))[0]||0,n=n[1]||0,l=t.anchorOffset||[],d=l[0]||0,v=l[1]||0,g=(l=t.size||[])[0]||0,p=l[1]||0,y=d-h,m=v-n,b=s[0],T=s[1],A=s[2],x=s[3],M=.8*u;switch(r){case o.ZM:a=c?(i=y,v-A-.2*u-(S=M*f+3*(f-1))):(i=d+x,v+b);break;case o.QM:var S=M/2*f+1.5*(f-1),a=c?(i=d+g+x,m-S):(i=d-T,v-S-A);break;case o.tj:a=c?(i=y,v+p+b):(i=d+x,v-A-(S=M*f+3*(f-1)));break;case o.LEFT:S=M/2*f+1.5*(f-1);a=c?(i=d-T,m-S):(i=d+x,v-S-A);break;case o.nj:case o.ij:a=c?(i=d+g/2,m-(S=M/2*f+1.5*(f-1))):(i=d,v-(S=M/2*f+1.5*(f-1))-A);break;default:i=d,a=v-(S=M/2*f+1.5*(f-1))-A}return[i,a]},t.prototype.OO=function(t,e){var r,n,i=CONSTS.JM,a=(e=void 0===e?{}:e).xO,o=(e.kO,e.yO),s=e.direction,u=e.lines,c=e.size,f=(e.IO,t[0]||0),h=t[1]||0;switch(this.mO(s,o).textAlign){case i.LEFT:r=f,n=h;break;case i.QM:r=f-a,n=h;break;case i.ij:r=f-a/2,n=h}return{x:r,y:n,w:a,h:this.TO(c,u),FO:f,_O:h}},t.prototype.mO=function(t,e){var r,n,i=CONSTS.JM;if(e)switch(t){case i.LEFT:r=i.QM;break;case i.QM:r=i.LEFT;break;case i.ZM:case i.tj:default:r=i.ij,n=i.tj}else switch(t){case i.LEFT:case i.ij:case i.QM:r=t,n=i.tj;break;case i.ZM:case i.tj:case i.nj:default:r=i.LEFT,n=t}return{textAlign:r,verticalAlign:n}},t.prototype.TO=function(t,e){return void 0===t&&(t=12),(t*=5/4)*(e=void 0===e?1:e)+3*(e-1)},t.prototype.CT=function(t,e){return this.Mf?this.Mf.measureText(t,e):this.NT?(this.NT.font=(e||12)+"px",this.NT.measureText(t.join("")).width):0},t.prototype.SO=function(t,e,r){var n,i,a,o,s,u,c,f;return e&&r.txt?(n=(o=CONSTS.sj.text).direction,i=o.offset,o=o.style,c=r.yO,s=r.CO,n=e.direction||n,i=e.offset||i,a=(e=e.style||o).fontSize||12,f=e.padding||o.padding,e=!1===e.fold?100:o.fj,o=r.txt.length,r=(s=this.Mf.lineBreak(r.txt,{fontSize:a,CO:s,type:r.BG||"ch",fj:e,YQ:this.NT,from:r.from})).lines.length,u=this.TO(a,1),s={xO:s.maxWidth,kO:u,yO:c,direction:n,padding:f,fj:e,lines:r,size:a,IO:o},u=this.AO(t,t.size,n,s),c=vector.add(u,i),f=vector.add(t.origin,c),e=this.OO(f,s),{origin:t.origin,offset:c,coords:f,start:e}):{origin:t.origin,offset:[0,0],coords:t.coords,start:{}}},t.prototype.EO=function(t,e,r){if(!e||!r.txt)return{offsetX:0,offsetY:0,w:0,h:0};var n,i,a=CONSTS.JM,o=CONSTS.sj,s=(t.coords,t.start),u=(t=void 0===(t=t.offset)?[]:t)[0],c=t[1],f=s.w,t=s.h,s=r.yO,o=(r=o.text).direction,r=r.style,o=e.direction||o,h=(e=(e.style||r).padding||r.padding)[0],r=e[1],l=e[2],d=e[3];if(s)switch(o){case a.ZM:n=u-f/2-d,i=c-h;break;case a.QM:n=u-d,i=c-h;break;case a.tj:n=u-f/2-d,i=c-h;break;case a.LEFT:n=u-f-d,i=c-h;break;case a.nj:case a.ij:n=u-f/2-d,i=c-h;break;default:n=u-f/2-d,i=c+l}else switch(o){case a.ZM:n=u-d,i=c+l;break;case a.QM:n=u-f-d,i=c+l;break;case a.tj:case a.LEFT:n=u-d,i=c+l;break;case a.nj:case a.ij:n=u-f/2-d,i=c-h;break;default:n=u-f/2-d,i=c+l}return{offsetX:n,offsetY:i,w:f+d+r,h:t+h+l}},t.prototype.fO=function(t,e,r,n){var i=(n=void 0===n?{}:n).from,a=n.center,o=e.data,s=e.opts||{},u=o.position,c=o.txt,s=s.icon,r=r.text,e=e.CO,f=this.oO().zoom,f=(a[2]=a[2]||0,i="inner"!==i||"relative"!==o.positionType&&LocalZoom<=f?vector.Ip(u,a):u,vector.add(i,[0,0])),a=!!s;return{origin:i,icon:u=this.wO(f,s&&s[0]),text:f=this.SO(u,r,{CO:e,txt:c,yO:a,BG:o.BG,from:n.from}),padding:this.EO(f,r,{txt:c,yO:a})}},t}(),LabelGroup=function(){function t(){this.oT={},this.index=1}return t.prototype.nT=function(t){var e,r,n,i,a;return t?(e=t.fontSize,a=void 0===(a=t.fillColor)?CONSTS.COLOR.Uj:a,r=void 0===(r=t.strokeColor)?CONSTS.COLOR.Uj:r,n=t.strokeWidth,i=t.backgroundColor,t=t.borderColor,a=labelsUtil.toString(a)+labelsUtil.toString(r)+(i?labelsUtil.toString(i):""+(t?labelsUtil.toString(t):""))+e+n,this.AS(a),this.oT[a]):""},t.prototype.AS=function(t){this.oT[t]||(this.oT[t]=this.index++)},t}(),labelGroup=new LabelGroup,isSupportFloat64Array="undefined"!=typeof Float64Array,isSupportFloat32Array$1="undefined"!=typeof Float32Array,RESIZE_MULTIPLIER=(isSupportFloat64Array?setMatrixArrayType(Float64Array):isSupportFloat32Array$1?setMatrixArrayType(Float32Array):(window.Float32Array=void 0,setMatrixArrayType(Array)),2),DEFAULT_CAPACITY=128,StructArray=function(){function t(){this.pM=!1,this.yM=-1,this.length=0}return t.Wb=function(t,e){return t.trim(),e&&(t.pM=!0,e.push(t.arrayBuffer)),{length:t.length,arrayBuffer:t.arrayBuffer}},t.Gb=function(t){var e=Object.create(this.prototype);return e.arrayBuffer=t.arrayBuffer,e.length=t.length,e.yM=t.arrayBuffer.byteLength/this.Rb,e.mM(),e},t.prototype.trim=function(){this.length!==this.yM&&(this.yM=this.length,this.arrayBuffer=this.arrayBuffer.slice(0,this.length*this.constructor.Rb),this.mM())},t.prototype.resize=function(t){this.gM(t),this.length=t},t.prototype.gM=function(t){t>this.yM&&(this.yM=Math.max(t,Math.floor(this.yM*RESIZE_MULTIPLIER),DEFAULT_CAPACITY),t=this.wM,this.arrayBuffer=new ArrayBuffer(this.yM*this.constructor.Rb),this.mM(),t)&&this.wM.set(t)},t}(),FillArray=function(e){function t(){var t=e.call(this)||this;return t.pM=!1,t.resize(0),t}return __extends(t,e),t.prototype.kb=function(t,e){var r=this.length;this.resize(this.length+1),this.MM(r,t,e)},t.prototype.MM=function(t,e,r){this.Mb[t*=2]=e,this.Mb[1+t]=r},t.prototype.mM=function(){this.wM=new Uint8Array(this.arrayBuffer),this.Mb=new Float32Array(this.arrayBuffer)},t.Rb=8,t}(StructArray),FillExtrusionArray=function(e){function t(){var t=e.call(this)||this;return t.pM=!1,t.resize(0),t}return __extends(t,e),t.prototype.kb=function(t,e,r,n,i,a){var o=this.length;this.resize(o+1),this.MM(o,t,e,r,n,i,a)},t.prototype.MM=function(t,e,r,n,i,a,o){var s=8*t,e=(this.Mb[s]=e,this.Mb[1+s]=r,this.Mb[2+s]=n,this.Mb[3+s]=i,this.Mb[4+s]=a[0],this.Mb[5+s]=a[1],this.Mb[6+s]=a[2],16*t);this.jM[14+e]=o[0],this.jM[15+e]=o[1]},t.prototype.mM=function(){this.wM=new Uint8Array(this.arrayBuffer),this.Mb=new Float32Array(this.arrayBuffer),this.jM=new Uint16Array(this.arrayBuffer)},t.Rb=32,t}(StructArray),LinesIndexArray=function(e){function t(){var t=e.call(this)||this;return t.length=0,t.resize(0),t}return __extends(t,e),t.prototype.kb=function(t,e){var r=this.length;this.resize(this.length+1),this.MM(r,t,e)},t.prototype.MM=function(t,e,r){this.jM[t*=2]=e,this.jM[1+t]=r},t.prototype.mM=function(){this.wM=new Uint8Array(this.arrayBuffer),this.jM=new Uint16Array(this.arrayBuffer)},t.Rb=4,t}(StructArray),LinesIndexArrayUint=function(e){function t(){var t=e.call(this)||this;return t.length=0,t.resize(0),t}return __extends(t,e),t.prototype.kb=function(t,e){var r=this.length;this.resize(this.length+1),this.MM(r,t,e)},t.prototype.MM=function(t,e,r){this.UI[t*=2]=e,this.UI[1+t]=r},t.prototype.mM=function(){this.wM=new Uint8Array(this.arrayBuffer),this.UI=new Uint32Array(this.arrayBuffer)},t.Rb=8,t}(StructArray),LineArrayBuffer=function(e){function t(){var t=e.call(this)||this;return t.resize(0),t}return __extends(t,e),t.prototype.kb=function(t,e,r,n){var i=this.length;this.resize(i+1),this.MM(i,t,e,r,n)},t.prototype.MM=function(t,e,r,n,i){t*=this.constructor.Rb/4,this.Mb[t]=e[0],this.Mb[1+t]=e[1],this.Mb[2+t]=r[0],this.Mb[3+t]=r[1],this.Mb[4+t]=n,this.Mb[5+t]=i[0],this.Mb[6+t]=i[1]},t.prototype.mM=function(){this.wM=new Uint8Array(this.arrayBuffer),this.Mb=new Float32Array(this.arrayBuffer)},t.Rb=28,t}(StructArray),TriangleIndexArray=function(e){function t(){var t=e.call(this)||this;return t.resize(0),t}return __extends(t,e),t.prototype.kb=function(t,e,r){var n=this.length;this.resize(n+1),this.MM(n,t,e,r)},t.prototype.MM=function(t,e,r,n){this.jM[t*=3]=e,this.jM[1+t]=r,this.jM[2+t]=n},t.prototype.mM=function(){this.wM=new Uint8Array(this.arrayBuffer),this.jM=new Uint16Array(this.arrayBuffer)},t.Rb=6,t}(StructArray),TriangleIndexArrayUint=function(e){function t(){var t=e.call(this)||this;return t.resize(0),t}return __extends(t,e),t.prototype.kb=function(t,e,r){var n=this.length;this.resize(n+1),this.MM(n,t,e,r)},t.prototype.MM=function(t,e,r,n){this.UI[t*=3]=e,this.UI[1+t]=r,this.UI[2+t]=n},t.prototype.mM=function(){this.wM=new Uint8Array(this.arrayBuffer),this.UI=new Uint32Array(this.arrayBuffer)},t.Rb=12,t}(StructArray),SymbolArray=function(e){function t(){var t=e.call(this)||this;return t.pM=!1,t.resize(0),t}return __extends(t,e),t.prototype.kb=function(t,e,r){var n=this.length;this.resize(this.length+1),this.MM(n,t,e,r)},t.prototype.MM=function(t,e,r,n){var t=13*t,e=(this.Mb[t]=e,this.Mb[1+t]=r,n.color),r=n.borderColor,i=n.radius,a=n.borderWidth;this.Mb[2+t]=i,this.Mb[3+t]=a,this.Mb[4+t]=e[0],this.Mb[5+t]=e[1],this.Mb[6+t]=e[2],this.Mb[7+t]=e[3],this.Mb[8+t]=r[0],this.Mb[9+t]=r[1],this.Mb[10+t]=r[2],this.Mb[11+t]=r[3],this.Mb[12+t]=+(n.visible&&n.filter)},t.prototype.mM=function(){this.wM=new Uint8Array(this.arrayBuffer),this.Mb=new Float32Array(this.arrayBuffer)},t.Rb=52,t}(StructArray),SimpleSymbolArray=function(e){function t(){var t=e.call(this)||this;return t.pM=!1,t.resize(0),t}return __extends(t,e),t.prototype.kb=function(t,e){var r=this.length;this.resize(this.length+1),this.MM(r,t,e)},t.prototype.MM=function(t,e,r){this.Mb[t*=2]=e,this.Mb[1+t]=r},t.prototype.mM=function(){this.wM=new Uint8Array(this.arrayBuffer),this.Mb=new Float32Array(this.arrayBuffer)},t.Rb=4,t}(StructArray),SmartArrayBuffer=function(){function t(t,e,r,n){void 0===n&&(n="ARRAY_BUFFER"),this.AM=t,this.kM=r,this.type=n,t&&(this.buffer="ARRAY_BUFFER"===n?t.fe(e,r,"DYNAMIC_DRAW"):t.ve(e),this.uf=e.byteLength,this.byteLength=e.byteLength)}return t.prototype.update=function(t){var e,r,n;0!==t.length&&this.AM&&(e="ARRAY_BUFFER"===this.type,r=this.AM.gl,n=(e?this.AM.de:this.AM.me).current,(e?this.AM.de:this.AM.me).set(this.buffer),this.uf<t.byteLength?(r.bufferData(r[this.type],t,r.STATIC_DRAW),this.byteLength=t.byteLength,this.uf=t.byteLength):(r.bufferSubData(r[this.type],0,t),this.byteLength=t.byteLength),(e?this.AM.de:this.AM.me).set(n))},t.prototype.destroy=function(){this.buffer&&this.AM&&this.AM.deleteBuffer(this.buffer)},t.prototype.TX=function(){this.AM=null},__decorate([InnerClass("SmartArrayBuffer")],t)}(),COS_HALF_SHARP_CORNER=Math.cos(Math.PI/180*75),prepMatClockwise=fromValues(0,-1,1,0),perpMatCounterClockwise=fromValues(0,1,-1,0);function perpCounterClockwise(t,e){transformMat2(t,e,perpMatCounterClockwise)}function perpClockwise(t,e){transformMat2(t,e,prepMatClockwise)}var minRoundAngle=Math.PI/9,emptyVec2=create$3(),emptyVec3=create$1(),prevPos=create$3(),currentPos=create$3(),nextPos=create$3(),tmpPos=create$3(),currentNormal=create$3(),nextNormal=create$3(),distance$1=0,nextDir=create$3(),currentDir=create$3(),negateCurrentNormal=create$3(),lineJoin,lineCap,currentNormal_addLineVertex=create$3(),leftNormal=create$3(),rightNormal=create$3(),offsetLeft=create$3(),offsetRight=create$3(),joinNormal_addMiter=create$3(),tmp_addTiangleVertex=create$1(),currentNormal_addTiangleVertex=create$3(),nextNormal_addTiangleVertex=create$3(),normal_addTiangleVertex=create$3(),tmp_addRoundVertex=create$1(),currentNormal_addRoundVertex=create$3(),nextNormal_addRoundVertex=create$3(),tmpNormal_addRoundVertex=create$3(),roundCenter_addRoundVertex=create$3(),CoreLineBucket=function(){function h(){this._b=new LineArrayBuffer,this.e1=this.e2=this.e3=-1,this.uploaded=!1}return h.OM=function(t,e,r){sub$1(t,e,r),normalize(t,t),perpCounterClockwise(t,t)},h.xM=function(t,e,r){add(t,e,r),0===t[0]&&0===t[1]||normalize(t,t)},h.prototype.hb=function(t,e){if(t.length<4)return{Iw:0,distance:0};"auto"===(e=void(distance$1=0)===e?{X_:1,lineJoin:"miter",lineCap:"butt"}:e).lineJoin&&(e.lineJoin="miter"),lineJoin=e.lineJoin,lineCap=e.lineCap||"butt";for(var r,n=this.Qx.length,i=0,a=t.length;i<a;i+=2)0===i?(currentPos[0]=t[i],currentPos[1]=t[i+1],nextPos[0]=t[i+2],nextPos[1]=t[i+3],h.OM(nextNormal,nextPos,currentPos),copy$1(currentNormal,nextNormal),sub$1(nextDir,nextPos,currentPos),normalize(nextDir,nextDir),"square"===lineCap?this.IM(currentPos,currentNormal,nextNormal,distance$1,nextDir,!0,e.X_,"bevel"):("round"===lineCap&&(copy$1(negateCurrentNormal,currentNormal),negate(negateCurrentNormal,currentNormal),this.DI(currentPos,negateCurrentNormal,currentNormal,distance$1)),this.IM(currentPos,currentNormal,nextNormal,distance$1,nextDir,!0,0,"bevel")),copy$1(currentDir,nextDir),copy$1(prevPos,currentPos)):i===a-2?(currentPos[0]=t[i],currentPos[1]=t[i+1],r=dist$1(currentPos,prevPos),distance$1+=r,"square"===lineCap?this.IM(currentPos,currentNormal,nextNormal,distance$1,nextDir,!1,-1*e.X_,"miter"):"round"===lineCap?(this.IM(currentPos,currentNormal,nextNormal,distance$1,nextDir,!1,0,"miter"),copy$1(negateCurrentNormal,nextNormal),negate(negateCurrentNormal,nextNormal),this.DI(currentPos,nextNormal,negateCurrentNormal,distance$1)):this.IM(currentPos,currentNormal,nextNormal,distance$1,currentDir,!1,0,"miter")):(currentPos[0]=t[i],currentPos[1]=t[i+1],nextPos[0]=t[i+2],nextPos[1]=t[i+3],h.OM(nextNormal,nextPos,currentPos),0===nextNormal[0]&&0===nextNormal[1]||(r=dist$1(currentPos,prevPos),distance$1+=r,sub$1(nextDir,nextPos,currentPos),normalize(nextDir,nextDir),this.IM(currentPos,currentNormal,nextNormal,distance$1,currentDir,!1,0,e.lineJoin),this.IM(currentPos,currentNormal,nextNormal,distance$1,nextDir,!0,0,e.lineJoin),copy$1(prevPos,currentPos),copy$1(currentNormal,nextNormal),copy$1(currentDir,nextDir)));return{Iw:3*(this.Qx.length-n),distance:distance$1}},h.prototype.g0=function(t,e){if(t.length<2)return{Iw:0,distance:0};"auto"===(e=void(distance$1=0)===e?{X_:1,lineJoin:"miter",lineCap:"butt"}:e).lineJoin&&(e.lineJoin="miter"),lineJoin=e.lineJoin,lineCap=e.lineCap||"butt";for(var r,n=this.Qx.length,i=0,a=t.length;i<a;i++)0===i?(currentPos[0]=t[i][0],currentPos[1]=t[i][1],nextPos[0]=t[i+1][0],nextPos[1]=t[i+1][1],h.OM(nextNormal,nextPos,currentPos),copy$1(currentNormal,nextNormal),sub$1(nextDir,nextPos,currentPos),normalize(nextDir,nextDir),"square"===lineCap?this.IM(currentPos,currentNormal,nextNormal,distance$1,nextDir,!0,e.X_,"bevel"):("round"===lineCap&&(copy$1(negateCurrentNormal,currentNormal),negate(negateCurrentNormal,currentNormal),this.DI(currentPos,negateCurrentNormal,currentNormal,distance$1)),this.IM(currentPos,currentNormal,nextNormal,distance$1,nextDir,!0,0,"bevel")),copy$1(currentDir,nextDir),copy$1(prevPos,currentPos)):i===a-1?(currentPos[0]=t[i][0],currentPos[1]=t[i][1],r=dist$1(currentPos,prevPos),distance$1+=r,"square"===lineCap?this.IM(currentPos,currentNormal,nextNormal,distance$1,nextDir,!1,-1*e.X_,"miter"):"round"===lineCap?(this.IM(currentPos,currentNormal,nextNormal,distance$1,nextDir,!1,0,"miter"),copy$1(negateCurrentNormal,nextNormal),negate(negateCurrentNormal,nextNormal),this.DI(currentPos,nextNormal,negateCurrentNormal,distance$1)):this.IM(currentPos,currentNormal,nextNormal,distance$1,currentDir,!1,0,"miter")):(currentPos[0]=t[i][0],currentPos[1]=t[i][1],nextPos[0]=t[i+1][0],nextPos[1]=t[i+1][1],h.OM(nextNormal,nextPos,currentPos),0===nextNormal[0]&&0===nextNormal[1]||(r=dist$1(currentPos,prevPos),distance$1+=r,sub$1(nextDir,nextPos,currentPos),normalize(nextDir,nextDir),this.IM(currentPos,currentNormal,nextNormal,distance$1,currentDir,!1,0,e.lineJoin),this.IM(currentPos,currentNormal,nextNormal,distance$1,nextDir,!0,0,e.lineJoin),copy$1(prevPos,currentPos),copy$1(currentNormal,nextNormal),copy$1(currentDir,nextDir)));return{Iw:3*(this.Qx.length-n),distance:distance$1}},h.prototype.eD=function(t,e,r){if(void 0===r&&(r=3e3),t.length<4)return{Iw:0,distance:0};"auto"===(e=void(distance$1=0)===e?{X_:1,lineJoin:"miter",lineCap:"butt"}:e).lineJoin&&(e.lineJoin="miter"),lineJoin=e.lineJoin,lineCap=e.lineCap||"butt";for(var n=this.Qx.length,i=0,a=t.length;i<a;i+=2)if(0===i)currentPos[0]=t[i],currentPos[1]=t[i+1],nextPos[0]=t[i+2],nextPos[1]=t[i+3],h.OM(nextNormal,nextPos,currentPos),copy$1(currentNormal,nextNormal),sub$1(nextDir,nextPos,currentPos),normalize(nextDir,nextDir),"square"===lineCap?this.IM(currentPos,currentNormal,nextNormal,distance$1,nextDir,!0,e.X_,"bevel"):("round"===lineCap&&(copy$1(negateCurrentNormal,currentNormal),negate(negateCurrentNormal,currentNormal),this.DI(currentPos,negateCurrentNormal,currentNormal,distance$1)),this.IM(currentPos,currentNormal,nextNormal,distance$1,nextDir,!0,0,"bevel")),copy$1(currentDir,nextDir),copy$1(prevPos,currentPos);else if(i===a-2){tmpPos[0]=t[i],tmpPos[1]=t[i+1];var o=dist$1(tmpPos,prevPos);copy$1(tmpPos,prevPos);for(var s=0;r<o-s;)tmpPos[0]=tmpPos[0]+currentDir[0]*r,tmpPos[1]=tmpPos[1]+currentDir[1]*r,s+=r,this.IM(tmpPos,currentNormal,nextNormal,distance$1+s,currentDir,!1,0,"miter"),this.IM(tmpPos,currentNormal,nextNormal,distance$1+s,currentDir,!0,0,"miter");currentPos[0]=t[i],currentPos[1]=t[i+1],distance$1+=o,"square"===lineCap?this.IM(currentPos,currentNormal,nextNormal,distance$1,nextDir,!1,-1*e.X_,"miter"):"round"===lineCap?(this.IM(currentPos,currentNormal,nextNormal,distance$1,nextDir,!1,0,"miter"),copy$1(negateCurrentNormal,nextNormal),negate(negateCurrentNormal,nextNormal),this.DI(currentPos,nextNormal,negateCurrentNormal,distance$1)):this.IM(currentPos,currentNormal,nextNormal,distance$1,currentDir,!1,0,"miter")}else if(currentPos[0]=t[i],currentPos[1]=t[i+1],nextPos[0]=t[i+2],nextPos[1]=t[i+3],h.OM(nextNormal,nextPos,currentPos),0!==nextNormal[0]||0!==nextNormal[1]){var u=dist$1(currentPos,prevPos);for(copy$1(tmpPos,prevPos),s=0;r<u-s;)tmpPos[0]=tmpPos[0]+currentDir[0]*r,tmpPos[1]=tmpPos[1]+currentDir[1]*r,s+=r,this.IM(tmpPos,currentNormal,currentNormal,distance$1+s,currentDir,!1,0,"miter"),this.IM(tmpPos,currentNormal,currentNormal,distance$1+s,currentDir,!0,0,"miter");currentPos[0]=t[i],currentPos[1]=t[i+1],distance$1+=u,sub$1(nextDir,nextPos,currentPos),normalize(nextDir,nextDir),this.IM(currentPos,currentNormal,nextNormal,distance$1,currentDir,!1,0,e.lineJoin),this.IM(currentPos,currentNormal,nextNormal,distance$1,nextDir,!0,0,e.lineJoin),copy$1(prevPos,currentPos),copy$1(currentNormal,nextNormal),copy$1(currentDir,nextDir)}return{Iw:3*(this.Qx.length-n),distance:distance$1}},h.prototype.Nx=function(t,e){if(void 0===e&&(e={lineJoin:"miter"}),t.length<2)return{Iw:0,distance:0};for(var r,n,i=this.Qx.length,a=0,o=t.length;a<o;a++)0===a?(copy$1(currentPos,t[a]),r=t[a+1],n=t[o-2],h.OM(nextNormal,r,currentPos),h.OM(currentNormal,currentPos,n),sub$1(nextDir,r,currentPos),normalize(nextDir,nextDir),this.IM(currentPos,currentNormal,nextNormal,distance$1,nextDir,!0,0,e.lineJoin),copy$1(currentDir,nextDir),copy$1(currentNormal,nextNormal),copy$1(prevPos,currentPos)):a===o-1?(copy$1(currentPos,t[a]),copy$1(nextPos,t[1]),distance$1+=dist$1(currentPos,prevPos),h.OM(nextNormal,nextPos,currentPos),this.IM(currentPos,currentNormal,nextNormal,distance$1,currentDir,!1,0,e.lineJoin)):(copy$1(currentPos,t[a]),copy$1(nextPos,t[a+1]),distance$1+=dist$1(currentPos,prevPos),h.OM(nextNormal,nextPos,currentPos),sub$1(nextDir,nextPos,currentPos),normalize(nextDir,nextDir),this.IM(currentPos,currentNormal,nextNormal,distance$1,currentDir,!1,0,e.lineJoin),this.IM(currentPos,currentNormal,nextNormal,distance$1,nextDir,!0,0,e.lineJoin),copy$1(prevPos,currentPos),copy$1(currentNormal,nextNormal),copy$1(currentDir,nextDir));return{Iw:3*(this.Qx.length-i),distance:distance$1}},h.prototype.destroy=function(){this.uploaded=!1,this.zs&&(this.zs.destroy(),delete this.zs),this.Pc&&(this.Pc.destroy(),delete this.Pc)},h.prototype.IM=function(t,e,r,n,i,a,o,s){copy$1(joinNormal_addMiter,emptyVec2),h.xM(joinNormal_addMiter,e,r);var u=dot(joinNormal_addMiter,e),c=(scale$2(joinNormal_addMiter,joinNormal_addMiter,1/u),0),f=0;o&&(f=c=o),"bevel"===s||"miter"===s&&u<COS_HALF_SHARP_CORNER?a?this.SM(t,r,n,c,f,i):(this.SM(t,e,n,c,f,i),this.e3=this._b.length-2,this.e2=this.e3-1,this.e1=this.e2-1,this.Qx.kb(this.e1,this.e2,this.e3),this.e1=this.e2,this.e2=this.e3,this.e3=this.e3+1,this.Qx.kb(this.e1,this.e2,this.e3),this.CM(t,e,r,n)):"round"===s?a?this.SM(t,r,n,c,f,i):(this.SM(t,e,n,c,f,i),this.e3=this._b.length-2,this.e2=this.e3-1,this.e1=this.e2-1,this.Qx.kb(this.e1,this.e2,this.e3),this.e1=this.e2,this.e2=this.e3,this.e3=this.e3+1,this.Qx.kb(this.e1,this.e2,this.e3),this.DI(t,e,r,n)):(this.SM(t,joinNormal_addMiter,n,c,f,i),a||(this.e3=this._b.length-2,this.e2=this.e3-1,this.e1=this.e2-1,this.Qx.kb(this.e1,this.e2,this.e3),this.e1=this.e2,this.e2=this.e3,this.e3=this.e3+1,this.Qx.kb(this.e1,this.e2,this.e3)))},h.prototype.SM=function(t,e,r,n,i,a){copy$1(currentNormal_addLineVertex,e),copy$1(leftNormal,currentNormal_addLineVertex),copy$1(rightNormal,currentNormal_addLineVertex),copy$1(offsetLeft,emptyVec2),copy$1(offsetRight,emptyVec2),scale$2(rightNormal,currentNormal_addLineVertex,-1),n&&(perpCounterClockwise(offsetLeft,leftNormal),scale$2(offsetLeft,offsetLeft,n),add(leftNormal,offsetLeft,leftNormal)),i&&(perpClockwise(offsetRight,rightNormal),scale$2(offsetRight,offsetRight,i),add(rightNormal,offsetRight,rightNormal)),this._b.kb(t,leftNormal,r,a),this._b.kb(t,rightNormal,r,a)},h.prototype.CM=function(t,e,r,n){void 0===n&&(n=0),copy(tmp_addTiangleVertex,emptyVec3),copy$1(currentNormal_addTiangleVertex,e),copy$1(nextNormal_addTiangleVertex,r),copy$1(normal_addTiangleVertex,emptyVec2),cross$1(tmp_addTiangleVertex,currentNormal_addTiangleVertex,nextNormal_addTiangleVertex),e=0<tmp_addTiangleVertex[2],this._b.kb(t,normal_addTiangleVertex,n,normal_addTiangleVertex),e&&(negate(currentNormal_addTiangleVertex,currentNormal_addTiangleVertex),negate(nextNormal_addTiangleVertex,nextNormal_addTiangleVertex)),this._b.kb(t,currentNormal_addTiangleVertex,n,normal_addTiangleVertex),this._b.kb(t,nextNormal_addTiangleVertex,n,normal_addTiangleVertex),this.e3=this._b.length-1,this.e2=this.e3-1,this.e1=this.e2-1,this.Qx.kb(this.e1,this.e2,this.e3)},h.prototype.DI=function(t,e,r,n){void 0===n&&(n=0),copy(tmp_addRoundVertex,emptyVec3),copy$1(currentNormal_addRoundVertex,e),copy$1(nextNormal_addRoundVertex,r);var i=angle(currentNormal_addRoundVertex,nextNormal_addRoundVertex),a=(cross$1(tmp_addRoundVertex,currentNormal_addRoundVertex,nextNormal_addRoundVertex),0<tmp_addRoundVertex[2]),o=[];o.push(currentNormal_addRoundVertex);for(var s=minRoundAngle;s<i;s+=minRoundAngle){var u=create$3();rotate(u,currentNormal_addRoundVertex,fromValues$3(0,0),a?s:-1*s),o.push(u)}o.push(nextNormal_addRoundVertex),a&&forEach(o,function(t){negate(t,t)}),copy$1(roundCenter_addRoundVertex,emptyVec2),this._b.kb(t,roundCenter_addRoundVertex,n,roundCenter_addRoundVertex);var c=this._b.length-1;this._b.kb(t,o[0],n,roundCenter_addRoundVertex),this.e3=this._b.length-1,this.e2=this.e3-1;for(var f=1,h=o.length;f<h;f++)this._b.kb(t,o[f],n,roundCenter_addRoundVertex),this.e3=this._b.length-1,this.e2=this.e3-1,this.Qx.kb(c,this.e2,this.e3)},h}(),PolylineBucket=function(e){function t(){var t=e.call(this)||this;return t.Qx=new TriangleIndexArrayUint,t}return __extends(t,e),t.prototype.upload=function(t,e){void 0===e&&(e=!1),this.uploaded||(this.uploaded=!0,this.zs?this.zs.update(this._b.Mb):this.zs=new SmartArrayBuffer(t,this._b.Mb,LineArrayBuffer.Rb),this.Pc?this.Pc.update(this.Qx.UI):this.Pc=new SmartArrayBuffer(t,this.Qx.UI,32,"ELEMENT_ARRAY_BUFFER"),e&&(delete this.Qx,delete this._b))},t.prototype.reset=function(){this.uploaded=!1,this._b=new LineArrayBuffer,this.Qx=new TriangleIndexArrayUint,this.e1=this.e2=this.e3=-1,this.uploaded=!1},t}(CoreLineBucket),earcut_1=earcut,default_1$1=earcut;function earcut(t,e,r){r=r||2;var n,i,a,o,s,u=e&&e.length,c=u?e[0]*r:t.length,f=linkedList(t,0,c,r,!0),h=[];if(f&&f.next!==f.NM){if(u&&(f=eliminateHoles(t,e,f,r)),t.length>80*r){for(var l=n=t[0],d=i=t[1],v=r;v<c;v+=r)(a=t[v])<l&&(l=a),(o=t[v+1])<d&&(d=o),n<a&&(n=a),i<o&&(i=o);s=0!==(s=Math.max(n-l,i-d))?32767/s:0}earcutLinked(f,h,r,l,d,s,0)}return h}function linkedList(t,e,r,n,i){var a,o;if(i===0<signedArea(t,e,r,n))for(a=e;a<r;a+=n)o=insertNode(a,t[a],t[a+1],o);else for(a=r-n;e<=a;a-=n)o=insertNode(a,t[a],t[a+1],o);return o&&equals$2(o,o.next)&&(removeNode(o),o=o.next),o}function filterPoints(t,e){if(!t)return t;e=e||t;var r,n=t;do{if(r=!1,n.LM||!equals$2(n,n.next)&&0!==area(n.NM,n,n.next))n=n.next;else{if(removeNode(n),(n=e=n.NM)===n.next)break;r=!0}}while(r||n!==e);return e}function earcutLinked(t,e,r,n,i,a,o){if(t){!o&&a&&indexCurve(t,n,i,a);for(var s,u,c=t;t.NM!==t.next;)if(s=t.NM,u=t.next,a?isEarHashed(t,n,i,a):isEar(t))e.push(s.i/r|0),e.push(t.i/r|0),e.push(u.i/r|0),removeNode(t),t=u.next,c=u.next;else if((t=u)===c){o?1===o?earcutLinked(t=cureLocalIntersections(filterPoints(t),e,r),e,r,n,i,a,2):2===o&&splitEarcut(t,e,r,n,i,a):earcutLinked(filterPoints(t),e,r,n,i,a,1);break}}}function isEar(t){var e=t.NM,r=t;if(!(0<=area(e,r,t=t.next))){for(var n=e.x,i=r.x,a=t.x,o=e.y,s=r.y,u=t.y,c=n<i?n<a?n:a:i<a?i:a,f=o<s?o<u?o:u:s<u?s:u,h=i<n?a<n?n:a:a<i?i:a,l=s<o?u<o?o:u:u<s?s:u,d=t.next;d!==e;){if(d.x>=c&&d.x<=h&&d.y>=f&&d.y<=l&&pointInTriangle(n,o,i,s,a,u,d.x,d.y)&&0<=area(d.NM,d,d.next))return;d=d.next}return 1}}function isEarHashed(t,e,r,n){var i=t.NM,a=t,o=t.next;if(!(0<=area(i,a,o))){for(var s=i.x,u=a.x,c=o.x,f=i.y,h=a.y,l=o.y,d=s<u?s<c?s:c:u<c?u:c,v=f<h?f<l?f:l:h<l?h:l,g=u<s?c<s?s:c:c<u?u:c,p=h<f?l<f?f:l:l<h?h:l,y=zOrder(d,v,e,r,n),m=zOrder(g,p,e,r,n),b=t.DM,T=t.RM;b&&b.z>=y&&T&&T.z<=m;){if(b.x>=d&&b.x<=g&&b.y>=v&&b.y<=p&&b!==i&&b!==o&&pointInTriangle(s,f,u,h,c,l,b.x,b.y)&&0<=area(b.NM,b,b.next))return;if(b=b.DM,T.x>=d&&T.x<=g&&T.y>=v&&T.y<=p&&T!==i&&T!==o&&pointInTriangle(s,f,u,h,c,l,T.x,T.y)&&0<=area(T.NM,T,T.next))return;T=T.RM}for(;b&&b.z>=y;){if(b.x>=d&&b.x<=g&&b.y>=v&&b.y<=p&&b!==i&&b!==o&&pointInTriangle(s,f,u,h,c,l,b.x,b.y)&&0<=area(b.NM,b,b.next))return;b=b.DM}for(;T&&T.z<=m;){if(T.x>=d&&T.x<=g&&T.y>=v&&T.y<=p&&T!==i&&T!==o&&pointInTriangle(s,f,u,h,c,l,T.x,T.y)&&0<=area(T.NM,T,T.next))return;T=T.RM}return 1}}function cureLocalIntersections(t,e,r){var n=t;do{var i=n.NM,a=n.next.next}while(!equals$2(i,a)&&intersects$1(i,n,n.next,a)&&locallyInside(i,a)&&locallyInside(a,i)&&(e.push(i.i/r|0),e.push(n.i/r|0),e.push(a.i/r|0),removeNode(n),removeNode(n.next),n=t=a),(n=n.next)!==t);return filterPoints(n)}function splitEarcut(t,e,r,n,i,a){var o=t;do{for(var s,u=o.next.next;u!==o.NM;){if(o.i!==u.i&&isValidDiagonal(o,u))return s=splitPolygon(o,u),o=filterPoints(o,o.next),s=filterPoints(s,s.next),earcutLinked(o,e,r,n,i,a,0),earcutLinked(s,e,r,n,i,a,0);u=u.next}}while((o=o.next)!==t)}function eliminateHoles(t,e,r,n){for(var i,a=[],o=0,s=e.length;o<s;o++)(i=linkedList(t,e[o]*n,o<s-1?e[o+1]*n:t.length,n,!1))===i.next&&(i.LM=!0),a.push(getLeftmost(i));for(a.sort(compareX),o=0;o<a.length;o++)r=eliminateHole(a[o],r);return r}function compareX(t,e){return t.x-e.x}function eliminateHole(t,e){var r=findHoleBridge(t,e);return r?(filterPoints(t=splitPolygon(r,t),t.next),filterPoints(r,r.next)):e}function findHoleBridge(t,e){var r,n=e,i=t.x,a=t.y,o=-1/0;do{if(a<=n.y&&a>=n.next.y&&n.next.y!==n.y){var s=n.x+(a-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(s<=i&&o<s&&(r=n.x<n.next.x?n:n.next,(o=s)===i))return r}}while((n=n.next)!==e);if(!r)return null;for(var u,c=r,f=r.x,h=r.y,l=1/0,n=r;i>=n.x&&n.x>=f&&i!==n.x&&pointInTriangle(a<h?i:o,a,f,h,a<h?o:i,a,n.x,n.y)&&(u=Math.abs(a-n.y)/(i-n.x),locallyInside(n,t))&&(u<l||u===l&&(n.x>r.x||n.x===r.x&&sectorContainsSector(r,n)))&&(r=n,l=u),(n=n.next)!==c;);return r}function sectorContainsSector(t,e){return area(t.NM,t,e.NM)<0&&area(e.next,t,t.next)<0}function indexCurve(t,e,r,n){for(var i=t;0===i.z&&(i.z=zOrder(i.x,i.y,e,r,n)),i.DM=i.NM,i.RM=i.next,(i=i.next)!==t;);i.DM.RM=null,i.DM=null,sortLinked(i)}function sortLinked(t){var e,r,n,i,a,o,s,u,c=1;do{for(r=t,a=t=null,o=0;r;){for(o++,n=r,e=s=0;e<c&&(s++,n=n.RM);e++);for(u=c;0<s||0<u&&n;)0!==s&&(0===u||!n||r.z<=n.z)?(r=(i=r).RM,s--):(n=(i=n).RM,u--),a?a.RM=i:t=i,i.DM=a,a=i;r=n}}while(a.RM=null,c*=2,1<o)}function zOrder(t,e,r,n,i){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=(t-r)*i|0)|t<<8))|t<<4))|t<<2))|t<<1))|(1431655765&((e=858993459&((e=252645135&((e=16711935&((e=(e-n)*i|0)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function getLeftmost(t){for(var e=t,r=t;(e.x<r.x||e.x===r.x&&e.y<r.y)&&(r=e),(e=e.next)!==t;);return r}function pointInTriangle(t,e,r,n,i,a,o,s){return(t-o)*(a-s)<=(i-o)*(e-s)&&(r-o)*(e-s)<=(t-o)*(n-s)&&(i-o)*(n-s)<=(r-o)*(a-s)}function isValidDiagonal(t,e){return t.next.i!==e.i&&t.NM.i!==e.i&&!intersectsPolygon(t,e)&&(locallyInside(t,e)&&locallyInside(e,t)&&middleInside(t,e)&&(area(t.NM,t,e.NM)||area(t,e.NM,e))||equals$2(t,e)&&0<area(t.NM,t,t.next)&&0<area(e.NM,e,e.next))}function area(t,e,r){return(e.y-t.y)*(r.x-e.x)-(e.x-t.x)*(r.y-e.y)}function equals$2(t,e){return t.x===e.x&&t.y===e.y}function intersects$1(t,e,r,n){var i=sign(area(t,e,r)),a=sign(area(t,e,n)),o=sign(area(r,n,t)),s=sign(area(r,n,e));return i!==a&&o!==s||0===i&&onSegment(t,r,e)||0===a&&onSegment(t,n,e)||0===o&&onSegment(r,t,n)||0===s&&onSegment(r,e,n)}function onSegment(t,e,r){return e.x<=Math.max(t.x,r.x)&&e.x>=Math.min(t.x,r.x)&&e.y<=Math.max(t.y,r.y)&&e.y>=Math.min(t.y,r.y)}function sign(t){return 0<t?1:t<0?-1:0}function intersectsPolygon(t,e){var r=t;do{if(r.i!==t.i&&r.next.i!==t.i&&r.i!==e.i&&r.next.i!==e.i&&intersects$1(r,r.next,t,e))return 1}while((r=r.next)!==t)}function locallyInside(t,e){return area(t.NM,t,t.next)<0?0<=area(t,e,t.next)&&0<=area(t,t.NM,e):area(t,e,t.NM)<0||area(t,t.next,e)<0}function middleInside(t,e){for(var r=t,n=!1,i=(t.x+e.x)/2,a=(t.y+e.y)/2;r.y>a!=r.next.y>a&&r.next.y!==r.y&&i<(r.next.x-r.x)*(a-r.y)/(r.next.y-r.y)+r.x&&(n=!n),(r=r.next)!==t;);return n}function splitPolygon(t,e){var r=new Node(t.i,t.x,t.y),n=new Node(e.i,e.x,e.y),i=t.next,a=e.NM;return(t.next=e).NM=t,(r.next=i).NM=r,(n.next=r).NM=n,(a.next=n).NM=a,n}function insertNode(t,e,r,n){return t=new Node(t,e,r),n?(t.next=n.next,(t.NM=n).next.NM=t,n.next=t):(t.NM=t).next=t,t}function removeNode(t){t.next.NM=t.NM,t.NM.next=t.next,t.DM&&(t.DM.RM=t.RM),t.RM&&(t.RM.DM=t.DM)}function Node(t,e,r){this.i=t,this.x=e,this.y=r,this.NM=null,this.next=null,this.z=0,this.DM=null,this.RM=null,this.LM=!1}function signedArea(t,e,r,n){for(var i=0,a=e,o=r-n;a<r;a+=n)i+=(t[o]-t[a])*(t[a+1]+t[o+1]),o=a;return i}earcut.PM=function(t,e,r,n){var i=e&&e.length,a=i?e[0]*r:t.length,o=Math.abs(signedArea(t,0,a,r));if(i)for(var s=0,u=e.length;s<u;s++){var c=e[s]*r,f=s<u-1?e[s+1]*r:t.length;o-=Math.abs(signedArea(t,c,f,r))}for(var h=0,s=0;s<n.length;s+=3){var l=n[s]*r,d=n[s+1]*r,v=n[s+2]*r;h+=Math.abs((t[l]-t[v])*(t[1+d]-t[1+l])-(t[l]-t[d])*(t[1+v]-t[1+l]))}return 0===o&&0===h?0:Math.abs((h-o)/o)},earcut.UM=function(t){for(var e=t[0][0].length,r={rp:[],BM:[],dimensions:e},n=0,i=0;i<t.length;i++){for(var a=0;a<t[i].length;a++)for(var o=0;o<e;o++)r.rp.push(t[i][a][o]);0<i&&(n+=t[i-1].length,r.BM.push(n))}return r},earcut_1.default=default_1$1;var CoreFillBucket=function(){function t(){this._b=new FillArray,this.zM=new FillArray,this.uploaded=!1}return t.prototype.Nx=function(t,e){if(t.length<6)return 0;for(var r=this.Qx.length,n=this._b.length,i=earcut_1(t,e),a=0,o=i.length;a<o;a+=3)this.Qx.kb(n+i[a],n+i[a+1],n+i[a+2]);for(a=0,o=t.length;a<o;a+=2)this._b.kb(t[a],t[a+1]);return 0<(e=3*(this.Qx.length-r))&&(this.uploaded=!1),e},t.prototype.Ew=function(t){if(t.length<2)return 0;for(var e=this.qM.length,r=this.zM.length,n=0,i=t.length;n<i;n+=2)this.zM.kb(t[n][0],t[n][1]),this.zM.kb(t[n+1][0],t[n+1][1]),this.qM.kb(r+n,r+n+1);return 0<(e=2*(this.qM.length-e))&&(this.uploaded=!1),e},t.prototype.destroy=function(){this.uploaded=!1,this.zs&&(this.zs.context.deleteBuffer(this.zs),delete this.zs),this.Pc&&(this.Pc.context.deleteBuffer(this.Pc),delete this.Pc),this.Ec&&(this.Ec.context.deleteBuffer(this.Ec),delete this.Ec),this.Nc&&(this.Nc.context.deleteBuffer(this.Nc),delete this.Nc)},t}(),PolygonBucket=function(e){function t(){var t=e.call(this)||this;return t.Qx=new TriangleIndexArrayUint,t.qM=new LinesIndexArrayUint,t}return __extends(t,e),t.prototype.upload=function(t,e){void 0===e&&(e=!1),this.uploaded||(this.destroy(),this.uploaded=!0,this.zs=t.fe(this._b.Mb,FillArray.Rb),this.Pc=t.ve(this.Qx.UI),this.Ec=t.fe(this.zM.Mb,LinesIndexArray.Rb),this.Nc=t.ve(this.qM.UI),e&&(delete this.Qx,delete this._b,delete this.zM,delete this.qM))},t.prototype.reset=function(){this._b=new FillArray,this.zM=new FillArray,this.Qx=new TriangleIndexArrayUint,this.qM=new LinesIndexArrayUint,this.uploaded=!1},t}(CoreFillBucket),FaceTextureCoord={empty:fromValues$3(-1,-1),Gm:fromValues$3(1,1),qm:fromValues$3(0,1),Nm:fromValues$3(1,0),Um:fromValues$3(0,0)},MaxInfo={Gm:create$3(),qm:create$3(),Nm:create$3(),Um:create$3()},floorHeight=6,FillExtrusionBucket=function(){function t(){this._b=new FillExtrusionArray,this.uploaded=!1}return t.prototype.tz=function(t,e,r){void 0===e&&(e=100);for(var n=[],i=[],a=t.length,o=0;o<a;o+=2)i[s=o/2*3]=t[o],i[s+1]=t[o+1],i[s+2]=0;for(var s,o=0;o<a;o+=2)n[s=o/2*3]=t[o],n[s+1]=t[o+1],n[s+2]=e;return this.Nx(n,e,r)+this.RI(i,n,r)},t.prototype.RI=function(t,e,r){var n=e.length,i=e[2],a=this._b.length;t=t.concat(t.slice(0,3)),e=e.concat(e.slice(0,3));for(var o=0;o<n-3;o+=3){var s=Math.abs(t[o]-t[o+3]),u=Math.abs(t[o+1]-t[o+4]),c=Math.round(i),s=Math.round(Math.sqrt(Math.pow(s,2)+Math.pow(u,2))),s=(0<(u=fromValues$3(Math.ceil(s/floorHeight),Math.round(c/floorHeight)))[1]?(mul(MaxInfo.qm,FaceTextureCoord.qm,u),mul(MaxInfo.Gm,FaceTextureCoord.Gm,u),mul(MaxInfo.Um,FaceTextureCoord.Um,u),mul(MaxInfo.Nm,FaceTextureCoord.Nm,u)):(set$1(MaxInfo.qm,-1,-1),set$1(MaxInfo.Gm,-1,-1),set$1(MaxInfo.Um,-1,-1),set$1(MaxInfo.Nm,-1,-1)),this.zI(t.slice(o,o+3),t.slice(o+3,o+6),e.slice(o+3,o+6)));this._b.kb(t[o],t[o+1],t[o+2],i,s,MaxInfo.qm),this._b.kb(e[o+3],e[o+4],e[o+5],i,s,MaxInfo.Nm),this._b.kb(t[o+3],t[o+4],t[o+5],i,s,MaxInfo.Gm),this._b.kb(t[o],t[o+1],t[o+2],i,s,MaxInfo.qm),this._b.kb(e[o],e[o+1],e[o+2],i,s,MaxInfo.Um),this._b.kb(e[o+3],e[o+4],e[o+5],i,s,MaxInfo.Nm)}return 0<(a=this._b.length-a)&&(this.uploaded=!1),a},t.prototype.Nx=function(t,e,r){if(t.length<9)return 0;for(var n=this._b.length,i=earcut_1(t,r,3),a=i.length-1;0<=a;a--){var o=3*i[a];this._b.kb(t[o],t[1+o],t[2+o],e,fromValues$1(0,0,1),FaceTextureCoord.empty)}return 0<(r=this._b.length-n)&&(this.uploaded=!1),r},t.prototype.zI=function(t,e,r){var t=fromValues$1(t[0],t[1],t[2]),e=fromValues$1(e[0],e[1],e[2]),r=fromValues$1(r[0],r[1],r[2]),n=create$1(),i=create$1(),a=create$1();return sub(i,t,e),sub(a,r,e),cross(n,i,a),n},t.prototype.upload=function(t,e){void 0===e&&(e=!1),this.uploaded||(this.destroy(),this.uploaded=!0,this.zs=t.fe(this._b.Mb,FillExtrusionArray.Rb),e&&delete this._b)},t.prototype.destroy=function(){this.uploaded=!1,this.zs&&(this.zs.context.deleteBuffer(this.zs),delete this.zs),this.Pc&&(this.Pc.context.deleteBuffer(this.Pc),delete this.Pc)},t.prototype.reset=function(){this._b=new FillExtrusionArray,this.uploaded=!1},t}(),StyleParser=function(){function b(t){this.TY=t,this.CI=new AdaptorMap,this.Ve=null,this.RV=null,this.bN=null}return b.Wb=function(t){return{style:JSON.stringify(t.styles),TY:t.TY}},b.Gb=function(t){var e=new b(t.TY);return e.jY(JSON.parse(t.style)),e},b.mV=function(t){var e,r={};for(e in t)if(t.hasOwnProperty(e)){var n=t[e],i=void 0;switch(e[0]){case"1":i=b.Xe;break;case"2":i=b.rn,n.type="road";break;case"3":i=b.cn;break;case"4":i=b.un;break;case"5":i=b.ln,n.type="building"}if(i){for(var o=(a=n.key)[0],a=a[1],s=(void 0===r[o]&&(r[o]={}),(r[o][a]=n).browserStyle),u=0,c=s.length;u<c;u+=1){var f=s[u];if(s[u]=i(f),void 0===n.z)switch(e[0]){case"2":n.z=(s[u]?s[u][0]:n).z;break;case"1":case"3":case"4":case"5":n.z=s[u].z;break;default:n.z=-1}}b.Sn(n)}else delete t[e]}return r},b.$V=function(t){var e,r={};for(e in t)if(t.hasOwnProperty(e)){var n=t[e],i=void 0;switch(e[0]){case"1":i=b.Xe;break;case"2":i=b.rn,n.type="road";break;case"3":i=b.cn;break;case"4":i=b.un;break;case"5":i=b.ln,n.type="building"}if(i){for(var o=(a=e.split(":"))[0],a=a[1],s=(void 0===r[o]&&(r[o]={}),(r[o][a]=n).browserStyle),u=0,c=s.length;u<c;u+=1){var f=s[u];if(s[u]=i(f),void 0===n.z)switch(e[0]){case"2":n.z=(s[u]?s[u][0]:n).z;break;case"1":case"3":case"4":case"5":n.z=s[u].z;break;default:n.z=-1}}b.Sn(n)}else delete t[e]}return r},b.SZ=function(t){for(var e=t.stylemaps,r=e.length,n={},i=0;i<r;i++){for(var a=e[i],o=a.key[0],s=a.key[1],u={},c=(void 0===n[o]&&(n[o]={}),(n[o][s]=u).browserStyle=a.browserStyle,{}),f=a.levelStyleMapping.length,h=0;h<f;h+=2){var l=a.levelStyleMapping[h],d=a.levelStyleMapping[h+1];c[l]=d}u.levelStyleMapping=c;var v=void 0;switch(o[0]){case"1":v=b.Xe;break;case"2":v=b.rn,u.type="road";break;case"3":v=b.cn;break;case"4":v=b.un;break;case"5":v=b.ln,u.type="building"}for(var g=u.browserStyle,p=0,y=g.length;p<y;p+=1){var m=g[p];if(g[p]=v(m),void 0===u.z)switch(o[0]){case"2":u.z=(g[p]?g[p][0]:u).z;break;case"1":case"3":case"4":case"5":u.z=g[p].z;break;default:u.z=-1}}b.Sn(u)}return n},b.Je=function(t){var e;return t&&"0"!==t?(8===t.length&&(t=t.slice(2)+t.slice(0,2)),this.yQ&&this.yQ[t]?Color.create(this.yQ[t]):(e=Color.create(t),this.yQ||(this.yQ={}),this.yQ[t]||(this.yQ[t]=e.rgba.slice(0)),e)):null},b.Sn=function(t){if(void 0!==t.levelStyleMapping[3]&&(t.levelStyleMapping[2]=t.levelStyleMapping[3]),void 0!==t.levelStyleMapping[20]&&(t.levelStyleMapping[21]=t.levelStyleMapping[20],t.levelStyleMapping[22]=t.levelStyleMapping[20],t.levelStyleMapping[23]=t.levelStyleMapping[20],t.levelStyleMapping[24]=t.levelStyleMapping[20],t.levelStyleMapping[25]=t.levelStyleMapping[20],t.levelStyleMapping[26]=t.levelStyleMapping[20],t.levelStyleMapping[27]=t.levelStyleMapping[20],t.levelStyleMapping[28]=t.levelStyleMapping[20],t.levelStyleMapping[29]=t.levelStyleMapping[20],t.levelStyleMapping[30]=t.levelStyleMapping[20]),"building"===t.type&&t.levelStyleMapping&&(delete t.levelStyleMapping[15],delete t.levelStyleMapping[16]),"road"===t.type&&void 0!==t.levelStyleMapping[20]){var e=t.browserStyle,r=t.levelStyleMapping[20],n=e[r];if(n)for(var i=1;i<=10;i++){var a=[];a.push(exports.Ln({},n[0])),a.push(exports.Ln({},n[1])),a[0].roadWidth=a[0].roadWidth*Math.pow(2,i),a[0].borderWidth=a[0].borderWidth*Math.pow(2,i),t.browserStyle.push(a),t.levelStyleMapping[i+20]=r+i}}},b.prototype._Q=function(){return Boolean(this.styles)},b.prototype.jY=function(t){this.styles=t},b.prototype.clearStyleCache=function(){this.EI=-1,this.CI.clear()},b.prototype.setStyle=function(t){this.Ve=t,this.clearStyleCache()},b.prototype.EY=function(t){this.RV=t},b.prototype.MS=function(t){if(this.RV)return this.RV[t]},b.prototype.kF=function(t){this.bN=t},b.prototype.dn=function(t,e,r){if(this.styles)return this.SI(t,e,r)?this.CI.get((t<<16)+e):(r=this.jk(t,e,r)?this.Ak(t,e,r,this.Ve)||null:this.kk(t,e,r)||null,this.CI.set((t<<16)+e,r),r)},b.prototype.MF=function(t,e){var r=this.bN;if(!r||!r[t])return null;if(r[t].styles&&r[t].styles.color){var n,i,e=Util.getOptimalZoom(e),a={};for(n in r[t].styles.color.nodesObj)r[t].styles.color.nodesObj.hasOwnProperty(n)&&(a[(i=r[t].styles.color.nodesObj[n]).zoom]=i.value);return a[e=this._k(a,e)]?Util.Hex2Rgba(a[e]):null}return r[t].color?(e=r[t].color,Util.Hex2Rgba(e)):void 0},b.prototype.nX=function(t,e,r,n){var i=this.Ve;return i&&i[t]&&i[t][e]?(i=i[t][e]).styles&&i.styles[r]?(t=Util.getOptimalZoom(n),(n=this._k(i.styles[r].nodesObj,t))&&i.styles[r].nodesObj[n]?i.styles[r].nodesObj[n]:null):"visible"===r||i[r]&&(i.visible||"3"!==e)?i[r]:void 0:null},b.prototype.Ok=function(t,e,r){return void 0!==this.styles[t]&&(t=this.styles[t][e])&&void 0!==(e=t.levelStyleMapping[r])?t.browserStyle[e]:null},b.prototype.xk=function(t,e,r){if(void 0===this.styles[t])return null;if(void 0===this.styles[t][e])return null;if(void 0===this.styles[t][e].levelStyleMapping)return null;if(void 0===this.styles[t][e].browserStyle)return null;var n=this.styles[t][e].levelStyleMapping,t=this.styles[t][e].browserStyle,i=Math.floor(r);if(i===(e=Math.ceil(r)))return(a=t[n[i]])?(g=l=cloneDeep(a),l instanceof Array&&(g=l[0]),l):null;var a=r-i<.8?i:e,o=t[n[i]],t=t[n[e]];if((o||t)&&(o||a!==i)&&(!o||t||a!==e)&&(o||!t||i!==a)){if(!o&&t){for(var s,u,c=l=cloneDeep(t),f=(l instanceof Array&&(c=l[0]),Object.keys(c)),h=0;h<f.length;h++)-1<(d=f[h]).indexOf("Color")&&c[d]&&c[d].rgba?(u=(r-i-.8)/.2,s=Math.floor(c[d].rgba[3]*u),c[d].rgba[3]=s):-1<d.indexOf("Width")&&(c[d]=c[d]*(u=(r-i-.8)/.2));return l}if(o&&t){for(var l,d,v,g=l=cloneDeep(o),c=t,f=(l instanceof Array&&(g=l[0]),l instanceof Array&&(c=t[0]),Object.keys(g)),h=0;h<f.length;h++)-1<(d=f[h]).indexOf("Width")&&(v=(r-i)*(c[d]-g[d])+g[d],g[d]=v);return l}return o&&!t?(g=l=cloneDeep(o),l instanceof Array&&(g=l[0]),l):null}},b.prototype.Ik=function(t,e,r){var n=[];return n[0]=t[0]+(e[0]-t[0])*r,n[1]=t[1]+(e[1]-t[1])*r,n[2]=t[2]+(e[2]-t[2])*r,n[3]=t[3]+(e[3]-t[3])*r,n},b.prototype.kk=function(t,e,r){var n=t.toString()[0];return"1"===n||"4"===n?(n=Util.getOptimalZoom(r),this.Ok(t,e,n)):this.xk(t,e,r)},b.prototype.Ak=function(t,e,r,n){var i=r,a=n[t][e]||n[t].all,o=null;if(a.styles){var s=Util.getOptimalZoom(r);if(a.styles.visible&&(n=this._k(a.styles.visible.nodesObj,s))&&void 0!==(n=a.styles.visible.nodesObj[n])&&!1===n)return null;for(var u=(b=cloneDeep(this.styles[t][e])).levelStyleMapping,c=b.browserStyle,f=Object.keys(a.styles),h=0;h<f.length;h++){var l=f[h],d=a.styles[l],v=null;if(d.transitional&&"linear"===d.transitional){var g,p=this.Tk(d.nodesObj,r);if(!p||!p[0])continue;if(!(i=p[0]))continue;if(void 0===(g=u[s]))continue;o=c[g],1===p.length?v=d.nodesObj[i]:"color"===l&&(v=this.Fk(p,d.nodesObj,r))}else{if(!(i=this._k(d.nodesObj,s)))continue;if(void 0===(g=u[s]))continue;o=c[g],v=d.nodesObj[i]}if(!o)return null;var y=t.toString()[0],m=this.uP(a,s);if("1"===y){if(!m)return null;this.NI(l,v,o,t,e)}else"2"===y?(this.Sk(l,v,o),!m&&o&&o[1]&&(o[1]=null)):"4"===y?this.LI(l,v,o):this.Ck(l,v,o)}}else{if(void 0!==a.visible&&!1===a.visible)return null;if(void 0===(g=(u=this.styles[t][e].levelStyleMapping)[i=Util.getOptimalZoom(i)]))return null;if(!this.styles[t][e].browserStyle[g])return null;for(var b,o=(c=(b=cloneDeep(this.styles[t][e])).browserStyle)[g],f=Object.keys(a),m=this.uP(a,i),h=0;h<f.length;h++){if(l=f[h],!o)return null;if("1"===(y=t.toString()[0])){if(!m)return null;this.NI(l,a[l],o,t,e)}else"2"===y?(this.Sk(l,a[l],o),!m&&o&&o[1]&&(o[1]=null)):"4"===y?this.LI(l,a[l],o):this.Ck(l,a[l],o)}}return o},b.prototype.mn=function(t,e){return void 0===this.styles[t]?null:(t=this.styles[t][e])?(e=t.levelStyleMapping||{},t=Object.keys(e),[parseInt(t[0],10),parseInt(t[t.length-1],10)]):[]},b.prototype.Lw=function(t,e){return void 0!==this.styles[t]&&(t=this.styles[t][e])?t.z:null},b.prototype.mW=function(t,e,r){return 2===Math.floor(t/1e4)&&(t=this.xk(t,e,r))&&t[0]?(e=["butt","butt"],-1<(r=t[0]).roadStyle.indexOf("roundcap")?e[0]="round":-1<r.roadStyle.indexOf("squarecap")&&(e[0]="square"),-1<r.borderStyle.indexOf("roundcap")?e[1]="round":-1<r.borderStyle.indexOf("squarecap")&&(e[1]="square"),e):defaultCap},b.prototype.destroy=function(){this.styles&&(this.styles={})},b.prototype.uP=function(t,e){var r=!0;return t.styles&&t.styles.showLabel?(e=this._k(t.styles.showLabel.nodesObj,e),void 0!==(e=t.styles.showLabel.nodesObj[e])&&!1===e&&(r=!1)):void 0!==t.showLabel&&!1===t.showLabel&&(r=!1),r},b.prototype.SI=function(t,e,r){return r=this.TY?Math.floor(r):Math.floor(r*(16.8<=r?100:10)),this.EI!==r&&(this.EI=r,this.CI.clear()),this.CI.has((t<<16)+e)},b.prototype.jk=function(t,e,r){return!!this.Ve&&!!this.Ve[t]&&!(!this.Ve[t][e]&&!this.Ve[t].all||!this.styles||!this.styles[t]||!this.styles[t][e])},b.prototype.Fk=function(t,e,r){var n=Util.Hex2Rgba(e[t[0]]),e=Util.Hex2Rgba(e[t[1]]),r=(r-t[0])/(t[1]-t[0]);return[Math.floor(n[0]+r*(e[0]-n[0])),Math.floor(n[1]+r*(e[1]-n[1])),Math.floor(n[2]+r*(e[2]-n[2])),Math.floor(n[3]+r*(e[3]-n[3]))]},b.prototype.UV=function(t){for(var e={},r=0;r<t.length;r++){t[r];var n=t[r].zoom,i=t[r].value;e[n]=i}return e},b.prototype.Tk=function(t,e){var r=[];if(t[e])r.push(e);else{for(var n=!0,i=Math.floor(e);n&&0<i;){if(t[i]){r.push(i),n=!1;break}i--}for(i=Math.ceil(e),n=!0;n&&i<25;){if(t[i]){r.push(i),n=!1;break}i++}}return r},b.prototype._k=function(t,e){if(!t)return null;if(!isUndefined$1(t[e]))return e;for(var r=!0,n=e;r&&0<n;)if(t[--n]||!1===t[n]||""===t[n]){r=!1;break}if(!r)return n;for(n=e;r&&n<25;)if(t[++n]||!1===t[n]||""===t[n]){r=!1;break}return r?null:n},b.prototype.Ck=function(t,e,r){var n=null;switch(t){case"color":case"fillColor":n=e,Array.isArray(e)||(n=Util.Hex2Rgba(e)),r.faceColor||(r.faceColor=new Color(n)),r.faceColor.rgba=n;break;case"fontSize":r.fontSize=e;break;case"texture":r.texture=e?AMap.getConfig().protocol+"://"+e:"";break;case"backgroundColor":n=Util.Hex2Rgba(e),r.holoColor&&(r.holoColor.rgba=n);break;case"strokeColor":n=Util.Hex2Rgba(e),r.borderColor||(r.borderColor=new Color(n)),r.borderColor.rgba=n;break;case"showIcon":!1===e&&r.iconID&&(r.iconID="0")}},b.prototype.LI=function(t,e,r){var n=null;switch(t){case"textFillColor":n=e,Array.isArray(e)||(n=Util.Hex2Rgba(e)),r.faceColor||(r.faceColor=new Color(n)),r.faceColor.rgba=n;break;case"fontSize":r.fontSize=e;break;case"backgroundColor":n=Util.Hex2Rgba(e),r.holoColor&&(r.holoColor.rgba=n);break;case"textStrokeColor":n=Util.Hex2Rgba(e),r.borderColor||(r.borderColor=new Color(n)),r.borderColor.rgba=n;break;case"showIcon":!1===e&&r.iconID&&(r.iconID="0");break;case"showLabel":r.showText=e?1:0}},b.prototype.NI=function(t,e,r,n,i){var a=null;switch(t){case"showIcon":!1===e&&r.iconID&&(r.iconID="0");break;case"textFillColor":a=e,Array.isArray(e)||(a=Util.Hex2Rgba(e)),r.faceColor||(r.faceColor=new Color(a)),r.faceColor.rgba=a;break;case"fontSize":r.fontSize=e;break;case"backgroundColor":a=Util.Hex2Rgba(e),r.holoColor?r.holoColor.rgba=a:10002!==n||8!==i&&37!==i||(r.holoColor=new Color(a));break;case"textStrokeColor":a=Util.Hex2Rgba(e),r.borderColor||(r.borderColor=new Color(a)),r.borderColor.rgba=a;break;case"sel-highlight":r["sel-highlight"]=!0===e;break;case"sel-textFillColor":a=Util.Hex2Rgba(e),r["sel-textFillColor"]=map(a,function(t){return t/255});break;case"sel-textStrokeColor":a=Util.Hex2Rgba(e),r["sel-textStrokeColor"]=map(a,function(t){return t/255});break;case"label-bg":r["label-bg"]=!0===e;break;case"label-bgColor":a=Util.Hex2Rgba(e),r.holoColor?r.holoColor.rgba=a:10002!==n||8!==i&&37!==i||(r.holoColor=new Color(a));break;case"showLabel":r.showText=e?1:0}},b.prototype.Sk=function(t,e,r){var n,i=null;switch(t){case"color":case"fillColor":i=Util.Hex2Rgba(e),r[0]&&(r[0].roadColor||(r[0].roadColor=new Color(i)),r[0].roadColor.rgba=i);break;case"fillOpacity":r[0]&&r[0].roadColor&&r[0].roadColor.rgba&&(n=r[0].roadColor.rgba,i=Util.Opacity2Rgba(e,n),r[0].roadColor.rgba=i);break;case"fillWidth":r[0]&&(r[0].roadWidth=e);break;case"strokeColor":i=Util.Hex2Rgba(e),r[0]&&(r[0].borderColor||(r[0].borderColor=new Color(i)),r[0].borderColor.rgba=i);break;case"strokeWidth":r[0]&&(r[0].borderWidth=e);break;case"textFillColor":r[1]&&(i=Util.Hex2Rgba(e),r[1].faceColor||(r[1].faceColor=new Color(i)),r[1].faceColor.rgba=i);break;case"textStrokeColor":r[1]&&(i=Util.Hex2Rgba(e),r[1].borderColor||(r[1].borderColor=new Color(i)),r[1].borderColor.rgba=i);break;case"fontSize":r[1]&&(r[1].fontSize=e);break;case"showLabel":r.showText=e?1:0}},b.Xe=function(t){var t=t.split("&"),e={};return e.iconID=t[0],e.fontSize=parseInt(t[1],10),e.faceColor=b.Je(t[2]),e.borderColor=b.Je(t[3]),e.holoColor=b.Je(t[4]),e.showMode=parseInt(t[6],10),e.showText=2===e.showMode?0:1,e.forceShow=parseInt(t[7],10),e.clickEnable=parseInt(t[8],10),e.xOffset=parseInt(t[9],10),e.yOffset=parseInt(t[10],10),e.iconFile=t[5],e},b.rn=function(t){var e=(t=t.split("|"))[0].split("&"),r={},e=(t[0]?(r.roadWidth=parseInt(e[0],10),r.roadColor=b.Je(e[1]),r.roadStyle=e[2]||"",r.borderWidth=parseInt(e[3],10),r.borderColor=b.Je(e[4]),r.borderStyle=e[5]||"",r.z=parseInt(e[6],10),r.roadStyle&&r.roadStyle.indexOf&&(0===r.roadStyle.indexOf("dash")?(r.roadDash=r.roadStyle.substring(4).slice(1,-1).split(","),r.roadDash=map(r.roadDash,function(t){return parseInt(t,10)}),2===r.roadDash.length&&(e=r.roadDash).push.apply(e,r.roadDash)):0<r.roadStyle.indexOf("railway")||r.roadStyle.indexOf("dash_crewel")),r.borderStyle&&r.borderStyle.indexOf&&(0===r.borderStyle.indexOf("dash")?(r.borderDash=r.borderStyle.substring(4).slice(1,-1).split(","),r.borderDash=map(r.borderDash,function(t){return parseInt(t,10)}),2===r.borderDash.length&&(e=r.borderDash).push.apply(e,r.borderDash)):0<r.borderStyle.indexOf("railway")||r.borderStyle.indexOf("dash_crewel"))):(r.roadWidth=0,r.roadColor=b.Je("00000000"),r.roadStyle="",r.borderWidth=0,r.borderColor=b.Je("00000000"),r.borderStyle="",r.z=0),{});return t[1]&&(t=t[1].split("&"),e.iconID="",e.fontSize=parseInt(t[1],10),e.faceColor=b.Je(t[2]),e.borderColor=b.Je(t[3]),e.z=parseInt(t[4],10)),[r,e]},b.ln=function(t){var t=t.split("&"),e={};return e.faceColor=b.Je(t[0]),e.borderWidth=parseInt(t[1],10),e.borderColor=b.Je(t[2]),e.wallColor1=b.Je(t[3]),e.wallColor2=b.Je(t[4]),e.opacity=parseFloat(t[5]),e.z=parseInt(t[6],10),e},b.un=function(t){var t=t.split("&"),e={};return e.iconID=t[0],e.fontSize=parseInt(t[1],10),e.faceColor=b.Je(t[2]),e.borderColor=b.Je(t[3]),e.holoColor=null,e.z=parseInt(t[5],10),e},b.cn=function(t){var t=t.split("&"),e={};return e.faceColor=b.Je(t[0]),e.borderWidth=0,e.borderColor=null,e.z=parseInt(t[3],10),e},b}(),NebulaSegements=function(){function t(){this.jc=[],this.GM=-1,this.HM=-1,this.VM=0,this.WM=new LineSegement(-1,-1,-1,-1,-1)}return t.prototype.add=function(t,e,r,n,i,a,o,s){this.WM.eT(t,e,i,n)&&a===this.WM.bz&&o+""==this.WM.roofColor+""&&s+""==this.WM.wallColor+""||(this.GM=t,this.HM=e,this.VM+=this.WM?this.WM.length:0,this.WM=new LineSegement(t,e,this.VM,n,i,a,o,s),this.jc.push(this.WM)),this.WM.add(r)},t.prototype.reset=function(){this.WM=new LineSegement(-1,-1,-1,-1,-1)},t}(),LineSegement=function(){function t(t,e,r,n,i,a,o,s){this.mainkey=t,this.subkey=e,this.offset=r,this.minzoom=n,this.maxzoom=i,this.bz=a,this.roofColor=o,this.wallColor=s,this.length=0}return t.prototype.add=function(t){this.length+=t},t.prototype.eT=function(t,e,r,n){return this.mainkey===t&&this.subkey===e&&this.maxzoom===r&&this.minzoom===n},t}(),PolygonSegements=function(){function t(){this.jc=[],this.VM=0}return t.prototype.add=function(t){this.jc.push({length:t,offset:this.VM}),this.VM+=t},t.prototype.reset=function(){this.jc=[],this.VM=0},t.prototype.destroy=function(){this.jc&&0<this.jc.length&&(this.jc=[])},t}(),VectorTileFeature=function(t,e,r,n,i){this.properties={},this.extent=r,this.type=0,this.fA=t,this.hA=-1,this.cA=n,this.vA=i,t.nw(readFeature,this,e)};function readFeature(t,e,r){1===t?e.id=r.ow():2===t?readTag(r,e):3===t?e.type=r.ow():4===t&&(e.hA=r.pos)}function readTag(t,e){for(var r=t.ow()+t.pos;t.pos<r;){var n=e.cA[t.ow()],i=e.vA[t.ow()];e.properties[n]=i}}function classifyRings(t){var e=t.length;if(e<=1)return[t];for(var r,n=[],i=[],a=0;a<e;a++){var o=signedArea$1(t[a]);0!==o&&((r=void 0===r?o<0:r)===o<0?(i&&n.push(i),i=[t[a]]):i.push(t[a]))}return i&&n.push(i),n}function signedArea$1(t){for(var e,r,n=0,i=0,a=t.length,o=a-1;i<a;o=i++)e=t[i],n+=((r=t[o]).x-e.x)*(e.y+r.y);return n}VectorTileFeature.types=["Unknown","Point","LineString","Polygon"],VectorTileFeature.prototype.Dw=function(){for(var t,e=this.fA,r=(e.pos=this.hA,e.ow()+e.pos),n=1,i=0,a=0,o=0,s=[],u=[];e.pos<r;)if(i<=0&&(n=7&(t=e.ow()),i=t>>3),i--,1===n||2===n)a+=e.lA(),o+=e.lA(),1===n&&(u&&0<u.length&&s.push(u),u=[]),u.push([a,o]);else{if(7!==n)throw new Error("unknown command "+n);u&&u.push([u[0][0],u[0][1]])}return u&&0<u.length&&s.push(u),this.lines=s},VectorTileFeature.prototype.Ro=function(){for(var t,e=this.fA,r=(e.pos=this.hA,e.ow()+e.pos),n=1,i=0,a=0,o=0,s=1/0,u=-1/0,c=1/0,f=-1/0;e.pos<r;)if(i<=0&&(n=7&(t=e.ow()),i=t>>3),i--,1===n||2===n)(a+=e.lA())<s&&(s=a),u<a&&(u=a),(o+=e.lA())<c&&(c=o),f<o&&(f=o);else if(7!==n)throw new Error("unknown command "+n);return[s,c,u,f]},VectorTileFeature.prototype.dA=function(t,e,r){var n,i=this.extent*Math.pow(2,r),a=this.extent*t,o=this.extent*e,s=this.Dw(),r=VectorTileFeature.types[this.type];function u(t){for(var e=0;e<t.length;e++){var r=t[e],n=180-360*(r.y+o)/i;t[e]=[360*(r.x+a)/i-180,360/Math.PI*Math.atan(Math.exp(n*Math.PI/180))-90]}}switch(this.type){case 1:for(var c=[],f=0;f<s.length;f++)c[f]=s[f][0];u(s=c);break;case 2:for(f=0;f<s.length;f++)u(s[f]);break;case 3:for(s=classifyRings(s),f=0;f<s.length;f++)for(n=0;n<s[f].length;n++)u(s[f][n])}return 1===s.length?s=s[0]:r="Multi"+r,t={type:"Feature",geometry:{type:r,coordinates:s},properties:this.properties},"id"in this&&(t.id=this.id),t};var VectorTileLayer=function(t,e){this.version=1,this.name=null,this.extent=4096,this.length=0,this.fA=t,this.cA=[],this.vA=[],this.Cw=[],t.nw(readLayer,this,e),this.length=this.Cw.length};function readLayer(t,e,r){15===t?e.version=r.ow():1===t?e.name=r.aw():5===t?e.extent=r.ow():2===t?e.Cw.push(r.pos):3===t?e.cA.push(r.aw()):4===t&&e.vA.push(readValueMessage(r))}function readValueMessage(t){for(var e=null,r=t.ow()+t.pos;t.pos<r;)var n=t.ow()>>3,e=1==n?t.aw():2==n?t.pA():3==n?t.yA():4==n?t.mA():5==n?t.ow():6==n?t.lA():7==n?t.vw():null;return e}VectorTileLayer.prototype.Gw=function(t){if(t<0||t>=this.Cw.length)throw new Error("feature index out of bounds");return this.fA.pos=this.Cw[t],t=this.fA.ow()+this.fA.pos,new VectorTileFeature(this.fA,t,this.extent,this.cA,this.vA)};var VectorTile$1=function(t,e){this.type="vector",this.layers=t.nw(readTile,{},e)};function readTile(t,e,r){3===t&&(t=new VectorTileLayer(r,r.ow()+r.pos)).length&&(e[t.name]=t)}VectorTile$1.Wb=function(t){return t},VectorTile$1.Gb=function(t){return t},VectorTile$1.prototype.nG=function(t){this.type=t};var SHIFT_LEFT_32=4294967296,SHIFT_RIGHT_32=1/SHIFT_LEFT_32,Pbf=function(){function n(t){this.gA=ArrayBuffer.isView&&ArrayBuffer.isView(t)?t:new Uint8Array(t||0),this.pos=0,this.type=0,this.length=this.gA.length}return n.prototype.destroy=function(){this.gA=new Uint8Array(0)},n.prototype.nw=function(t,e,r){for(r=r||this.length;this.pos<r;){var n=this.ow(),i=n>>3,a=this.pos;this.type=7&n,t(i,e,this),this.pos===a&&this.wA(n)}return e},n.prototype.MA=function(t,e){return this.nw(t,e,this.ow()+this.pos)},n.prototype.jA=function(){var t=readUInt32(this.gA,this.pos);return this.pos+=4,t},n.prototype.AA=function(){var t=readInt32(this.gA,this.pos);return this.pos+=4,t},n.prototype.kA=function(){var t=readUInt32(this.gA,this.pos)+readUInt32(this.gA,this.pos+4)*SHIFT_LEFT_32;return this.pos+=8,t},n.prototype.OA=function(){var t=readUInt32(this.gA,this.pos)+readInt32(this.gA,this.pos+4)*SHIFT_LEFT_32;return this.pos+=8,t},n.prototype.pA=function(){var t=this.xA(this.gA,this.pos,!0,23,4);return this.pos+=4,t},n.prototype.yA=function(){var t=this.xA(this.gA,this.pos,!0,52,8);return this.pos+=8,t},n.prototype.ow=function(t){var e=this.gA,r=e[this.pos++],n=127&r;return r<128||(n|=(127&(r=e[this.pos++]))<<7,r<128)||(n|=(127&(r=e[this.pos++]))<<14,r<128)||(n|=(127&(r=e[this.pos++]))<<21,r<128)?n:readVarintRemainder(n|=(15&e[this.pos])<<28,t,this)},n.prototype.mA=function(){return this.ow(!0)},n.prototype.lA=function(){var t=this.ow();return t%2==1?(t+1)/-2:t/2},n.prototype.vw=function(){return Boolean(this.ow())},n.prototype.aw=function(){var t=this.ow()+this.pos,e=readUtf8(this.gA,this.pos,t);return this.pos=t,e},n.prototype.mw=function(){var t=this.ow()+this.pos,e=this.gA.subarray(this.pos,t);return this.pos=t,e},n.prototype.tw=function(t,e){var r=readPackedEnd(this);for(t=t||[];this.pos<r;)t.push(this.ow(e));return t},n.prototype.IA=function(t){var e=readPackedEnd(this);for(t=t||[];this.pos<e;)t.push(this.lA());return t},n.prototype.TA=function(t){var e=readPackedEnd(this);for(t=t||[];this.pos<e;)t.push(this.vw());return t},n.prototype.FA=function(t){var e=readPackedEnd(this);for(t=t||[];this.pos<e;)t.push(this.pA());return t},n.prototype._A=function(t){var e=readPackedEnd(this);for(t=t||[];this.pos<e;)t.push(this.yA());return t},n.prototype.SA=function(t){var e=readPackedEnd(this);for(t=t||[];this.pos<e;)t.push(this.jA());return t},n.prototype.CA=function(t){var e=readPackedEnd(this);for(t=t||[];this.pos<e;)t.push(this.AA());return t},n.prototype.EA=function(t){var e=readPackedEnd(this);for(t=t||[];this.pos<e;)t.push(this.kA());return t},n.prototype.NA=function(t){var e=readPackedEnd(this);for(t=t||[];this.pos<e;)t.push(this.OA());return t},n.prototype.wA=function(t){(t&=7)!==n.LA&&(t===n.DA?this.pos=this.ow()+this.pos:t===n.RA?this.pos+=4:t===n.PA?this.pos+=8:console.log("Unimplemented type: "+t))},n.prototype.UA=function(t,e){this.BA(t<<3|e)},n.prototype.zA=function(t){for(var e,r=this.length||16;r<this.pos+t;)r*=2;r!==this.length&&((e=new Uint8Array(r)).set(this.gA),this.gA=e,this.length=r)},n.prototype.finish=function(){return this.length=this.pos,this.pos=0,this.gA.subarray(0,this.length)},n.prototype.qA=function(t){this.zA(4),writeInt32(this.gA,t,this.pos),this.pos+=4},n.prototype.WA=function(t){this.zA(4),writeInt32(this.gA,t,this.pos),this.pos+=4},n.prototype.GA=function(t){this.zA(8),writeInt32(this.gA,-1&t,this.pos),writeInt32(this.gA,Math.floor(t*SHIFT_RIGHT_32),this.pos+4),this.pos+=8},n.prototype.HA=function(t){this.zA(8),writeInt32(this.gA,-1&t,this.pos),writeInt32(this.gA,Math.floor(t*SHIFT_RIGHT_32),this.pos+4),this.pos+=8},n.prototype.BA=function(t){268435455<(t=+t||0)||t<0?writeBigVarint(t,this):(this.zA(4),this.gA[this.pos++]=127&t|(127<t?128:0),t<=127||(this.gA[this.pos++]=127&(t>>>=7)|(127<t?128:0),t<=127)||(this.gA[this.pos++]=127&(t>>>=7)|(127<t?128:0),t<=127)||(this.gA[this.pos++]=t>>>7&127))},n.prototype.VA=function(t){this.BA(t<0?2*-t-1:2*t)},n.prototype.$A=function(t){this.BA(Boolean(t))},n.prototype.YA=function(t){t=String(t),this.zA(4*t.length),this.pos++;var e=this.pos;this.pos=writeUtf8(this.gA,t,this.pos),128<=(t=this.pos-e)&&makeRoomForExtraLength(e,t,this),this.pos=e-1,this.BA(t),this.pos+=t},n.prototype.KA=function(t){this.zA(4),this.XA(this.gA,t,this.pos,!0,23,4),this.pos+=4},n.prototype.JA=function(t){this.zA(8),this.XA(this.gA,t,this.pos,!0,52,8),this.pos+=8},n.prototype.ZA=function(t){var e=t.length;this.BA(e),this.zA(e);for(var r=0;r<e;r++)this.gA[this.pos++]=t[r]},n.prototype.QA=function(t,e){this.pos++;var r=this.pos;t(e,this),128<=(t=this.pos-r)&&makeRoomForExtraLength(r,t,this),this.pos=r-1,this.BA(t),this.pos+=t},n.prototype.fw=function(t,e,r){this.UA(t,n.DA),this.QA(e,r)},n.prototype.tk=function(t,e){this.fw(t,writePackedVarint,e)},n.prototype.rk=function(t,e){this.fw(t,writePackedSVarint,e)},n.prototype.nk=function(t,e){this.fw(t,writePackedBoolean,e)},n.prototype.ik=function(t,e){this.fw(t,writePackedFloat,e)},n.prototype.ek=function(t,e){this.fw(t,writePackedDouble,e)},n.prototype.ak=function(t,e){this.fw(t,writePackedFixed32,e)},n.prototype.uk=function(t,e){this.fw(t,writePackedSFixed32,e)},n.prototype.sk=function(t,e){this.fw(t,writePackedFixed64,e)},n.prototype.fk=function(t,e){this.fw(t,writePackedSFixed64,e)},n.prototype.ww=function(t,e){this.UA(t,n.DA),this.ZA(e)},n.prototype.hk=function(t,e){this.UA(t,n.RA),this.qA(e)},n.prototype.ck=function(t,e){this.UA(t,n.RA),this.WA(e)},n.prototype.vk=function(t,e){this.UA(t,n.PA),this.GA(e)},n.prototype.lk=function(t,e){this.UA(t,n.PA),this.HA(e)},n.prototype.rw=function(t,e){this.UA(t,n.LA),this.BA(e)},n.prototype.dk=function(t,e){this.UA(t,n.LA),this.VA(e)},n.prototype.uw=function(t,e){this.UA(t,n.DA),this.YA(e)},n.prototype.bk=function(t,e){this.UA(t,n.RA),this.KA(e)},n.prototype.pk=function(t,e){this.UA(t,n.PA),this.JA(e)},n.prototype.hw=function(t,e){this.rw(t,Boolean(e))},n.prototype.xA=function(t,e,r,n,i){var a,o,s=8*i-n-1,u=(1<<s)-1,c=u>>1,f=-7,h=r?i-1:0,l=r?-1:1,i=t[e+h];for(h+=l,a=i&(1<<-f)-1,i>>=-f,f+=s;0<f;a=256*a+t[e+h],h+=l,f-=8);for(o=a&(1<<-f)-1,a>>=-f,f+=n;0<f;o=256*o+t[e+h],h+=l,f-=8);if(0===a)a=1-c;else{if(a===u)return o?NaN:1/0*(i?-1:1);o+=Math.pow(2,n),a-=c}return(i?-1:1)*o*Math.pow(2,a-n)},n.prototype.XA=function(t,e,r,n,i,a){var o,s,u=8*a-i-1,c=(1<<u)-1,f=c>>1,h=23===i?Math.pow(2,-24)-Math.pow(2,-77):0,l=n?0:a-1,d=n?1:-1,a=e<0||0===e&&1/e<0?1:0;for(e=Math.abs(e),isNaN(e)||e===1/0?(s=isNaN(e)?1:0,o=c):(o=Math.floor(Math.log(e)/Math.LN2),e*(n=Math.pow(2,-o))<1&&(o--,n*=2),2<=(e+=1<=o+f?h/n:h*Math.pow(2,1-f))*n&&(o++,n/=2),c<=o+f?(s=0,o=c):1<=o+f?(s=(e*n-1)*Math.pow(2,i),o+=f):(s=e*Math.pow(2,f-1)*Math.pow(2,i),o=0));8<=i;t[r+l]=255&s,l+=d,s/=256,i-=8);for(o=o<<i|s,u+=i;0<u;t[r+l]=255&o,l+=d,o/=256,u-=8);t[r+l-d]|=128*a},n.LA=0,n.PA=1,n.DA=2,n.RA=5,n}();function readVarintRemainder(t,e,r){var n=r.gA,i=n[r.pos++],a=(112&i)>>4;if(i<128)return toNum(t,a,e);if(a|=(127&(i=n[r.pos++]))<<3,i<128)return toNum(t,a,e);if(a|=(127&(i=n[r.pos++]))<<10,i<128)return toNum(t,a,e);if(a|=(127&(i=n[r.pos++]))<<17,i<128)return toNum(t,a,e);if(a|=(127&(i=n[r.pos++]))<<24,i<128)return toNum(t,a,e);if(a|=(1&(i=n[r.pos++]))<<31,i<128)return toNum(t,a,e);throw new Error("Expected varint not more than 10 bytes")}function readPackedEnd(t){return t.type===Pbf.DA?t.ow()+t.pos:t.pos+1}function toNum(t,e,r){return r?4294967296*e+(t>>>0):4294967296*(e>>>0)+(t>>>0)}function writeBigVarint(t,e){var r,n;if(0<=t?(r=t%4294967296|0,n=t/4294967296|0):(n=~(-t/4294967296),4294967295^(r=~(-t%4294967296))?r=r+1|0:n=n+1|(r=0)),0x10000000000000000<=t||t<-0x10000000000000000)throw new Error("Given varint doesn\'t fit into 10 bytes");e.zA(10),writeBigVarintLow(r,n,e),writeBigVarintHigh(n,e)}function writeBigVarintLow(t,e,r){r.gA[r.pos++]=127&t|128,t>>>=7,r.gA[r.pos++]=127&t|128,t>>>=7,r.gA[r.pos++]=127&t|128,t>>>=7,r.gA[r.pos++]=127&t|128,r.gA[r.pos]=127&(t>>>=7)}function writeBigVarintHigh(t,e){var r=(7&t)<<4;e.gA[e.pos++]|=r|((t>>>=3)?128:0),t&&(e.gA[e.pos++]=127&t|((t>>>=7)?128:0),t)&&(e.gA[e.pos++]=127&t|((t>>>=7)?128:0),t)&&(e.gA[e.pos++]=127&t|((t>>>=7)?128:0),t)&&(e.gA[e.pos++]=127&t|((t>>>=7)?128:0),t)&&(e.gA[e.pos++]=127&t)}function makeRoomForExtraLength(t,e,r){var n=e<=16383?1:e<=2097151?2:e<=268435455?3:Math.ceil(Math.log(e)/(7*Math.LN2));r.zA(n);for(var i=r.pos-1;t<=i;i--)r.gA[i+n]=r.gA[i]}function writePackedVarint(t,e){for(var r=0;r<t.length;r++)e.BA(t[r])}function writePackedSVarint(t,e){for(var r=0;r<t.length;r++)e.VA(t[r])}function writePackedFloat(t,e){for(var r=0;r<t.length;r++)e.KA(t[r])}function writePackedDouble(t,e){for(var r=0;r<t.length;r++)e.JA(t[r])}function writePackedBoolean(t,e){for(var r=0;r<t.length;r++)e.$A(t[r])}function writePackedFixed32(t,e){for(var r=0;r<t.length;r++)e.qA(t[r])}function writePackedSFixed32(t,e){for(var r=0;r<t.length;r++)e.WA(t[r])}function writePackedFixed64(t,e){for(var r=0;r<t.length;r++)e.GA(t[r])}function writePackedSFixed64(t,e){for(var r=0;r<t.length;r++)e.HA(t[r])}function readUInt32(t,e){return(t[e]|t[e+1]<<8|t[e+2]<<16)+16777216*t[e+3]}function writeInt32(t,e,r){t[r]=e,t[r+1]=e>>>8,t[r+2]=e>>>16,t[r+3]=e>>>24}function readInt32(t,e){return(t[e]|t[e+1]<<8|t[e+2]<<16)+(t[e+3]<<24)}function readUtf8(t,e,r){for(var n="",i=e;i<r;){var a=t[i],o=null,s=239<a?4:223<a?3:191<a?2:1;if(r<i+s)break;var u,c=void 0,f=void 0;1===s?a<128&&(o=a):2===s?128==(192&(c=t[i+1]))&&(o=(31&a)<<6|63&c)<=127&&(o=null):3===s?(c=t[i+1],f=t[i+2],128==(192&c)&&128==(192&f)&&((o=(15&a)<<12|(63&c)<<6|63&f)<=2047||55296<=o&&o<=57343)&&(o=null)):4===s&&(c=t[i+1],f=t[i+2],u=t[i+3],128==(192&c))&&128==(192&f)&&128==(192&u)&&((o=(15&a)<<18|(63&c)<<12|(63&f)<<6|63&u)<=65535||1114112<=o)&&(o=null),null===o?(o=65533,s=1):65535<o&&(o-=65536,n+=String.fromCharCode(o>>>10&1023|55296),o=56320|1023&o),n+=String.fromCharCode(o),i+=s}return n}function writeUtf8(t,e,r){for(var n=0,i=void 0,a=void 0;n<e.length;n++){if(55295<(i=e.charCodeAt(n))&&i<57344){if(!a){56319<i||n+1===e.length?(t[r++]=239,t[r++]=191,t[r++]=189):a=i;continue}if(i<56320){t[r++]=239,t[r++]=191,t[r++]=189,a=i;continue}i=a-55296<<10|i-56320|65536,a=null}else a&&(t[r++]=239,t[r++]=191,t[r++]=189,a=null);i<128?t[r++]=i:(i<2048?t[r++]=i>>6|192:(i<65536?t[r++]=i>>12|224:(t[r++]=i>>18|240,t[r++]=i>>12&63|128),t[r++]=i>>6&63|128),t[r++]=63&i|128)}return r}var StyleOptionsBuilding=function(){this.hideWithoutStyle=!1,this.areas=[]},VectorTileSegements=function(){function t(){this.jc=[],this.VM=0}return t.prototype.add=function(t,e,r,n,i){VTLineSegement.getKey(t,e,i,n)!==(this.WM?this.WM.getKey():"-1")&&(this.VM+=this.WM?this.WM.length:0,this.WM=new VTLineSegement(t,e,this.VM,n,i),this.jc.push(this.WM)),this.WM.add(r)},t}(),VTLineSegement=function(){function t(t,e,r,n,i){this.mainkey=t,this.subkey=e,this.offset=r,this.minzoom=n,this.maxzoom=i,this.length=0}return t.getKey=function(t,e,r,n){return t+":"+e+":"+r+":"+n},t.prototype.add=function(t){this.length+=t},t.prototype.getKey=function(){return this.mainkey+":"+this.subkey+":"+this.maxzoom+":"+this.minzoom},t}(),MapboxSegements=function(){function t(){this.jc=[],this.GM=-1,this.HM=-1,this.VM=0}return t.prototype.add=function(t,e){MBLineSegement.getKey(t),this.WM&&this.WM.getKey(),this.GM=t,this.VM+=this.WM?this.WM.length:0,this.WM=new MBLineSegement(t,this.VM),this.jc.push(this.WM),this.WM.add(e)},t}(),MBLineSegement=function(){function t(t,e){this.style=t,this.offset=e,this.length=0}return t.getKey=function(t){return""+t},t.prototype.add=function(t){this.length+=t},t.prototype.getKey=function(){return""+this.style},t}(),ImageDataWraperType,ImageDataWraper=(function(t){t.base64="base64",t.arraybuffer="arraybuffer",t.bitmap="bitmap",t.empty="empty"}(ImageDataWraperType=ImageDataWraperType||{}),function(){function t(t,e,r){this.hash=t,this.IV=!1,"string"!=typeof e?r&&r.imageBitmap?(this.type=ImageDataWraperType.bitmap,this.status="success",this.data=e):(t=new Blob([e],{type:"image/png"}),(r=URLObject.createObjectURL(t))?(this.data=r,this.type=ImageDataWraperType.arraybuffer,this.status="success"):(this.data="",this.type=ImageDataWraperType.arraybuffer,this.status="error")):(this.data=e,this.type=ImageDataWraperType.base64,this.status="success")}return t.AV=function(t){return createImageBitmap(new Blob([new Uint8Array(t)]))},t.Wb=function(t){var e={data:t.data,type:t.type,status:t.status,IV:t.IV,hash:t.hash};return t.transform(),e},t.prototype.transform=function(){this.IV=!0,this.type===ImageDataWraperType.bitmap&&(this.data="")},t.prototype.destroy=function(){"destroyed"!==this.status&&(this.type===ImageDataWraperType.arraybuffer&&URLObject.revokeObjectURL(this.data),this.data="",this.status="destroyed")},t.prototype.IZ=function(t){var e;this.type===ImageDataWraperType.bitmap?t(this.data):((e=new Image).crossOrigin="",e.onload=function(){t(e)},e.src=this.data)},t}()),EmptyImageDataWraper=new ImageDataWraper("",""),CircleBucket=(EmptyImageDataWraper.type=ImageDataWraperType.empty,function(){function t(){this._b=new SymbolArray,this.uploaded=!1}return t.prototype.wb=function(t,e){var r=this._b.length;return this._b.kb(t[0],t[1],e),this._b.length-r},t.prototype.upload=function(t){this.uploaded||(this.destroy(),this.uploaded=!0,this.zs=t.fe(this._b.Mb,SymbolArray.Rb))},t.prototype.destroy=function(){this.uploaded=!1,this.zs&&this.zs.context&&(this.zs.context.deleteBuffer(this.zs),delete this.zs)},t.prototype.reset=function(){this._b=new SymbolArray,this.uploaded=!1},t}()),SimpleCircleBucket=function(){function t(){this._b=new SimpleSymbolArray,this.uploaded=!1}return t.prototype.wb=function(t){var e=this._b.length;return this._b.kb(t[0],t[1]),this._b.length-e},t.prototype.upload=function(t){this.uploaded||(this.destroy(),this.uploaded=!0,this.zs=t.fe(this._b.Mb,SimpleSymbolArray.Rb))},t.prototype.destroy=function(){this.uploaded=!1,this.zs&&this.zs.context&&(this.zs.context.deleteBuffer(this.zs),delete this.zs)},t.prototype.reset=function(){this._b=new SimpleSymbolArray,this.uploaded=!1},t}(),DistrictLayerStyle=function(){this["stroke-width"]="",this["coastline-stroke"]="",this["nation-stroke"]="",this["province-stroke"]="",this["city-stroke"]="",this["county-stroke"]="",this.fill=""},registry={};function register(t,e,r){void 0===r&&(r={}),Object.defineProperty(e,"yk",{value:t,writable:!1}),registry[t]={mk:e,gk:r.gk||[],wk:r.wk||[]}}function serialize(t,e){if(null==t||"boolean"==typeof t||"number"==typeof t||"string"==typeof t||t instanceof Boolean||t instanceof Number||t instanceof String||t instanceof Date||t instanceof RegExp)return t;if(t instanceof ArrayBuffer)return e&&e.push(t),t;if(Browser.imageBitmap&&t instanceof ImageBitmap)return e&&e.indexOf(t)<0&&e.push(t),t;if(ArrayBuffer.isView(t))return o=t,e&&e.push(o.buffer),o;if(t instanceof ImageData)return e&&e.push(t.data.buffer),t;if(Array.isArray(t)){for(var r=[],n=0,i=t;n<i.length;n++){var a=i[n];r.push(serialize(a,e))}return r}if("object"!=typeof t)throw new Error("can\'t serialize object of type "+typeof t);var o=t.constructor,s=o.yk;if(!s)throw new Error("can\'t serialize object of unregistered class");var u,c=void 0;if(o.Wb)c=o.Wb(t,e);else{for(var f in c={},t)!t.hasOwnProperty(f)||0<=registry[s].gk.indexOf(f)||(u=t[f],c[f]=0<=registry[s].wk.indexOf(f)?u:serialize(u,e));t instanceof Error&&(c.message=t.message)}if(c.$name)throw new Error("$name property is reserved for worker serialization logic.");return"Object"!==s&&(c.$name=s),c}function deserialize(t){if(null==t||"boolean"==typeof t||"number"==typeof t||"string"==typeof t||t instanceof Boolean||t instanceof Number||t instanceof String||t instanceof Date||t instanceof RegExp||t instanceof ArrayBuffer||ArrayBuffer.isView(t)||t instanceof ImageData||Browser.imageBitmap&&t instanceof ImageBitmap)return t;if(Array.isArray(t))return map(t,deserialize);if("object"!=typeof t)throw new Error("can\'t deserialize object of type "+typeof t);var e=t.$name||"Object",r=registry[e].mk;if(!r)throw new Error("can\'t deserialize unregistered class "+e);if(r.Gb)return r.Gb(t);for(var n=Object.create(r.prototype),i=0,a=Object.keys(t);i<a.length;i++){var o,s=a[i];"$name"!==s&&(o=t[s],n[s]=0<=registry[e].wk.indexOf(s)?o:deserialize(o))}return n}register("Object",Object),register("LineArrayBuffer",LineArrayBuffer),register("TriangleIndexArray",TriangleIndexArray),register("TriangleIndexArrayUint",TriangleIndexArrayUint),register("PolylineBucket",PolylineBucket),register("LinesIndexArray",LinesIndexArray),register("LinesIndexArrayUint",LinesIndexArrayUint),register("FillArray",FillArray),register("PolygonBucket",PolygonBucket),register("CircleBucket",CircleBucket),register("SymbolArray",SymbolArray),register("FillExtrusionBucket",FillExtrusionBucket),register("FillExtrusionArray",FillExtrusionArray),register("SmartArrayBuffer",SmartArrayBuffer),register("Color",Color),register("Segements",NebulaSegements),register("VectorTileSegements",VectorTileSegements),register("VTLineSegement",VTLineSegement),register("LineSegement",LineSegement),register("PolygonSegements",PolygonSegements),register("VectorTile",VectorTile$1),register("VectorTileLayer",VectorTileLayer),register("VectorTileFeature",VectorTileFeature),register("Pbf",Pbf),register("StyleOptionsBuilding",StyleOptionsBuilding),register("DistrictStyleOptions",DistrictLayerStyle),register("MapboxSegements",MapboxSegements),register("MBLineSegement",MBLineSegement),register("ImageDataWraper",ImageDataWraper),register("TileCoord",TileCoord),register("Tile",Tile),register("StyleParser",StyleParser);var LabelTextStyle=function(){function t(t){this.origin=t}return t.BV=function(t,e){var r=DangerousFontSize,n=void 0===(n=t.fontSize)?12:n,i=t.fillColor,a=t.strokeColor,o=void 0===(o=t.strokeWidth)?0:o,s=void 0===(s=t.backgroundColor)?0:s,t=t.borderColor,i=labelsUtil.Yj(Util.color2RgbaArray(void 0===i?[0,0,0,1]:i)),s=s?labelsUtil.Yj(Util.color2RgbaArray(s)):[0,0,0,0],a=labelsUtil.Yj(Util.color2RgbaArray(a),[.988,.988,.988,1]),t=labelsUtil.Yj(Util.color2RgbaArray(t),[.988,.988,.988,1]),u=(n=n||12)<10?.78125:205/256,c=0,r=(o&&(c=u*(1-(10<o*e?10:o)/10.1)),o=1.4142*(r<n||1<e?1.7:1.5)/n,u+1.5/256*(e-1));return(n=new Float32Array(28)).set(i,0),n.set(a,4),n[8]=o,n[9]=c,n[10]=r,n.set(s,11),n.set(t,15),n[19]=1,n.set(i,20),n.set(a,24),n},t.prototype.GV=function(t){switch(t){case"fillColor":return this.origin.slice(0,4);case"strokeColor":return this.origin.slice(4,8);case"backgroundColor":return this.origin.slice(11,15);case"borderColor":return this.origin.slice(15,19);case"u_gamma":return this.origin[8];case"u_borderBuffer":return this.origin[9];case"u_buffer":return this.origin[10];case"u_fontSizeFactor":return this.origin[19];case"u_highlightFillColor":return this.origin.slice(20,24);case"u_highlightStrokeColor":return this.origin.slice(24,28);default:return}},t.prototype.VV=function(t,e){switch(t){case"u_fontSizeFactor":this.origin[19]=e;break;case"fillColor":this.origin.set(e,0);break;case"strokeColor":this.origin.set(e,4);break;case"backgroundColor":this.origin.set(e,11);break;case"borderColor":this.origin.set(e,8);break;case"u_highlightFillColor":this.origin.set(e,20);break;case"u_highlightStrokeColor":this.origin.set(e,24)}},t}(),LabelBucket=(register("LabelTextStyle",LabelTextStyle),function(){function t(t){this.DO={rp:[],pp:[],bd:[],up:0},this.ZO=[],this.options={},this.Gj={},this.Hj={},this.Vj={},this.QO={},this.tI={},this.Fs={},this.$j=0,this.qO={},this.$O=0,this.rI={},this.iO="inner",this._id=Util.stamp(this),this.Mf=t.R_,this.ac=t.z_,this.io=t.canvas,this.NT=t.Nz}return t.prototype.rQ=function(t,e){var r=void 0===(r=e.from)?"inner":r,n=CONSTS.ud,t=(labelsUtil.zj(this,t),this.iO=r,this.Mf&&"SDFManagerBase"!==this.Mf.CLASS_NAME),i=this.DO,a=(t&&(i.rp=new Float32Array(this.$j*n*6)),this.Gj),o=this.Hj,s=this.Vj;if(!o||!s)return null;var r=assign(this.options,e),u=this.RO(a),c=isUndefined(r.opacity)?1:r.opacity;if(t){for(var f=0,h=0,l=0,d=u;l<d.length;l++){for(var v=d[l],g=void 0,p=0,y=v;p<y.length&&!((g=o[y[p]])&&g.text&&g.text.style);p++);var m,b={vd:[]},T=this.ym().KO;g&&g.text&&g.text.style?(m=g.text.style||{},b.vd=new LabelTextStyle(LabelTextStyle.BV(m,void 0===T?1:T))):(b.vd=new LabelTextStyle(new Float32Array(28)),b.vd.VV("u_fontSizeFactor",1)),m=h,b.start=m;var A=isUndefined(A=(T=a[v[0]].opts||{}).opacity)?1:A,x=T.icon&&T.icon[0]&&T.icon[0].image;b.opacity=A,b.rotation=T.rotation,b.opacity*=c,i.pp.push(b),b.dp=[];for(var M=0,S=v;M<S.length;M++){var w=S[M],P=a[w].CO||[],I={height:a[w]&&a[w].opts.height||0,from:e.from,angle:a[w]&&a[w].data.rotation||0},C=this.PO(w,s[w],o[w],i,I),N=this.zV(w,s[w],o[w],a[w],i,I,P),P=this.BO(w,s[w],o[w],a[w],i,P,I);b.dp.push({id:w,Rd:P,icon:C,bg:N,kd:I=6*(P+C+N)}),h+=I*n}b.end=h,b.pd=x,f+=A=h-m,i.bd.push(A)}i.up=f}return i.Fz=u,this.DO=i},t.prototype.destroy=function(){},t.prototype.ym=function(){return this.gs.aO()},t.prototype.zO=function(t){var e;return t?this.qO[t]||(e=labelsUtil.Kj(parseInt(t,10)),this.qO[t]=e,this.qO[t]):[]},t.prototype.RO=function(t){var e,r,n,i,a,o,s,u={},c=this.Gj,f=this.iO;for(e in t)t.hasOwnProperty(e)&&(n=(r=c[e]).data||{},i=(o=r.opts||{}).zIndex,a=o.forceShow,v=n.rank,v=a?v-1e5:v,n=isUndefined(o.opacity)?1:o.opacity,o=void 0===(o=(a=this.Hj[e]||{}).text)?{}:o,a=a.icon,u[i=("labelsLayer"===f?i||v:i)||1]=u[i]||{},o=o&&o.style||"",s=void 0,"labelsLayer"===f?(s=o?labelGroup.nT(o)+n:s,s+=a&&a[0]&&a[0].image?a[0].image:""):s=r.data.extData.Lp?(r.data.extData.Lp<<16)+r.data.extData.Ap:o?labelGroup.nT(o)+n:"-1-"+n,u[i][s]||(u[i][s]=[]),u[i][s].push(e));for(var h=[],l=0,d=labelsUtil.rank(Object.keys(u));l<d.length;l++)for(var v,g=u[v=d[l]],p=0,y=Object.keys(g).sort();p<y.length;p++){var m=y[p];h.push(g[m])}return h},t.prototype.WO=function(t,e){var r=Util.WorldAxesCenter;return[t-r.x,e-r.y]},t.prototype.GO=function(t){return t},t.prototype.HO=function(t,e,r,n,i){var a,o,s=i.VO,u=void 0===(u=i.type)?EnumLabelFragType.icon:u,c=i.zooms,f=i.height,e=void 0===(e=e.icon)?[]:e,h=CONSTS.ud,l=this.$O,d=0,v=0,g=((g=this.ac.getImage(r.image))&&(d=g.startX||0,v=g.startY||0),s[0]),s=s[1],p=c[0],c=c[1],y=exports.cY.icon,e=e.anchorOffset,m=r.size,b=r.clipSize,T=r.clipOrigin,A=m[0],m=m[1],x=b[0],b=b[1],M=T[0],T=T[1],S=(e=this.GO(e))[0]||0,e=e[1]||0,r=((r=r.offset)&&(o=r instanceof Array||void 0===r.x||void 0===r.y?(a=r[0],r[1]):(a=r.x,r.y)),d+M),d=v+T,M=(void 0!==a&&(S+=a),void 0!==o&&(e+=o),-i.angle*Math.PI/180||0);n.set([S,e,r,d,g,s,y,u,p,c,f,M,0,S+A,e,r+x,d,g,s,y,u,p,c,f,M,0,S,m+e,r,d+b,g,s,y,u,p,c,f,M,0,S+A,e,r+x,d,g,s,y,u,p,c,f,M,0,S+A,m+e,r+x,d+b,g,s,y,u,p,c,f,M,0,S,m+e,r,d+b,g,s,y,u,p,c,f,M,0],l),this.$O+=6*h},t.prototype.PO=function(t,e,r,n,i){if(!e||!r)return 0;var a=e.icon;if(!(r=void 0===(r=r.icon)?[]:r).length||!r[0].image)return 0;for(var o=(a=(void 0===a?{}:a).origin)[0],s=a[1],u=(a[2],this.WO(o,s)),c=i.height,f=i.angle,h=0,l=r;h<l.length;h++){var d=l[h];this.HO(t,e,d,n.rp,{VO:u,zooms:d.zooms,height:c,angle:f}),delete d.clipOrigin,delete d.clipSize,delete d.size,delete d.image,delete d.type,delete d.anchor,delete d.retina}return r.length},t.prototype.YO=function(t,e,r,n,i){var a=i.VO,o=void 0===(o=i.type)?EnumLabelFragType.bg:o,s=i.zooms,u=i.height,c=CONSTS.ud,f=CONSTS.Kp,h=this.$O,e=e.padding,l=a[0],a=a[1],d=s[0],s=s[1],v=e.w,g=e.h,f=e.offsetX-f.buffer,e=e.offsetY,i=-i.angle*Math.PI/180||0;if(n.set([f,e,0,0,l,a,0,o,d,s,u,i,0,f+v,e,0,0,l,a,0,o,d,s,u,i,0,f,g+e,0,0,l,a,0,o,d,s,u,i,0,f+v,e,0,0,l,a,0,o,d,s,u,i,0,f+v,g+e,0,0,l,a,0,o,d,s,u,i,0,f,g+e,0,0,l,a,0,o,d,s,u,i,0],h),this.$O+=6*c,h=this.$O,o=r.text.style.borderWidth){for(var p=[f,e,v,g,l,a,o,d,s,u,i],y=0;y<4;y++)p[11]=y,this.sT(p,n,h),h+=6*c;this.$O=h}},t.prototype.sT=function(t,e,r){var n=(t=void 0===t?{}:t)[0],i=t[1],a=t[2],o=t[3],s=t[4],u=t[5],c=t[6],f=t[7],h=t[8],l=t[9],d=t[10],t=t[11],v=EnumLabelFragType.tq,g=0,p=0,y=0,m=0,b=0,T=0,A=0,x=0;switch(t){case 0:m=p=i-c,b=g=n+0,A=y=n+a,x=T=i+0;break;case 1:y=(g=n+a)+c,m=p=i-c,A=(b=n+a)+c,x=T=i+o+c;break;case 2:b=g=n+0,A=y=n+a,x=T=(m=p=i+o)+c;break;case 3:g=n-c,m=p=i-c,b=(y=n)-c,A=n,x=T=i+o+c}e.set([g,p,0,0,s,u,0,v,f,h,l,d,0,y,m,0,0,s,u,0,v,f,h,l,d,0,b,T,0,0,s,u,0,v,f,h,l,d,0,y,m,0,0,s,u,0,v,f,h,l,d,0,b,T,0,0,s,u,0,v,f,h,l,d,0,A,x,0,0,s,u,0,v,f,h,l,d,0],r)},t.prototype.UO=function(t,e,r,n,i){var a,o,s,u,c,f;return e&&r&&(a=CONSTS.Mp,o=CONSTS.Rp,f=e.text,s=(r.text||{}).zooms,r.text)&&f.origin?(u=(f=f.origin)[0],c=f[1],f[2],f=i.height,this.YO(t,e,r,n.rp,{VO:[u,c],zooms:void 0===s?[a,o]:s,height:f}),i=1,r.text.style.borderWidth&&(i+=4),i):0},t.prototype.zV=function(t,e,r,n,i,a,o){if(!e||!r)return 0;var s=CONSTS.Mp,u=CONSTS.Rp,f=e.text.offset,l=(h=(c=r).text||{}).style;h.type;var d=void 0===(d=h.direction)?"left":d,s=void 0===(h=h.zooms)?[s,u]:h;if(!c.text||!c.text.style)return 0;if(o.length,u=!1===(l=void 0===l?{}:l).fold?100:6,h=this.Mf.lineBreak(c.text.txt,{fontSize:l.fontSize,CO:n.CO,type:n.data&&n.data.BG||"ch",fj:u,from:a.from}),o={direction:d,size:l.fontSize,yO:c.icon.length&&c.icon[0].image},c=(u=(n=e.text).origin)[0],e=u[1],u[2],!r.text||!n.origin)return 0;var u=[c,e],n=a.height,c=EnumLabelFragType.bg,v=CONSTS.ud,g=this.$O,e=u[0],u=u[1],p=s[0],s=s[1],y=i.rp,i=h.maxWidth+6,l=l.fontSize*h.width.length+8,h=this.XV(i,d,o.yO),d=f[0]+h[0]-1,o=f[1]-2,h=-a.angle*Math.PI/180||0;if(y.set([d,o,0,0,e,u,0,c,p,s,n,h,0,d+i,o,0,0,e,u,0,c,p,s,n,h,0,d,l+o,0,0,e,u,0,c,p,s,n,h,0,d+i,o,0,0,e,u,0,c,p,s,n,h,0,d+i,l+o,0,0,e,u,0,c,p,s,n,h,0,d,l+o,0,0,e,u,0,c,p,s,n,h,0],g),this.$O+=6*v,g=this.$O,f=r.text.style.borderWidth){for(var m=[d,o,i,l,e,u,f,p,s,n,h],b=0;b<4;b++)m[11]=b,this.sT(m,y,g),g+=6*v;return this.$O=g,5}return 1},t.prototype.CT=function(t,e){return this.Mf?this.Mf.measureText(t,e):this.NT?(this.NT.font=(e||12)+"px",this.NT.measureText(t.join("")).width):0},t.prototype.XO=function(t,e){var r=CONSTS.JM,r=void 0===(n=(e=void 0===e?{}:e).direction)?r.LEFT:n,n=e.size,e=void 0!==(e=e.yO)&&e,t=this.CT(t=void 0===t?[]:t,void 0===n?DangerousFontSize:n);return this.XV(t,r,e)},t.prototype.XV=function(t,e,r){void 0===r&&(r=!1);var n=0,i=0;switch(e){case(r=CONSTS.JM).LEFT:n=-t,i=0;break;case r.QM:i=n=0;break;case r.ZM:case r.tj:n=-t/2,i=0;break;case r.ij:case r.nj:n=-t/2,i=0;break;default:i=n=0}return[n,i]},t.prototype.JO=function(t,e,r,n){var i,a,o,s,u,c,f,h,l,d,v,g,p=CONSTS.ud,y=this.$O,m=n.size,b=n.VO,T=void 0===(T=n.type)?EnumLabelFragType.text:T,A=(n.id,n.zooms),x=n.height,M=CONSTS.Kp,S=this.Mf.mz(e);S&&(i=S.index,g=S.pos,S=S.char,a=b[0],b=b[1],o=A[0],A=A[1],S||(console.log("!metric",e,String.fromCharCode(e)),S=this.Mf.mz(32).char),e=m/M.size,m=S[0],s=S[1],S[2],S[3],S[4],v=S[5],u=S[6],M=M.buffer,0<m&&0<s&&(c=(f=r.x)-M*e,f=+(f+((m+=2*M)-M)*e),h=+((l=r.y)+u*e),l=+(l+((s+=2*M)+u)*e),d=M=0,M=(M+=g.startX)+v,v=(d+=g.startY)+u,g=-n.angle*Math.PI/180||0,t.set([c,h,M,v,a,b,i,T,o,A,x,g,0,f,h,M+m,v,a,b,i,T,o,A,x,g,0,c,l,M,v+s,a,b,i,T,o,A,x,g,0,c,l,M,v+s,a,b,i,T,o,A,x,g,0,f,h,M+m,v,a,b,i,T,o,A,x,g,0,f,l,M+m,v+s,a,b,i,T,o,A,x,g,0],y),this.$O+=6*p),r.x=r.x+(S[0]+CONSTS.ic)*e)},t.prototype.BO=function(t,e,r,n,i,a,o){if(!(e&&r&&r.text&&r.text.txt))return 0;var s=CONSTS.Mp,u=CONSTS.Rp,c=(e=e.text).origin,f=e.offset,h=(e=r.text||{}).style;e.type;var l=void 0===(l=e.direction)?"left":l,d=void 0===(e=e.zooms)?[s,u]:e,v=a,s=c[0],u=c[1];if(c[2],!r.text||!r.text.style)return 0;for(var g=v.length,p=g,e=!1===(h=void 0===h?{}:h).fold?100:6,y=((a=this.Mf.lineBreak(r.text.txt,{fontSize:h.fontSize,CO:(n=void 0===n?{}:n).CO,type:n.data&&n.data.BG||"ch",fj:e,from:o.from})).lines.length,a.oQ),m=h.fontSize,b={direction:l,size:m,yO:r.icon.length&&r.icon[0].image},T=[s,u],A={x:0,y:0},x=o.height,M=o.angle,S=-1,w=0,P=0;P<g;P++){var I=v[P],C=this.eQ(y,w),N=(w+=I.split("|").length,this.nQ(v,y[C],y[C+1])),N=v.slice.apply(v,N),N=this.XO(N,b),N=vector.add(f,N);if(0===C&&0===P&&(A.x=N[0],A.y=N[1]),C&&(A.y=N[1]+(m+3)*C,S!==C)){if("32"===I){p--;continue}A.x=N[0]}S=C,this.JO(i.rp,I,A,{size:m,VO:T,id:t,zooms:d,height:x,angle:M})}return p},t.prototype.nQ=function(t,e,r){for(var n=0,i=0,a=0,o=t.length,s=0;s<o;s++){for(var u=t[s].split("|").length,c=0;c<u;c++){var f=a+c;f===e&&(n=s),f===r&&(i=s)}a+=u}return[n,i=a<=r?o:i]},t.prototype.eQ=function(t,e){for(var r=(t=void 0===t?[]:t).length,n=0;n<r-1;n++)if(e>=t[n]&&e<t[n+1])return n;return 0},t}()),DefaultLabelsLayerOpts={opacity:1,collision:!0,animation:!0},Labels=function(){function t(t){if(this.CLASS_NAME="AMap.LabelsLayer",this.Gj={},this.Hj={},this.Vj={},this.Fs={},this.Es={},this.Wj={},this.$j=0,this.zp={},this.render=null,this.eI={},this.nI=[],this.cI=!1,this.iI=!1,this.iO="",this.cI=!1,this._opts=assign({},DefaultLabelsLayerOpts,{opacity:t.opacity}),this.Mf=t.R_,this.ac=t.z_,this.PN=t.info||{},!this.Mf||"SDFManagerBase"===this.Mf.CLASS_NAME)try{var e=this.io=document.createElement("canvas"),r=void 0;e&&(r=this.NT=e.getContext("2d")),t.canvas=e,t.Nz=r}catch(t){console.log("canvas 初始化失败")}this.sI=new LabelPlacement(t),this.fI=new LabelBucket(t)}return t.prototype.Ns=function(t,e){var r=(e=void 0===e?{}:e).zoom,n=e.center,i=e.from;return this.nI=t,this.iI=!0,this.iO=i,this.eI.zoom=r||20,this.oI(),this.hu=n,this.uI(e)},t.prototype.aO=function(){return this.eI},t.prototype.zL=function(t){return this.Wj[t]},t.prototype.uI=function(t){var e=this.iO,e={center:this.hu,from:e};if(assign(e,t=void 0===t?{}:t),this.sI.nO(this,e),this.$j=this.sI.$j,t=this.fI.rQ(this,e)){var r,n,i,a,o,s,u,c={},f={},e=t.Fz||{},h=(delete t.Fz,this.Gj);if("inner"!==this.iO)return{Nf:h,style:this.Hj,coords:this.Vj,rp:t,zp:this.zp,Fz:e};for(r in h)h.hasOwnProperty(r)&&(n=h[r],i=this.Vj[r],a=(u=n.data).extData,o=u.position,s=u.name,u=u.rank,c[r]={data:{position:o,name:s,rank:u,extData:{type:a.type,id:a.id,Lp:a.Lp,Ap:a.Ap,bz:a.bz}}},f[r]={origin:i.origin,icon:{anchorOffset:i.icon.anchorOffset,size:i.icon.size},padding:i.padding},n.opts)&&(c[r].opts={zooms:n.opts.zooms});return{Nf:c,style:this.Hj,coords:f,rp:t,zp:this.zp,Fz:e}}},t.prototype.oI=function(){for(var t=this.nI,e=this.Gj||{},r=this.Wj,n=this.zp,i=CONSTS.Mp,a=CONSTS.Rp,o=CONSTS.Pp,s=CONSTS.jp,u=0,c=t;u<c.length;u++){for(var f=c[u],h=f.data.id,l=f.opts&&f.opts.zooms||[],d=void 0===(d=l[0])?i:d,v=void 0===(l=l[1])?a:l,g=isUndefined(r[h])?Util.stamp(this):r[h],p=(h&&(r[h]=g),Math.ceil(d-o));p<=v+s;)n[p]||(n[p]=[]),n[p].push(g),p++;e[g]=f,e[g].CO=this.Ws(f),this.hI(f)}if("undefined"!=typeof Uint32Array)for(var y in n)n.hasOwnProperty(y)&&(n[y]=new Uint32Array(n[y]));this.Gj=e},t.prototype.hI=function(t){var e=this.Fs;(t=(t=t.opts.icon)&&t.image||"")&&(e[t]=1)},t.prototype.Ws=function(t){this.Es;var e=t.data.txt||"",t=(t.opts&&t.opts.text||{}).$G||[],e=labelsUtil.EQ(e,t);return labelsUtil.aQ(e)},t}(),DynamicVerticeStyle=function(){},DynamicVertice=function(){function r(t,e){this.zo=t,this.Nf=e.Nf,this.style=e.style,Object.setPrototypeOf(this.style,new DynamicVerticeStyle),this.coords=e.coords,this.rp=e.rp,this.zp=e.zp}return r.Wb=function(t,e){var r={zo:t.zo,coords:t.coords,Nf:t.Nf,style:t.style};return{JSON:JSON.stringify(r),kV:{rp:serialize(t.rp,e),zp:serialize(t.zp,e)}}},r.Gb=function(t){var e=JSON.parse(t.JSON);return t.kV.rp.pp=deserialize(t.kV.rp.pp),e.rp=t.kV.rp,e.zp=t.kV.zp,new r(e.zo,e)},r.prototype.upload=function(t){this.buffer||(this.buffer=t.fe(this.rp.rp,CONSTS.sp))},r.prototype.destroy=function(){this.buffer&&(this.buffer.context.deleteBuffer(this.buffer),delete this.buffer)},r}();function feature(t,e,r){var n={type:"Feature"};return 0!==(r=void 0===r?{}:r).id&&!r.id||(n.id=r.id),r.Ro&&(n.Ro=r.Ro),n.properties=e||{},n.geometry=t,n}function polygon(t,e,r){void 0===r&&(r={});for(var n=0,i=t;n<i.length;n++){var a=i[n];if(a.length<4)throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");for(var o=0;o<a[a.length-1].length;o++)if(a[a.length-1][o]!==a[0][o])throw new Error("First and last Position are not equivalent.")}return feature({type:"Polygon",coordinates:t},e,r)}function lineString(t,e,r){if(void 0===r&&(r={}),t.length<2)throw new Error("coordinates must be an array of two or more positions");return feature({type:"LineString",coordinates:t},e,r)}function multiLineString(t,e,r){return feature({type:"MultiLineString",coordinates:t},e,r=void 0===r?{}:r)}function multiPolygon(t,e,r){return feature({type:"MultiPolygon",coordinates:t},e,r=void 0===r?{}:r)}function getGeom(t){return"Feature"===t.type?t.geometry:t}function lineclip(t,e,r){var n,i,a,o,s,u=t.length,c=bitCode(t[0],e),f=[];for(r=r||[],n=1;n<u;n++){for(o=t[n-1],i=a=bitCode(s=t[n],e);;){if(!(c|i)){f.push(o),i!==a?(f.push(s),n<u-1&&(r.push(f),f=[])):n===u-1&&f.push(s);break}if(c&i)break;c?c=bitCode(o=intersect(o,s,c,e),e):i=bitCode(s=intersect(o,s,i,e),e)}c=a}f.length&&r.push(f)}function polygonclip(t,e){for(var r,n,i,a,o,s,u=1;u<=8;u*=2){for(r=[],i=!(bitCode(n=t[t.length-1],e)&u),a=0;a<t.length;a++)(s=!(bitCode(o=t[a],e)&u))!==i&&r.push(intersect(n,o,u,e)),s&&r.push(o),n=o,i=s;if(!(t=r).length)break}return r}function intersect(t,e,r,n){return 8&r?[t[0]+(e[0]-t[0])*(n[3]-t[1])/(e[1]-t[1]),n[3]]:4&r?[t[0]+(e[0]-t[0])*(n[1]-t[1])/(e[1]-t[1]),n[1]]:2&r?[n[2],t[1]+(e[1]-t[1])*(n[2]-t[0])/(e[0]-t[0])]:1&r?[n[0],t[1]+(e[1]-t[1])*(n[0]-t[0])/(e[0]-t[0])]:null}function bitCode(t,e){var r=0;return t[0]<e[0]?r|=1:t[0]>e[2]&&(r|=2),t[1]<e[1]?r|=4:t[1]>e[3]&&(r|=8),r}function bboxClip(t,e){var r=getGeom(t),n=r.type,i="Feature"===t.type?t.properties:{},a=r.coordinates;switch(n){case"LineString":case"MultiLineString":var o=[];return(a="LineString"===n?[a]:a).forEach(function(t){lineclip(t,e,o)}),1===o.length?lineString(o[0],i):multiLineString(o,i);case"Polygon":return polygon(clipPolygon(a,e),i);case"MultiPolygon":return multiPolygon(a.map(function(t){return clipPolygon(t,e)}),i);default:throw new Error("geometry "+n+" not supported")}}function clipPolygon(t,e){for(var r=[],n=0,i=t;n<i.length;n++){var a=polygonclip(i[n],e);0<a.length&&(a[0][0]===a[a.length-1][0]&&a[0][1]===a[a.length-1][1]||a.push(a[0]),4<=a.length)&&r.push(a)}return r}register("DynamicVertice",DynamicVertice);var DEF_NDS_MAX_COORD=2147483648,DEF_DEGREE_MAX_COORD=180,MKT=20037508.342789244;function tileInnerCoord2LngLat(t,e,r,n){var a=r+(i=getTileSWCoord(t,e))[0],i=n+i[1];return r=a<<(t=getCoordShift(t.z,e)),n=i<<t,[coord2Degree(r=0<a&&r<0?DEF_NDS_MAX_COORD-1:r),coord2Degree(n)]}function LngLat2TileInnerCoord(t,e,r,n,i){var r=degree2Coord(r),n=degree2Coord(n),a=getCoordShift(i.z,e),n=n>>a;return[(r=r>>a)-(a=getTileSWCoord(i,e))[0],n-a[1]]}var cache={};function lnglat2WGSCoord2(t){var e,r;return cache[t]||(r=33-t,e=degree2Coord(180)/(1<<r),r=degree2Coord(90)/(1<<r),e=0<e?Math.floor(.5+e):Math.floor(e-.5),r=0<r?Math.floor(.5+r):Math.floor(r-.5),cache[t]=[2*e,2*r]),cache[t]}function getWorldSize(t,e){return lnglat2WGSCoord2(t+e)}function getTileSWCoord(t,e){var r=(e=getWorldSize(t.z,e))[0],e=e[1],n=1<<t.z;return[-r/2+t.x*r/n,e/2-(t.y+1)*e/n]}function degree2Coord(t){return Math.floor(t*DEF_NDS_MAX_COORD/DEF_DEGREE_MAX_COORD+.5)}function coord2Degree(t){return t*DEF_DEGREE_MAX_COORD/DEF_NDS_MAX_COORD}function getCoordShift(t,e){return 33-e-t}function getMVTTileBbox(t,e,r,n,i){return[t*(i=void 0===i?256:i)*n-MKT,-((e+1)*i*n-MKT),(t+1)*i*n-MKT,-(e*i*n-MKT)]}var MapboxVTSourceWorker=function(){function t(){}return t.prototype.bw=function(t,e,r,n,i,a){var o=this,s={point:{},line:{},polygon:{},polyhedron:{},label:{}},u=new XMLHttpRequest;return u.onreadystatechange=function(){var t;4!==u.readyState||200!==u.status&&204!==u.status||(s.point=o.AX(i.point),s.line=o.AX(i.line),s.polygon=o.AX(i.polygon),s.polyhedron=o.AX(i.polyhedron),s.label=o.AX(i.label),t=new VectorTile$1(new Pbf(new Uint8Array(u.response))),t=o.Ow(t,{x:e.x,y:e.y,z:e.z,projectionId:r,tileSize:n},s),a(null,exports.Ln({zo:e},t)))},u.responseType="arraybuffer",u.open("GET",t,!0),u.send(),{cancel:function(){u.abort()}}},t.prototype.mX=function(t,e,r){var n={point:{},line:{},polygon:{},polyhedron:{},label:{}};n.point=this.AX(e.point),n.line=this.AX(e.line),n.polygon=this.AX(e.polygon),n.polyhedron=this.AX(e.polyhedron),n.label=this.AX(e.label),this.xw(t,n,!0),this.zw(t,n,!0),this.nz(t,n,!0),this.SX(t,n,!0),this.i1(t,n,!0),r&&r(null,t)},t.prototype.Ow=function(h,t,e){var r=t.x,n=t.y,i=t.z,a=t.tileSize,o=t.projectionId,l=(h.z=i,h.x=r,h.y=n,ProjectionManager.getProjection(o)),t=l.getResolution(i),s=(h.projectionId=o,h.Ro=getMVTTileBbox(r,n,i,t,a),h.zS=lcs.getLocalByCoord([h.Ro[0],h.Ro[1]]),h.visible={point:{},line:{},polygon:{},label:{},polyhedron:{}},ProjectionManager.getProjection(o).getResolution(i));return forIn(h.layers,function(f){var t=f.Cw,e=(f.Ah=[],f.scale=s*a/f.extent,transform[o].Xs(a*r,a*n,i));f.ox=e[0],f.oy=e[1],forEach(t,function(t,e){if((t=f.Gw(e)).Dw(),f.Ah.push(t),t.lines&&0<t.lines.length){t.Rw=[],t.n1=[];for(var r=0,n=t.lines.length;r<n;r++){for(var i=[],a=[],o=0,s=t.lines[r].length;o<s;o++){var u=[f.ox+f.scale*t.lines[r][o][0],f.oy-f.scale*t.lines[r][o][1]],c=[u[0]-h.zS.center[0],u[1]-h.zS.center[1]];a.push(l.unproject(u[0],u[1])),i.push(c)}t.Rw.push(i),t.n1.push(a)}}})}),this.uW(h),this.xw(h,e),this.zw(h,e),this.nz(h,e),this.SX(h,e),this.i1(h,e),h},t.prototype.uW=function(t){for(var e in t.polygons={},t.polygonOut={},t.polyhedrons={},t.polylines={},t.points={},t.layers)if(t.layers.hasOwnProperty(e)){for(var r=t.layers[e],n=[],i=[],a=[],o=[],s=[],u=0;u<r.Ah.length;u+=1){var c=r.Ah[u];if(3==+c.type&&c.Rw){for(var f=c.Rw,h=c.n1,l=[],d=this.g8t(c),v=d.w8t,g=d.height,p=0;p<f.length;p++)PlaneGeometryUtilInstance.isClockwise(f[p])?l.push([p]):l.length&&l[l.length-1].push(p);for(var y=0;y<l.length;y++){var m=l[y];if(1<m.length)if(v){for(var b=[],T=[],A=0;A<m.length;A++){var x=h[m[A]];if(P=this.d8t(t,x)){0<A&&b.push(T.length/2);for(var M=[],S=0;S<P.length;S++){var w=P[S];M.unshift(w[0],w[1])}T.push.apply(T,M)}}a.push({_id_:Util.getGuid("amap_"),properties:c.properties,path:T,LQ:b,height:g})}else{for(b=[],T=[],A=0;A<m.length;A++){var P=f[m[A]];for(0<A&&b.push(T.length/2),S=0;S<P.length;S++){var I=P[S];T.push(I[0],I[1])}i.push({properties:c.properties,path:P,_id_:Util.getGuid("amap_")})}n.push({properties:c.properties,path:T,LQ:b})}else if(v){if(T=[],x=h[m[0]],P=this.d8t(t,x)){for(S=0;S<P.length;S++){var C=P[S];T.unshift(C[0],C[1])}a.push({_id_:Util.getGuid("amap_"),properties:c.properties,path:T,height:g})}}else{for(T=[],P=f[m[0]],S=0;S<P.length;S++){var N=P[S];T.push(N[0],N[1])}n.push({properties:c.properties,path:T}),i.push({properties:c.properties,path:P,_id_:Util.getGuid("amap_")})}}}else if(2==+c.type&&c.Rw)for(var $=0,k=c.Rw.length;$<k;$++)o.push({properties:c.properties,path:c.Rw[$],_id_:Util.getGuid("amap_")});else if(1==+c.type&&c.Rw)for(h=c.n1,y=0;y<c.Rw.length;y++)s.push({_id_:Util.getGuid("amap_"),properties:c.properties,path:c.Rw[y],lnglat:__spreadArrays(h[0][0])});delete c.n1}t.polygons[e]=n,t.polygonOut[e]=i,t.polyhedrons[e]=a,t.polylines[e]=o,t.points[e]=s}delete t.layers},t.prototype.xw=function(t,e,r){if(void 0===r&&(r=!1),!t||!t.$c||r){var n=new VectorTileSegements,i=(t.Uc=n,r||(t.$c=new PolylineBucket),e.line.sourceLayer),a=t.polylines;if(a)for(var o in t.visible.line[i]=[],a)if(!i||i===o)for(var u=a[o],c=0,f=u.length;c<f;c++){var h,l=u[c],v=(d=this.Mn(e.line,l.properties)).color,g=d.lineWidth,p=d.dash,d=+(d.visible||!d.filter);t.visible.line[i]||(t.visible.line[i]=[]),d&&t.visible.line[i].push(l._id_),v[3]*=d,r?n.add(v+":"+g+":"+p,0,l.a1,0,22):(h=(d=t.$c.g0(l.path,{X_:0,lineJoin:"round",lineCap:"butt"})).Iw,d=d.distance,0<h&&(l.a1=h,n.add(v+":"+g+":"+p,0,h,0,22),l.distance=d))}}},t.prototype.zw=function(t,e,r){if(void 0===r&&(r=!1),!t||!t.Dc||r){var n=new VectorTileSegements,i=(t.Oc=n,new VectorTileSegements),a=(t.Fc=i,r||(t.Dc=new PolygonBucket,t.pX=new PolylineBucket),e.polygon.sourceLayer),o=t.polygons;if(o){for(var s in o)if(!a||a===s)for(var u=0,c=(v=o[s]).length;u<c;u++){var f,h=v[u],l=+((g=this.Mn(e.polygon,h.properties)).visible||!g.filter);g.color[3]*=l,r?n.add(g.color+"",0,h.a1,0,22):0<(f=t.Dc.Nx(h.path,h.LQ))&&(h.a1=f,n.add(g.color+"",0,f,0,22))}var d=t.polygonOut;for(s in d)if(!a||a===s)for(var v,u=0,c=(v=d[s]).length;u<c;u++){var g,p,y,m=v[u],l=+((g=this.Mn(e.polygon,m.properties)).visible||!g.filter);t.visible.polygon[a]||(t.visible.polygon[a]=[]),l&&t.visible.polygon[a].push(m._id_),g.borderWidth*=l,r?i.add(g.borderColor+":"+g.dash+":"+g.borderWidth,0,m.a1,0,22):(p=(y=t.pX.g0(m.path,{X_:0,lineJoin:"round",lineCap:"butt"})).Iw,y=y.distance,0<p&&(m.a1=p,i.add(g.borderColor+":"+g.dash+":"+g.borderWidth,0,p,0,22),m.distance=y))}}}},t.prototype.nz=function(t,e,r){if(void 0===r&&(r=!1),!t||!t.A_||r){var n=new NebulaSegements,i=(t.w0=n,r||(t.A_=new FillExtrusionBucket),e.polyhedron.sourceLayer),a=t.polyhedrons;if(a)for(var o in t.visible.polyhedron[i]=[],a)if(!i||i===o)for(var u=a[o],c=0,f=u.length;c<f;c++){var h=u[c],l=h.properties,d=+((l=this.Mn(e.polyhedron,void 0===l?{}:l)).visible||!l.filter);t.visible.polyhedron[i]||(t.visible.polyhedron[i]=[]),d?t.visible.polyhedron[i].push(h._id_):(l.topColor=void 0,l.sideColor=void 0,l.texture=""),r?n.add(h._id_,1e3,h.a1,0,22,l.texture,l.topColor,l.sideColor):0<(d=t.A_.tz(h.path,h.height,h.LQ))&&(h.a1=d,n.add(h._id_,1e3,d,0,22,l.texture,l.topColor,l.sideColor))}}},t.prototype.SX=function(t,e,r){if(void 0===r&&(r=!1),!t||!t.dX||r){var n=t.IX,n=new VectorTileSegements,i=(t.IX=n,t.dX=new CircleBucket,e.point.sourceLayer),a=t.points;if(a)for(var o in t.visible.point[i]=[],a)if(!i||i===o)for(var u=a[o],c=0,f=u.length;c<f;c++){var h=u[c],l=this.Mn(e.point,h.properties);t.visible.point[i]||(t.visible.point[i]=[]),t.visible.point[i].push(h._id_),0<(h=t.dX.wb(h.path[0],l))&&n.add("point",0,h,0,22)}}},t.prototype.i1=function(t,e,r){if(void 0===r&&(r=!1),!t||!t.labels||r){t.labels=[];var n=e.label.sourceLayer,i=(t.visible.label[n]=[],t.points[n]);if(i)for(var a=0,o=i.length;a<o;a++){var s=i[a],c=(u=this.g8t(s)).height,u=u.w8t,f=this.Mn(e.label,s.properties);t.visible.label[n].push(s._id_),t.labels.push(exports.Ln(exports.Ln({},f),{position:u?__spreadArrays(s.lnglat,[c+1]):s.lnglat}))}}},t.prototype.Mn=function(t,e){var r,n={visible:!0,filter:!0};for(r in t){var i=t[r];n[r]="style"===r||"icon"===r||"text"===r?this.Mn(i,e):"function"==typeof i?i()(e,t.injection):i,-1<r.toLowerCase().indexOf("color")&&(n[r]=Util.color2RgbaArray(n[r])),"filter"===r&&(n.filter=this.$X(e,i))}return n},t.prototype.AX=function(t){var e,r={};for(e in t){var n=t[e];n.indexOf&&-1<n.indexOf("function")?(n=n.replace("function","return function"),r[e]=new Function(n)):r[e]="style"===e||"icon"===e||"text"===e?this.AX(n):n}return r},t.prototype.$X=function(t,e){if(e){var r=e[0],n=e[1],i=e[2],a=t[r];switch(n){case"in":return-1<i.indexOf(a);case"out":return i.indexOf(a)<0}}return!0},t.prototype.d8t=function(t,e){var r=t.projectionId,n=t.zS,t=t.Ro,i=ProjectionManager.getProjection(r),r=t[0],a=t[1],o=t[2],t=t[3],r=__spreadArrays(i.unproject(r,a),i.unproject(o,t)),s=null==(a=bboxClip(polygon([e]),r).geometry)?void 0:a.coordinates[0];if(!s)return s;for(var u=[],c=0;c<s.length;c++){var f=s[c],f=i.project(f[0],f[1]);u.push([f[0]-n.center[0],f[1]-n.center[1]])}return u},t.prototype.g8t=function(t){var e="Y"===(t=t.properties||{})._AS_CUBE&&t._HEIGHT_PROP,t=e?+t[t._HEIGHT_PROP]:0;return{w8t:e,height:t=Number.isNaN(t)||t<0?0:t}},t}(),Ring={read:function(t,e){return t.nw(Ring.iw,{path:[]},e)},iw:function(t,e,r){0===t&&r.tw(e.path,!0)},write:function(t,e){if(t.path)for(var r=0;r<t.path.length;r++)e.rw(0,t.path[r])}},Building={read:function(t,e){return t.nw(Building.iw,{minzoom:0,maxzoom:0,path:[],height:0,ew:"",altitude:0},e)},iw:function(t,e,r){0===t?e.minzoom=r.ow():1===t?e.maxzoom=r.ow():2===t?e.path.push(Ring.read(r,r.ow()+r.pos)):3===t?e.height=r.ow():4===t?e.ew=r.aw():5===t&&(e.altitude=r.ow())},write:function(t,e){if(t.minzoom&&e.rw(0,t.minzoom),t.maxzoom&&e.rw(1,t.maxzoom),t.path)for(var r=0;r<t.path.length;r++)e.fw(2,Ring.write,t.path[r]);t.height&&e.rw(3,t.height),t.ew&&e.uw(4,t.ew),t.altitude&&e.rw(5,t.altitude)}},BuildingSameStyle={read:function(t,e){return t.nw(BuildingSameStyle.iw,{mainkey:0,subkey:0,items:[],resolution:0},e)},iw:function(t,e,r){0===t?e.mainkey=r.ow():1===t?e.subkey=r.ow():2===t?e.items.push(Building.read(r,r.ow()+r.pos)):3===t&&(e.resolution=r.ow())},write:function(t,e){if(t.mainkey&&e.rw(0,t.mainkey),t.subkey&&e.rw(1,t.subkey),t.items)for(var r=0;r<t.items.length;r++)e.fw(2,Building.write,t.items[r]);t.resolution&&e.rw(3,t.resolution)}},buildingLayer={read:function(t,e){return t.nw(buildingLayer.iw,{building:[]},e)},iw:function(t,e,r){0===t&&e.building.push(BuildingSameStyle.read(r,r.ow()+r.pos))},write:function(t,e){if(t.building)for(var r=0;r<t.building.length;r++)e.fw(0,BuildingSameStyle.write,t.building[r])}},Poi={read:function(t,e){return t.nw(Poi.IQ,{minzoom:0,maxzoom:0,pos:[],cw:"",ew:"",name:"",rank:0,BQ:"",name_en:"",QQ:"",CQ:"",$G:[],iQ:[],JQ:[]},e)},IQ:function(t,e,r){0===t?e.minzoom=r.ow():1===t?e.maxzoom=r.ow():2===t?r.tw(e.pos,!0):3===t?e.cw=r.aw():4===t?e.ew=r.aw():5===t?e.name=r.aw():6===t?e.rank=r.ow():7===t?e.BQ=r.aw():8===t?e.name_en=r.aw():9===t?e.QQ=r.aw():10===t?e.CQ=r.aw():11===t?r.tw(e.$G):12===t?r.tw(e.iQ):13===t&&r.tw(e.JQ)},write:function(t,e){if(t.minzoom&&e.rw(0,t.minzoom),t.maxzoom&&e.rw(1,t.maxzoom),t.pos)for(var r=0;r<t.pos.length;r++)e.rw(2,t.pos[r]);if(t.cw&&e.uw(3,t.cw),t.ew&&e.uw(4,t.ew),t.name&&e.uw(5,t.name),t.rank&&e.rw(6,t.rank),t.BQ&&e.uw(7,t.BQ),t.name_en&&e.uw(8,t.name_en),t.QQ&&e.uw(9,t.QQ),t.CQ&&e.uw(10,t.CQ),t.$G)for(r=0;r<t.$G.length;r++)e.rw(11,t.$G[r]);if(t.iQ)for(r=0;r<t.iQ.length;r++)e.rw(12,t.iQ[r]);if(t.JQ)for(r=0;r<t.JQ.length;r++)e.rw(13,t.JQ[r])}},PoiSameStyle={read:function(t,e){return t.nw(PoiSameStyle.IQ,{mainkey:0,subkey:0,items:[],resolution:0},e)},IQ:function(t,e,r){0===t?e.mainkey=r.ow():1===t?e.subkey=r.ow():2===t?e.items.push(Poi.read(r,r.ow()+r.pos)):3===t&&(e.resolution=r.ow())},write:function(t,e){if(t.mainkey&&e.rw(0,t.mainkey),t.subkey&&e.rw(1,t.subkey),t.items)for(var r=0;r<t.items.length;r++)e.fw(2,Poi.write,t.items[r]);t.resolution&&e.rw(3,t.resolution)}},PoiLayer={read:function(t,e){return t.nw(PoiLayer.IQ,{poilabel:[]},e)},IQ:function(t,e,r){0===t&&e.poilabel.push(PoiSameStyle.read(r,r.ow()+r.pos))},write:function(t,e){if(t.poilabel)for(var r=0;r<t.poilabel.length;r++)e.fw(0,PoiSameStyle.write,t.poilabel[r])}},Ring$1={read:function(t,e){return t.nw(Ring$1.iw,{path:[]},e)},iw:function(t,e,r){0===t&&r.tw(e.path,!0)},write:function(t,e){if(t.path)for(var r=0;r<t.path.length;r++)e.rw(0,t.path[r])}},Region={read:function(t,e){return t.nw(Region.iw,{minzoom:0,maxzoom:0,path:[],sw:""},e)},iw:function(t,e,r){0===t?e.minzoom=r.ow():1===t?e.maxzoom=r.ow():2===t?e.path.push(Ring$1.read(r,r.ow()+r.pos)):3===t&&(e.sw=r.aw())},write:function(t,e){if(t.minzoom&&e.rw(0,t.minzoom),t.maxzoom&&e.rw(1,t.maxzoom),t.path)for(var r=0;r<t.path.length;r++)e.fw(2,Ring$1.write,t.path[r]);t.sw&&e.uw(3,t.sw)}},RegionSameStyle={read:function(t,e){return t.nw(RegionSameStyle.iw,{mainkey:0,subkey:0,items:[],resolution:0},e)},iw:function(t,e,r){0===t?e.mainkey=r.ow():1===t?e.subkey=r.ow():2===t?e.items.push(Region.read(r,r.ow()+r.pos)):3===t&&(e.resolution=r.ow())},write:function(t,e){if(t.mainkey&&e.rw(0,t.mainkey),t.subkey&&e.rw(1,t.subkey),t.items)for(var r=0;r<t.items.length;r++)e.fw(2,Region.write,t.items[r]);t.resolution&&e.rw(3,t.resolution)}},regionLayer={read:function(t,e){return t.nw(regionLayer.iw,{region:[]},e)},iw:function(t,e,r){0===t&&e.region.push(RegionSameStyle.read(r,r.ow()+r.pos))},write:function(t,e){if(t.region)for(var r=0;r<t.region.length;r++)e.fw(0,RegionSameStyle.write,t.region[r])}},Road={read:function(t,e){return t.nw(Road.iw,{minzoom:0,maxzoom:0,path:[],shield:"",shieldType:0,name:"",rank:0,name_en:"",BQ:"",QQ:"",CQ:"",$G:[],iQ:[]},e)},iw:function(t,e,r){0===t?e.minzoom=r.ow():1===t?e.maxzoom=r.ow():2===t?r.tw(e.path,!0):3===t?e.shield=r.aw():4===t?e.shieldType=r.ow():5===t?e.name=r.aw():6===t?e.rank=r.ow():7===t?e.BQ=r.aw():8===t?e.name_en=r.aw():9===t?e.QQ=r.aw():10===t?e.CQ=r.aw():11===t?r.tw(e.$G):12===t&&(e.id=r.ow())},write:function(t,e){if(t.minzoom&&e.rw(0,t.minzoom),t.maxzoom&&e.rw(1,t.maxzoom),t.path)for(var r=0;r<t.path.length;r++)e.rw(2,t.path[r]);if(t.shield&&e.uw(3,t.shield),t.shieldType&&e.rw(4,t.shieldType),t.name&&e.uw(5,t.name),t.rank&&e.rw(6,t.rank),t.BQ&&e.uw(7,t.BQ),t.name_en&&e.uw(8,t.name_en),t.QQ&&e.uw(9,t.QQ),t.CQ&&e.uw(10,t.CQ),t.$G)for(r=0;r<t.$G.length;r++)e.rw(11,t.$G[r]);t.id&&e.rw(12,t.id)}},RoadSameStyle={read:function(t,e){return t.nw(RoadSameStyle.iw,{mainkey:0,subkey:0,items:[],resolution:0},e)},iw:function(t,e,r,n){0===t?e.mainkey=r.ow():1===t?e.subkey=r.ow():2===t?e.items.push(Road.read(r,r.ow()+r.pos)):3===t&&(e.resolution=r.ow())},write:function(t,e){if(t.mainkey&&e.rw(0,t.mainkey),t.subkey&&e.rw(1,t.subkey),t.items)for(var r=0;r<t.items.length;r++)e.fw(2,Road.write,t.items[r]);t.resolution&&e.rw(3,t.resolution)}},roadLayer={read:function(t,e){return t.nw(roadLayer.iw,{road:[]},e)},iw:function(t,e,r,n){0===t&&e.road.push(RoadSameStyle.read(r,r.ow()+r.pos))},write:function(t,e){if(t.road)for(var r=0;r<t.road.length;r++)e.fw(0,RoadSameStyle.write,t.road[r])}},roadNameLayer={read:function(t,e){return t.nw(roadNameLayer.iw,{roadName:[]},e)},iw:function(t,e,r,n){0===t&&e.roadName.push(RoadSameStyle.read(r,r.ow()+r.pos))},write:function(t,e){if(t.roadName)for(var r=0;r<t.road.length;r++)e.fw(0,RoadSameStyle.write,t.roadName[r])}},Result={read:function(t,e){return t.nw(Result.IQ,{tiles:[],version:"",status:!1,db:""},e)},IQ:function(t,e,r){0===t?e.tiles.push(Result.Gh.read(r,r.ow()+r.pos)):1===t?e.version=r.aw():2===t?e.status=r.vw():3===t&&(e.db=r.aw())},write:function(t,e){if(t.tiles)for(var r=0;r<t.tiles.length;r++)e.fw(0,Result.Gh.write,t.tiles[r]);t.version&&e.uw(1,t.version),t.status&&e.hw(2,t.status),t.db&&e.uw(3,t.db)},Gh:{}},Style=(Result.Gh.read=function(t,e){return t.nw(Result.Gh.IQ,{z:0,x:0,y:0,layers:[],t:0},e)},Result.Gh.IQ=function(t,e,r){0===t?e.z=r.ow():1===t?e.x=r.ow():2===t?e.y=r.ow():3===t?e.layers.push(Result.Gh.lw.read(r,r.ow()+r.pos)):4===t&&(e.t=r.ow())},Result.Gh.write=function(t,e){if(t.z&&e.rw(0,t.z),t.x&&e.rw(1,t.x),t.y&&e.rw(2,t.y),t.layers)for(var r=0;r<t.layers.length;r++)e.fw(3,Result.Gh.lw.write,t.layers[r]);t.t&&e.rw(4,t.t)},Result.Gh.lw={},Result.Gh.lw.read=function(t,e){return t.nw(Result.Gh.lw.IQ,{z:0,x:0,y:0,type:0,d:null,t:0},e)},Result.Gh.lw.IQ=function(t,e,r){0===t?e.z=r.ow():1===t?e.x=r.ow():2===t?e.y=r.ow():3===t?e.type=r.ow():4===t?e.d=r.mw():5===t&&(e.t=r.ow())},Result.Gh.lw.write=function(t,e){t.z&&e.rw(0,t.z),t.x&&e.rw(1,t.x),t.y&&e.rw(2,t.y),t.type&&e.rw(3,t.type),t.d&&e.ww(4,t.d),t.t&&e.rw(5,t.t)},{read:function(t,e){return t.nw(Style.IQ,{bgColor:"",zn:0,xV:"",stylemaps:[],test:0},e)},IQ:function(t,e,r){1===t?e.bgColor=r.aw():2===t?e.zn=r.ow(!0):3===t?e.xV=r.aw():4===t?e.stylemaps.push(Style.SV.read(r,r.ow()+r.pos)):5===t&&(e.test=r.ow(!0))},write:function(t,e){if(t.bgColor&&e.uw(1,t.bgColor),t.zn&&e.rw(2,t.zn),t.xV&&e.uw(3,t.xV),t.stylemaps)for(var r=0;r<t.stylemaps.length;r++)e.fw(4,Style.SV.write,t.stylemaps[r]);t.test&&e.rw(5,t.test)},SV:{}}),decodeStyle=(Style.SV.read=function(t,e){return t.nw(Style.SV.IQ,{key:[],browserStyle:[],levelStyleMapping:[]},e)},Style.SV.IQ=function(t,e,r){1===t?e.key.push(r.aw()):2===t?e.browserStyle.push(r.aw()):3===t&&r.tw(e.levelStyleMapping,!0)},Style.SV.write=function(t,e){if(t.key)for(var r=0;r<t.key.length;r++)e.uw(1,t.key[r]);if(t.browserStyle)for(r=0;r<t.browserStyle.length;r++)e.uw(2,t.browserStyle[r]);if(t.levelStyleMapping)for(r=0;r<t.levelStyleMapping.length;r++)e.rw(3,t.levelStyleMapping[r])},function(t){return t=new Pbf(t),Style.read(t)}),decodePois=function(t){return t=new Pbf(t),PoiLayer.read(t)},decodeRoads=function(t){return t=new Pbf(t),roadLayer.read(t)},decodeRoadNames=function(t){return t=new Pbf(t),roadNameLayer.read(t)},decodeRegions=function(t){return t=new Pbf(t),regionLayer.read(t)},decodeBuildings=function(t){return t=new Pbf(t),buildingLayer.read(t)},decodeTiles=function(t){for(var t=new Pbf(t),e=(t=Result.read(t)).tiles,r=0,n=e.length;r<n;r+=1)for(var i=e[r].layers,a=0,o=i.length;a<o;a+=1)switch(i[a].type){case 0:i[a].d=decodePois(i[a].d);break;case 1:i[a].d=decodeRoads(i[a].d);break;case 2:i[a].d=decodeRegions(i[a].d);break;case 3:i[a].d=decodeBuildings(i[a].d);break;case 4:i[a].d=decodeRoadNames(i[a].d)}return t},CONSTS$2={_U:["th","my"]},SDFManagerBase=function(e){function t(){var t=e.call(this)||this;return t.CLASS_NAME="SDFManagerBase",t}return __extends(t,e),t.jU=function(t){return t=LangManager.gG(t+""),-1!==CONSTS$2._U.indexOf(t)},t.prototype.FU=function(t){for(var e=[],r=0,n=t;r<n.length;r++){var i=n[r];LangManager.gG(i+""),e.push(i)}return{UU:e,DU:[]}},t.prototype.measureText=function(t,e,r){if(r){r.font=(e||12)+"px";for(var n="",i=0,a=t;i<a.length;i++){var o=a[i];n+=String.fromCharCode(o)}return r.measureText(n).width}return 0},t.prototype.lineBreak=function(t,e){var n=void 0===(r=(e=void 0===e?{}:e).fontSize)?12:r,r=e.maxWidth,i=e.CO,a=void 0===(a=e.fj)?6:a,s=void 0===(o=e.type)?"en":o,u=e.YQ,c=(t=void 0===t?"":t).split(" "),f=[],o=r||90,h=0,l=[],d=[],v=[0];if("labelsLayer"===e.from){for(var g=t.length,p=Math.ceil(g/a),y=Math.ceil(g/p),m=void 0,b=0,T=0;T<p;T++){l[T]||(l[T]=[b]),0===T?m=i.slice(0,b=g%y||y):(m=i.slice(b,b+y),b+=y);var A=this.measureText(m,n,u);d.push(A),l[T].push(b)}for(T=0;T<l.length;T++){var x=l[T];v.push(x[x.length-1])}}else if("ch"===s)for(T=b=0;T<c.length;T++){for(var x=c[T],m=[],M=0;M<x.length;M++)m.push(x.charCodeAt(M));A=this.measureText(m,n,u),d.push(A),l.push([b,b+x.length+1]),b+=x.length+1,v.push(b)}else{for(T=0;T<c.length;T++){var S=c[T],m=[];if("en"===s)for(var w=0;w<S.length;w++)m.push(S.charCodeAt(w));else{var P=-1===(P=i.indexOf("32",h))?i.length:P;m=i.slice(h,P),h=P+1}A=this.measureText(m,n,u),f.push(A)}for(r=Math.max.apply(Math,f),l=(e=this.GU(f,o<r?r:o)).lines,d=e.BU,T=0;T<l.length;T++){var x=l[T],I=c.slice(x[0],x[x.length-1]+1).join(" "),C=t.indexOf(I),I=I.length-1;v.push(C+I+1)}}return{lines:l,oQ:v,width:d,maxWidth:Math.max.apply(Math,d)}},t.prototype.GU=function(t,e){for(var r=[],n=0,i=0,a=[],o=0,s=t.length,u=0;u<s;u++){var c=t[u];i+=c,r[n]||(r[n]=[]),e<i&&(r[++n]=[],a.push(o),o=i=0),r[n].push(u),o+=c,u===s-1&&a.push(o)}return{lines:r,BU:a}},t.prototype.destroy=function(){},t}(Event),LoadFlag,SDFManagerWorker=(function(t){t.TEXTUREFINISH="TEXTUREFINISH",t.UNLOAD="unload",t.LOADING="loading",t.LOADED="loaded",t.FAIL="fail"}(LoadFlag=LoadFlag||{}),function(t){t.AllLoaded="AllLoaded",t.AllUnLoaded="AllUnLoaded",t.SomeLoading="SomeLoading",t.AllLoading="AllLoading"}(exports.qu||(exports.qu={})),function(r){function t(t){var e=r.call(this)||this;return e.CLASS_NAME="SDFManagerWorker",e.protocol="https",e.range=[],e.info={},e.dc=0,e._c={},e._size=24,e.nc=new AdaptorMap,e.xc=[],e.bc={},e.Xu={},e.yc=1,e.fN={},e.ac=t.z_,e._parent=t.parent,e}return __extends(t,r),t.prototype.vW=function(t,e){var n=void 0===(r=e.tiles)?[]:r,i=e.cb,a=e.optimalZoom,r=void 0===(r=e.tags)?[]:r,o=e.stamp;this.cN=a,this.fN[o]||(this.fN[o]=r);for(var s=0;s<n.length;s++){var u=n[s],c=this.Zu(t);e.result=c,this.loadData(t,{tile:u,result:c,cb:i,optimalZoom:a,stamp:o,i:s})}},t.prototype.loadData=function(t,e){var r=this,n=e.cb,i=e.tile,a=e.result,o=(e.optimalZoom,e.stamp),s=e.i,u=a||this.Zu(t);switch(u.status){case exports.qu.AllLoaded:n([]);break;case exports.qu.AllUnLoaded:var c=this.Yu(n,{tile:i,stamp:o,index:s});this.MI(u.Vu,function(t){r.Xu[c]=t=void 0===t?{}:t,r.Hu()});break;case exports.qu.SomeLoading:var f=this.Yu(n,{tile:i,stamp:o,index:s});this.MI(u.Vu,function(t){r.Xu[f]=t=void 0===t?{}:t,r.Hu()});break;case exports.qu.AllLoading:var h=this.Yu(n,{tile:i,stamp:o,index:s});this.Xu[h]=[],this.Hu()}},t.prototype.mz=function(t){var e=this.info||{};return e[t]&&(e=e[t]).pos&&e.info[t]?{key:t,index:exports.cY.dynamic,char:e.info[t],pos:e.pos}:null},t.prototype.measureText=function(t,e){for(var r=CONSTS.ic,n=0,i=this.info,a=e/this._size,o=this.nc,s=0,u=t;s<u.length;s++){var c=u[s],f=void 0,h=c;(f=o.get(h))||i.hasOwnProperty(h)&&(h=i[h].info[h])&&this.nc.set(c,f=h[4]),n+=(f+r)*a}return n},t.prototype.Ju=function(t){for(var e={},r=0,n=t;r<n.length;r++){var a=(i=n[r]).range,o=i.info,i=i.pos,s=this.info;s[a],s[a]={info:((s={})[a]=o,s),pos:i},this.range.push(a),e[a]=1}return e},t.prototype.AI=function(t,e){this.info[t]&&(this.info[t].pos=e)},t.prototype.MI=function(e,r){for(var n=this,t=(void 0===e&&(e=[]),CONSTS.Mj),i=0,a=e;i<a.length;i++){var o=a[i];this._c[o]=!0}for(var s=[],u=0,c=this.FU(e),f=c.UU,h=c.DU,l=h.length,d=Math.ceil(l/CONSTS.Mj);u<d;){var v=h.slice(v=t*u,l<v+t?l:v+t),v=this.xI(v);s.push(v),u++}s.push(this.pG(f)),Promise.all(s).then(function(t){n.II(e),t=n.zU(t),n.Ju(t),r(t)})},t.prototype.pG=function(t){var r=this;return new Promise(function(e){r._parent.loadWordsByFront({Es:t,cb:function(t){e(t)}})})},t.prototype.xI=function(t){var a=this,e=this.fc()+("/getsdfdata?chars="+t.join(",").split(",").join("|"));return new Promise(function(n,i){XHR.send(e,{Me:"json",method:"get",qw:function(t){var e,r;t&&t.info?(e=a.vc(t.info),r=new ImageDataWraper(e,t.url),t.url=r,n({range:e,info:t})):i(null)},error:function(){i(null)}})})},t.prototype.fc=function(){var t=CONSTS.pc,e=this.protocol+t[this.dc];return this.dc=(this.dc+1)%t.length,e},t.prototype.vc=function(t){void 0===t&&(t={});(t=map(Object.keys(t),function(t){return parseInt(t,10)})).sort(function(t,e){return t-e});var e=t.length;return 2<=e?t[0]+"-"+t[e-1]:1===e?""+t[0]:""},t.prototype.gc=function(t){var e=this.range||[],r=this.info||{};if(-1!==e.indexOf(t))return!0;for(var n=parseInt(t,10),i=0,a=e;i<a.length;i++){var o=a[i];if(o.indexOf("-")<0){if(n===+o&&(r[o]&&r[o].info||{})[t])return!0}else{var s=o.split("-"),u=parseInt(s[0]||"",10),s=parseInt(s[1]||"",10);if(u<=n&&n<=s&&(r[o]&&r[o].info||{})[t])return!0}}return!1},t.prototype.wc=function(t){return this._c[t]},t.prototype.Zu=function(t){for(var e=[],r=0,n=0,i=0,a=t;i<a.length;i++){var o=a[i];this.gc(o)||(this.wc(o)?n+=1:(r+=1,e.push(o)))}return 0===n&&0===r?{status:exports.qu.AllLoaded,Vu:e}:0<r&&0===n?{status:exports.qu.AllUnLoaded,Vu:e}:0===r&&0<n?{status:exports.qu.AllLoading,Vu:e}:{status:exports.qu.SomeLoading,Vu:e}},t.prototype.Yu=function(t,e){void 0===e&&(e={});var r=this.yc+=1;return this.xc.push(r),this.bc[r]=t,this.bc[r]={cb:t,params:e},r},t.prototype.Hu=function(){var t,e,r=this.xc[0];r&&(t=this.Xu[r])&&(this.xc.shift(),(e=this.bc[r])?e.cb(t):console.error("sdf task error"),delete this.Xu[r],delete this.bc[r],this.Hu())},t.prototype.II=function(t){for(var e=0,r=t;e<r.length;e++){var n=r[e];delete this._c[n]}},t.prototype.zU=function(t){for(var e=[],r=0,n=t=void 0===t?[]:t;r<n.length;r++){var i=n[r];if(Array.isArray(i))for(var a=0,o=i;a<o.length;a++){var s=o[a];e.push(s)}else e.push(i)}return e},t}(SDFManagerBase)),TaskManager=(function(t){t[t.stop=0]="stop",t[t.finish=1]="finish",t[t.pause=2]="pause"}(exports.vY||(exports.vY={})),function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.id=0,t.LV=[],t._V={},t.CV={},t}return __extends(t,e),t.prototype.register=function(t,e,r){if(this.CV[t])throw Error("TaskManager: Exist Task Creator");this.CV[t]={PV:e,OV:r}},t.prototype.add=function(t,e){var r;if(this.CV[t])return t=this.CV[t],r=this.id++,e=t.PV(e),this.LV.push({UQ:e,OV:{id:r,kY:t.OV.kY}}),r;throw Error("TaskManager: Not Exist Task Type")},t.prototype.XQ=function(t,e,r){void 0===e&&(e={kY:1/0}),void 0===r&&(r=!1);var n=this.id++;return r?this.LV.unshift({UQ:t,OV:{id:this.id++,kY:e.kY}}):this.LV.push({UQ:t,OV:{id:this.id++,kY:e.kY}}),n},t.prototype.exec=function(t){this.jV();for(var e=t,r=Date.now();0<e;){var n=this.LV.shift();if(!n)break;var i=n.UQ.play(e);n.UQ.status===exports.vY.finish?this.emit("task:"+n.OV.id,{data:i}):this.LV.unshift(n),e=t-(Date.now()-r),0===this.LV.length&&this.emit("taskclear",!0)}},t.prototype.xY=function(){return 0<this.LV.length},t.prototype.destroy=function(){this.LV=[]},t.prototype.clear=function(e){this.LV=e?this.LV.filter(function(t){return t.UQ.type===e}):[]},t.prototype.jV=function(){this.LV.sort(function(t,e){return t.OV.kY-e.OV.kY})},t}(Event)),Actor=function(){function t(t,e,r){this.UD=!1,this.gI=this.gI.bind(this),this.target=t,this.parent=e,this.dI=r,this.pI={},this.bI=Browser.DW?1:0,this.target.addEventListener("message",this.gI,!1)}return t.prototype.send=function(t,e,r,n){var i=this,a=r?this.dI+":"+this.bI:null,o=(this.bI+=2,r&&a&&(this.pI[a]=r),[]),s=serialize(e,o);if(this.target.postMessage({yI:n,mI:this.dI,type:t,id:String(a),data:s},o),r)return{cancel:function(){i.target.postMessage({yI:n,mI:i.dI,type:"<cancel>",id:String(a),key:e.ya}),a&&delete i.pI[a]}}},t.prototype.gI=function(t){var n,e,i=this;Browser.DW&&"destroy"===t.data.type&&self.close();var a=(t=t.data).id;t.yI&&this.dI!==t.yI||("<cancel>"===t.type?(e=this.pI[t.id],delete this.pI[t.id],e&&e("<cancel>")):"<response>"===t.type?(e=this.pI[t.id],delete this.pI[t.id],e&&t.error?e(deserialize(t.error)):e&&e(null,deserialize(t.data))):void 0!==t.id&&this.parent[t.type]&&(n=function(t,e){delete i.pI[a];var r=[],e=serialize(e,r);i.target.postMessage({mI:i.dI,type:"<response>",id:String(a),error:t?serialize(t):null,data:e},r),n=void 0},this.pI[t.id]=null,e=this.parent[t.type](t.mI,deserialize(t.data),n))&&null===this.pI[t.id]&&(this.pI[t.id]=e.cancel))},t.prototype.remove=function(){this.target.removeEventListener("message",this.gI,!1)},t}(),TaskPool=function(){function t(){this.listener={},this.SN={}}return t.prototype.nS=function(r,t){var n=this;return this.SN[r]=!0,this.listener[r]||(this.listener[r]=[]),t(function(t,e){n.$N(r,t,e)})},t.prototype.cancel=function(t){delete this.SN[t]},t.prototype.has=function(t){return Boolean(this.SN[t])},t.prototype.GN=function(t){return this.listener[t]&&0<this.listener[t].length},t.prototype.SH=function(t,e){this.listener[t]||(this.listener[t]=[]),this.listener[t].push(e)},t.prototype.kN=function(t,e){this.listener[t]&&-1<(e=this.listener[t].indexOf(e))&&this.listener[t].splice(e,1)},t.prototype.$N=function(t,e,r){delete this.SN[t];var n=this.listener[t];if(delete this.listener[t],n)for(var i=0,a=n;i<a.length;i++)(0,a[i])(e,r)},t}(),StaticSDFManagerWorker=function(){function t(t,e){this.parent=t,this.CN=e,this.jN=[],this.EN=0,this._N={},this.NN={},this.LN=new TaskPool,this.zW(this.parent.GW.db),this.parent.Uh.send("updateDataVersion",this.parent.GW.nebulaVersion)}return t.prototype.loadData=function(t,o,r){var s,u,c,n,e,f,h=this,l=staticSDFTileKeyToKey(t);return l?(s=this.fc(),u=s+l+".json",c=s+l+(o.mH?".webp":".png"),n=this.parent.protocol,void 0!==this._N[l]&&void 0!==this.NN[l]?(r(null,[this._N[l],this.NN[l]]),{cancel:noop$1}):(e=this.LN.has(l),this.LN.SH(l,f=function(t,e){e&&(e.protocol=n),r(t,e)}),e?{cancel:function(){h.NW(t)}}:this.LN.nS(l,function(r){function n(t,e){r(null,e)}var i=0,a=[],t=h.ON(u,function(t,e){t?"404"!==t?(console.log(t),n(0,null)):(a[0]=e?{}:null,h._N[l]=a[0],2==++i&&n(0,a)):(a[0]=e,h._N[l]=e,2==++i&&n(0,a))}),e=h.IN(c,function(t,e){t||!e?"404"!==t?(console.log(t),n(0,e)):(a[1]=null,h.NN[l]=a[1],2==++i&&n(0,a)):!e||e.byteLength<128?(a[1]=null,h.NN[l]=a[1],2==++i&&n(0,a)):o.imageBitmap?ImageDataWraper.AV(e).then(function(t){"success"!==(t=new ImageDataWraper(c,t,{imageBitmap:!0})).status?(console.log("createObjectURL fail"),r("createObjectURL fail",null)):(a[1]=t,h.NN[l]=t,2==++i&&n(0,a))}):"success"!==(t=new ImageDataWraper(s,e)).status?(console.log("createObjectURL fail"),n(0,null)):(a[1]=t,h.NN[l]=t,2==++i&&n(0,a))});return"lesszoom10"!==l?{cancel:function(){h.LN.kN(l,f),h.LN.GN(l)||(t.abort(),e.abort(),h.LN.cancel(l)),f("cancel",null)}}:{cancel:function(){h.LN.kN(l,f),f("cancel",null)}}}))):(console.log("!key"),r(null,[void 0,null]),{cancel:noop$1})},t.prototype.NW=function(t){var e=this.NN[t];e&&e.destroy(),delete this.NN[t],delete this._N[t]},t.prototype.zW=function(t){this._N={},this.NN={},this.jN=["://glyph.amap.com/sdf"+t+"/","://glyph01.amap.com/sdf"+t+"/","://glyph02.amap.com/sdf"+t+"/","://glyph03.amap.com/sdf"+t+"/","://glyph04.amap.com/sdf"+t+"/"]},t.prototype.ON=function(t,e){return this.CN.send(t,{Me:"json",method:"get",qw:function(t){e(null,t||null)},Aw:function(t){e(t&&t.message||"unknown error")}})},t.prototype.IN=function(t,e){return this.CN.send(t,{Me:"arraybuffer",method:"get",qw:function(t){t?e(null,t):e("empty data",null)},Aw:function(t){e(t&&t.message||"unknown error")}})},t.prototype.fc=function(){this.EN=this.EN%this.jN.length;var t=this.parent.protocol+this.jN[this.EN];return this.EN++,t},t}(),emptyObj={},SDFStaticTextureCache=function(){function t(t,e,r){this.parent=t,this.DN=e,this.UN=r,this.RN={},this.XN={}}return t.prototype.xH=function(t,e){void 0===e&&(e=!1);var r=staticSDFTileKeyToKey(t),n=this.RN[r];if(e){if(!n)return;n.indexOf(t)<0&&n.push(t)}return this.DN.getImage(r)},t.prototype.LB=function(t){return t=staticSDFTileKeyToKey(t),this.XN[t]||emptyObj},t.prototype.bH=function(n,i,a,o){var t,s=this,u=staticSDFTileKeyToKey(n);i.type===ImageDataWraperType.bitmap?i.IV?(t=this.DN.getImage(i.hash),o(null,t)):this.DN.addImageBitmap(i.data,{url:u,cb:function(t,e){var r;t||(i.destroy(),s.RN[u]||(s.RN[u]=[],s.XN[u]=a),(r=s.RN[u]).indexOf(n)<0&&r.push(n)),o(t,e)}}):this.DN.addImage(u,{url:i.data,cb:function(t,e){var r;t||(s.RN[u]||(s.RN[u]=[],s.XN[u]=a),(r=s.RN[u]).indexOf(n)<0&&r.push(n)),o(t,e)}})},t.prototype.kH=function(t){var e=staticSDFTileKeyToKey(t),r=this.RN[e];r?(0<=(t=r.indexOf(t))&&r.splice(t,1),0===r.length&&(this.DN.RH(e),this.UN.deleteTileStaticSDF(e),delete this.RN[e],delete this.XN[e])):delete this.XN[e]},t}(),RenderThread=function(){function t(t){this.Jv=5,this.Qv=0,this.Yv=!1,this.render=t.render,this.check=t.check}return t.prototype.Yf=function(){this.Yv||(0<this.Jv&&this.Kv?(this.render(),this.Qv=Util.requestAnimFrame(this.Yf.bind(this))):(this.Jv<=0||!this.Kv)&&(this.Kv=!1,Util.cancelAnimFrame(this.Qv),this.Qv=0,this.Qv||this.check()&&(this.render(),this.setNeedUpdate(!0))),this.Jv--)},t.prototype.setNeedUpdate=function(t){this.Jv=5,t&&!this.Kv&&(this.Kv=t,Util.cancelAnimFrame(this.Qv),this.Qv=0,this.to()),this.Kv=t},t.prototype.to=function(){this.Qv||(this.Qv=Util.requestAnimFrame(this.Yf.bind(this)))},t.prototype.destroy=function(){this.Yv=!0},t}();Uint8Array.prototype.fill||(Uint8Array.prototype.fill=Array.prototype.fill),Float32Array.prototype.slice||Object.defineProperty(Float32Array.prototype,"slice",{value:function(t,e){return new Float32Array(Array.prototype.slice.call(this,t,e))}}),Float64Array.prototype.slice||Object.defineProperty(Float64Array.prototype,"slice",{value:function(t,e){return new Float64Array(Array.prototype.slice.call(this,t,e))}}),exports.Ge=AMapStyleSource,exports.Bh=Actor,exports.OZ=AdaptorMap,exports.bb=BezierUtil,exports.tc=CONSTS,exports._n=Color,exports.ZQ=ComputeTileRange,exports.hL=Coordinate,exports.PY=DangerousFontSize,exports.La=DynamicVertice,exports.Event=Event,exports.iz=FillExtrusionBucket,exports.GeometryUtil=GeometryUtil,exports.rW=GeometryUtilCls,exports.x_=HALF_WORLD_SIZE,exports.WQ=ImageDataWraper,exports.pZ=InnerClass,exports.eG=Labels,exports.LabelsRenderUtil=LabelsRenderUtil,exports.bG=LangManager,exports.LngLat=LngLat$2,exports.ZY=LngLat2TileInnerCoord,exports.za=LocalTileZoom,exports.Ra=LocalZoom,exports.MapboxLabelFormat=MapboxLabelFormat,exports.fQ=MapboxSegements,exports.bX=MapboxVTSourceWorker,exports.Module=Module,exports.NebulaLabelFormat=NebulaLabelFormat,exports._w=NebulaSegements,exports.pa=NebulaTile,exports.wa=NebulaTileCoord,exports.pw=Pbf,exports.Pixel=Pixel,exports.PlaneGeometryUtil=PlaneGeometryUtil,exports.kS=PlaneGeometryUtilInstance,exports.K_=PolygonBucket,exports.oE=PolygonSegements,exports.J_=PolylineBucket,exports.ProjectionManager=ProjectionManager,exports.tS=Queue,exports.Vs=RasterTile,exports.wY=RenderThread,exports.vG=SDFManagerBase,exports.jb=SDFManagerWorker,exports.LH=SDFStaticTextureCache,exports.e0=SimpleCircleBucket,exports.Size=Size,exports.yp=SmartArrayBuffer,exports.xW=StaticSDFManagerWorker,exports.StyleParser=StyleParser,exports.Support=Browser,exports.vH=Task,exports.MY=TaskManager,exports.IH=TaskPool,exports.Gh=Tile,exports.ca=TileCoord,exports.V=transform,exports.Util=Util,exports.Sw=VectorTile,exports.tW=VectorTile$1,exports.LW=VectorTileSegements,exports.Yw=XHR,exports.T8t=__awaiter,exports.dZ=__decorate,exports.Ei=__extends,exports.x8t=__generator,exports.Pt=__spreadArrays,exports.assign=assign,exports.jw=calcTileMectorBounds,exports.clone=clone,exports.Ex=clone$1,exports.yn=cloneDeep,exports.create=create$3,exports.Il=create,exports.Dl=create$1,exports.Zl=create$2,exports.M8t=createCommonjsModule,exports.CZ=decodeStyle,exports.KQ=decodeTiles,exports.equals=equals$1,exports.Ru=equals,exports.every=every,exports.extend=extend,exports.filter=filter,exports.find=find,exports.findIndex=findIndex,exports.forEach=forEach,exports.vx=forIn,exports.Bu=fromValues$2,exports.xd=fromValues$3,exports.$Q=getMVTTileBbox,exports.vZ=getOutseaData,exports.Ol=getTranslation,exports.Ul=invert,exports.VB=isBezierCurve,exports.xs=isBounds,exports.sB=isCircleMarker,exports.isEmpty=isEmpty,exports.isEqual=isEqual,exports.isFunction=isFunction,exports.qG=isInnerLabelsLayer,exports.px=isLayer,exports.Bs=isLngLat,exports.iL=isLnglatLikeArray,exports.eL=isLnglatLikeArrayArray,exports.yL=isLnglatLikeArrayArrayArray,exports.vB=isNumber,exports.ys=isNumberArrayArray,exports.Ox=isNumberArrayArrayArray,exports.tL=isNumberArrayArrayArrayArray,exports.er=isOverlay,exports.RF=isOverlayGroup,exports.oy=isPixel,exports.GB=isPolyline,exports.ay=isSize,exports.FF=isVectorLayer,exports.jsonLngLatData=jsonLngLatData,exports.keys=keys,exports.labelsUtil=labelsUtil,exports.lcs=lcs,exports.lookAt=lookAt,exports.map=map,exports.multiply=multiply,exports.ou=ortho,exports.parseLngLatData=parseLngLatData,exports.perspective=perspective,exports.rbush=_rbush_2_0_2_rbush,exports.scale=scale$1,exports.set=set$1,exports.Pl=set,exports.some=some,exports.XY=tileInnerCoord2LngLat,exports.Gu=transformMat4,exports.vector=vector,exports.zoomRange=zoomRange}),define(["./shared"],function(polyfill){var _aesJs_3_1_2_aesJs=polyfill.M8t(function(i,t){function e(i){return parseInt(i)===i}function o(i){if(e(i.length)){for(var t=0;t<i.length;t++)if(!e(i[t])||i[t]<0||255<i[t])return;return 1}}function r(i,t){if(i.buffer&&"Uint8Array"===i.name)return t?i.slice?i.slice():Array.prototype.slice.call(i):i;if(Array.isArray(i)){if(o(i))return new Uint8Array(i);throw new Error("Array contains invalid value: "+i)}if(e(i.length)&&o(i))return new Uint8Array(i);throw new Error("unsupported array-like object")}function a(i){return new Uint8Array(i)}function n(i,t,e,o,h){null==o&&null==h||(i=i.slice?i.slice(o,h):Array.prototype.slice.call(i,o,h)),t.set(i,e)}var h,l={AAA:function(i){var t=[],e=0;for(i=encodeURI(i);e<i.length;){var o=i.charCodeAt(e++);37===o?(t.push(parseInt(i.substr(e,2),16)),e+=2):t.push(o)}return r(t)},iAA:function(i){for(var t=[],e=0;e<i.length;){var o=i[e];o<128?(t.push(String.fromCharCode(o)),e++):191<o&&o<224?(t.push(String.fromCharCode((31&o)<<6|63&i[e+1])),e+=2):(t.push(String.fromCharCode((15&o)<<12|(63&i[e+1])<<6|63&i[e+2])),e+=3)}return t.join("")}},s=(h="0123456789abcdef",{AAA:function(i){for(var t=[],e=0;e<i.length;e+=2)t.push(parseInt(i.substr(e,2),16));return t},iAA:function(i){for(var t=[],e=0;e<i.length;e++){var o=i[e];t.push(h[(240&o)>>4]+h[15&o])}return t.join("")}}),u={16:10,24:12,32:14},p=[1,2,4,8,16,32,64,128,27,54,108,216,171,77,154,47,94,188,99,198,151,53,106,212,179,125,250,239,197,145],d=[99,124,119,123,242,107,111,197,48,1,103,43,254,215,171,118,202,130,201,125,250,89,71,240,173,212,162,175,156,164,114,192,183,253,147,38,54,63,247,204,52,165,229,241,113,216,49,21,4,199,35,195,24,150,5,154,7,18,128,226,235,39,178,117,9,131,44,26,27,110,90,160,82,59,214,179,41,227,47,132,83,209,0,237,32,252,177,91,106,203,190,57,74,76,88,207,208,239,170,251,67,77,51,133,69,249,2,127,80,60,159,168,81,163,64,143,146,157,56,245,188,182,218,33,16,255,243,210,205,12,19,236,95,151,68,23,196,167,126,61,100,93,25,115,96,129,79,220,34,42,144,136,70,238,184,20,222,94,11,219,224,50,58,10,73,6,36,92,194,211,172,98,145,149,228,121,231,200,55,109,141,213,78,169,108,86,244,234,101,122,174,8,186,120,37,46,28,166,180,198,232,221,116,31,75,189,139,138,112,62,181,102,72,3,246,14,97,53,87,185,134,193,29,158,225,248,152,17,105,217,142,148,155,30,135,233,206,85,40,223,140,161,137,13,191,230,66,104,65,153,45,15,176,84,187,22],f=[82,9,106,213,48,54,165,56,191,64,163,158,129,243,215,251,124,227,57,130,155,47,255,135,52,142,67,68,196,222,233,203,84,123,148,50,166,194,35,61,238,76,149,11,66,250,195,78,8,46,161,102,40,217,36,178,118,91,162,73,109,139,209,37,114,248,246,100,134,104,152,22,212,164,92,204,93,101,182,146,108,112,72,80,253,237,185,218,94,21,70,87,167,141,157,132,144,216,171,0,140,188,211,10,247,228,88,5,184,179,69,6,208,44,30,143,202,63,15,2,193,175,189,3,1,19,138,107,58,145,17,65,79,103,220,234,151,242,207,206,240,180,230,115,150,172,116,34,231,173,53,133,226,249,55,232,28,117,223,110,71,241,26,113,29,41,197,137,111,183,98,14,170,24,190,27,252,86,62,75,198,210,121,32,154,219,192,254,120,205,90,244,31,221,168,51,136,7,199,49,177,18,16,89,39,128,236,95,96,81,127,169,25,181,74,13,45,229,122,159,147,201,156,239,160,224,59,77,174,42,245,176,200,235,187,60,131,83,153,97,23,43,4,126,186,119,214,38,225,105,20,99,85,33,12,125],x=[3328402341,4168907908,4000806809,4135287693,4294111757,3597364157,3731845041,2445657428,1613770832,33620227,3462883241,1445669757,3892248089,3050821474,1303096294,3967186586,2412431941,528646813,2311702848,4202528135,4026202645,2992200171,2387036105,4226871307,1101901292,3017069671,1604494077,1169141738,597466303,1403299063,3832705686,2613100635,1974974402,3791519004,1033081774,1277568618,1815492186,2118074177,4126668546,2211236943,1748251740,1369810420,3521504564,4193382664,3799085459,2883115123,1647391059,706024767,134480908,2512897874,1176707941,2646852446,806885416,932615841,168101135,798661301,235341577,605164086,461406363,3756188221,3454790438,1311188841,2142417613,3933566367,302582043,495158174,1479289972,874125870,907746093,3698224818,3025820398,1537253627,2756858614,1983593293,3084310113,2108928974,1378429307,3722699582,1580150641,327451799,2790478837,3117535592,0,3253595436,1075847264,3825007647,2041688520,3059440621,3563743934,2378943302,1740553945,1916352843,2487896798,2555137236,2958579944,2244988746,3151024235,3320835882,1336584933,3992714006,2252555205,2588757463,1714631509,293963156,2319795663,3925473552,67240454,4269768577,2689618160,2017213508,631218106,1269344483,2723238387,1571005438,2151694528,93294474,1066570413,563977660,1882732616,4059428100,1673313503,2008463041,2950355573,1109467491,537923632,3858759450,4260623118,3218264685,2177748300,403442708,638784309,3287084079,3193921505,899127202,2286175436,773265209,2479146071,1437050866,4236148354,2050833735,3362022572,3126681063,840505643,3866325909,3227541664,427917720,2655997905,2749160575,1143087718,1412049534,999329963,193497219,2353415882,3354324521,1807268051,672404540,2816401017,3160301282,369822493,2916866934,3688947771,1681011286,1949973070,336202270,2454276571,201721354,1210328172,3093060836,2680341085,3184776046,1135389935,3294782118,965841320,831886756,3554993207,4068047243,3588745010,2345191491,1849112409,3664604599,26054028,2983581028,2622377682,1235855840,3630984372,2891339514,4092916743,3488279077,3395642799,4101667470,1202630377,268961816,1874508501,4034427016,1243948399,1546530418,941366308,1470539505,1941222599,2546386513,3421038627,2715671932,3899946140,1042226977,2521517021,1639824860,227249030,260737669,3765465232,2084453954,1907733956,3429263018,2420656344,100860677,4160157185,470683154,3261161891,1781871967,2924959737,1773779408,394692241,2579611992,974986535,664706745,3655459128,3958962195,731420851,571543859,3530123707,2849626480,126783113,865375399,765172662,1008606754,361203602,3387549984,2278477385,2857719295,1344809080,2782912378,59542671,1503764984,160008576,437062935,1707065306,3622233649,2218934982,3496503480,2185314755,697932208,1512910199,504303377,2075177163,2824099068,1841019862,739644986],y=[2781242211,2230877308,2582542199,2381740923,234877682,3184946027,2984144751,1418839493,1348481072,50462977,2848876391,2102799147,434634494,1656084439,3863849899,2599188086,1167051466,2636087938,1082771913,2281340285,368048890,3954334041,3381544775,201060592,3963727277,1739838676,4250903202,3930435503,3206782108,4149453988,2531553906,1536934080,3262494647,484572669,2923271059,1783375398,1517041206,1098792767,49674231,1334037708,1550332980,4098991525,886171109,150598129,2481090929,1940642008,1398944049,1059722517,201851908,1385547719,1699095331,1587397571,674240536,2704774806,252314885,3039795866,151914247,908333586,2602270848,1038082786,651029483,1766729511,3447698098,2682942837,454166793,2652734339,1951935532,775166490,758520603,3000790638,4004797018,4217086112,4137964114,1299594043,1639438038,3464344499,2068982057,1054729187,1901997871,2534638724,4121318227,1757008337,0,750906861,1614815264,535035132,3363418545,3988151131,3201591914,1183697867,3647454910,1265776953,3734260298,3566750796,3903871064,1250283471,1807470800,717615087,3847203498,384695291,3313910595,3617213773,1432761139,2484176261,3481945413,283769337,100925954,2180939647,4037038160,1148730428,3123027871,3813386408,4087501137,4267549603,3229630528,2315620239,2906624658,3156319645,1215313976,82966005,3747855548,3245848246,1974459098,1665278241,807407632,451280895,251524083,1841287890,1283575245,337120268,891687699,801369324,3787349855,2721421207,3431482436,959321879,1469301956,4065699751,2197585534,1199193405,2898814052,3887750493,724703513,2514908019,2696962144,2551808385,3516813135,2141445340,1715741218,2119445034,2872807568,2198571144,3398190662,700968686,3547052216,1009259540,2041044702,3803995742,487983883,1991105499,1004265696,1449407026,1316239930,504629770,3683797321,168560134,1816667172,3837287516,1570751170,1857934291,4014189740,2797888098,2822345105,2754712981,936633572,2347923833,852879335,1133234376,1500395319,3084545389,2348912013,1689376213,3533459022,3762923945,3034082412,4205598294,133428468,634383082,2949277029,2398386810,3913789102,403703816,3580869306,2297460856,1867130149,1918643758,607656988,4049053350,3346248884,1368901318,600565992,2090982877,2632479860,557719327,3717614411,3697393085,2249034635,2232388234,2430627952,1115438654,3295786421,2865522278,3633334344,84280067,33027830,303828494,2747425121,1600795957,4188952407,3496589753,2434238086,1486471617,658119965,3106381470,953803233,334231800,3005978776,857870609,3151128937,1890179545,2298973838,2805175444,3056442267,574365214,2450884487,550103529,1233637070,4289353045,2018519080,2057691103,2399374476,4166623649,2148108681,387583245,3664101311,836232934,3330556482,3100665960,3280093505,2955516313,2002398509,287182607,3413881008,4238890068,3597515707,975967766],c=[1671808611,2089089148,2006576759,2072901243,4061003762,1807603307,1873927791,3310653893,810573872,16974337,1739181671,729634347,4263110654,3613570519,2883997099,1989864566,3393556426,2191335298,3376449993,2106063485,4195741690,1508618841,1204391495,4027317232,2917941677,3563566036,2734514082,2951366063,2629772188,2767672228,1922491506,3227229120,3082974647,4246528509,2477669779,644500518,911895606,1061256767,4144166391,3427763148,878471220,2784252325,3845444069,4043897329,1905517169,3631459288,827548209,356461077,67897348,3344078279,593839651,3277757891,405286936,2527147926,84871685,2595565466,118033927,305538066,2157648768,3795705826,3945188843,661212711,2999812018,1973414517,152769033,2208177539,745822252,439235610,455947803,1857215598,1525593178,2700827552,1391895634,994932283,3596728278,3016654259,695947817,3812548067,795958831,2224493444,1408607827,3513301457,0,3979133421,543178784,4229948412,2982705585,1542305371,1790891114,3410398667,3201918910,961245753,1256100938,1289001036,1491644504,3477767631,3496721360,4012557807,2867154858,4212583931,1137018435,1305975373,861234739,2241073541,1171229253,4178635257,33948674,2139225727,1357946960,1011120188,2679776671,2833468328,1374921297,2751356323,1086357568,2408187279,2460827538,2646352285,944271416,4110742005,3168756668,3066132406,3665145818,560153121,271589392,4279952895,4077846003,3530407890,3444343245,202643468,322250259,3962553324,1608629855,2543990167,1154254916,389623319,3294073796,2817676711,2122513534,1028094525,1689045092,1575467613,422261273,1939203699,1621147744,2174228865,1339137615,3699352540,577127458,712922154,2427141008,2290289544,1187679302,3995715566,3100863416,339486740,3732514782,1591917662,186455563,3681988059,3762019296,844522546,978220090,169743370,1239126601,101321734,611076132,1558493276,3260915650,3547250131,2901361580,1655096418,2443721105,2510565781,3828863972,2039214713,3878868455,3359869896,928607799,1840765549,2374762893,3580146133,1322425422,2850048425,1823791212,1459268694,4094161908,3928346602,1706019429,2056189050,2934523822,135794696,3134549946,2022240376,628050469,779246638,472135708,2800834470,3032970164,3327236038,3894660072,3715932637,1956440180,522272287,1272813131,3185336765,2340818315,2323976074,1888542832,1044544574,3049550261,1722469478,1222152264,50660867,4127324150,236067854,1638122081,895445557,1475980887,3117443513,2257655686,3243809217,489110045,2662934430,3778599393,4162055160,2561878936,288563729,1773916777,3648039385,2391345038,2493985684,2612407707,505560094,2274497927,3911240169,3460925390,1442818645,678973480,3749357023,2358182796,2717407649,2306869641,219617805,3218761151,3862026214,1120306242,1756942440,1103331905,2578459033,762796589,252780047,2966125488,1425844308,3151392187,372911126],v=[1667474886,2088535288,2004326894,2071694838,4075949567,1802223062,1869591006,3318043793,808472672,16843522,1734846926,724270422,4278065639,3621216949,2880169549,1987484396,3402253711,2189597983,3385409673,2105378810,4210693615,1499065266,1195886990,4042263547,2913856577,3570689971,2728590687,2947541573,2627518243,2762274643,1920112356,3233831835,3082273397,4261223649,2475929149,640051788,909531756,1061110142,4160160501,3435941763,875846760,2779116625,3857003729,4059105529,1903268834,3638064043,825316194,353713962,67374088,3351728789,589522246,3284360861,404236336,2526454071,84217610,2593830191,117901582,303183396,2155911963,3806477791,3958056653,656894286,2998062463,1970642922,151591698,2206440989,741110872,437923380,454765878,1852748508,1515908788,2694904667,1381168804,993742198,3604373943,3014905469,690584402,3823320797,791638366,2223281939,1398011302,3520161977,0,3991743681,538992704,4244381667,2981218425,1532751286,1785380564,3419096717,3200178535,960056178,1246420628,1280103576,1482221744,3486468741,3503319995,4025428677,2863326543,4227536621,1128514950,1296947098,859002214,2240123921,1162203018,4193849577,33687044,2139062782,1347481760,1010582648,2678045221,2829640523,1364325282,2745433693,1077985408,2408548869,2459086143,2644360225,943212656,4126475505,3166494563,3065430391,3671750063,555836226,269496352,4294908645,4092792573,3537006015,3452783745,202118168,320025894,3974901699,1600119230,2543297077,1145359496,387397934,3301201811,2812801621,2122220284,1027426170,1684319432,1566435258,421079858,1936954854,1616945344,2172753945,1330631070,3705438115,572679748,707427924,2425400123,2290647819,1179044492,4008585671,3099120491,336870440,3739122087,1583276732,185277718,3688593069,3772791771,842159716,976899700,168435220,1229577106,101059084,606366792,1549591736,3267517855,3553849021,2897014595,1650632388,2442242105,2509612081,3840161747,2038008818,3890688725,3368567691,926374254,1835907034,2374863873,3587531953,1313788572,2846482505,1819063512,1448540844,4109633523,3941213647,1701162954,2054852340,2930698567,134748176,3132806511,2021165296,623210314,774795868,471606328,2795958615,3031746419,3334885783,3907527627,3722280097,1953799400,522133822,1263263126,3183336545,2341176845,2324333839,1886425312,1044267644,3048588401,1718004428,1212733584,50529542,4143317495,235803164,1633788866,892690282,1465383342,3115962473,2256965911,3250673817,488449850,2661202215,3789633753,4177007595,2560144171,286339874,1768537042,3654906025,2391705863,2492770099,2610673197,505291324,2273808917,3924369609,3469625735,1431699370,673740880,3755965093,2358021891,2711746649,2307489801,218961690,3217021541,3873845719,1111672452,1751693520,1094828930,2576986153,757954394,252645662,2964376443,1414855848,3149649517,370555436],g=[1374988112,2118214995,437757123,975658646,1001089995,530400753,2902087851,1273168787,540080725,2910219766,2295101073,4110568485,1340463100,3307916247,641025152,3043140495,3736164937,632953703,1172967064,1576976609,3274667266,2169303058,2370213795,1809054150,59727847,361929877,3211623147,2505202138,3569255213,1484005843,1239443753,2395588676,1975683434,4102977912,2572697195,666464733,3202437046,4035489047,3374361702,2110667444,1675577880,3843699074,2538681184,1649639237,2976151520,3144396420,4269907996,4178062228,1883793496,2403728665,2497604743,1383856311,2876494627,1917518562,3810496343,1716890410,3001755655,800440835,2261089178,3543599269,807962610,599762354,33778362,3977675356,2328828971,2809771154,4077384432,1315562145,1708848333,101039829,3509871135,3299278474,875451293,2733856160,92987698,2767645557,193195065,1080094634,1584504582,3178106961,1042385657,2531067453,3711829422,1306967366,2438237621,1908694277,67556463,1615861247,429456164,3602770327,2302690252,1742315127,2968011453,126454664,3877198648,2043211483,2709260871,2084704233,4169408201,0,159417987,841739592,504459436,1817866830,4245618683,260388950,1034867998,908933415,168810852,1750902305,2606453969,607530554,202008497,2472011535,3035535058,463180190,2160117071,1641816226,1517767529,470948374,3801332234,3231722213,1008918595,303765277,235474187,4069246893,766945465,337553864,1475418501,2943682380,4003061179,2743034109,4144047775,1551037884,1147550661,1543208500,2336434550,3408119516,3069049960,3102011747,3610369226,1113818384,328671808,2227573024,2236228733,3535486456,2935566865,3341394285,496906059,3702665459,226906860,2009195472,733156972,2842737049,294930682,1206477858,2835123396,2700099354,1451044056,573804783,2269728455,3644379585,2362090238,2564033334,2801107407,2776292904,3669462566,1068351396,742039012,1350078989,1784663195,1417561698,4136440770,2430122216,775550814,2193862645,2673705150,1775276924,1876241833,3475313331,3366754619,270040487,3902563182,3678124923,3441850377,1851332852,3969562369,2203032232,3868552805,2868897406,566021896,4011190502,3135740889,1248802510,3936291284,699432150,832877231,708780849,3332740144,899835584,1951317047,4236429990,3767586992,866637845,4043610186,1106041591,2144161806,395441711,1984812685,1139781709,3433712980,3835036895,2664543715,1282050075,3240894392,1181045119,2640243204,25965917,4203181171,4211818798,3009879386,2463879762,3910161971,1842759443,2597806476,933301370,1509430414,3943906441,3467192302,3076639029,3776767469,2051518780,2631065433,1441952575,404016761,1942435775,1408749034,1610459739,3745345300,2017778566,3400528769,3110650942,941896748,3265478751,371049330,3168937228,675039627,4279080257,967311729,135050206,3635733660,1683407248,2076935265,3576870512,1215061108,3501741890],w=[1347548327,1400783205,3273267108,2520393566,3409685355,4045380933,2880240216,2471224067,1428173050,4138563181,2441661558,636813900,4233094615,3620022987,2149987652,2411029155,1239331162,1730525723,2554718734,3781033664,46346101,310463728,2743944855,3328955385,3875770207,2501218972,3955191162,3667219033,768917123,3545789473,692707433,1150208456,1786102409,2029293177,1805211710,3710368113,3065962831,401639597,1724457132,3028143674,409198410,2196052529,1620529459,1164071807,3769721975,2226875310,486441376,2499348523,1483753576,428819965,2274680428,3075636216,598438867,3799141122,1474502543,711349675,129166120,53458370,2592523643,2782082824,4063242375,2988687269,3120694122,1559041666,730517276,2460449204,4042459122,2706270690,3446004468,3573941694,533804130,2328143614,2637442643,2695033685,839224033,1973745387,957055980,2856345839,106852767,1371368976,4181598602,1033297158,2933734917,1179510461,3046200461,91341917,1862534868,4284502037,605657339,2547432937,3431546947,2003294622,3182487618,2282195339,954669403,3682191598,1201765386,3917234703,3388507166,0,2198438022,1211247597,2887651696,1315723890,4227665663,1443857720,507358933,657861945,1678381017,560487590,3516619604,975451694,2970356327,261314535,3535072918,2652609425,1333838021,2724322336,1767536459,370938394,182621114,3854606378,1128014560,487725847,185469197,2918353863,3106780840,3356761769,2237133081,1286567175,3152976349,4255350624,2683765030,3160175349,3309594171,878443390,1988838185,3704300486,1756818940,1673061617,3403100636,272786309,1075025698,545572369,2105887268,4174560061,296679730,1841768865,1260232239,4091327024,3960309330,3497509347,1814803222,2578018489,4195456072,575138148,3299409036,446754879,3629546796,4011996048,3347532110,3252238545,4270639778,915985419,3483825537,681933534,651868046,2755636671,3828103837,223377554,2607439820,1649704518,3270937875,3901806776,1580087799,4118987695,3198115200,2087309459,2842678573,3016697106,1003007129,2802849917,1860738147,2077965243,164439672,4100872472,32283319,2827177882,1709610350,2125135846,136428751,3874428392,3652904859,3460984630,3572145929,3593056380,2939266226,824852259,818324884,3224740454,930369212,2801566410,2967507152,355706840,1257309336,4148292826,243256656,790073846,2373340630,1296297904,1422699085,3756299780,3818836405,457992840,3099667487,2135319889,77422314,1560382517,1945798516,788204353,1521706781,1385356242,870912086,325965383,2358957921,2050466060,2388260884,2313884476,4006521127,901210569,3990953189,1014646705,1503449823,1062597235,2031621326,3212035895,3931371469,1533017514,350174575,2256028891,2177544179,1052338372,741876788,1606591296,1914052035,213705253,2334669897,1107234197,1899603969,3725069491,2631447780,2422494913,1635502980,1893020342,1950903388,1120974935],b=[2807058932,1699970625,2764249623,1586903591,1808481195,1173430173,1487645946,59984867,4199882800,1844882806,1989249228,1277555970,3623636965,3419915562,1149249077,2744104290,1514790577,459744698,244860394,3235995134,1963115311,4027744588,2544078150,4190530515,1608975247,2627016082,2062270317,1507497298,2200818878,567498868,1764313568,3359936201,2305455554,2037970062,1047239e3,1910319033,1337376481,2904027272,2892417312,984907214,1243112415,830661914,861968209,2135253587,2011214180,2927934315,2686254721,731183368,1750626376,4246310725,1820824798,4172763771,3542330227,48394827,2404901663,2871682645,671593195,3254988725,2073724613,145085239,2280796200,2779915199,1790575107,2187128086,472615631,3029510009,4075877127,3802222185,4107101658,3201631749,1646252340,4270507174,1402811438,1436590835,3778151818,3950355702,3963161475,4020912224,2667994737,273792366,2331590177,104699613,95345982,3175501286,2377486676,1560637892,3564045318,369057872,4213447064,3919042237,1137477952,2658625497,1119727848,2340947849,1530455833,4007360968,172466556,266959938,516552836,0,2256734592,3980931627,1890328081,1917742170,4294704398,945164165,3575528878,958871085,3647212047,2787207260,1423022939,775562294,1739656202,3876557655,2530391278,2443058075,3310321856,547512796,1265195639,437656594,3121275539,719700128,3762502690,387781147,218828297,3350065803,2830708150,2848461854,428169201,122466165,3720081049,1627235199,648017665,4122762354,1002783846,2117360635,695634755,3336358691,4234721005,4049844452,3704280881,2232435299,574624663,287343814,612205898,1039717051,840019705,2708326185,793451934,821288114,1391201670,3822090177,376187827,3113855344,1224348052,1679968233,2361698556,1058709744,752375421,2431590963,1321699145,3519142200,2734591178,188127444,2177869557,3727205754,2384911031,3215212461,2648976442,2450346104,3432737375,1180849278,331544205,3102249176,4150144569,2952102595,2159976285,2474404304,766078933,313773861,2570832044,2108100632,1668212892,3145456443,2013908262,418672217,3070356634,2594734927,1852171925,3867060991,3473416636,3907448597,2614737639,919489135,164948639,2094410160,2997825956,590424639,2486224549,1723872674,3157750862,3399941250,3501252752,3625268135,2555048196,3673637356,1343127501,4130281361,3599595085,2957853679,1297403050,81781910,3051593425,2283490410,532201772,1367295589,3926170974,895287692,1953757831,1093597963,492483431,3528626907,1446242576,1192455638,1636604631,209336225,344873464,1015671571,669961897,3375740769,3857572124,2973530695,3747192018,1933530610,3464042516,935293895,3454686199,2858115069,1863638845,3683022916,4085369519,3292445032,875313188,1080017571,3279033885,621591778,1233856572,2504130317,24197544,3017672716,3835484340,3247465558,2220981195,3060847922,1551124588,1463996600],R=[4104605777,1097159550,396673818,660510266,2875968315,2638606623,4200115116,3808662347,821712160,1986918061,3430322568,38544885,3856137295,718002117,893681702,1654886325,2975484382,3122358053,3926825029,4274053469,796197571,1290801793,1184342925,3556361835,2405426947,2459735317,1836772287,1381620373,3196267988,1948373848,3764988233,3385345166,3263785589,2390325492,1480485785,3111247143,3780097726,2293045232,548169417,3459953789,3746175075,439452389,1362321559,1400849762,1685577905,1806599355,2174754046,137073913,1214797936,1174215055,3731654548,2079897426,1943217067,1258480242,529487843,1437280870,3945269170,3049390895,3313212038,923313619,679998e3,3215307299,57326082,377642221,3474729866,2041877159,133361907,1776460110,3673476453,96392454,878845905,2801699524,777231668,4082475170,2330014213,4142626212,2213296395,1626319424,1906247262,1846563261,562755902,3708173718,1040559837,3871163981,1418573201,3294430577,114585348,1343618912,2566595609,3186202582,1078185097,3651041127,3896688048,2307622919,425408743,3371096953,2081048481,1108339068,2216610296,0,2156299017,736970802,292596766,1517440620,251657213,2235061775,2933202493,758720310,265905162,1554391400,1532285339,908999204,174567692,1474760595,4002861748,2610011675,3234156416,3693126241,2001430874,303699484,2478443234,2687165888,585122620,454499602,151849742,2345119218,3064510765,514443284,4044981591,1963412655,2581445614,2137062819,19308535,1928707164,1715193156,4219352155,1126790795,600235211,3992742070,3841024952,836553431,1669664834,2535604243,3323011204,1243905413,3141400786,4180808110,698445255,2653899549,2989552604,2253581325,3252932727,3004591147,1891211689,2487810577,3915653703,4237083816,4030667424,2100090966,865136418,1229899655,953270745,3399679628,3557504664,4118925222,2061379749,3079546586,2915017791,983426092,2022837584,1607244650,2118541908,2366882550,3635996816,972512814,3283088770,1568718495,3499326569,3576539503,621982671,2895723464,410887952,2623762152,1002142683,645401037,1494807662,2595684844,1335535747,2507040230,4293295786,3167684641,367585007,3885750714,1865862730,2668221674,2960971305,2763173681,1059270954,2777952454,2724642869,1320957812,2194319100,2429595872,2815956275,77089521,3973773121,3444575871,2448830231,1305906550,4021308739,2857194700,2516901860,3518358430,1787304780,740276417,1699839814,1592394909,2352307457,2272556026,188821243,1729977011,3687994002,274084841,3594982253,3613494426,2701949495,4162096729,322734571,2837966542,1640576439,484830689,1202797690,3537852828,4067639125,349075736,3342319475,4157467219,4255800159,1030690015,1155237496,2951971274,1757691577,607398968,2738905026,499347990,3794078908,1011452712,227885567,2818666809,213114376,3034881240,1455525988,3414450555,850817237,1817998408,3092726480],m=[0,235474187,470948374,303765277,941896748,908933415,607530554,708780849,1883793496,2118214995,1817866830,1649639237,1215061108,1181045119,1417561698,1517767529,3767586992,4003061179,4236429990,4069246893,3635733660,3602770327,3299278474,3400528769,2430122216,2664543715,2362090238,2193862645,2835123396,2801107407,3035535058,3135740889,3678124923,3576870512,3341394285,3374361702,3810496343,3977675356,4279080257,4043610186,2876494627,2776292904,3076639029,3110650942,2472011535,2640243204,2403728665,2169303058,1001089995,899835584,666464733,699432150,59727847,226906860,530400753,294930682,1273168787,1172967064,1475418501,1509430414,1942435775,2110667444,1876241833,1641816226,2910219766,2743034109,2976151520,3211623147,2505202138,2606453969,2302690252,2269728455,3711829422,3543599269,3240894392,3475313331,3843699074,3943906441,4178062228,4144047775,1306967366,1139781709,1374988112,1610459739,1975683434,2076935265,1775276924,1742315127,1034867998,866637845,566021896,800440835,92987698,193195065,429456164,395441711,1984812685,2017778566,1784663195,1683407248,1315562145,1080094634,1383856311,1551037884,101039829,135050206,437757123,337553864,1042385657,807962610,573804783,742039012,2531067453,2564033334,2328828971,2227573024,2935566865,2700099354,3001755655,3168937228,3868552805,3902563182,4203181171,4102977912,3736164937,3501741890,3265478751,3433712980,1106041591,1340463100,1576976609,1408749034,2043211483,2009195472,1708848333,1809054150,832877231,1068351396,766945465,599762354,159417987,126454664,361929877,463180190,2709260871,2943682380,3178106961,3009879386,2572697195,2538681184,2236228733,2336434550,3509871135,3745345300,3441850377,3274667266,3910161971,3877198648,4110568485,4211818798,2597806476,2497604743,2261089178,2295101073,2733856160,2902087851,3202437046,2968011453,3936291284,3835036895,4136440770,4169408201,3535486456,3702665459,3467192302,3231722213,2051518780,1951317047,1716890410,1750902305,1113818384,1282050075,1584504582,1350078989,168810852,67556463,371049330,404016761,841739592,1008918595,775550814,540080725,3969562369,3801332234,4035489047,4269907996,3569255213,3669462566,3366754619,3332740144,2631065433,2463879762,2160117071,2395588676,2767645557,2868897406,3102011747,3069049960,202008497,33778362,270040487,504459436,875451293,975658646,675039627,641025152,2084704233,1917518562,1615861247,1851332852,1147550661,1248802510,1484005843,1451044056,933301370,967311729,733156972,632953703,260388950,25965917,328671808,496906059,1206477858,1239443753,1543208500,1441952575,2144161806,1908694277,1675577880,1842759443,3610369226,3644379585,3408119516,3307916247,4011190502,3776767469,4077384432,4245618683,2809771154,2842737049,3144396420,3043140495,2673705150,2438237621,2203032232,2370213795],k=[0,185469197,370938394,487725847,741876788,657861945,975451694,824852259,1483753576,1400783205,1315723890,1164071807,1950903388,2135319889,1649704518,1767536459,2967507152,3152976349,2801566410,2918353863,2631447780,2547432937,2328143614,2177544179,3901806776,3818836405,4270639778,4118987695,3299409036,3483825537,3535072918,3652904859,2077965243,1893020342,1841768865,1724457132,1474502543,1559041666,1107234197,1257309336,598438867,681933534,901210569,1052338372,261314535,77422314,428819965,310463728,3409685355,3224740454,3710368113,3593056380,3875770207,3960309330,4045380933,4195456072,2471224067,2554718734,2237133081,2388260884,3212035895,3028143674,2842678573,2724322336,4138563181,4255350624,3769721975,3955191162,3667219033,3516619604,3431546947,3347532110,2933734917,2782082824,3099667487,3016697106,2196052529,2313884476,2499348523,2683765030,1179510461,1296297904,1347548327,1533017514,1786102409,1635502980,2087309459,2003294622,507358933,355706840,136428751,53458370,839224033,957055980,605657339,790073846,2373340630,2256028891,2607439820,2422494913,2706270690,2856345839,3075636216,3160175349,3573941694,3725069491,3273267108,3356761769,4181598602,4063242375,4011996048,3828103837,1033297158,915985419,730517276,545572369,296679730,446754879,129166120,213705253,1709610350,1860738147,1945798516,2029293177,1239331162,1120974935,1606591296,1422699085,4148292826,4233094615,3781033664,3931371469,3682191598,3497509347,3446004468,3328955385,2939266226,2755636671,3106780840,2988687269,2198438022,2282195339,2501218972,2652609425,1201765386,1286567175,1371368976,1521706781,1805211710,1620529459,2105887268,1988838185,533804130,350174575,164439672,46346101,870912086,954669403,636813900,788204353,2358957921,2274680428,2592523643,2441661558,2695033685,2880240216,3065962831,3182487618,3572145929,3756299780,3270937875,3388507166,4174560061,4091327024,4006521127,3854606378,1014646705,930369212,711349675,560487590,272786309,457992840,106852767,223377554,1678381017,1862534868,1914052035,2031621326,1211247597,1128014560,1580087799,1428173050,32283319,182621114,401639597,486441376,768917123,651868046,1003007129,818324884,1503449823,1385356242,1333838021,1150208456,1973745387,2125135846,1673061617,1756818940,2970356327,3120694122,2802849917,2887651696,2637442643,2520393566,2334669897,2149987652,3917234703,3799141122,4284502037,4100872472,3309594171,3460984630,3545789473,3629546796,2050466060,1899603969,1814803222,1730525723,1443857720,1560382517,1075025698,1260232239,575138148,692707433,878443390,1062597235,243256656,91341917,409198410,325965383,3403100636,3252238545,3704300486,3620022987,3874428392,3990953189,4042459122,4227665663,2460449204,2578018489,2226875310,2411029155,3198115200,3046200461,2827177882,2743944855],_=[0,218828297,437656594,387781147,875313188,958871085,775562294,590424639,1750626376,1699970625,1917742170,2135253587,1551124588,1367295589,1180849278,1265195639,3501252752,3720081049,3399941250,3350065803,3835484340,3919042237,4270507174,4085369519,3102249176,3051593425,2734591178,2952102595,2361698556,2177869557,2530391278,2614737639,3145456443,3060847922,2708326185,2892417312,2404901663,2187128086,2504130317,2555048196,3542330227,3727205754,3375740769,3292445032,3876557655,3926170974,4246310725,4027744588,1808481195,1723872674,1910319033,2094410160,1608975247,1391201670,1173430173,1224348052,59984867,244860394,428169201,344873464,935293895,984907214,766078933,547512796,1844882806,1627235199,2011214180,2062270317,1507497298,1423022939,1137477952,1321699145,95345982,145085239,532201772,313773861,830661914,1015671571,731183368,648017665,3175501286,2957853679,2807058932,2858115069,2305455554,2220981195,2474404304,2658625497,3575528878,3625268135,3473416636,3254988725,3778151818,3963161475,4213447064,4130281361,3599595085,3683022916,3432737375,3247465558,3802222185,4020912224,4172763771,4122762354,3201631749,3017672716,2764249623,2848461854,2331590177,2280796200,2431590963,2648976442,104699613,188127444,472615631,287343814,840019705,1058709744,671593195,621591778,1852171925,1668212892,1953757831,2037970062,1514790577,1463996600,1080017571,1297403050,3673637356,3623636965,3235995134,3454686199,4007360968,3822090177,4107101658,4190530515,2997825956,3215212461,2830708150,2779915199,2256734592,2340947849,2627016082,2443058075,172466556,122466165,273792366,492483431,1047239e3,861968209,612205898,695634755,1646252340,1863638845,2013908262,1963115311,1446242576,1530455833,1277555970,1093597963,1636604631,1820824798,2073724613,1989249228,1436590835,1487645946,1337376481,1119727848,164948639,81781910,331544205,516552836,1039717051,821288114,669961897,719700128,2973530695,3157750862,2871682645,2787207260,2232435299,2283490410,2667994737,2450346104,3647212047,3564045318,3279033885,3464042516,3980931627,3762502690,4150144569,4199882800,3070356634,3121275539,2904027272,2686254721,2200818878,2384911031,2570832044,2486224549,3747192018,3528626907,3310321856,3359936201,3950355702,3867060991,4049844452,4234721005,1739656202,1790575107,2108100632,1890328081,1402811438,1586903591,1233856572,1149249077,266959938,48394827,369057872,418672217,1002783846,919489135,567498868,752375421,209336225,24197544,376187827,459744698,945164165,895287692,574624663,793451934,1679968233,1764313568,2117360635,1933530610,1343127501,1560637892,1243112415,1192455638,3704280881,3519142200,3336358691,3419915562,3907448597,3857572124,4075877127,4294704398,3029510009,3113855344,2927934315,2744104290,2159976285,2377486676,2594734927,2544078150],S=[0,151849742,303699484,454499602,607398968,758720310,908999204,1059270954,1214797936,1097159550,1517440620,1400849762,1817998408,1699839814,2118541908,2001430874,2429595872,2581445614,2194319100,2345119218,3034881240,3186202582,2801699524,2951971274,3635996816,3518358430,3399679628,3283088770,4237083816,4118925222,4002861748,3885750714,1002142683,850817237,698445255,548169417,529487843,377642221,227885567,77089521,1943217067,2061379749,1640576439,1757691577,1474760595,1592394909,1174215055,1290801793,2875968315,2724642869,3111247143,2960971305,2405426947,2253581325,2638606623,2487810577,3808662347,3926825029,4044981591,4162096729,3342319475,3459953789,3576539503,3693126241,1986918061,2137062819,1685577905,1836772287,1381620373,1532285339,1078185097,1229899655,1040559837,923313619,740276417,621982671,439452389,322734571,137073913,19308535,3871163981,4021308739,4104605777,4255800159,3263785589,3414450555,3499326569,3651041127,2933202493,2815956275,3167684641,3049390895,2330014213,2213296395,2566595609,2448830231,1305906550,1155237496,1607244650,1455525988,1776460110,1626319424,2079897426,1928707164,96392454,213114376,396673818,514443284,562755902,679998e3,865136418,983426092,3708173718,3557504664,3474729866,3323011204,4180808110,4030667424,3945269170,3794078908,2507040230,2623762152,2272556026,2390325492,2975484382,3092726480,2738905026,2857194700,3973773121,3856137295,4274053469,4157467219,3371096953,3252932727,3673476453,3556361835,2763173681,2915017791,3064510765,3215307299,2156299017,2307622919,2459735317,2610011675,2081048481,1963412655,1846563261,1729977011,1480485785,1362321559,1243905413,1126790795,878845905,1030690015,645401037,796197571,274084841,425408743,38544885,188821243,3613494426,3731654548,3313212038,3430322568,4082475170,4200115116,3780097726,3896688048,2668221674,2516901860,2366882550,2216610296,3141400786,2989552604,2837966542,2687165888,1202797690,1320957812,1437280870,1554391400,1669664834,1787304780,1906247262,2022837584,265905162,114585348,499347990,349075736,736970802,585122620,972512814,821712160,2595684844,2478443234,2293045232,2174754046,3196267988,3079546586,2895723464,2777952454,3537852828,3687994002,3234156416,3385345166,4142626212,4293295786,3841024952,3992742070,174567692,57326082,410887952,292596766,777231668,660510266,1011452712,893681702,1108339068,1258480242,1343618912,1494807662,1715193156,1865862730,1948373848,2100090966,2701949495,2818666809,3004591147,3122358053,2235061775,2352307457,2535604243,2653899549,3915653703,3764988233,4219352155,4067639125,3444575871,3294430577,3746175075,3594982253,836553431,953270745,600235211,718002117,367585007,484830689,133361907,251657213,2041877159,1891211689,1806599355,1654886325,1568718495,1418573201,1335535747,1184342925];function I(i){for(var t=[],e=0;e<i.length;e+=4)t.push(i[e]<<24|i[e+1]<<16|i[e+2]<<8|i[e+3]);return t}function A(i){if(!(this instanceof A))throw Error("AES must be instanitated with `new`");Object.defineProperty(this,"key",{value:r(i,!0)}),this.gAA()}function C(i){if(!(this instanceof C))throw Error("AES must be instanitated with `new`");this.description="Electronic Code Block",this.name="ecb",this.tAA=new A(i)}function E(i,t){if(!(this instanceof E))throw Error("AES must be instanitated with `new`");if(this.description="Cipher Block Chaining",this.name="cbc",t){if(16!=t.length)throw new Error("invalid initialation vector size (must be 16 bytes)")}else t=a(16);this.IAA=r(t,!0),this.tAA=new A(i)}function M(i,t,e){if(!(this instanceof M))throw Error("AES must be instanitated with `new`");if(this.description="Cipher Feedback",this.name="cfb",t){if(16!=t.length)throw new Error("invalid initialation vector size (must be 16 size)")}else t=a(16);this.BAA=e=e||1,this.eAA=r(t,!0),this.tAA=new A(i)}function D(i,t){if(!(this instanceof D))throw Error("AES must be instanitated with `new`");if(this.description="Output Feedback",this.name="ofb",t){if(16!=t.length)throw new Error("invalid initialation vector size (must be 16 bytes)")}else t=a(16);this.QAA=r(t,!0),this.oAA=16,this.tAA=new A(i)}function T(i){if(!(this instanceof T))throw Error("Counter must be instanitated with `new`");"number"==typeof(i=0!==i?i||1:i)?(this.g2t=a(16),this.VV(i)):this.CAA(i)}function z(i,t){if(!(this instanceof z))throw Error("AES must be instanitated with `new`");this.description="Counter",this.name="ctr",t instanceof T||(t=new T(t)),this.g2t=t,this.EAA=null,this.hAA=16,this.tAA=new A(i)}A.prototype.gAA=function(){var i=u[this.key.length];if(null==i)throw new Error("invalid key size (must be 16, 24 or 32 bytes)");this.aAA=[],this.nAA=[];for(var t=0;t<=i;t++)this.aAA.push([0,0,0,0]),this.nAA.push([0,0,0,0]);for(var e,o=4*(i+1),h=this.key.length/4,r=I(this.key),t=0;t<h;t++)this.aAA[e=t>>2][t%4]=r[t],this.nAA[i-e][t%4]=r[t];for(var n,l=0,a=h;a<o;){if(n=r[h-1],r[0]^=d[n>>16&255]<<24^d[n>>8&255]<<16^d[255&n]<<8^d[n>>24&255]^p[l]<<24,l+=1,8!=h)for(t=1;t<h;t++)r[t]^=r[t-1];else{for(t=1;t<h/2;t++)r[t]^=r[t-1];for(n=r[h/2-1],r[h/2]^=d[255&n]^d[n>>8&255]<<8^d[n>>16&255]<<16^d[n>>24&255]<<24,t=h/2+1;t<h;t++)r[t]^=r[t-1]}for(t=0;t<h&&a<o;)this.aAA[s=a>>2][f=a%4]=r[t],this.nAA[i-s][f]=r[t++],a++}for(var s=1;s<i;s++)for(var f=0;f<4;f++)n=this.nAA[s][f],this.nAA[s][f]=m[n>>24&255]^k[n>>16&255]^_[n>>8&255]^S[255&n]},A.prototype.encrypt=function(i){if(16!=i.length)throw new Error("invalid plaintext size (must be 16 bytes)");for(var t=this.aAA.length-1,e=[0,0,0,0],o=I(i),h=0;h<4;h++)o[h]^=this.aAA[0][h];for(var r=1;r<t;r++){for(h=0;h<4;h++)e[h]=x[o[h]>>24&255]^y[o[(h+1)%4]>>16&255]^c[o[(h+2)%4]>>8&255]^v[255&o[(h+3)%4]]^this.aAA[r][h];o=e.slice()}for(var n,l=a(16),h=0;h<4;h++)n=this.aAA[t][h],l[4*h]=255&(d[o[h]>>24&255]^n>>24),l[4*h+1]=255&(d[o[(h+1)%4]>>16&255]^n>>16),l[4*h+2]=255&(d[o[(h+2)%4]>>8&255]^n>>8),l[4*h+3]=255&(d[255&o[(h+3)%4]]^n);return l},A.prototype.decrypt=function(i){if(16!=i.length)throw new Error("invalid ciphertext size (must be 16 bytes)");for(var t=this.nAA.length-1,e=[0,0,0,0],o=I(i),h=0;h<4;h++)o[h]^=this.nAA[0][h];for(var r=1;r<t;r++){for(h=0;h<4;h++)e[h]=g[o[h]>>24&255]^w[o[(h+3)%4]>>16&255]^b[o[(h+2)%4]>>8&255]^R[255&o[(h+1)%4]]^this.nAA[r][h];o=e.slice()}for(var n,l=a(16),h=0;h<4;h++)n=this.nAA[t][h],l[4*h]=255&(f[o[h]>>24&255]^n>>24),l[4*h+1]=255&(f[o[(h+3)%4]>>16&255]^n>>16),l[4*h+2]=255&(f[o[(h+2)%4]>>8&255]^n>>8),l[4*h+3]=255&(f[255&o[(h+1)%4]]^n);return l},C.prototype.encrypt=function(i){if((i=r(i)).length%16!=0)throw new Error("invalid plaintext size (must be multiple of 16 bytes)");for(var t=a(i.length),e=a(16),o=0;o<i.length;o+=16)n(i,e,0,o,o+16),n(e=this.tAA.encrypt(e),t,o);return t},C.prototype.decrypt=function(i){if((i=r(i)).length%16!=0)throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");for(var t=a(i.length),e=a(16),o=0;o<i.length;o+=16)n(i,e,0,o,o+16),n(e=this.tAA.decrypt(e),t,o);return t},E.prototype.encrypt=function(i){if((i=r(i)).length%16!=0)throw new Error("invalid plaintext size (must be multiple of 16 bytes)");for(var t=a(i.length),e=a(16),o=0;o<i.length;o+=16){n(i,e,0,o,o+16);for(var h=0;h<16;h++)e[h]^=this.IAA[h];this.IAA=this.tAA.encrypt(e),n(this.IAA,t,o)}return t},E.prototype.decrypt=function(i){if((i=r(i)).length%16!=0)throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");for(var t=a(i.length),e=a(16),o=0;o<i.length;o+=16){n(i,e,0,o,o+16);for(var e=this.tAA.decrypt(e),h=0;h<16;h++)t[o+h]=e[h]^this.IAA[h];n(i,this.IAA,0,o,o+16)}return t},M.prototype.encrypt=function(i){if(i.length%this.BAA!=0)throw new Error("invalid plaintext size (must be segmentSize bytes)");for(var t=r(i,!0),e=0;e<t.length;e+=this.BAA){for(var o=this.tAA.encrypt(this.eAA),h=0;h<this.BAA;h++)t[e+h]^=o[h];n(this.eAA,this.eAA,0,this.BAA),n(t,this.eAA,16-this.BAA,e,e+this.BAA)}return t},M.prototype.decrypt=function(i){if(i.length%this.BAA!=0)throw new Error("invalid ciphertext size (must be segmentSize bytes)");for(var t=r(i,!0),e=0;e<t.length;e+=this.BAA){for(var o=this.tAA.encrypt(this.eAA),h=0;h<this.BAA;h++)t[e+h]^=o[h];n(this.eAA,this.eAA,0,this.BAA),n(i,this.eAA,16-this.BAA,e,e+this.BAA)}return t},D.prototype.decrypt=D.prototype.encrypt=function(i){for(var t=r(i,!0),e=0;e<t.length;e++)16===this.oAA&&(this.QAA=this.tAA.encrypt(this.QAA),this.oAA=0),t[e]^=this.QAA[this.oAA++];return t},T.prototype.VV=function(i){if("number"!=typeof i||parseInt(i)!=i)throw new Error("invalid counter value (must be an integer)");if(i>Number.MAX_SAFE_INTEGER)throw new Error("integer value out of safe range");for(var t=15;0<=t;--t)this.g2t[t]=i%256,i=parseInt(i/256)},T.prototype.CAA=function(i){if(16!=(i=r(i,!0)).length)throw new Error("invalid counter bytes size (must be 16 bytes)");this.g2t=i},T.prototype.lAA=function(){for(var i=15;0<=i;i--){if(255!==this.g2t[i]){this.g2t[i]++;break}this.g2t[i]=0}},z.prototype.decrypt=z.prototype.encrypt=function(i){for(var t=r(i,!0),e=0;e<t.length;e++)16===this.hAA&&(this.EAA=this.tAA.encrypt(this.g2t.g2t),this.hAA=0,this.g2t.lAA()),t[e]^=this.EAA[this.hAA++];return t},i.exports={rAA:A,Counter:T,sAA:{wAA:C,cAA:E,yAA:M,xAA:D,dAA:z},fAA:{pAA:s,DAA:l},padding:{uAA:{pad:function(i){var t=16-(i=r(i,!0)).length%16,e=a(i.length+t);n(i,e);for(var o=i.length;o<e.length;o++)e[o]=t;return e},RAA:function(i){if((i=r(i,!0)).length<16)throw new Error("PKCS#7 invalid length");var t=i[i.length-1];if(16<t)throw new Error("PKCS#7 padding byte out of range");for(var e=i.length-t,o=0;o<t;o++)if(i[e+o]!==t)throw new Error("PKCS#7 invalid padding byte");var h=a(e);return n(i,h,0,0,e),h}}},vAA:{bAA:r,SAA:a,GAA:n}}}),_a,geoUtil=new polyfill.rW({}),LabelFormatMap=(_a={},_a[polyfill.NebulaLabelFormat.id]=polyfill.NebulaLabelFormat,_a.nebula=polyfill.NebulaLabelFormat,_a[polyfill.MapboxLabelFormat.id]=polyfill.MapboxLabelFormat,_a),NebulaSourceWorker=function(e){function h(i){var t=e.call(this)||this;return t.parent=i,t.id="nebula",t.sQ={},t.aW=null,t.WW=20,t.xQ=[],t.bQ=[],t.iii=[26,16,8,4,12,20,9,3,6,23,14,17,1,5,19,2],t.bind(),t}return polyfill.Ei(h,e),h.prototype.bind=function(){var g=this;this.on("styleReady",function(){var i=g.xQ.length;if(0<i){for(var t=0;t<i;t++){var e=(d=g.xQ[t]).data,o=d.projectionId,h=d.zoom,r=d.viewMode,n=d.showBuildingBlock,l=d.mS,a=d.optimalZoom,s=d.ZL,f=d.cb,u=d.url;g.pQ(e,o,h,r,n,l,a,s,f,u)}g.xQ=[]}var p=g.bQ.length;if(0<p){for(t=0;t<p;t++){var d,x=(d=g.bQ[t]).CD,y=d.cQ,e=d.data,o=d.projectionId,f=d.cb,c=d.UQ,v=d.mH,s=d.ZL;g.mQ(x,y,e,o,f,c,v,s)}g.bQ=[]}})},h.prototype.bw=function(e,i,o,h,r,t,n,l,a,s,f,u,p){var d=this;if(void 0===p&&(p=!0),polyfill.Support.wasm&&p){if(!this.parent.PW)return void u("not init");p=i.join(";"),p=_aesJs_3_1_2_aesJs.fAA.DAA.AAA(\'["\'+p+\'","\'+f+\'"]\'),p=new _aesJs_3_1_2_aesJs.sAA.dAA(this.iii,new _aesJs_3_1_2_aesJs.Counter(5)).encrypt(p),p=_aesJs_3_1_2_aesJs.fAA.pAA.iAA(p),e=e+("?key="+this.parent.key)+"&val="+p}else e=e+("?key="+this.parent.key)+"&flds="+f+"&t="+i.join(";");return e+="&p=3",makeFetchRequest(this.parent.Uh,e,function(i,t){i?u(i):setTimeout(function(){d.pQ(t,r,o,l,a,n,h,s,u,e)},10)})},h.prototype.pQ=function(i,e,o,h,r,n,l,t,a,s){var f=this;if(this.parent.vn&&this.parent.vn._Q()){polyfill.Support.amapRunTime&&!polyfill.Support.amapRunTime["data-decode-begin"]&&(polyfill.Support.amapRunTime["data-decode-begin"]=(new Date).getTime());for(var u=polyfill.KQ(new Uint8Array(i)),p=[],d=(polyfill.forEach(u.tiles,function(i){var t=new polyfill.Gh(new polyfill.ca(i.z,i.x,i.y)),i=(t.data=f.kw(i,e,t),f.xw(t,o),f.zw(t,o,h,r),f.nz(t,n,l),polyfill.Util.pW(i.t));p.push({zo:t.zo,ba:t.data,tag:i,version:u.version||""})}),[]),x=this.parent.vn,y=0,c=p;y<c.length;y++){var v=c[y];if(v&&v.ba){if(v.ba.road){for(var g=[],w=0,b=v.ba.road;w<b.length;w++){var m=b[w],R=(R=x.dn(m.Fp,m.Ep,t))?R[1]:null;m.id&&R&&R.fontSize&&R.faceColor&&(delete m.gw,g.push({path:m.path,id:m.id}))}v.ba.road=g}delete v.ba.poilabel,delete v.ba.region,delete v.ba.building,delete v.ba.Mw}d.push(v)}polyfill.Support.amapRunTime&&!polyfill.Support.amapRunTime["data-decode-end"]&&(polyfill.Support.amapRunTime["data-decode-end"]=(new Date).getTime()),a(null,{nebulaDatas:d,amapRunTime:polyfill.Support.amapRunTime})}else this.xQ.push({data:i,projectionId:e,zoom:o,viewMode:h,showBuildingBlock:r,mS:n,optimalZoom:l,ZL:t,cb:a,url:s})},h.prototype.mQ=function(i,t,e,o,h,r,n,l){this.parent.vn?this.HQ(e,t,o,i,r,n,l,h):this.bQ.push({CD:i,cQ:t,data:e,projectionId:o,cb:h,UQ:r,mH:n,ZL:l})},h.prototype.bW=function(i,e,o,h,r,n){var l=this;if(polyfill.Support.wasm){if(!this.parent.PW)return void n("not init");var t=e.join(";"),t=_aesJs_3_1_2_aesJs.fAA.DAA.AAA(\'["\'+t+\'","poi,roadname"]\'),t=new _aesJs_3_1_2_aesJs.sAA.dAA(this.iii,new _aesJs_3_1_2_aesJs.Counter(5)).encrypt(t),t=_aesJs_3_1_2_aesJs.fAA.pAA.iAA(t);i=i+("?key="+this.parent.key)+"&val="+t}else i=i+("?key="+this.parent.key)+"&flds=poi,roadname&t="+e.join(";");i+="&p=3",this.WW=h;var a=-1!==i.indexOf("/oversea"),s=new polyfill.vH;return s._H(makeFetchRequest(this.parent.Uh,i,function(i,t){i?n(i):setTimeout(function(){l.mQ(e,a,t,o,n,s,r,h)},10)})),{cancel:s.cancel}},h.prototype.HQ=function(i,t,e,o,h,r,n,l){for(var a=this,s=polyfill.KQ(new Uint8Array(i)),f=(!t&&s.version&&this.parent.GW.nebulaVersion!==s.version&&(this.parent.GW.nebulaVersion=s.version,this.parent.GW.db=s.db,this.parent.IW.zW(this.parent.GW.db),this.parent.Uh.send("updateDataVersion",this.parent.GW.nebulaVersion)),[]),u=(polyfill.forEach(s.tiles,function(i){var t=new polyfill.Gh(new polyfill.ca(i.z,i.x,i.y)),i=(t.data=a.kw(i,e,t),polyfill.Util.pW(i.t));f.push({zo:t.zo,ba:t.data,tag:i})}),[]),p=0,d=f;p<d.length;p++){var x,y,c=d[p];c&&c.ba&&(x=c.ba.roadName,y=c.ba.poilabel,delete c.ba.poilabel,delete c.ba.Mw,u.push({zo:c.zo,ba:{roadName:x,poilabel:y},tag:c.tag,version:s.version||""}))}if(u.length){for(var v={},g=0,w=u;g<w.length;g++){var R=new polyfill.Gh((b=w[g]).zo),m=polyfill.wa.ga(R.zo.x,R.zo.y,R.zo.z,"EPSG:3857"),m=(R.type="nebula",t&&(R.cQ=!0),polyfill.lcs.getLocalByCoord([m[0],m[1]]));R.localCoord=m,R.data=b.ba;(m=this.parent.params).showLabel;var m=m.scale,b=b.tag;this.sQ[R.zo.key+","+b]={tile:R,params:{scale:m,tag:b}},v[R.zo.key+","+polyfill.Util.SD(b)]=!0}l(null,v)}},h.prototype.OW=function(i){this.parent.Zw?this.on("once",i):i()},h.prototype.YE=function(i,t){polyfill.map(polyfill.ZQ.ha(t.bounds,polyfill.ZQ.ra(t.zoom)),function(i){return i.join(",")});var t=this.sQ,e=polyfill.Util.getOptimalZoom(this.WW);i(t,{ZL:this.WW,optimalZoom:e,cb:function(){}}),this.sQ={}},h.prototype.kw=function(i,t,e){var x=this,o={},y=polyfill.ProjectionManager.getProjection(t),t=polyfill.wa.ga(i.x,i.y,i.z,"EPSG:3857"),c=polyfill.lcs.getLocalByCoord([t[0],t[1]]).center,v=(e.Mw=c,e.Ro=t,e.zo.z);return polyfill.forEach(i.layers,function(u){var i,p=[],d=h.Wa[u.type];polyfill.forEach(u.d[d],function(s){s.items.sort(x.A0);var f=x.parent.vn.mW(s.mainkey,s.subkey,v);polyfill.forEach(s.items,function(i){switch(d){case"road":for(var t=0;t<i.path.length;t+=2){var e=i.path[t],o=i.path[t+1],h=polyfill.XY(u,s.resolution,e,o),h=y.project(h[0],h[1]);v>=polyfill.Ra&&(h[0]-=c[0],h[1]-=c[1]),i.path[t]=h[0],i.path[t+1]=h[1]}break;case"region":for(var r=i.path,n=0;n<r.length;n+=1){for(var l=r[n].path,a=[],t=0;t<l.length;t+=2)e=l[t],o=l[t+1],h=polyfill.XY(u,s.resolution,e,o),a[t]=h[0],a[t+1]=h[1],h=y.project(h[0],h[1]),v>=polyfill.Ra&&(h[0]-=c[0],h[1]-=c[1]),l[t]=h[0],l[t+1]=h[1];r[n]=l}break;case"building":for(r=i.path,i.oW=[],n=0;n<r.length;n+=1){for(l=r[n].path,a=[],t=0;t<l.length;t+=2)e=l[t],o=l[t+1],h=polyfill.XY(u,s.resolution,e,o),a[t]=h[0],a[t+1]=h[1],h=y.project(h[0],h[1]),v>=polyfill.Ra&&(h[0]-=c[0],h[1]-=c[1]),l[t]=h[0],l[t+1]=h[1];r[n]=l,i.oW[n]=a}break;case"poilabel":case"roadName":if(i.pos&&(a=polyfill.XY(u,s.resolution,i.pos[0],i.pos[1]),i.pos=y.project(a[0],a[1])),i.path)if(i.shield)a=polyfill.XY(u,s.resolution,i.path[0],i.path[1]),h=y.project(a[0],a[1]),v>=polyfill.Ra&&(h[0]-=c[0],h[1]-=c[1]),i.path[0]=h[0],i.path[1]=h[1];else for(t=0;t<i.path.length;t+=2)e=i.path[t],o=i.path[t+1],h=polyfill.XY(u,s.resolution,e,o),h=y.project(h[0],h[1]),v>=polyfill.Ra&&(h[0]-=c[0],h[1]-=c[1]),i.path[t]=h[0],i.path[t+1]=h[1]}i.du=s.resolution,i.Fp=s.mainkey,i.Ep=s.subkey,i.zIndex=x.parent.vn.Lw(s.mainkey,s.subkey),i.lineCap=f[0],i.RQ=f[1],i.gw={z:u.z,y:u.y,x:u.x},p.push(i)})}),"poilabel"!==d?x.Tw(p):x.Na(p),"poilabel"===d?(i=u.z+"-"+u.x+"-"+u.y,o[d]?o[d][i]?o[d][i].push.apply(o[d][i],p):o[d][i]=p:(o[d]={},o[d][i]=p)):o[d]?o[d].push.apply(o[d],p):o[d]=p}),o.Mw=c,o},h.prototype.A0=function(i,t){return i.minzoom-t.minzoom||i.maxzoom-t.maxzoom},h.prototype.Tw=function(i){return i.sort(function(i,t){return i.zIndex-t.zIndex}),i},h.prototype.Na=function(i){return i.sort(function(i,t){return i.rank-t.rank}),i},h.prototype.xw=function(i,t){var e=i.data,o=new polyfill._w;if(e.Uc=o,!e.$c){e.$c=new polyfill.J_,e.road=e.road||[];var h=i.Mw.slice(0);if(i.zo.z<=polyfill.za&&(h[0]=0,h[1]=0),e.road.push({name:"",rank:1,maxzoom:polyfill.zoomRange[1],minzoom:polyfill.zoomRange[0],path:[i.Ro[0]-h[0],i.Ro[1]-h[1],i.Ro[2]-h[0],i.Ro[1]-h[1],i.Ro[2]-h[0],i.Ro[3]-h[1],i.Ro[0]-h[0],i.Ro[3]-h[1],i.Ro[0]-h[0],i.Ro[1]-h[1]],Fp:-2,Ep:-2,shield:"",shieldType:0,du:13,lineCap:"butt",RQ:"butt"}),e.road)for(var r=0,n=e.road;r<n.length;r++){var l=n[r],a=l.path,s=(a=e.$c.hb(a,{X_:"butt"===l.lineCap?0:.9,lineCap:l.lineCap,lineJoin:"auto"})).Iw,a=a.distance;0<s&&(o.add(l.Fp,l.Ep,s,l.minzoom,l.maxzoom),l.distance=a)}}},h.prototype.zw=function(i,L,P,t){var e=i.data,o=new polyfill._w;if(e.Oc=o,e.Fc=new polyfill._w,!e.Dc){e.Dc=new polyfill.K_,e.region=e.region||[];var h=i.Mw.slice(0);if(i.zo.z<=polyfill.za&&(h[0]=0,h[1]=0),e.region.unshift({maxzoom:polyfill.zoomRange[1],minzoom:polyfill.zoomRange[0],path:[[i.Ro[0]-h[0],i.Ro[1]-h[1],i.Ro[2]-h[0],i.Ro[1]-h[1],i.Ro[2]-h[0],i.Ro[3]-h[1],i.Ro[0]-h[0],i.Ro[3]-h[1],i.Ro[0]-h[0],i.Ro[1]-h[1]]],Fp:30001,Ep:1}),e.region)for(var r=0,n=e.region;r<n.length;r++)for(var l=n[r],a=0,s=l.path;a<s.length;a++)(b=s[a]).push(b[0],b[1]),0<(A=e.Dc.Nx(b))&&o.add(l.Fp,l.Ep,A,l.minzoom,l.maxzoom);if(!t&&e.building){if(e.FD)return;e.FD=new polyfill.K_,e.BD=new polyfill._w;for(var f=e.BD,u=0,p=e.building;u<p.length;u++){for(var d=p[u],y=(x=polyfill.jw(d.gw.z,d.gw.x,d.gw.y))[0],c=x[1],v=x[2],x=x[3],B=(i.Mw&&(y-=i.Mw[0],v-=i.Mw[0],c-=i.Mw[1],x-=i.Mw[1]),Math.floor(y)),O=Math.floor(v),J=Math.floor(c),U=Math.floor(x),g=0,w=d.path;g<w.length;g++){var b=w[g];0<(A=e.FD.Nx(b))&&f.add(d.Fp,d.Ep,A,d.minzoom,d.maxzoom,d.ew||"indoor_out_building")}for(var R=0,m=d.path;R<m.length;R++){for(var k=m[R],b=(k.push(k[0],k[1]),[]),_=0,S=k.length;_<S-2;_+=2)b.push(polyfill.xd(k[_],k[_+1])),b.push(polyfill.xd(k[_+2],k[_+3]));for(var I=[],_=0,S=b.length;_<S;_+=2){var A,C=b[_][0],E=b[_][1],j=b[_+1][0],V=b[_+1][1],M=Math.floor(C),D=Math.floor(E);(C!==j||M!==B&&M!==O)&&(E!==V||D!==J&&D!==U)?I.push(b[_],b[_+1]):(0<(A=e.Dc.Ew(I))&&e.Fc.add(d.Fp,d.Ep,A,d.minzoom,d.maxzoom,d.ew||"indoor_out_building"),I=[])}0<I.length&&0<(A=e.Dc.Ew(I))&&e.Fc.add(d.Fp,d.Ep,A,d.minzoom,d.maxzoom,d.ew)}}}if(e.building){for(var T=[],z=0,W=e.building;z<W.length;z++)if((d=W[z]).ew)if(-1<d.ew.indexOf("|"))for(var F=d.ew.split("|"),_=0;_<F.length;_++)T.push(F[_]);else T.push(d.ew);e.indoorInfo||(e.indoorInfo=[]),e.indoorInfo=T}}},h.prototype.nz=function(i,t,e){void 0===t&&(t={});var o=i.data;if(o.C_=new polyfill._w,!o.A_){o.A_=new polyfill.iz;var h=t.hideWithoutStyle,r=t.areas;if(o.building)for(var n=0,l=o.building;n<l.length;n++)for(var a=l[n],s=0;s<a.path.length;s++){for(var f=a.path[s],u=a.oW[s],p=(f.push(f[0],f[1]),u.push(u[0],u[1]),[]),d=0;d<u.length;d+=2)p.push([u[d],u[d+1]]);if(r){for(var x,y=!1,c=!1,v={},g=0;g<r.length;g++){var w=r[g],b=w.path;geoUtil.isRingInRing(p,b)&&(y=!0,!w.visible&&void 0!==w.visible||(c=!0,v={roofColor:polyfill.Util.color2RgbaArray(w.color1),wallColor:polyfill.Util.color2RgbaArray(w.color2)}))}!y&&h||y&&!c||0<(x=o.A_.tz(f,a.height))&&o.C_.add(a.Fp,a.Ep,x,a.minzoom,a.maxzoom,a.ew,v.roofColor,v.wallColor)}else 0<(x=o.A_.tz(f,a.height))&&o.C_.add(a.Fp,a.Ep,x,a.minzoom,a.maxzoom,a.ew)}}},h.prototype.hQ=function(i,t){if(i)for(var e=this.SQ(i)||[],o=0,h=e=new LabelFormatMap[i.type]({vn:this.parent.vn}).DQ(e,{zoom:t});o<h.length;o++){var r=h[o],n=r.CO;r.EG||(r.EG={});for(var l=0,a=n;l<a.length;l++){var s=a[l],f=this.parent.R_.mz(s);r.EG[s]=f}}return e},h.prototype.SQ=function(i){return i.data&&i.data.roadName||i.Dh},h.Pw=[1,0,1,0],h.Wa={0:"poilabel",1:"road",2:"region",3:"building",4:"roadName"},h}(polyfill.Event),hasWarning=!1;function makeFetchRequest(i,t,e){var o,h,r;return!polyfill.Support.safari&&!polyfill.Support.AQ&&!polyfill.Support.gQ&&self.fetch&&self.Request&&self.AbortController&&self.Request.prototype.hasOwnProperty("signal")?(h=(o=new AbortController).signal,h=new self.Request(t,{method:"GET",referrer:"null"===self.location.origin?void 0:self.location.origin,signal:h}),polyfill.Support.amapRunTime&&!polyfill.Support.amapRunTime["data-request"]&&(polyfill.Support.amapRunTime["data-request"]=(new Date).getTime()),fetch(h).then(function(i){return polyfill.Support.amapRunTime&&!polyfill.Support.amapRunTime["data-loaded"]&&(polyfill.Support.amapRunTime["data-loaded"]=(new Date).getTime()),"application/x-protobuf"===i.headers.get("content-type")?i.arrayBuffer():i.json()}).then(function(i){i.info?hasWarning||(hasWarning=!0,console.log(t),console.log("<AMap JSAPI> KEY异常，错误信息："+i.info)):e(null,i)}).catch(function(i){"AbortError"!==i.name&&e(i.message||"unknown error")}),{cancel:function(){o.abort()}}):r=i.send("request",t,function(i,t){i?("<cancel>"===i&&r&&r.cancel&&r.cancel(),r=void 0,e(i)):(r=void 0,e(null,t))})}var DistrictSourceWorker=function(){function DistrictSourceWorker(i){this.parent=i,this.fW={}}return DistrictSourceWorker.prototype.bw=function(i,t,e,o,h){var r=this,n=new XMLHttpRequest;return n.onreadystatechange=function(){var i;4!==n.readyState||200!==n.status&&204!==n.status||(i=new polyfill.tW(new polyfill.pw(new Uint8Array(n.response))),i=r.Ow(i,{x:t.x,y:t.y,z:t.z,projectionId:e,tileSize:o}),h(null,polyfill.Ln({zo:t},i)))},n.open("GET",i,!0),n.responseType="arraybuffer",n.send(),{cancel:function(){n.abort()}}},DistrictSourceWorker.prototype.Ow=function(s,i){var e=i.x,o=i.y,h=i.z,r=i.tileSize,n=i.projectionId,i=(s.z=h,s.x=e,s.y=o,polyfill.ProjectionManager.getProjection(n).getResolution(h)),l=(s.Ro=polyfill.$Q(e,o,h,i,r),s.zS=polyfill.lcs.getLocalByCoord([s.Ro[0],s.Ro[1]]),polyfill.ProjectionManager.getProjection(n).getResolution(h));return polyfill.vx(s.layers,function(a){var i=a.Cw,t=(a.Ah=[],a.scale=l*r/a.extent,polyfill.V[n].Xs(r*e,r*o,h));a.ox=t[0],a.oy=t[1],polyfill.forEach(i,function(i,t){if((i=a.Gw(t)).Dw(),a.Ah.push(i),i.lines&&0<i.lines.length){i.Rw=[];for(var e=0,o=i.lines.length;e<o;e++){for(var h=[],r=0,n=i.lines[e].length;r<n;r++){var l=[a.ox+a.scale*i.lines[e][r][0]-s.zS.center[0],a.oy-a.scale*i.lines[e][r][1]-s.zS.center[1]];h.push(l)}i.Rw.push(h)}}})}),this.uW(s),this.xw(s),this.zw(s),s},DistrictSourceWorker.prototype.uW=function(i){var t,e=[],o=[];for(t in i.layers)if(i.layers.hasOwnProperty(t))for(var h=i.layers[t],r=0;r<h.Ah.length;r+=1){var n=h.Ah[r];if(3==+n.type&&n.Rw){for(var l=n.Rw,a=[],s=0;s<l.length;s++)polyfill.kS.isClockwise(l[s])?a.push([s]):a.length&&a[a.length-1].push(s);for(var f=0;f<a.length;f++){var u=a[f];if(1<u.length){for(var p=[],d=[],x=0;x<u.length;x++){var y=l[u[x]];0<x&&p.push(d.length/2);for(var c=0;c<y.length;c++){var v=y[c];d.push(v[0],v[1])}}e.push({properties:n.properties,path:d,LQ:p})}else{for(d=[],y=l[u[0]],c=0;c<y.length;c++){var g=y[c];d.push(g[0],g[1])}e.push({properties:n.properties,path:d})}}}else if(3!==n.type&&n.Rw)for(var w=0;w<n.Rw.length;w++)o.push({properties:n.properties,path:n.Rw[w]});this.cW(n)}i.polygons=e,i.Dh=o,delete i.layers},DistrictSourceWorker.prototype.xw=function(i){if(!i||!i.$c){var t=new polyfill.LW;if(!i.$c&&(i.Uc=t,i.$c=new polyfill.J_,i.Dh))for(var e=0,o=i.Dh;e<o.length;e++){var h=o[e],r=JSON.stringify(h.properties),l=(n=i.$c.g0(h.path,{X_:0,lineJoin:"round",lineCap:"butt"})).Iw,n=n.distance;0<l&&(t.add(r,0,l,0,22),h.distance=n)}}},DistrictSourceWorker.prototype.zw=function(i){if(!i||!i.Dc){var t=new polyfill.LW;i.Oc=t,i.Dc=new polyfill.K_;for(var e=0,o=i.polygons;e<o.length;e++){var h=o[e],r=JSON.stringify(h.properties);0<(h=i.Dc.Nx(h.path,h.LQ))&&t.add(r,0,h,0,22)}}},DistrictSourceWorker.prototype.dW=function(i){switch(i){case 0:case 1:return"Nation_Border_China";case 2:return"Coastline_China";case 3:case 4:return"Province_Border_China";case 5:return"City_Border_China";case 6:return"County_Border_China";case 7:case 8:return"Nation_Border_Foreign";case 9:return"Coastline_Foreign";case 10:case 11:return"Nation_Border_Foreign";case 12:return"Province_Border_Foreign";default:return""}},DistrictSourceWorker.prototype.sW=function(code){return this.fW[code]||(this.fW[code]=eval("\'"+code.replace(/\\//g,"\\\\u")+"\'")),this.fW[code]},DistrictSourceWorker.prototype.cW=function(i){i.properties.NAME_CHN&&(i.properties.NAME_CHN=this.sW(i.properties.NAME_CHN.trim())),i.properties.NAME_ENG&&(i.properties.NAME_ENG=i.properties.NAME_ENG.trim()),i.properties.level&&(i.properties.level=i.properties.level.trim()),i.properties.citycode&&i.properties.citycode.length&&(i.properties.citycode=i.properties.citycode.trim()),i.properties.type_=+i.properties.type,i.properties.feature_type_=+i.type,i.properties.type=this.dW(+i.properties.type)},DistrictSourceWorker}(),mbStyle={Hr:void 0,_r:{},kr:{"pedestrian-polygon":{width:128,height:128,x:0,y:0,pixelRatio:2,visible:!0},"turning-circle-outline":{width:92,height:92,x:128,y:0,pixelRatio:2,visible:!0},"turning-circle":{width:84,height:84,x:0,y:128,pixelRatio:2,visible:!0},"us-interstate-truck-2":{width:40,height:80,x:84,y:128,pixelRatio:2,visible:!0},"us-interstate-truck-3":{width:52,height:80,x:124,y:128,pixelRatio:2,visible:!0},"us-highway-business-2":{width:40,height:76,x:176,y:128,pixelRatio:2,visible:!0},"us-highway-business-3":{width:52,height:76,x:216,y:128,pixelRatio:2,visible:!0},"us-highway-bypass-2":{width:40,height:76,x:268,y:128,pixelRatio:2,visible:!0},"us-highway-bypass-3":{width:52,height:76,x:308,y:128,pixelRatio:2,visible:!0},"us-highway-truck-2":{width:40,height:76,x:360,y:128,pixelRatio:2,visible:!0},"us-highway-truck-3":{width:52,height:76,x:400,y:128,pixelRatio:2,visible:!0},"ae-f-route-3":{width:48,height:54,x:452,y:128,pixelRatio:2,visible:!0},"ae-s-route-4":{width:76,height:52,x:220,y:0,pixelRatio:2,visible:!0},"pe-national-2":{width:36,height:52,x:296,y:0,pixelRatio:2,visible:!0},"pe-national-3":{width:44,height:52,x:332,y:0,pixelRatio:2,visible:!0},"ae-national-3":{width:52,height:50,x:376,y:0,pixelRatio:2,visible:!0},"ae-national-4":{width:64,height:50,x:428,y:0,pixelRatio:2,visible:!0},"ae-d-route-3":{width:48,height:48,x:0,y:212,pixelRatio:2,visible:!0},"ae-d-route-4":{width:60,height:48,x:48,y:212,pixelRatio:2,visible:!0},"tw-provincial-2":{width:44,height:48,x:108,y:212,pixelRatio:2,visible:!0},"tw-provincial-3":{width:56,height:48,x:152,y:212,pixelRatio:2,visible:!0},"tw-provincial-expy-2":{width:44,height:48,x:208,y:212,pixelRatio:2,visible:!0},"tw-provincial-expy-3":{width:56,height:48,x:252,y:212,pixelRatio:2,visible:!0},"za-provincial-2":{width:48,height:48,x:308,y:212,pixelRatio:2,visible:!0},"cn-nths-expy-2":{width:40,height:46,x:356,y:212,pixelRatio:2,visible:!0},"cn-nths-expy-3":{width:52,height:46,x:396,y:212,pixelRatio:2,visible:!0},"cn-nths-expy-4":{width:64,height:46,x:448,y:212,pixelRatio:2,visible:!0},"cn-nths-expy-5":{width:76,height:46,x:0,y:260,pixelRatio:2,visible:!0},"cn-provincial-expy-2":{width:40,height:46,x:76,y:260,pixelRatio:2,visible:!0},"cn-provincial-expy-3":{width:52,height:46,x:116,y:260,pixelRatio:2,visible:!0},"cn-provincial-expy-4":{width:64,height:46,x:168,y:260,pixelRatio:2,visible:!0},"cn-provincial-expy-5":{width:76,height:46,x:232,y:260,pixelRatio:2,visible:!0},"br-federal-3":{width:52,height:44,x:308,y:260,pixelRatio:2,visible:!0},"hk-strategic-route-2":{width:36,height:44,x:360,y:260,pixelRatio:2,visible:!0},"in-national-2":{width:32,height:44,x:396,y:260,pixelRatio:2,visible:!0},"in-national-3":{width:40,height:44,x:428,y:260,pixelRatio:2,visible:!0},"in-national-4":{width:48,height:44,x:0,y:306,pixelRatio:2,visible:!0},"in-state-2":{width:32,height:44,x:48,y:306,pixelRatio:2,visible:!0},"in-state-3":{width:40,height:44,x:80,y:306,pixelRatio:2,visible:!0},"kr-natl-expy-2":{width:40,height:44,x:120,y:306,pixelRatio:2,visible:!0},"kr-natl-expy-3":{width:52,height:44,x:160,y:306,pixelRatio:2,visible:!0},"mx-federal-2":{width:36,height:44,x:212,y:306,pixelRatio:2,visible:!0},"mx-federal-3":{width:46,height:44,x:248,y:306,pixelRatio:2,visible:!0},"mx-federal-4":{width:56,height:44,x:294,y:306,pixelRatio:2,visible:!0},"mx-state-2":{width:36,height:44,x:350,y:306,pixelRatio:2,visible:!0},"mx-state-3":{width:46,height:44,x:386,y:306,pixelRatio:2,visible:!0},"mx-state-4":{width:56,height:44,x:432,y:306,pixelRatio:2,visible:!0},"pe-regional-3":{width:46,height:44,x:0,y:350,pixelRatio:2,visible:!0},"pe-regional-4":{width:56,height:44,x:46,y:350,pixelRatio:2,visible:!0},"tw-national-2":{width:42,height:44,x:102,y:350,pixelRatio:2,visible:!0},"us-interstate-2":{width:40,height:44,x:144,y:350,pixelRatio:2,visible:!0},"us-interstate-3":{width:52,height:44,x:184,y:350,pixelRatio:2,visible:!0},"us-interstate-4":{width:64,height:44,x:236,y:350,pixelRatio:2,visible:!0},"us-interstate-business-2":{width:40,height:44,x:300,y:350,pixelRatio:2,visible:!0},"us-interstate-business-3":{width:52,height:44,x:340,y:350,pixelRatio:2,visible:!0},"us-interstate-duplex-4":{width:64,height:44,x:392,y:350,pixelRatio:2,visible:!0},"us-interstate-duplex-5":{width:76,height:44,x:0,y:394,pixelRatio:2,visible:!0},"airfield-15":{width:42,height:42,x:456,y:350,pixelRatio:2,visible:!0},"airport-15":{width:42,height:42,x:76,y:394,pixelRatio:2,visible:!0},"alcohol-shop-15":{width:42,height:42,x:118,y:394,pixelRatio:2,visible:!0},"american-football-15":{width:42,height:42,x:160,y:394,pixelRatio:2,visible:!0},"amusement-park-15":{width:42,height:42,x:202,y:394,pixelRatio:2,visible:!0},"aquarium-15":{width:42,height:42,x:244,y:394,pixelRatio:2,visible:!0},"art-gallery-15":{width:42,height:42,x:286,y:394,pixelRatio:2,visible:!0},"attraction-15":{width:42,height:42,x:328,y:394,pixelRatio:2,visible:!0},"au-tourist-2":{width:40,height:42,x:370,y:394,pixelRatio:2,visible:!0},"au-tourist-3":{width:56,height:42,x:410,y:394,pixelRatio:2,visible:!0},"bakery-15":{width:42,height:42,x:466,y:394,pixelRatio:2,visible:!0},"bank-15":{width:42,height:42,x:468,y:260,pixelRatio:2,visible:!0},"bar-15":{width:42,height:42,x:0,y:438,pixelRatio:2,visible:!0},"basketball-15":{width:42,height:42,x:42,y:438,pixelRatio:2,visible:!0},"beach-15":{width:42,height:42,x:84,y:438,pixelRatio:2,visible:!0},"beer-15":{width:42,height:42,x:126,y:438,pixelRatio:2,visible:!0},"bicycle-15":{width:42,height:42,x:168,y:438,pixelRatio:2,visible:!0},"bowling-alley-15":{width:42,height:42,x:210,y:438,pixelRatio:2,visible:!0},"bridge-15":{width:42,height:42,x:252,y:438,pixelRatio:2,visible:!0},"cafe-15":{width:42,height:42,x:294,y:438,pixelRatio:2,visible:!0},"campsite-15":{width:42,height:42,x:336,y:438,pixelRatio:2,visible:!0},"car-15":{width:42,height:42,x:378,y:438,pixelRatio:2,visible:!0},"car-rental-15":{width:42,height:42,x:420,y:438,pixelRatio:2,visible:!0},"car-repair-15":{width:42,height:42,x:462,y:438,pixelRatio:2,visible:!0},"casino-15":{width:42,height:42,x:504,y:438,pixelRatio:2,visible:!0},"castle-15":{width:42,height:42,x:546,y:438,pixelRatio:2,visible:!0},"cemetery-15":{width:42,height:42,x:588,y:438,pixelRatio:2,visible:!0},"charging-station-15":{width:42,height:42,x:630,y:438,pixelRatio:2,visible:!0},"cinema-15":{width:42,height:42,x:672,y:438,pixelRatio:2,visible:!0},"clothing-store-15":{width:42,height:42,x:714,y:438,pixelRatio:2,visible:!0},"college-15":{width:42,height:42,x:756,y:438,pixelRatio:2,visible:!0},"communications-tower-15":{width:42,height:42,x:798,y:438,pixelRatio:2,visible:!0},"confectionery-15":{width:42,height:42,x:840,y:438,pixelRatio:2,visible:!0},"convenience-15":{width:42,height:42,x:882,y:438,pixelRatio:2,visible:!0},"dentist-15":{width:42,height:42,x:924,y:438,pixelRatio:2,visible:!0},"doctor-15":{width:42,height:42,x:966,y:438,pixelRatio:2,visible:!0},"dog-park-15":{width:42,height:42,x:488,y:306,pixelRatio:2,visible:!0},"drinking-water-15":{width:42,height:42,x:530,y:306,pixelRatio:2,visible:!0},"embassy-15":{width:42,height:42,x:572,y:306,pixelRatio:2,visible:!0},"farm-15":{width:42,height:42,x:614,y:306,pixelRatio:2,visible:!0},"fast-food-15":{width:42,height:42,x:656,y:306,pixelRatio:2,visible:!0},"fire-station-15":{width:42,height:42,x:698,y:306,pixelRatio:2,visible:!0},"fitness-centre-15":{width:42,height:42,x:740,y:306,pixelRatio:2,visible:!0},"fuel-15":{width:42,height:42,x:782,y:306,pixelRatio:2,visible:!0},"furniture-15":{width:42,height:42,x:824,y:306,pixelRatio:2,visible:!0},"garden-15":{width:42,height:42,x:866,y:306,pixelRatio:2,visible:!0},"globe-15":{width:42,height:42,x:908,y:306,pixelRatio:2,visible:!0},"golf-15":{width:42,height:42,x:950,y:306,pixelRatio:2,visible:!0},"grocery-15":{width:42,height:42,x:498,y:350,pixelRatio:2,visible:!0},"harbor-15":{width:42,height:42,x:540,y:350,pixelRatio:2,visible:!0},"hardware-15":{width:42,height:42,x:582,y:350,pixelRatio:2,visible:!0},"heliport-15":{width:42,height:42,x:624,y:350,pixelRatio:2,visible:!0},"horse-riding-15":{width:42,height:42,x:666,y:350,pixelRatio:2,visible:!0},"hospital-15":{width:42,height:42,x:708,y:350,pixelRatio:2,visible:!0},"ice-cream-15":{width:42,height:42,x:750,y:350,pixelRatio:2,visible:!0},"information-15":{width:42,height:42,x:792,y:350,pixelRatio:2,visible:!0},"jewelry-store-15":{width:42,height:42,x:834,y:350,pixelRatio:2,visible:!0},"laundry-15":{width:42,height:42,x:876,y:350,pixelRatio:2,visible:!0},"library-15":{width:42,height:42,x:918,y:350,pixelRatio:2,visible:!0},"lodging-15":{width:42,height:42,x:960,y:350,pixelRatio:2,visible:!0},"mobile-phone-15":{width:42,height:42,x:508,y:394,pixelRatio:2,visible:!0},"monument-15":{width:42,height:42,x:550,y:394,pixelRatio:2,visible:!0},"mountain-15":{width:42,height:42,x:592,y:394,pixelRatio:2,visible:!0},"museum-15":{width:42,height:42,x:634,y:394,pixelRatio:2,visible:!0},"music-15":{width:42,height:42,x:676,y:394,pixelRatio:2,visible:!0},"optician-15":{width:42,height:42,x:718,y:394,pixelRatio:2,visible:!0},"park-15":{width:42,height:42,x:760,y:394,pixelRatio:2,visible:!0},"parking-15":{width:42,height:42,x:802,y:394,pixelRatio:2,visible:!0},"parking-garage-15":{width:42,height:42,x:844,y:394,pixelRatio:2,visible:!0},"pharmacy-15":{width:42,height:42,x:886,y:394,pixelRatio:2,visible:!0},"picnic-site-15":{width:42,height:42,x:928,y:394,pixelRatio:2,visible:!0},"pitch-15":{width:42,height:42,x:970,y:394,pixelRatio:2,visible:!0},"place-of-worship-15":{width:42,height:42,x:510,y:260,pixelRatio:2,visible:!0},"playground-15":{width:42,height:42,x:552,y:260,pixelRatio:2,visible:!0},"police-15":{width:42,height:42,x:594,y:260,pixelRatio:2,visible:!0},"post-15":{width:42,height:42,x:636,y:260,pixelRatio:2,visible:!0},"prison-15":{width:42,height:42,x:678,y:260,pixelRatio:2,visible:!0},"ranger-station-15":{width:42,height:42,x:720,y:260,pixelRatio:2,visible:!0},"religious-buddhist-15":{width:42,height:42,x:762,y:260,pixelRatio:2,visible:!0},"religious-christian-15":{width:42,height:42,x:804,y:260,pixelRatio:2,visible:!0},"religious-jewish-15":{width:42,height:42,x:846,y:260,pixelRatio:2,visible:!0},"religious-muslim-15":{width:42,height:42,x:888,y:260,pixelRatio:2,visible:!0},"restaurant-15":{width:42,height:42,x:930,y:260,pixelRatio:2,visible:!0},"restaurant-noodle-15":{width:42,height:42,x:972,y:260,pixelRatio:2,visible:!0},"restaurant-pizza-15":{width:42,height:42,x:512,y:212,pixelRatio:2,visible:!0},"restaurant-seafood-15":{width:42,height:42,x:554,y:212,pixelRatio:2,visible:!0},"rocket-15":{width:42,height:42,x:596,y:212,pixelRatio:2,visible:!0},"school-15":{width:42,height:42,x:638,y:212,pixelRatio:2,visible:!0},"shoe-15":{width:42,height:42,x:680,y:212,pixelRatio:2,visible:!0},"shop-15":{width:42,height:42,x:722,y:212,pixelRatio:2,visible:!0},"skateboard-15":{width:42,height:42,x:764,y:212,pixelRatio:2,visible:!0},"slipway-15":{width:42,height:42,x:806,y:212,pixelRatio:2,visible:!0},"stadium-15":{width:42,height:42,x:848,y:212,pixelRatio:2,visible:!0},"suitcase-15":{width:42,height:42,x:890,y:212,pixelRatio:2,visible:!0},"swimming-15":{width:42,height:42,x:932,y:212,pixelRatio:2,visible:!0},"table-tennis-15":{width:42,height:42,x:974,y:212,pixelRatio:2,visible:!0},"tennis-15":{width:42,height:42,x:500,y:128,pixelRatio:2,visible:!0},"theatre-15":{width:42,height:42,x:542,y:128,pixelRatio:2,visible:!0},"toilet-15":{width:42,height:42,x:584,y:128,pixelRatio:2,visible:!0},"town-hall-15":{width:42,height:42,x:626,y:128,pixelRatio:2,visible:!0},"veterinary-15":{width:42,height:42,x:668,y:128,pixelRatio:2,visible:!0},"viewpoint-15":{width:42,height:42,x:710,y:128,pixelRatio:2,visible:!0},"volcano-15":{width:42,height:42,x:752,y:128,pixelRatio:2,visible:!0},"volleyball-15":{width:42,height:42,x:794,y:128,pixelRatio:2,visible:!0},"watch-15":{width:42,height:42,x:836,y:128,pixelRatio:2,visible:!0},"waterfall-15":{width:42,height:42,x:878,y:128,pixelRatio:2,visible:!0},"watermill-15":{width:42,height:42,x:920,y:128,pixelRatio:2,visible:!0},"windmill-15":{width:42,height:42,x:962,y:128,pixelRatio:2,visible:!0},"zoo-15":{width:42,height:42,x:492,y:0,pixelRatio:2,visible:!0},"au-national-highway-2":{width:40,height:40,x:534,y:0,pixelRatio:2,visible:!0},"au-national-highway-3":{width:52,height:40,x:574,y:0,pixelRatio:2,visible:!0},"au-national-route-2":{width:40,height:40,x:626,y:0,pixelRatio:2,visible:!0},"au-national-route-3":{width:52,height:40,x:666,y:0,pixelRatio:2,visible:!0},"au-national-route-4":{width:64,height:40,x:718,y:0,pixelRatio:2,visible:!0},"au-national-route-5":{width:76,height:40,x:782,y:0,pixelRatio:2,visible:!0},"au-national-route-6":{width:86,height:40,x:858,y:0,pixelRatio:2,visible:!0},"au-state-2":{width:36,height:40,x:944,y:0,pixelRatio:2,visible:!0},"au-state-3":{width:46,height:40,x:0,y:480,pixelRatio:2,visible:!0},"au-state-4":{width:58,height:40,x:46,y:480,pixelRatio:2,visible:!0},"au-state-5":{width:68,height:40,x:104,y:480,pixelRatio:2,visible:!0},"au-state-6":{width:78,height:40,x:172,y:480,pixelRatio:2,visible:!0},"br-state-2":{width:40,height:40,x:250,y:480,pixelRatio:2,visible:!0},"br-state-3":{width:56,height:40,x:290,y:480,pixelRatio:2,visible:!0},"circle-white-2":{width:40,height:40,x:346,y:480,pixelRatio:2,visible:!0},"circle-white-3":{width:52,height:40,x:386,y:480,pixelRatio:2,visible:!0},"circle-white-4":{width:64,height:40,x:438,y:480,pixelRatio:2,visible:!0},"hu-main-2":{width:40,height:40,x:502,y:480,pixelRatio:2,visible:!0},"hu-main-3":{width:52,height:40,x:542,y:480,pixelRatio:2,visible:!0},"hu-main-4":{width:64,height:40,x:594,y:480,pixelRatio:2,visible:!0},"hu-main-5":{width:76,height:40,x:658,y:480,pixelRatio:2,visible:!0},"hu-motorway-2":{width:40,height:40,x:734,y:480,pixelRatio:2,visible:!0},"hu-motorway-3":{width:52,height:40,x:774,y:480,pixelRatio:2,visible:!0},"marker-15":{width:24,height:40,x:826,y:480,pixelRatio:2,visible:!0},"nz-state-2":{width:36,height:40,x:850,y:480,pixelRatio:2,visible:!0},"nz-state-3":{width:46,height:40,x:886,y:480,pixelRatio:2,visible:!0},"ro-communal-2":{width:40,height:40,x:932,y:480,pixelRatio:2,visible:!0},"ro-communal-3":{width:52,height:40,x:972,y:480,pixelRatio:2,visible:!0},"ro-communal-4":{width:64,height:40,x:0,y:520,pixelRatio:2,visible:!0},"ro-county-3":{width:52,height:40,x:64,y:520,pixelRatio:2,visible:!0},"ro-county-4":{width:64,height:40,x:116,y:520,pixelRatio:2,visible:!0},"ro-national-2":{width:40,height:40,x:180,y:520,pixelRatio:2,visible:!0},"ro-national-3":{width:52,height:40,x:220,y:520,pixelRatio:2,visible:!0},"tw-county-township-2":{width:40,height:40,x:272,y:520,pixelRatio:2,visible:!0},"tw-county-township-3":{width:52,height:40,x:312,y:520,pixelRatio:2,visible:!0},"tw-county-township-4":{width:64,height:40,x:364,y:520,pixelRatio:2,visible:!0},"tw-county-township-5":{width:76,height:40,x:428,y:520,pixelRatio:2,visible:!0},"tw-county-township-6":{width:88,height:40,x:504,y:520,pixelRatio:2,visible:!0},"us-bia-2":{width:40,height:40,x:592,y:520,pixelRatio:2,visible:!0},"us-bia-3":{width:52,height:40,x:632,y:520,pixelRatio:2,visible:!0},"us-bia-4":{width:60,height:40,x:684,y:520,pixelRatio:2,visible:!0},"us-highway-2":{width:40,height:40,x:744,y:520,pixelRatio:2,visible:!0},"us-highway-3":{width:52,height:40,x:784,y:520,pixelRatio:2,visible:!0},"us-highway-4":{width:64,height:40,x:836,y:520,pixelRatio:2,visible:!0},"us-highway-alternate-2":{width:40,height:40,x:900,y:520,pixelRatio:2,visible:!0},"us-highway-alternate-3":{width:52,height:40,x:940,y:520,pixelRatio:2,visible:!0},"us-highway-duplex-3":{width:52,height:40,x:0,y:560,pixelRatio:2,visible:!0},"us-highway-duplex-4":{width:64,height:40,x:52,y:560,pixelRatio:2,visible:!0},"us-highway-duplex-5":{width:76,height:40,x:116,y:560,pixelRatio:2,visible:!0},"za-national-2":{width:40,height:40,x:192,y:560,pixelRatio:2,visible:!0},"za-national-3":{width:56,height:40,x:232,y:560,pixelRatio:2,visible:!0},"barcelona-metro":{width:38,height:38,x:288,y:560,pixelRatio:2,visible:!0},"boston-t":{width:38,height:38,x:326,y:560,pixelRatio:2,visible:!0},"de-s-bahn":{width:38,height:38,x:364,y:560,pixelRatio:2,visible:!0},"de-s-bahn.de-u-bahn":{width:70,height:38,x:402,y:560,pixelRatio:2,visible:!0},"delhi-metro":{width:38,height:38,x:472,y:560,pixelRatio:2,visible:!0},"kiev-metro":{width:38,height:38,x:510,y:560,pixelRatio:2,visible:!0},"kr-metro-expy-2":{width:40,height:38,x:548,y:560,pixelRatio:2,visible:!0},"kr-metro-expy-3":{width:52,height:38,x:588,y:560,pixelRatio:2,visible:!0},"kr-metro-expy-4":{width:64,height:38,x:640,y:560,pixelRatio:2,visible:!0},"madrid-metro":{width:38,height:38,x:704,y:560,pixelRatio:2,visible:!0},"new-york-subway":{width:38,height:38,x:742,y:560,pixelRatio:2,visible:!0},"oslo-metro":{width:38,height:38,x:780,y:560,pixelRatio:2,visible:!0},"paris-metro":{width:38,height:38,x:818,y:560,pixelRatio:2,visible:!0},"paris-metro.paris-rer":{width:74,height:38,x:856,y:560,pixelRatio:2,visible:!0},"paris-rer":{width:38,height:38,x:930,y:560,pixelRatio:2,visible:!0},"paris-rer.paris-transilien":{width:70,height:38,x:0,y:600,pixelRatio:2,visible:!0},"road-closure":{width:38,height:38,x:70,y:600,pixelRatio:2,visible:!0},"stockholm-metro":{width:38,height:38,x:108,y:600,pixelRatio:2,visible:!0},"taipei-metro":{width:38,height:38,x:146,y:600,pixelRatio:2,visible:!0},"vienna-u-bahn":{width:38,height:38,x:184,y:600,pixelRatio:2,visible:!0},"kr-natl-hwy-2":{width:44,height:36,x:222,y:600,pixelRatio:2,visible:!0},"airfield-11":{width:34,height:34,x:266,y:600,pixelRatio:2,visible:!0},"airport-11":{width:34,height:34,x:300,y:600,pixelRatio:2,visible:!0},"alcohol-shop-11":{width:34,height:34,x:334,y:600,pixelRatio:2,visible:!0},"american-football-11":{width:34,height:34,x:368,y:600,pixelRatio:2,visible:!0},"amusement-park-11":{width:34,height:34,x:402,y:600,pixelRatio:2,visible:!0},"aquarium-11":{width:34,height:34,x:436,y:600,pixelRatio:2,visible:!0},"art-gallery-11":{width:34,height:34,x:470,y:600,pixelRatio:2,visible:!0},"attraction-11":{width:34,height:34,x:504,y:600,pixelRatio:2,visible:!0},"bakery-11":{width:34,height:34,x:538,y:600,pixelRatio:2,visible:!0},"bank-11":{width:34,height:34,x:572,y:600,pixelRatio:2,visible:!0},"bar-11":{width:34,height:34,x:606,y:600,pixelRatio:2,visible:!0},"basketball-11":{width:34,height:34,x:640,y:600,pixelRatio:2,visible:!0},"beach-11":{width:34,height:34,x:674,y:600,pixelRatio:2,visible:!0},"beer-11":{width:34,height:34,x:708,y:600,pixelRatio:2,visible:!0},"bicycle-11":{width:34,height:34,x:742,y:600,pixelRatio:2,visible:!0},"bicycle-share":{width:34,height:34,x:776,y:600,pixelRatio:2,visible:!0},"bowling-alley-11":{width:34,height:34,x:810,y:600,pixelRatio:2,visible:!0},"bridge-11":{width:34,height:34,x:844,y:600,pixelRatio:2,visible:!0},bus:{width:34,height:34,x:878,y:600,pixelRatio:2,visible:!0},"cafe-11":{width:34,height:34,x:912,y:600,pixelRatio:2,visible:!0},"campsite-11":{width:34,height:34,x:946,y:600,pixelRatio:2,visible:!0},"car-11":{width:34,height:34,x:980,y:600,pixelRatio:2,visible:!0},"car-rental-11":{width:34,height:34,x:968,y:560,pixelRatio:2,visible:!0},"car-repair-11":{width:34,height:34,x:980,y:0,pixelRatio:2,visible:!0},"casino-11":{width:34,height:34,x:0,y:638,pixelRatio:2,visible:!0},"castle-11":{width:34,height:34,x:34,y:638,pixelRatio:2,visible:!0},"cemetery-11":{width:34,height:34,x:68,y:638,pixelRatio:2,visible:!0},"charging-station-11":{width:34,height:34,x:102,y:638,pixelRatio:2,visible:!0},"chongqing-rail-transit":{width:50,height:34,x:136,y:638,pixelRatio:2,visible:!0},"cinema-11":{width:34,height:34,x:186,y:638,pixelRatio:2,visible:!0},"clothing-store-11":{width:34,height:34,x:220,y:638,pixelRatio:2,visible:!0},"college-11":{width:34,height:34,x:254,y:638,pixelRatio:2,visible:!0},"communications-tower-11":{width:34,height:34,x:288,y:638,pixelRatio:2,visible:!0},"confectionery-11":{width:34,height:34,x:322,y:638,pixelRatio:2,visible:!0},"convenience-11":{width:34,height:34,x:356,y:638,pixelRatio:2,visible:!0},"de-u-bahn":{width:34,height:34,x:390,y:638,pixelRatio:2,visible:!0},"dentist-11":{width:34,height:34,x:424,y:638,pixelRatio:2,visible:!0},"doctor-11":{width:34,height:34,x:458,y:638,pixelRatio:2,visible:!0},"dog-park-11":{width:34,height:34,x:492,y:638,pixelRatio:2,visible:!0},"drinking-water-11":{width:34,height:34,x:526,y:638,pixelRatio:2,visible:!0},"embassy-11":{width:34,height:34,x:560,y:638,pixelRatio:2,visible:!0},entrance:{width:34,height:34,x:594,y:638,pixelRatio:2,visible:!0},"farm-11":{width:34,height:34,x:628,y:638,pixelRatio:2,visible:!0},"fast-food-11":{width:34,height:34,x:662,y:638,pixelRatio:2,visible:!0},ferry:{width:34,height:34,x:696,y:638,pixelRatio:2,visible:!0},"fire-station-11":{width:34,height:34,x:730,y:638,pixelRatio:2,visible:!0},"fitness-centre-11":{width:34,height:34,x:764,y:638,pixelRatio:2,visible:!0},"fuel-11":{width:34,height:34,x:798,y:638,pixelRatio:2,visible:!0},"furniture-11":{width:34,height:34,x:832,y:638,pixelRatio:2,visible:!0},"garden-11":{width:34,height:34,x:866,y:638,pixelRatio:2,visible:!0},"globe-11":{width:34,height:34,x:900,y:638,pixelRatio:2,visible:!0},"golf-11":{width:34,height:34,x:934,y:638,pixelRatio:2,visible:!0},"grocery-11":{width:34,height:34,x:968,y:638,pixelRatio:2,visible:!0},"harbor-11":{width:34,height:34,x:0,y:672,pixelRatio:2,visible:!0},"hardware-11":{width:34,height:34,x:34,y:672,pixelRatio:2,visible:!0},"heliport-11":{width:34,height:34,x:68,y:672,pixelRatio:2,visible:!0},"hong-kong-mtr":{width:38,height:34,x:102,y:672,pixelRatio:2,visible:!0},"horse-riding-11":{width:34,height:34,x:140,y:672,pixelRatio:2,visible:!0},"hospital-11":{width:34,height:34,x:174,y:672,pixelRatio:2,visible:!0},"ice-cream-11":{width:34,height:34,x:208,y:672,pixelRatio:2,visible:!0},"information-11":{width:34,height:34,x:242,y:672,pixelRatio:2,visible:!0},"jewelry-store-11":{width:34,height:34,x:276,y:672,pixelRatio:2,visible:!0},"laundry-11":{width:34,height:34,x:310,y:672,pixelRatio:2,visible:!0},"library-11":{width:34,height:34,x:344,y:672,pixelRatio:2,visible:!0},"lodging-11":{width:34,height:34,x:378,y:672,pixelRatio:2,visible:!0},"marker-11":{width:24,height:34,x:412,y:672,pixelRatio:2,visible:!0},"mexico-city-metro":{width:34,height:34,x:436,y:672,pixelRatio:2,visible:!0},"milan-metro":{width:34,height:34,x:470,y:672,pixelRatio:2,visible:!0},"mobile-phone-11":{width:34,height:34,x:504,y:672,pixelRatio:2,visible:!0},"monument-11":{width:34,height:34,x:538,y:672,pixelRatio:2,visible:!0},"moscow-metro":{width:34,height:34,x:572,y:672,pixelRatio:2,visible:!0},"mountain-11":{width:34,height:34,x:606,y:672,pixelRatio:2,visible:!0},"museum-11":{width:34,height:34,x:640,y:672,pixelRatio:2,visible:!0},"music-11":{width:34,height:34,x:674,y:672,pixelRatio:2,visible:!0},"optician-11":{width:34,height:34,x:708,y:672,pixelRatio:2,visible:!0},"osaka-subway":{width:40,height:34,x:742,y:672,pixelRatio:2,visible:!0},"paris-transilien":{width:34,height:34,x:782,y:672,pixelRatio:2,visible:!0},"park-11":{width:34,height:34,x:816,y:672,pixelRatio:2,visible:!0},"parking-11":{width:34,height:34,x:850,y:672,pixelRatio:2,visible:!0},"parking-garage-11":{width:34,height:34,x:884,y:672,pixelRatio:2,visible:!0},"pharmacy-11":{width:34,height:34,x:918,y:672,pixelRatio:2,visible:!0},"philadelphia-septa":{width:38,height:34,x:952,y:672,pixelRatio:2,visible:!0},"picnic-site-11":{width:34,height:34,x:990,y:672,pixelRatio:2,visible:!0},"pitch-11":{width:34,height:34,x:0,y:706,pixelRatio:2,visible:!0},"place-of-worship-11":{width:34,height:34,x:34,y:706,pixelRatio:2,visible:!0},"playground-11":{width:34,height:34,x:68,y:706,pixelRatio:2,visible:!0},"police-11":{width:34,height:34,x:102,y:706,pixelRatio:2,visible:!0},"post-11":{width:34,height:34,x:136,y:706,pixelRatio:2,visible:!0},"prison-11":{width:34,height:34,x:170,y:706,pixelRatio:2,visible:!0},rail:{width:34,height:34,x:204,y:706,pixelRatio:2,visible:!0},"rail-light":{width:34,height:34,x:238,y:706,pixelRatio:2,visible:!0},"rail-metro":{width:34,height:34,x:272,y:706,pixelRatio:2,visible:!0},"ranger-station-11":{width:34,height:34,x:306,y:706,pixelRatio:2,visible:!0},"religious-buddhist-11":{width:34,height:34,x:340,y:706,pixelRatio:2,visible:!0},"religious-christian-11":{width:34,height:34,x:374,y:706,pixelRatio:2,visible:!0},"religious-jewish-11":{width:34,height:34,x:408,y:706,pixelRatio:2,visible:!0},"religious-muslim-11":{width:34,height:34,x:442,y:706,pixelRatio:2,visible:!0},"restaurant-11":{width:34,height:34,x:476,y:706,pixelRatio:2,visible:!0},"restaurant-noodle-11":{width:34,height:34,x:510,y:706,pixelRatio:2,visible:!0},"restaurant-pizza-11":{width:34,height:34,x:544,y:706,pixelRatio:2,visible:!0},"restaurant-seafood-11":{width:34,height:34,x:578,y:706,pixelRatio:2,visible:!0},"rocket-11":{width:34,height:34,x:612,y:706,pixelRatio:2,visible:!0},"san-francisco-bart":{width:34,height:34,x:646,y:706,pixelRatio:2,visible:!0},"school-11":{width:34,height:34,x:680,y:706,pixelRatio:2,visible:!0},"shoe-11":{width:34,height:34,x:714,y:706,pixelRatio:2,visible:!0},"shop-11":{width:34,height:34,x:748,y:706,pixelRatio:2,visible:!0},"singapore-mrt":{width:34,height:34,x:782,y:706,pixelRatio:2,visible:!0},"skateboard-11":{width:34,height:34,x:816,y:706,pixelRatio:2,visible:!0},"slipway-11":{width:34,height:34,x:850,y:706,pixelRatio:2,visible:!0},"stadium-11":{width:34,height:34,x:884,y:706,pixelRatio:2,visible:!0},"suitcase-11":{width:34,height:34,x:918,y:706,pixelRatio:2,visible:!0},"swimming-11":{width:34,height:34,x:952,y:706,pixelRatio:2,visible:!0},"table-tennis-11":{width:34,height:34,x:986,y:706,pixelRatio:2,visible:!0},"tennis-11":{width:34,height:34,x:0,y:740,pixelRatio:2,visible:!0},"theatre-11":{width:34,height:34,x:34,y:740,pixelRatio:2,visible:!0},"toilet-11":{width:34,height:34,x:68,y:740,pixelRatio:2,visible:!0},"tokyo-metro":{width:34,height:34,x:102,y:740,pixelRatio:2,visible:!0},"town-hall-11":{width:34,height:34,x:136,y:740,pixelRatio:2,visible:!0},"traffic-signal":{width:16,height:34,x:1002,y:638,pixelRatio:2,visible:!0},"veterinary-11":{width:34,height:34,x:170,y:740,pixelRatio:2,visible:!0},"viewpoint-11":{width:34,height:34,x:204,y:740,pixelRatio:2,visible:!0},"volcano-11":{width:34,height:34,x:238,y:740,pixelRatio:2,visible:!0},"volleyball-11":{width:34,height:34,x:272,y:740,pixelRatio:2,visible:!0},"washington-metro":{width:34,height:34,x:306,y:740,pixelRatio:2,visible:!0},"watch-11":{width:34,height:34,x:340,y:740,pixelRatio:2,visible:!0},"waterfall-11":{width:34,height:34,x:374,y:740,pixelRatio:2,visible:!0},"watermill-11":{width:34,height:34,x:408,y:740,pixelRatio:2,visible:!0},"windmill-11":{width:34,height:34,x:442,y:740,pixelRatio:2,visible:!0},"zoo-11":{width:34,height:34,x:476,y:740,pixelRatio:2,visible:!0},"ch-motorway-2":{width:44,height:32,x:510,y:740,pixelRatio:2,visible:!0},"ch-motorway-3":{width:56,height:32,x:554,y:740,pixelRatio:2,visible:!0},"de-motorway-2":{width:44,height:32,x:610,y:740,pixelRatio:2,visible:!0},"de-motorway-3":{width:56,height:32,x:654,y:740,pixelRatio:2,visible:!0},"gb-national-rail.london-dlr":{width:72,height:32,x:710,y:740,pixelRatio:2,visible:!0},"gb-national-rail.london-dlr.london-overground.london-tfl-rail.london-underground":{width:186,height:32,x:782,y:740,pixelRatio:2,visible:!0},"gb-national-rail.london-dlr.london-overground.london-underground":{width:148,height:32,x:0,y:774,pixelRatio:2,visible:!0},"gb-national-rail.london-dlr.london-underground":{width:110,height:32,x:148,y:774,pixelRatio:2,visible:!0},"gb-national-rail.london-overground":{width:72,height:32,x:258,y:774,pixelRatio:2,visible:!0},"gb-national-rail.london-overground.london-tfl-rail.london-underground":{width:148,height:32,x:330,y:774,pixelRatio:2,visible:!0},"gb-national-rail.london-overground.london-underground":{width:110,height:32,x:478,y:774,pixelRatio:2,visible:!0},"gb-national-rail.london-tfl-rail":{width:72,height:32,x:588,y:774,pixelRatio:2,visible:!0},"gb-national-rail.london-tfl-rail.london-overground":{width:110,height:32,x:660,y:774,pixelRatio:2,visible:!0},"gb-national-rail.london-tfl-rail.london-underground":{width:110,height:32,x:770,y:774,pixelRatio:2,visible:!0},"gb-national-rail.london-underground":{width:72,height:32,x:880,y:774,pixelRatio:2,visible:!0},"gr-motorway-2":{width:44,height:32,x:952,y:774,pixelRatio:2,visible:!0},"gr-motorway-3":{width:56,height:32,x:968,y:740,pixelRatio:2,visible:!0},"gr-motorway-4":{width:68,height:32,x:0,y:806,pixelRatio:2,visible:!0},"hr-motorway-3":{width:56,height:32,x:68,y:806,pixelRatio:2,visible:!0},"hr-motorway-4":{width:68,height:32,x:124,y:806,pixelRatio:2,visible:!0},"kr-metropolitan-2":{width:40,height:32,x:192,y:806,pixelRatio:2,visible:!0},"kr-metropolitan-3":{width:52,height:32,x:232,y:806,pixelRatio:2,visible:!0},"kr-metropolitan-4":{width:64,height:32,x:284,y:806,pixelRatio:2,visible:!0},"kr-metropolitan-5":{width:76,height:32,x:348,y:806,pixelRatio:2,visible:!0},"kr-metropolitan-6":{width:88,height:32,x:424,y:806,pixelRatio:2,visible:!0},"london-dlr":{width:40,height:32,x:512,y:806,pixelRatio:2,visible:!0},"london-dlr.london-tfl-rail":{width:78,height:32,x:552,y:806,pixelRatio:2,visible:!0},"london-dlr.london-tfl-rail.london-underground":{width:116,height:32,x:630,y:806,pixelRatio:2,visible:!0},"london-dlr.london-underground":{width:78,height:32,x:746,y:806,pixelRatio:2,visible:!0},"london-overground":{width:40,height:32,x:824,y:806,pixelRatio:2,visible:!0},"london-overground.london-tfl-rail":{width:78,height:32,x:864,y:806,pixelRatio:2,visible:!0},"london-overground.london-tfl-rail.london-underground":{width:116,height:32,x:0,y:838,pixelRatio:2,visible:!0},"london-overground.london-underground":{width:78,height:32,x:942,y:806,pixelRatio:2,visible:!0},"london-tfl-rail":{width:40,height:32,x:116,y:838,pixelRatio:2,visible:!0},"london-tfl-rail.london-underground":{width:78,height:32,x:156,y:838,pixelRatio:2,visible:!0},"london-underground":{width:40,height:32,x:234,y:838,pixelRatio:2,visible:!0},"si-motorway-2":{width:44,height:32,x:274,y:838,pixelRatio:2,visible:!0},wetland:{width:32,height:32,x:318,y:838,pixelRatio:2,visible:!0},"level-crossing":{width:30,height:30,x:350,y:838,pixelRatio:2,visible:!0},"default-2":{width:40,height:28,x:380,y:838,pixelRatio:2,visible:!0},"default-3":{width:52,height:28,x:420,y:838,pixelRatio:2,visible:!0},"default-4":{width:64,height:28,x:472,y:838,pixelRatio:2,visible:!0},"default-5":{width:76,height:28,x:536,y:838,pixelRatio:2,visible:!0},"default-6":{width:88,height:28,x:612,y:838,pixelRatio:2,visible:!0},"gb-national-rail":{width:34,height:28,x:700,y:838,pixelRatio:2,visible:!0},"motorway-exit-1":{width:40,height:28,x:734,y:838,pixelRatio:2,visible:!0},"motorway-exit-2":{width:40,height:28,x:774,y:838,pixelRatio:2,visible:!0},"motorway-exit-3":{width:52,height:28,x:814,y:838,pixelRatio:2,visible:!0},"motorway-exit-4":{width:64,height:28,x:866,y:838,pixelRatio:2,visible:!0},"motorway-exit-5":{width:76,height:28,x:930,y:838,pixelRatio:2,visible:!0},"motorway-exit-6":{width:88,height:28,x:0,y:870,pixelRatio:2,visible:!0},"motorway-exit-7":{width:100,height:28,x:88,y:870,pixelRatio:2,visible:!0},"motorway-exit-8":{width:112,height:28,x:188,y:870,pixelRatio:2,visible:!0},"motorway-exit-9":{width:124,height:28,x:300,y:870,pixelRatio:2,visible:!0},"rectangle-blue-2":{width:40,height:28,x:424,y:870,pixelRatio:2,visible:!0},"rectangle-blue-3":{width:52,height:28,x:464,y:870,pixelRatio:2,visible:!0},"rectangle-blue-4":{width:64,height:28,x:516,y:870,pixelRatio:2,visible:!0},"rectangle-green-2":{width:40,height:28,x:580,y:870,pixelRatio:2,visible:!0},"rectangle-green-3":{width:52,height:28,x:620,y:870,pixelRatio:2,visible:!0},"rectangle-green-4":{width:64,height:28,x:672,y:870,pixelRatio:2,visible:!0},"rectangle-green-5":{width:76,height:28,x:736,y:870,pixelRatio:2,visible:!0},"rectangle-green-6":{width:88,height:28,x:812,y:870,pixelRatio:2,visible:!0},"rectangle-red-2":{width:40,height:28,x:900,y:870,pixelRatio:2,visible:!0},"rectangle-red-3":{width:52,height:28,x:940,y:870,pixelRatio:2,visible:!0},"rectangle-red-4":{width:64,height:28,x:0,y:898,pixelRatio:2,visible:!0},"rectangle-white-2":{width:40,height:28,x:64,y:898,pixelRatio:2,visible:!0},"rectangle-white-3":{width:52,height:28,x:104,y:898,pixelRatio:2,visible:!0},"rectangle-white-4":{width:64,height:28,x:156,y:898,pixelRatio:2,visible:!0},"rectangle-white-5":{width:76,height:28,x:220,y:898,pixelRatio:2,visible:!0},"rectangle-white-6":{width:88,height:28,x:296,y:898,pixelRatio:2,visible:!0},"rectangle-yellow-2":{width:40,height:28,x:384,y:898,pixelRatio:2,visible:!0},"rectangle-yellow-3":{width:52,height:28,x:424,y:898,pixelRatio:2,visible:!0},"rectangle-yellow-4":{width:64,height:28,x:476,y:898,pixelRatio:2,visible:!0},"rectangle-yellow-5":{width:76,height:28,x:540,y:898,pixelRatio:2,visible:!0},"rectangle-yellow-6":{width:88,height:28,x:616,y:898,pixelRatio:2,visible:!0},"border-dot-13":{width:26,height:26,x:992,y:870,pixelRatio:2,visible:!0},"dot-10":{width:22,height:22,x:704,y:898,pixelRatio:2,visible:!0},"dot-11":{width:22,height:22,x:726,y:898,pixelRatio:2,visible:!0},"dot-9":{width:22,height:22,x:748,y:898,pixelRatio:2,visible:!0},cliff:{width:16,height:14,x:770,y:898,pixelRatio:2,visible:!0},"oneway-large":{width:28,height:12,x:786,y:898,pixelRatio:2,visible:!0},"oneway-white-large":{width:28,height:12,x:814,y:898,pixelRatio:2,visible:!0},"oneway-small":{width:22,height:10,x:842,y:898,pixelRatio:2,visible:!0},"oneway-white-small":{width:22,height:10,x:864,y:898,pixelRatio:2,visible:!0}},VU:{"Latin-1 Supplement":function(i){return 128<=i&&i<=255},Arabic:function(i){return 1536<=i&&i<=1791},"Arabic Supplement":function(i){return 1872<=i&&i<=1919},"Arabic Extended-A":function(i){return 2208<=i&&i<=2303},"Hangul Jamo":function(i){return 4352<=i&&i<=4607},"Unified Canadian Aboriginal Syllabics":function(i){return 5120<=i&&i<=5759},Khmer:function(i){return 6016<=i&&i<=6143},"Unified Canadian Aboriginal Syllabics Extended":function(i){return 6320<=i&&i<=6399},"General Punctuation":function(i){return 8192<=i&&i<=8303},"Letterlike Symbols":function(i){return 8448<=i&&i<=8527},"Number Forms":function(i){return 8528<=i&&i<=8591},"Miscellaneous Technical":function(i){return 8960<=i&&i<=9215},"Control Pictures":function(i){return 9216<=i&&i<=9279},"Optical Character Recognition":function(i){return 9280<=i&&i<=9311},"Enclosed Alphanumerics":function(i){return 9312<=i&&i<=9471},"Geometric Shapes":function(i){return 9632<=i&&i<=9727},"Miscellaneous Symbols":function(i){return 9728<=i&&i<=9983},"Miscellaneous Symbols and Arrows":function(i){return 11008<=i&&i<=11263},"CJK Radicals Supplement":function(i){return 11904<=i&&i<=12031},"Kangxi Radicals":function(i){return 12032<=i&&i<=12255},"Ideographic Description Characters":function(i){return 12272<=i&&i<=12287},"CJK Symbols and Punctuation":function(i){return 12288<=i&&i<=12351},Hiragana:function(i){return 12352<=i&&i<=12447},Katakana:function(i){return 12448<=i&&i<=12543},Bopomofo:function(i){return 12544<=i&&i<=12591},"Hangul Compatibility Jamo":function(i){return 12592<=i&&i<=12687},Kanbun:function(i){return 12688<=i&&i<=12703},"Bopomofo Extended":function(i){return 12704<=i&&i<=12735},"CJK Strokes":function(i){return 12736<=i&&i<=12783},"Katakana Phonetic Extensions":function(i){return 12784<=i&&i<=12799},"Enclosed CJK Letters and Months":function(i){return 12800<=i&&i<=13055},"CJK Compatibility":function(i){return 13056<=i&&i<=13311},"CJK Unified Ideographs Extension A":function(i){return 13312<=i&&i<=19903},"Yijing Hexagram Symbols":function(i){return 19904<=i&&i<=19967},"CJK Unified Ideographs":function(i){return 19968<=i&&i<=40959},"Yi Syllables":function(i){return 40960<=i&&i<=42127},"Yi Radicals":function(i){return 42128<=i&&i<=42191},"Hangul Jamo Extended-A":function(i){return 43360<=i&&i<=43391},"Hangul Syllables":function(i){return 44032<=i&&i<=55215},"Hangul Jamo Extended-B":function(i){return 55216<=i&&i<=55295},"Private Use Area":function(i){return 57344<=i&&i<=63743},"CJK Compatibility Ideographs":function(i){return 63744<=i&&i<=64255},"Arabic Presentation Forms-A":function(i){return 64336<=i&&i<=65023},"Vertical Forms":function(i){return 65040<=i&&i<=65055},"CJK Compatibility Forms":function(i){return 65072<=i&&i<=65103},"Small Form Variants":function(i){return 65104<=i&&i<=65135},"Arabic Presentation Forms-B":function(i){return 65136<=i&&i<=65279},"Halfwidth and Fullwidth Forms":function(i){return 65280<=i&&i<=65519}},layers:[],styles:{},Mr:!0,Rr:function(i,t){var l,n=this;if(!i)return!1;l=i,this.styles.zr=[];for(var a=this,e=0,o=l.length;e<o;e+=1)!function(i){var o,h,e,r=l[i],t=(r.zIndex=i,"line"===r.type&&(r.paint["line-width"]=void 0===r.paint["line-width"]?1:r.paint["line-width"]),r.paint["line-width"]&&(i=r.paint["line-width"],t=0,r.paint["line-gap-width"]&&(t=r.paint["line-gap-width"]),o=i,h=t,a.styles.zr.push(i=function(i,t){var e=0;return h&&(e=n.HU(t,h,i)),t=n.HU(t,o,i),e?2*t+e:t}),r.paint["line-width"]=i,r.paint["line-width"].Cr=a.styles.zr.length-1,delete r.paint["line-gap-width"]),r["source-layer"]);t?(a.styles[t]||(a.styles[t]=[]),(i=r.filter)&&(r.filters=[],(e=function(i){if("all"!==i[0])"in"===i[0]||"!in"===i[0]?r.filters.push([i[0],i[1],i.slice(2)]):r.filters.push(i);else for(var t=1;t<i.length;t+=1)e(i[t])})(i)),a.styles[t].push(r)):a.styles[r.id]=r}(e);this.backgroundColor=this.HU({},this.styles.land.paint["background-color"],12)},Ar:function(i,t,e,o){return i-=e,0==(o-=e)?0:1===t?i/o:(Math.pow(t,i)-1)/(Math.pow(t,o)-1)},Sr:function(i,t,e){var o=t.base||1,h=t.stops;if(e<=h[0][0])return this.HU(i,h[0][1],e);if(e>=h[h.length-1][0])return this.HU(i,h[h.length-1][1],e);for(var r=1,n=h.length;r<n;r+=1)if(e>h[r-1][0]&&e<=h[r][0]){var l=this.HU(i,h[r-1][1],e),a=this.HU(i,h[r][1],e);if(l instanceof Array){for(var s=new Array(l.length),f=0;f<l.length;f+=1){var u=a[f]-l[f];s[f]=l[f]+this.Ar(e,o,h[r-1][0])*u}return s}return"number"==typeof l?(u=a-l,l+this.Ar(e,o,h[r-1][0],h[r][0])*u):l}},Lr:function(i,t){if(i){var e=void 0;if("string"==typeof i)e=i;else if(i.stops)for(var o=0,h=i.stops.length;o<h;o+=1){if(i.stops[o][0]>t){e=i.stops[o][1];break}e=i.stops[h-1][1]}else if("interpolate"===i[0]){for(var r=i.slice(3),n=[],l=0;l<r.length;l+=2)n.push([r[l],r[l+1]]);for(o=0,h=n.length;o<h;o+=1){if(n[o][0]>t){e=n[o][1];break}e=n[h-1][1]}}return e}},Tr:function(i,t){if(i){var e=void 0;if(i.stops)for(var o=0,h=i.stops.length;o<h;o+=1){if(i.stops[o][0]>t){e=i.stops[o][1];break}e=i.stops[h-1][1]}else e=i;return e}},Ir:function(i,t){var e;if(void 0===i)return 0;if("function"==typeof i)return i(t);if("number"!=typeof i){if(i.stops)e=this.Sr(i.base||1,i.stops,t);else if("interpolate"===i[0]){for(var o=i.slice(3),h=[],r=0;r<o.length;r+=2)h.push([o[r],o[r+1]]);e=this.Sr(1,h,t)}}else e=i;return e},Dr:function(i,t,e,o){var h;if(void 0===t)return t;t instanceof Array?h=t:t.stops&&(h=this.Sr(i,t,e));var r=new Array(h.length);return h.forEach(function(i,t){r[t]=i*o}),r},Pr:function(i,t,e){for(var o,h,r,n,l,a,s,f,u,p,d,x,y,c="butt",v="butt",g="solid",w="solid",b=0,R=0,m=0;m<i.length;m+=1)"line"!==i[m].type||void 0!==(h=i[m]).minzoom&&h.minzoom>t||void 0!==h.maxzoom&&h.maxzoom<t||(o=h.paint,h=h.layout,void 0===(r=o["line-opacity"])&&(r=1),(r=this.HU(e,r,t))&&(this.WU(i[m].id,"-low")?(n=r,i[m].id,y=o["line-color"],l=this.HU(e,y,t),c=this.HU(e,h["line-cap"]||c,t),a=this.HU(e,o["line-width"],t),s=o["line-width"].Cr,this.Dr(e,o["line-dasharray"],t,a)&&(g="dashed"),R=Math.max(R,i[m].zIndex)):this.WU(i[m].id,"-case")||this.WU(i[m].id,"-tracks")?(f=!0,i[m].id,u=r,y=o["line-color"],p=this.HU(e,y,t),d=this.HU(e,o["line-width"],t),x=o["line-width"].Cr,v=this.HU(e,h["line-cap"]||v,t),this.Dr(e,o["line-dasharray"],t,d)&&(w="dashed"),b=Math.max(b,i[m].zIndex)):this.WU(i[m].id,"-bg")?(f=!0,i[m].id,u=r,y=o["line-color"],p=this.HU(e,y,t),v=this.HU(e,h["line-cap"]||v,t),d=this.HU(e,o["line-width"],t),x=o["line-width"].Cr,this.Dr(e,o["line-dasharray"],t,d)&&(w="dashed"),b=Math.max(b,i[m].zIndex)):(n=r,i[m].id,y=o["line-color"],l=this.HU(e,y,t),c=this.HU(e,h["line-cap"]||c,t),a=this.HU(e,o["line-width"],t),s=o["line-width"].Cr,this.Dr(e,o["line-dasharray"],t,a)&&(g="dashed"),R=Math.max(R,i[m].zIndex))));if(a)return{facezIndex:R,borderzIndex:b,faceStrokeStyle:g,faceOpacity:n,faceDashArray:void 0,faceWidth:a,faceColor:l,faceLineCap:c,borderLineCap:v,isOutline:f,borderOpacity:u,borderStrokeStyle:w,borderDashArray:void 0,borderColor:p,borderWidth:d,faceWidthFunIndex:s,borderWidthFunIndex:x}},QU:function(i){return i instanceof Array&&-1<this.KU(["geometry-type","to-number","case","step","is-supported-script","concat","get","literal","match","interpolate","to-string","string","coalesce","has","+","==","!=",">","<",">=","<=","in","!in"],i[0])||"object"==typeof i&&i.stops},KU:function(i,t){if(i&&i.length){if(i.indexOf)return i.indexOf(t);for(var e=0;e<i.length;e+=1)if(i[e]===t)return e}return-1},WU:function(i,t){return i.endsWith?i.endsWith(t):!(i.length<t.length)&&i.substr(i.length-t.length)===t},Vr:function(i,t,e){for(var o=0,h=0;h<i.length;h+=1){var r,n,l,a,s,f,u=i[h];"line"===i[h].type?u.minzoom&&u.minzoom>t||(o=Math.max(o,u.zIndex),s=(a=u.paint)["line-color"],r=this.HU(e,s,t),n=this.HU(e,a["line-width"],t),s=void 0===a["line-opacity"]?1:a["line-opacity"],l=this.HU(e,s,t)):"fill"!==i[h].type||u.minzoom&&u.minzoom>t||(o=Math.max(o,u.zIndex),s=(a=u.paint)["fill-color"],f=this.HU(e,s,t))}return{zIndex:o,fillColor:f,fillOpacity:1,strokeWeight:n,strokeColor:r,strokeOpacity:l}},Xr:function(i,t,e){var o,h,r,n,l,a,s,f,u,p,d,x,y=(i=i[0]).paint,c=i.layout;if("symbol"===i.type)return o=this.HU(e,y["text-color"],t),h=this.HU(e,y["text-halo-color"],t),a=this.HU(e,y["text-halo-width"],t),r=void 0===y["icon-opacity"]?1:y["icon-opacity"],r=this.HU(e,r,t),y=void 0===y["text-opacity"]?1:y["text-opacity"],y=this.HU(e,y,t),n=l=void 0,0===a&&(h=""),c["icon-image"]&&(l=this.HU(e,c["icon-image"],t),a=this.kr[l])&&r&&(a.height,n=[-a.width/2,-a.height/2,a.width,a.height,a.x,a.y,a.width,a.height]),a=this.HU(e,c["icon-rotation-alignment"],t),s=c["text-max-width"],f=this.HU(e,c["text-anchor"]||"center",t),(u=this.HU(e,c["text-font"],t)||"Microsoft YaHei")instanceof Array&&(u=u.join(" ")),p=c["text-offset"]?this.HU(e,c["text-offset"],t):[0,0],d=this.HU(e,c["text-size"],t),x="",y&&c["text-field"]&&(x=this.HU(e,c["text-field"]||"{name}",t)),{zIndex:i.zIndex,Jr:a,Kr:o||"black",Qr:h,th:(i.minzoom||1)+.5,ih:(i.maxzoom||20)+.5,eh:r,nh:l,qU:n,oh:s,textAnchor:f,ah:u,sh:p,rh:d,name:x}},lh:function(i,t,e){var o=[],h=this.Pr(i,t,e);return h&&(h.type="line",o.push(h)),(h=this.uh(i,t,e)).length&&o.push.apply(o,h),o},uh:function(i,t,e){for(var o=[],h=0;h<i.length;h+=1){var r=this.Xr([i[h]],t,e);r&&o.push(r)}return o},YU:function(i,t,e){for(var o=1,h=t.length-1;o<h;o+=2)if(this.HU(i,t[o],e))return this.HU(i,t[o+1],e);return this.HU(i,t[t.length-1],e)},JU:function(i,t,e){var o=this.HU(i,t[1],e),h=this.HU(i,t[2],e);return[o,this.HU(i,t[3],e)].join(h)},ZU:function(i,t,e){for(var o=t[1],h=1,r=("exponential"===o[0]?h=o[1]:"linear"===o[0]&&(h=1),t.slice(3)),n=[],l=0;l<r.length;l+=2)n.push([r[l],r[l+1]]);return o=this.Sr(i,{base:h,stops:n},e),this.HU(i,o,e)},XU:function(i,t,e){"zoom"!==t[1][0]&&"get"===t[1][0]&&(e=i.properties[t[1][1]]);for(var o=[],h=2,r=t.length;h<r;h+=2)o.push([parseFloat(t[h-1])||0,this.HU(i,t[h],e)]);if(e<o[0][0])return this.HU(i,o[0][1],e);if(e>=o[o.length-1][0])return this.HU(i,o[o.length-1][1],e);for(h=1,r=o.length;h<r;h+=1)if(e<=o[h][0])return this.HU(i,o[h-1][1],e)},tV:function(i,t,e){var o=this.HU(i,t[1],e);if(o){for(var h=2,r=t.length-1;h<r;h+=2)if(t[h]instanceof Array?-1!==this.KU(t[h],o):t[h]===o)return this.HU(i,t[h+1],e);return this.HU(i,t[t.length-1],e)}},HU:function(i,t,e){if(null==t)return null;var o=typeof t;if("number"==o||"boolean"==o)return t;if("function"==o)return t(e,i);if(!this.QU(t)){if("string"==typeof t&&-1!==this.KU(t,"{")){for(var h,r=[],n=0,l=0,a=t.length;l<a;l+=1)"{"===t[l]&&(n=l),"}"===t[l]&&(h=l,r.push(t.substring(n,h+1)));for(var s,l=0,a=r.length;l<a;l+=1){if(void 0===(s=i.properties[r[l].substring(1,r[l].length-1)]))return"";t=t.replace(r[l],s)}}return t}if("literal"===t[0])return t[1];if(t.stops)return this.Sr(i,t,e);if("get"===t[0])return this.Hr&&"name"===t[1].substr(0,4)&&(i.properties["name_zh-Hant"]||i.properties["name_zh-Hans"])||i.properties[t[1]];if("to-number"===t[0])return parseFloat(this.HU(i,t[1],e));if("to-string"===t[0])return(s=this.HU(i,t[1],e))?s+"":"";if("string"===t[0])return(s=this.HU(i,t[1],e))?s+"":"";if("match"===t[0])return this.tV(i,t,e);if("case"===t[0])return this.YU(i,t,e);if("interpolate"===t[0])return this.ZU(i,t,e);if("concat"===t[0])return this.JU(i,t,e);if("step"===t[0])return this.XU(i,t,e);if("coalesce"!==t[0])return"+"===t[0]?this.HU(i,t[1],e)+this.HU(i,t[2],e):"has"===t[0]?void 0!==i.properties[t[1]]:"is-supported-script"===t[0]?this.iV(this.HU(i,t[1],e)):"=="===t[0]?this.HU(i,t[1],e)===this.HU(i,t[2],e):"!="===t[0]?this.HU(i,t[1],e)!==this.HU(i,t[2],e):">"===t[0]?this.HU(i,t[1],e)>this.HU(i,t[2],e):"<"===t[0]?this.HU(i,t[1],e)<this.HU(i,t[2],e):">="===t[0]?this.HU(i,t[1],e)>=this.HU(i,t[2],e):"<="===t[0]?this.HU(i,t[1],e)<=this.HU(i,t[2],e):"in"===t[0]?-1<this.KU(this.HU(i,t[2],e),this.HU(i,t[1],e)):"!in"===t[0]?-1===this.KU(this.HU(i,t[2],e),this.HU(i,t[1],e)):"geometry-type"===t[0]?3===i.type?"Polygon":2===i.type?"LineString":"Point":void 0;for(l=1;l<t.length;l+=1){var f=this.HU(i,t[l],e);if(f)return f}},eV:function(i,t){return!(!t&&(1424<=i&&i<=2303||this.VU["Arabic Presentation Forms-A"](i)||this.VU["Arabic Presentation Forms-B"](i))||2304<=i&&i<=3583||3840<=i&&i<=4255||this.VU.Khmer(i))},iV:function(i){if(!i)return!1;for(var t=0,e=i.length;t<e;t+=1){var o=i[t];if(!this.eV(o.charCodeAt(0),!1))return!1}return!0},getStyle:function(l,a,i,s){var t,e=l.type,f=(l.properties.class,l.properties.type,this),u=this.styles[a];if(u&&(t=function(){for(var i=[],t=0,e=u.length;t<e;t+=1){var o=u[t];if(o.filters){for(var h=!0,r=0;r<o.filters.length;r+=1){var n=o.filters[r];if(!f.HU(l,n,s)){h=!1;break}}h&&i.push(o)}else o.id===a&&i.push(o)}return i}()).length)return 1===e?this.Xr(t,s,l):2===e?this.lh(t,s,l):3===e?this.Vr(t,s,l):void 0},fh:function(i,t){for(var e=1<<20-t.z,o=i.extent/256,h=0;h<i.style.length;h+=1){var r=i.style[h];if("line"!==r.type){for(var n="",l=(r.hh&&(n=i.properties[r.hh]),this.Mr),a=l?1.8*r.rh:r.rh,s=i.lines[0],f=1;f<i.lines.length;f+=1)s.length<i.lines[f].length&&(s=i.lines[f]);for(var u=[],p=0;p<s.length;p+=1){var d=[t.x*e*256+s[p][0]/o*e,256*t.y*e+s[p][1]/o*e];u.push(d)}var x=r.textAnchor,y=(this._r.font=r.rh+"px "+r.ah,this._r.measureText(n).width),c=0,v=0,g=r.nh&&"viewport"===r.Jr;if(r.nh){var c=(-i.properties.dh||0)-100,b=(w=polyfill.kS._S(u,polyfill.kS.distanceOfLine(u)/2)||[])[2];"viewport"!==r.Jr&&1<u.length&&(v=360-(new polyfill.Pixel(u[b+1][0]-u[b][0],u[b+1][1]-u[b][1]).direction()||0)),u=[w[0],w[1]]}else{if(this.vh(s))continue;if(90<(b=new polyfill.Pixel(s[1][0]-s[0][0],s[1][1]-s[0][1]).direction()||0)&&b<270&&(u.reverse(),s.reverse()),c=-i.properties.dh-1e6,polyfill.kS.distanceOfLine(u)/e<1.5*y)continue}var R,w={margin:this.mh,foreign:!0,zIndex:r.zIndex,yh:v,rank:c,font:r.ah,Kr:r.Kr,Qr:r.Qr,rh:a,id:i.id,xh:u,name:n,textAlign:"center",textBaseline:"center"===x?"middle":"top",bh:[],gh:new Array,wh:g,_h:!g,kh:!r.nh,th:r.th,Mh:!0,Rh:new Array,zh:!1,zoom:t.z};r.nh?(v=0,c=r.nh.replace("{maki}",i.properties.maki).replace("{shield}",i.properties.shield).replace("{reflen}",i.properties.reflen).replace("{network}",i.properties.network),(g=this.kr[c])&&r.eh&&(v=g.height,R=[-g.width/2,-g.height/2,g.width,g.height,g.x,g.y,g.width,g.height],w.gh.push(R)),n&&(c=void 0,g="center"===x?(c=0,-a/2):c=h*(a+2)+v/2,w.Rh.push([n,r.ah,a,r.Kr,r.Qr,0,0,!1,[0,c,l?1.8*y:y,a]]),w.gh.push(R=[-y/2,g,y,a])),(v||n)&&(n?w.id="mapbox_guideboard_"+polyfill.Util.stamp(w):(w.id="mapbox_singleway_"+polyfill.Util.stamp(w),w.zh=!0),t.labels.push(w))):n&&(w.id="mapbox_roadname_"+polyfill.Util.stamp(w),t.labels.push(w))}}},Sh:function(i,t){var e=1<<20-t.z,o=i.extent/256,h=i.Ch.xh[0][0],r=i.properties[i.style.hh];if(r){var n=this.Mr?2*i.style.rh:i.style.rh,e=[t.x*e*256+h[0]/o*e,256*t.y*e+h[1]/o*e],l=i.style.textAnchor,a={foreign:!0,margin:this.mh,zIndex:i.style.zIndex,rank:-i.properties.dh||0,id:i.id,xh:e,name:r,textAlign:"center",textBaseline:"center"===l?"middle":"top",bh:[],gh:new Array,yh:0,pos:[h[0]/o,h[1]/o],wh:!0,th:i.style.th,Mh:!0,Rh:new Array},s=0,f=(i.style.nh&&(e=i.style.nh.replace("{maki}",i.properties.maki).replace("{shield}",i.properties.shield).replace("{reflen}",i.properties.reflen).replace("{network}",i.properties.network),h=this.kr[e])&&i.style.eh&&(s=h.height,y=[-h.width/2,-h.height/2,h.width,h.height,h.x,h.y,h.width,h.height],a.gh=[y]),0<(o=r.indexOf("("))?[r.substr(0,o),r.substr(o)]:20<r.length&&1<(e=r.split(" ")).length?(h=Math.floor(e.length/2),[e.slice(0,h).join(" "),e.slice(h).join(" ")]):[r]);this._r.font=n+"px "+i.style.ah;for(var u=0;u<f.length;u+=1){var p=f[u],d=this._r.measureText(p).width,y=(a.Rh.push([p,i.style.ah,n,i.style.Kr,i.style.Qr,0,0,!1,[0,p="center"===l?(-.5*f.length+u)*(n+2):u*(n+2)+s/2,d,n]]),[-d/2,p,d,n]);a.gh.push(y)}return t.labels.push(a),a}},Lh:function(i){var t,e=[],o=[];for(t in i.layers)if(i.layers.hasOwnProperty(t)){for(var h=i.layers[t],r=[],n=0;n<h.Ah.length;n+=1)3==+(l=h.Ah[n]).type?e.push(l):2==+l.type&&r.push(l);for(n=0;n<r.length;n+=1){var l,a=(l=r[n]).style;a.isOutline&&o.push([l,{zIndex:a.borderzIndex,Th:a.borderWidthFunIndex,strokeStyle:a.borderStrokeStyle,strokeOpacity:a.borderOpacity,strokeDasharray:a.borderDashArray,lineCap:a.borderLineCap,strokeWeight:a.borderWidth,strokeColor:a.borderColor}]),o.push([l,{zIndex:a.facezIndex,Th:a.faceWidthFunIndex,strokeStyle:a.faceStrokeStyle,strokeOpacity:a.faceOpacity,strokeDasharray:a.faceDashArray,lineCap:a.faceLineCap,strokeWeight:a.faceWidth,strokeColor:a.faceColor}])}}o.sort(function(i,t){return i[1].zIndex>t[1].zIndex?1:-1}),i.polygons=e,i.Dh=o,delete i.layers},Ph:function(i){i.type,i.lines},jh:function(i,t,e,o){this.mh=3;var h,r=t.vt,n=(r.labels=[],[]);for(h in r.layers)if(r.layers.hasOwnProperty(h)){var l=r.layers[h],a=l.Ah;n.push(h);for(var s=0,f=a.length;s<f;s++){var u=a[s];u.Fh=l.name,u.style=this.getStyle(u,l.name,!0,r.z-1),u.style,this.Ph(u),u.style&&1!=+u.type&&2==+u.type&&u.style.length&&(this.fh(u,r),"line"===u.style[0].type)&&(u.style=u.style[0])}}this.Lh(r),this.Eh||(this.Eh=!0),e.features=r.labels,r.labels=null,n.length>this.layers.length&&(this.layers=n),o(null,{vt:r})}},MapboxStyle=function(){function i(i){var t=null,e="";i&&((i=i.KG)&&i.styles&&(t=JSON.parse(i.styles).layers),i)&&i.vectorMapForeign&&(e=i.vectorMapForeign),mbStyle.Rr(t,e)}return i.prototype.getMapboxStyle=function(){return mbStyle},i}(),MapboxSourceWorker=function(){function i(i){this.parent=i,this.id="mapbox",this.sQ={},this.yQ={},this.kQ={}}return i.prototype.YE=function(i){var t=polyfill.Util.getOptimalZoom(this.WW);i(this.sQ,{ZL:this.WW,optimalZoom:t,cb:function(){}}),this.sQ={}},i.prototype.bw=function(i,h,r,n,t,e,l){var a=this,s=new XMLHttpRequest;return s.onreadystatechange=function(){var i,t,e,o;4===s.readyState&&200===s.status&&(o=new polyfill.pw(new Uint8Array(s.response)),(o=new polyfill.tW(o)).nG("mapbox"),i=h.z,t=h.x,e=h.y,o.data={},o=a.Ow(o,{x:h.x,y:h.y,z:h.z,projectionId:r,tileSize:n}),a.wQ(o),o.zo=new polyfill.ca(i,t,e),a.FQ(o),delete o.road,l(null,polyfill.Ln({zo:h},o)))},s.open("GET",i,!0),s.responseType="arraybuffer",s.send(),{cancel:function(){s.abort()}}},i.prototype.wQ=function(i){i.stencil={};var t=new polyfill.fQ,i=(i.stencil.Oc=t,i.stencil.Dc=new polyfill.K_,i.stencil.Dc.Nx(i.MQ));t.add({},i)},i.prototype.Ow=function(e,i){var o=i.x,h=i.y,s=i.z,r=i.tileSize,f=i.projectionId;e.z=s,e.x=o,e.y=h;for(var i=polyfill.ProjectionManager.getProjection(f).getResolution(s),i=polyfill.$Q(o,h,s,i,r),n=(e.Ro=i,e.MQ=[i[0],i[1],i[2],i[1],i[2],i[3],i[0],i[3]],e.zS=polyfill.lcs.getLocalByCoord([e.Ro[0],e.Ro[1]]),e.localCoord=e.zS,Object.keys(e.layers)),t=0;t<n.length;t++)!function(i){var a=e.layers[n[i]],i=a.Cw,t=a.extent;a.Ah=[],a.scale=r/t,a.ox=r*o,a.oy=r*h,polyfill.forEach(i,function(i,t){if((i=a.Gw(t)).Dw(),a.Ah.push(i),i.lines&&i.lines.length&&(2===i.type||3===i.type||1===i.type)){i.Rw=[];for(var e=0,o=i.lines.length;e<o;e++){for(var h=[],r=0,n=i.lines[e].length;r<n;r++){var l=[a.ox+a.scale*i.lines[e][r][0],a.oy+a.scale*i.lines[e][r][1]],l=[(l=polyfill.V[f].Xs(l[0],l[1],s))[0],l[1]];h.push(l)}i.Rw.push(h)}}})}(t);return this.uW(e,s),this.xw(e),this.zw(e),e},i.prototype.uW=function(i,t){var e,o=[],h=[],r=[],n=(this.kQ,null);for(e in this.parent&&this.parent.QG&&(n=this.parent.QG),this.$h=new MapboxStyle({KG:n}).getMapboxStyle(),i.bgColor=this.$h.backgroundColor,i.layers)if(i.layers.hasOwnProperty(e))for(var l=i.layers[e],a=0;a<l.Ah.length;a+=1){var s,f=l.Ah[a],u=this.$h.getStyle(f,l.name,!0,t);u&&(f.style=u,3===f.type?o.push(f):2===f.type?h.push(f):1===f.type&&(s=u.name)&&((s={name:s,position:f.Rw[0],id:f.id,minzoom:u.th,maxzoom:u.ih}).style=u,r.push(s)))}h.sort(function(i,t){return i.style&&t.style&&i.style.zIndex>t.style.zIndex?1:-1}),o.sort(function(i,t){return i.style&&t.style&&i.style.zIndex>t.style.zIndex?1:-1}),i.polygons=o,i.Dh=h,i.data.poilabel=((n={})[i.z+","+i.x+","+i.y]=r,n),delete i.layers},i.prototype.startsWith=function(i,t){return i.startsWith?i.startsWith(t):i.substr(0,t.length)===t},i.prototype.argbHex2Rgba=function(i){for(var t=[],e=0,o=i.length;e<o;e+=2)t.push(parseInt(i.substr(e,2),16)/255);return t.push(t.shift()),t},i.prototype.uQ=function(i,t,e){return e<0&&(e+=1),1<e&&--e,e<1/6?i+6*(t-i)*e:e<.5?t:e<2/3?i+(t-i)*(2/3-e)*6:i},i.prototype.GQ=function(i,t,e,o){var h,r,n;return 0===t?h=r=n=e:(h=this.uQ(t=2*e-(e=e<.5?e*(1+t):e+t-e*t),e,i+1/3),r=this.uQ(t,e,i),n=this.uQ(t,e,i-1/3)),[h,r,n,o]},i.prototype.color2RgbaArray=function(i,t){var e,o,h,r,n,l,a;return void 0===t&&(t=1),i?(e=i.toString(),this.yQ[e]||(i instanceof Array?i:this.startsWith(i,"hsla")?(l=i.substr(5).split(","),o=parseInt(l[0],10)/360,h=parseInt(l[1],10)/100,r=parseInt(l[2],10)/100,a=parseFloat(l[3]),n=this.GQ(o,h,r,a),this.yQ[e]=n):this.startsWith(i,"hsl")?(l=i.substr(4).split(","),o=parseInt(l[0],10)/360,h=parseInt(l[1],10)/100,r=parseInt(l[2],10)/100,n=this.GQ(o,h,r,t),this.yQ[e]=n):this.startsWith(i,"#")?7===i.length?(n=this.argbHex2Rgba("ff"+i.substr(1)),this.yQ[e]=n):9===i.length?(n=this.argbHex2Rgba(i.substr(1)),this.yQ[e]=n):void 0:this.startsWith(i,"rgba")?(l=i.substr(5).split(","),[parseInt(l[0],10)/255,parseInt(l[1],10)/255,parseInt(l[2],10)/255,a=parseFloat(l[3])]):this.startsWith(i,"rgb")?(l=i.substr(4).split(","),[parseInt(l[0],10)/255,parseInt(l[1],10)/255,parseInt(l[2],10)/255,a=1]):void 0)):null},i.prototype.zw=function(i){if(!i||!i.Dc){var t=new polyfill.fQ,e=(i.Oc=t,i.Dc=new polyfill.K_,{fillColor:this.color2RgbaArray(i.bgColor),zIndex:0}),o=i.Dc.Nx(i.MQ);t.add(e,o);for(var h=0,r=i.polygons;h<r.length;h++){var n=r[h],l=n.style;if(l&&l.fillColor){l.fillColor=this.color2RgbaArray(l.fillColor);var a=n.Rw;if(1<a.length){for(var s=[],f=0;f<a.length;f++)polyfill.kS.isClockwise(a[f])?s.push([f]):s.length&&s[s.length-1].push(f);for(var u=0;u<s.length;u++){var p=s[u];if(1<p.length){for(var d=[],x=[],y=0;y<p.length;y++){var c=a[p[y]];0<y&&d.push(x.length/2);for(var v=0;v<c.length;v++){var g=c[v];x.push(g[0],g[1])}}var w=i.Dc.Nx(x,d)}else{for(x=[],c=a[p[0]],v=0;v<c.length;v++){var b=c[v];x.push(b[0],b[1])}w=i.Dc.Nx(x)}t.add(l,w)}}else{for(var R=a.length,x=[],m=0;m<R;m++){var k=a[m];if(0<k.length)for(v=0;v<k.length;v++)u=k[v],x.push(u[0],u[1])}n=i.Dc.Nx(x),t.add(l,n)}}}delete i.polygons}},i.prototype.xw=function(i){if(!i||!i.$c){var t=[],e=this.kQ,o=(i.$c=new polyfill.J_,new polyfill.fQ);i.Uc=o;for(var h=0,r=i.Dh;h<r.length;h++){var n=r[h],l=n.Rw,a=l.length,s=0,f=0;n.style&&n.style[0]&&n.style[0].borderColor&&(n.style[0].borderColor=this.color2RgbaArray(n.style[0].borderColor)),n.style&&n.style[0]&&n.style[0].faceColor&&(n.style[0].faceColor=this.color2RgbaArray(n.style[0].faceColor));for(var p=(u=n.style||[])[0],u=u[1],d=0;d<a;d++){var x=l[d];if(0<x.length){for(var y=[],c=0;c<x.length;c++){var v=x[c];y.push(v[0],v[1])}var g=i.$c.hb(y,{X_:0,lineJoin:"miter",lineCap:"round"});s+=g.Iw,f+=g.distance}}if(0<s&&(o.add(n.style,s),n.distance=f),p&&p.borderColor&&(n.style[0].borderColor=this.color2RgbaArray(p.borderColor)),p&&p.faceColor&&(n.style[0].faceColor=this.color2RgbaArray(p.faceColor)),u&&(n=u.name||"")){var p=u.Kr,w=u.Qr;p&&!e[p]&&(e[p]=polyfill.Util.color2RgbaArray(p)),w&&!e[w]&&(e[w]=polyfill.Util.color2RgbaArray(w)),u.Kr=e[p],u.Qr=e[w];for(var b=(p={style:u,path:[],name:n,distance:f}).path,R=0;R<a;R++)for(var m=l[R],c=0;c<m.length;c++)v=m[c],b.push(v[0],v[1]);t.push(p)}}i.road=t,delete i.Dh}},i.prototype.FQ=function(i){var t,e={};for(t in i)i.hasOwnProperty(t)&&"fillBucket"!==t&&"fillSegements"!==t&&"lineBucket"!==t&&"lineSegements"!==t&&(e[t]=i[t]);this.sQ[i.zo.key]={tile:e,params:{scale:this.parent.params.scale,tag:"all"}}},i}(),_a$1,mapBoxSprite="https://webapi.amap.com/style_icon/sprite_v8@2x.png",DefaultIconInfo=(_a$1={TW:{img:"https://vdata.amap.com/style_icon/2.0/icon-normal-big.png",width:512,height:1024,startX:0,startY:0,status:"loaded",type:"icon",ext:{hv:0}},RW:{img:"https://vdata.amap.com/style_icon/2.0/icon-biz-big.png",width:512,height:1024,startX:0,startY:1024,status:"loaded",type:"icon",ext:{hv:1}}},_a$1[mapBoxSprite]={img:mapBoxSprite,width:1024,height:926,startX:0,startY:2048,status:"loaded",type:"icon",ext:{hv:2}},_a$1),ImageManagerWorker=function(e){function i(){var i,t=e.call(this)||this;return t.Fs=((i={})[DefaultIconInfo.TW.img]=DefaultIconInfo.TW,i[DefaultIconInfo.RW.img]=DefaultIconInfo.RW,i),t.Cc=16,t.Uw=3,t.Hw={},t.Mc={},t}return polyfill.Ei(i,e),i.prototype.loadImage=function(i,t){var e=t.name,o=t.type,h=t.cb,r=this.Fs[e=e||i];r&&r.status===polyfill.uc.LOADED?h(r,t):r&&r.status===polyfill.uc.LOADING?(this.Mc[e]||(this.Mc[e]=[]),this.Mc[e].push({cb:h,opts:t})):("icon"===o&&(DefaultIconInfo[i]?t.hv=DefaultIconInfo[i].ext.hv:t.hv=this.Uw,this.Uw++),this.Rc(i,t))},i.prototype.loadImages=function(i,t){var h=this,e=t.cb,r=t.type;if(0===Object.keys(i).filter(function(i){return!h.Fs[i]}).length)e();else{var n=[],l=[];if(i.length){for(var o=0,a=i;o<a.length;o++)!function(o){var i=new Promise(function(e,i){h.loadImage(o,{cb:function(i,t){l.push(h.Fs[o]),e()},type:r})});n.push(i)}(a[o]);Promise.all(n).then(function(){e(l)}).catch(function(){e(l)})}else e(l)}},i.prototype.Vw=function(i,t){var h=this,r=t.cb,n=i.filter(function(i){return!h.Fs[i]});if(0===n.length)r([]);else{var e=[],l=[];if(i.length){for(var o=0,a=i;o<a.length;o++)!function(o){var i=new Promise(function(e,i){h.loadImage(o,{cb:function(i,t){l.push(h.Fs[o]),e()},type:"icon"})});e.push(i)}(a[o]);Promise.all(e).then(function(){var i=[];if(0<n.length){for(var t=0,e=n;t<e.length;t++){var o=e[t];i.push({url:o,data:h.getImage(o)})}h.emit("iconImageLoaded",{data:i})}r(l)}).catch(function(){r(l)})}else r(l)}},i.prototype.getImage=function(i){return this.Fs[i=void 0===i?"":i]},i.prototype.destory=function(){var i;this.Fs=((i={})[DefaultIconInfo.TW.img]=DefaultIconInfo.TW,i[DefaultIconInfo.RW.img]=DefaultIconInfo.RW,i)},i.prototype.Rc=function(t,e){var o=this,h=e.name,i=e.ext,r=void 0===i?{}:i,n=void 0===(i=e.type)?"other":i,l=e.cb,a=e.imageBitmap,s=this.Fs;s[h||t]={status:polyfill.uc.LOADING,startX:0,startY:1024*(e.hv||0),type:n,height:0,width:0},polyfill.Yw.send(t,{Me:"arraybuffer",qw:function(i){a?(console.time("createImageBitmap"),createImageBitmap(new Blob([new Uint8Array(i)])).then(function(i){console.timeEnd("createImageBitmap"),i=new polyfill.WQ(t,i,{imageBitmap:!0}),o.qQ(h||t,i,l,e,n,r)})):(i=new polyfill.WQ(t,i),o.qQ(h||t,i,l,e,n,r))},Aw:function(i){console.log(i),s[i=h||t].status=polyfill.uc.ERROR,l(s[i],e)}})},i.prototype.qQ=function(i,t,e,o,h,r){var n=this.Fs;if("success"!==t.status)console.error("createObjectURL fail"),n[i].status=polyfill.uc.ERROR,e(n[i],o);else if("icon"===h?(r.hv=o.hv,n[i]=DefaultIconInfo[i]||{ext:r,type:h,startX:0,startY:1024*(o.hv||0),height:1024,width:512,status:polyfill.uc.LOADED},n[i].data=t):n[i]={ext:r,type:h,startX:0,startY:0,height:0,width:0,data:t,status:polyfill.uc.LOADED},e(n[i],o),this.Mc[i]){for(var l=0,a=this.Mc[i];l<a.length;l++){var s=a[l];s.cb(n[i],s.opts)}delete this.Mc[i]}},i.prototype.Sc=function(i){var t,e=(e=(i=void 0===i?{}:i).img)&&e.context?(t=e.width||0,e.height||0):(t=i.width||0,i.height||0);return[t,e]},i}(polyfill.Event),Counter=function(e){function i(i){var t=e.call(this)||this;return t.OQ=i,t.zQ=0,t}return polyfill.Ei(i,e),i.prototype.TQ=function(){this.zQ+=1,this.zQ===this.OQ&&this.emit("count")},i.prototype.clear=function(){this.zQ=0},i}(polyfill.Event),_a$2,LabelFormatMap$1=(_a$2={},_a$2[polyfill.NebulaLabelFormat.id]=polyfill.NebulaLabelFormat,_a$2[polyfill.MapboxLabelFormat.id]=polyfill.MapboxLabelFormat,_a$2.nebula=polyfill.NebulaLabelFormat,_a$2),LabelWorker=function(e){function i(i){var t=e.call(this)||this;return t.parent=i,t.MW={},t.hD=["https://vdata.amap.com/style_icon/2.0/icon-normal-big.png","https://vdata.amap.com/style_icon/2.0/icon-biz-big.png"],t.z_=i.z_,t.R_=i.R_,t}return polyfill.Ei(i,e),i.prototype.iW=function(r,n){var i,f=this,u=(void 0===n&&(n={}),this.MW.ZL=n.ZL||polyfill.zoomRange[1],[]),p=(n.cb,this.parent.langForeign),d=this;for(i in r)!function(i){var l,t,e,o,a,h,s;r.hasOwnProperty(i)&&(o=(i=r[i]).tile,t=(i=i.params).scale,i=i.tag,u.push(i),e={vn:d.parent.vn},t=(e=new LabelFormatMap$1[n.id](e)).Ns(o,{ZL:d.MW.ZL,zoom:o.zo.z,scale:t,lang:p,VQ:d.parent.QZ}),l=[[o,e,t,i]],t=Object.keys(e.Fs),i=Object.keys(e.Es),e=[o],o=Date.now(),a=[],h=n.optimalZoom,(s=new Counter(2)).on("count",function(){f.parent.jQ.XQ(new LoadDynamicsTask(f.parent.vn,h,f.R_,f.z_,a,n,function(i){f.emit("dynamicTextVerticeLoadedByTile",{data:i.data,id:n.id})}),void 0,!0),f.parent.yY.setNeedUpdate(!0)},null,!0),d.R_.vW(i,{tiles:e,optimalZoom:h,tags:u,stamp:o,cb:function(i){for(var t=0,e=l;t<e.length;t++){var h=(o=e[t])[0],r=o[1],n=o[2],o=o[3];a.push({tile:h,gW:r,SW:n,tag:o})}s.TQ()}}),d.wW(t)?s.TQ():d.z_.Vw(t,{type:"icon",cb:function(){s.TQ()}}))}(i)},i.prototype.hW=function(i,t,e){var o=this;this.parent.jQ.XQ(new LoadDynamicsTask(this.parent.vn,this.MW.ZL,this.R_,this.z_,i,e,function(i){o.emit("dynamicTextVerticeLoadedByTile",{data:i.data,id:e.id})}),void 0,!0),this.parent.yY.setNeedUpdate(!0)},i.prototype.wW=function(i){for(var t=this.hD,e=0,o=0,h=i=void 0===i?[]:i;o<h.length;o++){var r=h[o];-1!==t.indexOf(r)&&e++}return e===i.length},i}(polyfill.Event),LoadDynamicsTask=function(){function i(i,t,e,o,h,r,n){this.vn=i,this.ZL=t,this.R_=e,this.z_=o,this.data=h,this.params=r,this.cb=n,this.type="LoadDynamicsTask",this.offset=0,this.result=[]}return i.prototype.play=function(i){for(var t=i,e=Date.now();0<t&&this.offset!==this.data.length;){var o,h=[],r=this.data[this.offset],n=r.tile,l=r.SW,a=(r.gW,r.tag),s=Object.keys(l).length,f={},u=0;if(0===s)h.push({data:n.zo});else{for(var p in l)l.hasOwnProperty(p)&&(o=l[p],o=new polyfill.eG({R_:this.R_,z_:this.z_}).Ns(o,{ZL:this.ZL,zoom:n.zo.z,from:"inner",center:n.localCoord.center}),f[p]=new polyfill.La(n.zo,o),++u===s)&&(p=this.hQ(n,this.ZL),h.push({data:f,XE:p,tag:a}));this.offset++,this.cb({data:h}),t=i-(Date.now()-e)}}return this.offset,this.data.length,this.result},Object.defineProperty(i.prototype,"status",{get:function(){return this.offset>=this.data.length?polyfill.vY.finish:polyfill.vY.pause},eb:!1,nb:!0}),i.prototype.hQ=function(i,t){if(i)for(var e=this.SQ(i)||[],o=0,h=e=new LabelFormatMap$1[i.type]({vn:this.vn}).DQ(e,{zoom:t});o<h.length;o++){var r=h[o],n=r.CO;r.EG||(r.EG={});for(var l=0,a=n;l<a.length;l++){var s=a[l],f=this.R_.mz(s);r.EG[s]=f}}return e},i.prototype.SQ=function(i){return i.data&&i.data.roadName||i.road},i}(),InnerLabelsSourceWorker=function(){function i(i){this.parent=i,this.Mf=i.R_,this.ac=i.z_}return i.prototype.loadData=function(h,r){var n=this,i=h.id===polyfill.n0.nebulaLabel?polyfill.n0.nebula:h.id;(i=this.parent.dQ(i))&&i.YE?i.YE(function(i,t){t.GW;var e=t.cb,o=t.ZL,t=t.optimalZoom;polyfill.isEmpty(i)?r&&r({}):n.parent.yw.iW(i,{ZL:o,optimalZoom:t,id:h.id,cb:function(i){r(i),e&&e()}})},h):r&&r({})},i}(),StaticSourceID,EnumTextureIndex,ImageStatus,noop=(function(i){i.nebula="nebula",i.nebulaLabel="nebulaLabel"}(StaticSourceID=StaticSourceID||{}),function(i){i[i.dynamic=0]="dynamic",i[i.icon=1]="icon"}(EnumTextureIndex=EnumTextureIndex||{}),function(i){i.BLOB="blob",i.TOLOAD="toload",i.LOADING="loading",i.LOADED="loaded",i.UNLOADED="unloaded",i.ERROR="error",i.RELOADING="reloading",i.UNCOMBINED="uncombined",i.COMBINING="combining",i.COMBINED="combined"}(ImageStatus=ImageStatus||{}),function(i){}),XHR={send:function(i,t){void 0===t&&(t={});var e=new XMLHttpRequest,h=void 0===(o=t.qw)?noop:o,r=void 0===(o=t.Aw)?noop:o,o=t.Me,n=t.method,t=t.content;return e.onreadystatechange=function(){if(4===e.readyState&&200===e.status){var i=e.response;try{h(i)}catch(i){r(i)}}else 404===e.status&&(e.abort(),r(Error("404")))},e.onerror=function(i){e.abort(),r(i)},e.open(n||"GET",i,!0),e.responseType=o||"json",e.send(t||void 0),e}};function parserFunc(i){var z={TS:function(){this.PS=0}},Ui=(z.TS.prototype.create=function(i){this.OS&&this.PS===i||(this.OS=[]),this.PS=i,this.FS=0,this.BS=0},z.TS.prototype.flush=function(){var i=this.FS-this.BS;if(0!==i){for(;i--;)this.ES.jS(this.OS[this.BS++]);this.FS>=this.PS&&(this.FS=0),this.BS=this.FS}},z.TS.prototype.NS=function(){this.flush(),this.ES=null},z.TS.prototype.US=function(i){this.NS(),this.ES=i},z.TS.prototype.init=function(i){i||(this.BS=0,this.FS=0)},z.TS.prototype.WS=function(i,t){var e=this.FS-i-1;for(e<0&&(e+=this.PS);t--;)e>=this.PS&&(e=0),this.OS[this.FS++]=this.OS[e++],this.FS>=this.PS&&this.flush()},z.TS.prototype.GS=function(i){this.OS[this.FS++]=i,this.FS>=this.PS&&this.flush()},z.TS.prototype.HS=function(i){return(i=this.FS-i-1)<0&&(i+=this.PS),this.OS[i]},z.VS=function(){},z.VS.prototype.US=function(i){this.ES=i},z.VS.prototype.NS=function(){this.ES=null},z.VS.prototype.init=function(){var i=5;for(this.ZS=0,this.YS=-1;i--;)this.ZS=this.ZS<<8|this.ES.JS()},z.VS.prototype.XS=function(i){for(var t,e=0,o=i;o--;)this.YS>>>=1,t=this.ZS-this.YS>>>31,this.ZS-=this.YS&t-1,e=e<<1|1-t,0==(4278190080&this.YS)&&(this.ZS=this.ZS<<8|this.ES.JS(),this.YS<<=8);return e},z.VS.prototype.qS=function(i,t){var e=i[t],o=(this.YS>>>11)*e;return(2147483648^this.ZS)<(2147483648^o)?(this.YS=o,i[t]+=2048-e>>>5,0==(4278190080&this.YS)&&(this.ZS=this.ZS<<8|this.ES.JS(),this.YS<<=8),0):(this.YS-=o,this.ZS-=o,i[t]-=e>>>5,0==(4278190080&this.YS)&&(this.ZS=this.ZS<<8|this.ES.JS(),this.YS<<=8),1)},z.QS=function(i,t){for(;t--;)i[t]=1024},z.KS=function(i){this.tR=[],this.iR=i},z.KS.prototype.init=function(){z.QS(this.tR,1<<this.iR)},z.KS.prototype.decode=function(i){for(var t=1,e=this.iR;e--;)t=t<<1|i.qS(this.tR,t);return t-(1<<this.iR)},z.KS.prototype.eR=function(i){for(var t,e=1,o=0,h=0;h<this.iR;++h)e=e<<1|(t=i.qS(this.tR,e)),o|=t<<h;return o},z.nR=function(i,t,e,o){for(var h,r=1,n=0,l=0;l<o;++l)r=r<<1|(h=e.qS(i,t+r)),n|=h<<l;return n},z.oR=function(){this.rR=[],this.aR=[],this.sR=[],this.hR=new z.KS(8),this.lR=0},z.oR.prototype.create=function(i){for(;this.lR<i;++this.lR)this.aR[this.lR]=new z.KS(3),this.sR[this.lR]=new z.KS(3)},z.oR.prototype.init=function(){var i=this.lR;for(z.QS(this.rR,2);i--;)this.aR[i].init(),this.sR[i].init();this.hR.init()},z.oR.prototype.decode=function(i,t){return 0===i.qS(this.rR,0)?this.aR[t].decode(i):0===i.qS(this.rR,1)?8+this.sR[t].decode(i):16+this.hR.decode(i)},z.fR=function(){this.uR=[]},z.fR.prototype.init=function(){z.QS(this.uR,768)},z.fR.prototype.cR=function(i){for(var t=1;(t=t<<1|i.qS(this.uR,t))<256;);return 255&t},z.fR.prototype.dR=function(i,t){var e,o,h=1;do{if(e=t>>7&1,t<<=1,h=h<<1|(o=i.qS(this.uR,(1+e<<8)+h)),e!==o){for(;h<256;)h=h<<1|i.qS(this.uR,h);break}}while(h<256);return 255&h},z.pR=function(){},z.pR.prototype.create=function(i,t){var e;if(!this.vR||this.mR!==t||this.yR!==i)for(this.yR=i,this.xR=(1<<i)-1,this.mR=t,this.vR=[],e=1<<this.mR+this.yR;e--;)this.vR[e]=new z.fR},z.pR.prototype.init=function(){for(var i=1<<this.mR+this.yR;i--;)this.vR[i].init()},z.pR.prototype.bR=function(i,t){return this.vR[((i&this.xR)<<this.mR)+((255&t)>>>8-this.mR)]},z.gR=function(){this.wR=new z.TS,this._R=new z.VS,this.kR=[],this.MR=[],this.SR=[],this.RR=[],this.zR=[],this.CR=[],this.AR=[],this.IR=[],this.$R=new z.KS(4),this.LR=new z.oR,this.DR=new z.oR,this.TR=new z.pR,this.PR=-1,this.OR=-1,this.AR[0]=new z.KS(6),this.AR[1]=new z.KS(6),this.AR[2]=new z.KS(6),this.AR[3]=new z.KS(6)},z.gR.prototype.FR=function(i){return!(i<0||(this.PR!==i&&(this.PR=i,this.OR=Math.max(this.PR,1),this.wR.create(Math.max(this.OR,4096))),0))},z.gR.prototype.BR=function(i,t,e){var o=1<<e;return!(8<i||4<t||4<e||(this.TR.create(t,i),this.LR.create(o),this.DR.create(o),this.jR=o-1,0))},z.gR.prototype.init=function(){var i=4;for(this.wR.init(!1),z.QS(this.kR,192),z.QS(this.CR,192),z.QS(this.MR,12),z.QS(this.SR,12),z.QS(this.RR,12),z.QS(this.zR,12),z.QS(this.IR,114),this.TR.init();i--;)this.AR[i].init();this.LR.init(),this.DR.init(),this.$R.init(),this._R.init()},z.gR.prototype.decode=function(i,t,e){var o,h,r,n,l=0,a=0,s=0,f=0,u=0,p=0,d=0;for(this._R.US(i),this.wR.US(t),this.init();e<0||p<e;)if(n=p&this.jR,0===this._R.qS(this.kR,(l<<4)+n))r=this.TR.bR(p++,d),d=7<=l?r.dR(this._R,this.wR.HS(a)):r.cR(this._R),this.wR.GS(d),l=l<4?0:l-(l<10?3:6);else{if(1===this._R.qS(this.MR,l))(o=0)===this._R.qS(this.SR,l)?0===this._R.qS(this.CR,(l<<4)+n)&&(l=l<7?9:11,o=1):(0===this._R.qS(this.RR,l)?h=s:(0===this._R.qS(this.zR,l)?h=f:(h=u,u=f),f=s),s=a,a=h),0===o&&(o=2+this.DR.decode(this._R,n),l=l<7?8:11);else if(u=f,f=s,s=a,o=2+this.LR.decode(this._R,n),l=l<7?7:10,4<=(r=this.AR[o<=5?o-2:3].decode(this._R))){if(a=(2|1&r)<<(n=(r>>1)-1),r<14)a+=z.nR(this.IR,a-r-1,this._R,n);else if((a=(a+=this._R.XS(n-4)<<4)+this.$R.eR(this._R))<0){if(-1===a)break;return!1}}else a=r;if(p<=a||a>=this.OR)return!1;this.wR.WS(a,o),p+=o,d=this.wR.HS(0)}return this.wR.flush(),this.wR.NS(),this._R.NS(),!0},z.gR.prototype.ER=function(i){var t;return!(i.size<5||(t=i.JS(),!this.BR(t%9,(t=~~(t/9))%5,~~(t/5))))&&(t=i.JS(),t=(t=(t|=i.JS()<<8)|i.JS()<<16)+16777216*i.JS(),this.FR(t))},z.NR=function(i,t){var e,o=new z.gR;if(!o.ER(i))throw new Error("Incorrect stream properties");if(e=i.JS(),e=((e|=i.JS()<<8)|i.JS()<<16)+16777216*i.JS(),i.JS(),i.JS(),i.JS(),i.JS(),o.decode(i,t,e))return!0;throw new Error("Error in data stream")},1e-9);function ji(i,t,e){for(var o,a,h=i.subarray(t,e),r=0,n="",l=0,r=0;r<h.length;)(a=h[r])>>>7==0?("0"!==(o=String.fromCharCode(h[r])).charCodeAt(0).toString(16)&&(n+=o),r+=1):252==(252&a)?(l=(3&h[r])<<30,l=(l=(l=(l=(l|=(63&h[r+1])<<24)|(63&h[r+2])<<18)|(63&h[r+3])<<12)|(63&h[r+4])<<6)|63&h[r+5],n+=String.fromCharCode(l),r+=6):248==(248&a)?(l=(7&h[r])<<24,l=(l=(l=(l|=(63&h[r+1])<<18)|(63&h[r+2])<<12)|(63&h[r+3])<<6)|63&h[r+4],n+=String.fromCharCode(l),r+=5):240==(240&a)?(l=(15&h[r])<<18,l=(l=(l|=(63&h[r+1])<<12)|(63&h[r+2])<<6)|63&h[r+3],n+=String.fromCharCode(l),r+=4):224==(224&a)?(l=(31&h[r])<<12,l=(l|=(63&h[r+1])<<6)|63&h[r+2],n+=String.fromCharCode(l),r+=3):192==(192&a)?(l=(63&h[r])<<6,l|=63&h[r+1],n+=String.fromCharCode(l),r+=2):("0"!==(o=String.fromCharCode(h[r])).charCodeAt(0).toString(16)&&(n+=o),r+=1);return n.trim()}var o=new RegExp("^[+\\\\-]?[0-1]*[.]?[0-1]*$","gi");function Vi(i,t){i=i.toString(),t=t.toString(),i=new Array(32-i.length+1).join("0")+i,t=new Array(32-t.length+1).join("0")+t;var e=o;return e.lastIndex=0,(t=(t+i).toString().match(e))?(i=-1===t[i=0].indexOf(".")?parseInt(t,2):i).toString(36).toUpperCase():"error"}i.getUnifyJson=function(i){var t=[];if(i instanceof ArrayBuffer){var e=new DataView(i),o=0,h=e.getInt16(o+=4,!1);o+=2;try{for(;0<h;){o+=4;for(var r=e.getUint8(o),n=(o+=1,new ArrayBuffer(r)),l=new Uint8Array(n),a=0;a<r;a++)l[a]=e.getUint8(o),o+=1;var s=ji(l,0,r),f=(o+=2,e.getInt8(o)),u=(o+=1,0!==f&&((C={}).status=f,C.building={},C.floor={},C.id=s,t.push(C)),e.getInt32(o,!1)),p=(o+=4,e.getInt32(o,!0)),d=(o+=4,u-p);if(0!==p){for(var x=2078870821,y=8*Math.ceil(p/8),c=p%8,v=new ArrayBuffer(y),g=new Int32Array(v),w=0;8<=p;){var b=e.getInt32(o,!0),R=e.getInt32(o+4,!0),m=b^x,k=292664^R;g[w]=m,g[w+1]=k,w+=2,o+=8,p-=8}0!==p&&(b=e.getInt32(o,!0),R=e.getInt32(o+4,!0),m=b^x,k=292664^R,g[w]=m,g[w+1]=k,o+=p);for(var _=new Uint8Array(v),S=_.length,I=S-8+c,A=new Uint8Array(I),a=0;a<I;a++)A[a]=_[a];for(a=0;a<c;a++)A[I-c+a]=_[S-1-a];for(var C,E={data:[],offset:0,jS:function(i){this.data[this.offset++]=i}},M=(z.NR({data:A,offset:0,JS:function(){return this.data[this.offset++]}},E),E.data),I=M.length,D=new ArrayBuffer(I),T=new Int8Array(D),a=0;a<I;a++)T[a]=M[a];(C=function(i){for(var t={},e={},o=new Uint8Array(i),h=new DataView(i),r=0,L=h.getInt32(r=r+4+4,!0),i=h.getInt32(r=r+4+4,!0),i=Vi(i=h.getUint32(r=r+(4+i)+4,!0).toString(2),h.getUint32(r+4,!0).toString(2)),n=ji(o,r+=8,r+64),l=ji(o,r+=64,r+64),a=h.getInt8(r+=64),P=ji(o,r+=1,r+8),B=h.getInt16(r+=8,!0),O=h.getInt16(r+2,!0),s=h.getFloat32(r+=4,!0),f=h.getFloat32(r+4,!0),J=h.getFloat32(r+=8,!0),U=h.getFloat32(r+4,!0),j=h.getFloat32(r+=8,!0),V=h.getFloat32(r+4,!0),u=h.getInt32(r+=8,!0),p=h.getInt32(r+=4,!0),d=h.getInt32(r+=4,!0),x=(r+=4,[]),y=0;y<u;y++)x.push(h.getInt32(r,!0)),r+=4;for(var c=[],y=0;y<d;y++)c.push(h.getInt32(r,!0)),r+=4;for(var v=[],y=0;y<u;y++){var N=ji(o,r,r+48);v.push(N),r+=48}for(var g=[],y=0;y<u;y++){var K=ji(o,r,r+8);g.push(K),r+=8}for(var w=[],y=0;y<p;y++){var b=h.getInt32(r,!0)*Ui+f,R=h.getInt32(r+4,!0)*Ui+s;w.push([b,R]),r+=8}i={type:"Feature",geometry:{type:"Polygon",coordinates:[w]},properties:{pid:i,name_cn:n,name_en:l,default_floor:a,buildingtype:P,building_poi_style:[B,O],centerPoint:[f,s],left_bottom_Point:[J,U],width:j,height:V,numberofFloor:u,numberofGeoPoints:p,park_floor_count:d,floor_indexs:x,park_floors:c,floor_names:v,floor_nonas:g}};for(var m=0;m<L;m++){for(var H=ji(o,r,r+8),k=(r+=8,h.getInt8(r)),G=(r+=1,e[k]={floor:{},shops:[],pubs:[],cons:[]},h.getInt16(r,!0)),$=h.getInt16(r+2,!0),X=(r+=4,h.getInt16(r,!0)),Z=h.getInt16(r+2,!0),q=(r+=4,h.getInt16(r,!0)),Y=h.getInt16(r+2,!0),_=(r+=4,h.getInt32(r,!0)),S=(r+=4,h.getInt32(r,!0)),I=(r+=4,h.getInt32(r,!0)),A=(r+=4,h.getInt32(r,!0)),C=(r+=4,[]),E=0;E<A;E++){for(var Q=h.getInt32(r,!0),M=(r+=4,[]),D=0;D<Q;D++)b=h.getInt32(r,!0)*Ui+f,R=h.getInt32(r+4,!0)*Ui+s,M.push([b,R]),r+=8;C.push(M)}for(var T="Polygon",z=C[0],T=(1<A&&(T="MultiPolygon",z=C),{type:"Feature",geometry:{type:T,coordinates:[z]},properties:{namecode:H,index:k,floor_region_type:[G,$],unhighlighted_floor_line_style:[X,Z],highlighted_floor_line_style:[q,Y],numberofShopCount:_,numberofPubCount:S,numberofConCount:I,floor_area_count:A}}),ii=(e[k].floor=T,[]),ti=0;ti<_;ti++){var ei=ji(o,r,r+128);r+=128;for(var oi=Vi(h.getUint32(r,!0).toString(2),h.getUint32(r+4,!0).toString(2)),hi=ji(o,r+=8,r+24),ri=ji(o,r+=24,r+12),ni=(r+=12,h.getInt32(r,!0)),li=(r+=4,h.getFloat32(r,!0)),ai=(r+=4,h.getInt8(r)),si=(r+=1,h.getInt16(r,!0)),fi=h.getInt16(r+2,!0),ui=(r+=4,h.getInt16(r,!0)),pi=h.getInt16(r+2,!0),di=(r+=4,h.getInt32(r,!0)*Ui+f),xi=h.getInt32(r+4,!0)*Ui+s,yi=(r+=8,h.getInt32(r,!0)),ci=(r+=4,[]),E=0;E<yi;E++)b=h.getInt32(r,!0)*Ui+f,R=h.getInt32(r+4,!0)*Ui+s,ci.push([b,R]),r+=8;ii.push({type:"Feature",geometry:{type:"Polygon",coordinates:[ci]},properties:{name:ei,pid:oi,cpid:hi,logo:ri,area:ni,rank:li,height:ai,poitype:[si,fi],regiontype:[ui,pi],font_anthor_point:[di,xi],shop_point_number:yi}})}e[k].shops=ii;for(var vi=[],gi=0;gi<S;gi++){var wi=ji(o,r,r+24);r+=24;var bi=Vi(h.getUint32(r,!0).toString(2),h.getUint32(r+4,!0).toString(2)),Ri=ji(o,r+=8,r+48),mi=(r+=48,h.getFloat32(r,!0)),ki=(r+=4,h.getInt16(r,!0)),_i=h.getInt16(r+2,!0),b=(r+=4,h.getInt32(r,!0)*Ui+f),R=h.getInt32(r+4,!0)*Ui+s;r+=8,vi.push({type:"Feature",geometry:{type:"Point",coordinates:[b,R]},properties:{cpid:wi,pid:bi,name:Ri,rank:mi,poitype:[ki,_i]}})}e[k].pubs=vi;for(var Si=[],Ii=0;Ii<I;Ii++){var Ai=ji(o,r,r+24);r+=24;var Ci=Vi(h.getUint32(r,!0).toString(2),h.getUint32(r+4,!0).toString(2)),Ei=ji(o,r+=8,r+48),Mi=(r+=48,h.getFloat32(r,!0)),Di=(r+=4,h.getInt16(r,!0)),Ti=h.getInt16(r+2,!0),b=(r+=4,h.getInt32(r,!0)*Ui+f),R=h.getInt32(r+4,!0)*Ui+s;r+=8,Si.push({type:"Feature",geometry:{type:"Point",coordinates:[b,R]},properties:{cpid:Ai,pid:Ci,name:Ei,rank:Mi,poitype:[Di,Ti]}})}e[k].cons=Si}for(var n=h.getInt32(r+=4,!0),zi=h.getInt32(r+=4+n,!0),Wi=(r+=4,[]),y=0;y<zi;y++)b=h.getInt32(r,!0)*Ui+f,R=h.getInt32(r+4,!0)*Ui+s,Wi.push([b,R]),r+=8;i.properties.outside_outline=Wi;var W,F={};for(W in e)if(e.hasOwnProperty(W)){for(F.floor=e[W].floor,D=0;D<e[W].shops.length;D++){var Fi=h.getInt16(r,!0),Li=(r+=2,h.getInt16(r,!0));r+=2,e[W].shops[D].properties.zoom_min=Fi,e[W].shops[D].properties.zoom_max=Li}for(F.shops=e[W].shops,D=0;D<e[W].pubs.length;D++){var Pi=h.getInt16(r,!0),Bi=(r+=2,h.getInt16(r,!0));r+=2,e[W].pubs[D].properties.zoom_min=Pi,e[W].pubs[D].properties.zoom_max=Bi}for(F.pubs=e[W].pubs,D=0;D<e[W].cons.length;D++){var Oi=h.getInt16(r,!0),Ji=(r+=2,h.getInt16(r,!0));r+=2,e[W].cons[D].properties.zoom_min=Oi,e[W].cons[D].properties.zoom_max=Ji}F.cons=e[W].cons,t.floor=F}return l=h.getInt32(r+=4,!0),a=h.getInt8(r+=4+l),r+=1,i.properties.UR=a,t.building=i,t}(D)).status=f,C.id=s,t.push(C)}o+=d,--h}}catch(i){}}else t.push(C={status:3,building:{},floor:{},id:""});return t}}var obj={WR:parserFunc},IndoorMapBinDataParser=(parserFunc(obj),obj),OverlayWorker=function(){function i(i){this.parent=i}return i.prototype.setPathWebgl=function(i,t){try{for(var e=new polyfill.K_,o=new polyfill.J_,h=new polyfill.oE,r=new polyfill.oE,n=i.data,l=this.EW(n[0][0][0]),a=0,s=n;a<s.length;a++){for(var f=s[a],u=l.center,p=[],d=[],x=f[0],y=[],c=[],v=[],g=0,w=x;g<w.length;g++){var b=w[g],R=polyfill.ProjectionManager.getProjection("EPSG:3857").project(b[0],b[1]);p.push(R[0]-u[0],R[1]-u[1]),d.push(b)}for(var m=1,k=f.length;m<k;m++){for(var _=f[m],S=[],I=[],A=0,C=_;A<C.length;A++)b=C[A],polyfill.Bs(b)?(S.push(b.pos[0]-u[0],b.pos[1]-u[1]),I.push(b.toJSON())):(R=polyfill.ProjectionManager.getProjection("EPSG:3857").project(b[0],b[1]),S.push(R[0]-u[0],R[1]-u[1]),I.push(b));y.push(S),c.push(I)}for(var E=[],m=0,k=p.length;m<k;m+=2)E.push(polyfill.xd(p[m],p[m+1]));polyfill.equals(E[0],E[E.length-1])||E.push(polyfill.Ex(E[0]));for(var M=p.length,m=0;m<y.length;m++)v.push(M/2),M+=y[m].length,polyfill.Util.Ig(p,y[m]);for(var D=e.Nx(p,v),T=(h.add(D),o.Nx(E,{lineJoin:"miter"}).Iw),m=0;m<y.length;m++){for(var z=[],W=0,k=(S=y[m]).length;W<k;W+=2)z.push(polyfill.xd(S[W],S[W+1]));z.push(polyfill.xd(S[0],S[1])),T+=o.Nx(z,{lineJoin:"miter"}).Iw}r.add(T)}t(null,{$c:o,Dc:e,Sx:l,Oc:h,Uc:r})}catch(i){t(i.message)}},i.prototype.AW=function(i,t){try{var e={},o=IndoorMapBinDataParser.getUnifyJson(i);if(!o)return!1;for(var h,r,n,l,a,s,f,u=0;u<o.length;u++)0===o[u].status&&(r=(h=o[u]).floor,n=h.building,l=h.status,a=h.id,s=r.floor.properties.index,e[a]||(e[a]={}),e[a].building=n,e[a].data||(e[a].data={}),f={floor:r,status:l,id:a,building:n},e[a].data[s]=f);t(null,e)}catch(i){t(i.message,null)}},i.prototype.EW=function(i){if(i)return i=polyfill.Bs(i)?polyfill.ProjectionManager.getProjection("EPSG:3857").project(i.KL,i.kT):polyfill.ProjectionManager.getProjection("EPSG:3857").project(i[0],i[1]),polyfill.lcs.getLocalByCoord(i)},i}(),wasm,heap=new Array(32).fill(void 0);function getObject(i){return heap[i]}heap.push(void 0,null,!0,!1);var heap_next=heap.length;function dropObject(i){i<36||(heap[i]=heap_next,heap_next=i)}function takeObject(i){getObject(i),dropObject(i)}var cachedTextDecoder=self.TextDecoder?new TextDecoder("utf-8",{ignoreBOM:!0,fatal:!0}):{},cachegetUint8Memory0=(cachedTextDecoder.decode&&cachedTextDecoder.decode(),null);function getUint8Memory0(){return cachegetUint8Memory0=null!==cachegetUint8Memory0&&cachegetUint8Memory0.buffer===wasm.memory.buffer?cachegetUint8Memory0:new Uint8Array(wasm.memory.buffer)}function getStringFromWasm0(i,t){return cachedTextDecoder.decode(getUint8Memory0().subarray(i,i+t))}var WASM_VECTOR_LEN=0,cachedTextEncoder=self.TextEncoder?new TextEncoder:{},encodeString="function"==typeof cachedTextEncoder.encodeInto?function(i,t){return cachedTextEncoder.encodeInto(i,t)}:function(i,t){var e=cachedTextEncoder.encode(i);return t.set(e),{read:i.length,jW:e.length}};function passStringToWasm0(i,t,e){var o;if(void 0===e)return o=t((h=cachedTextEncoder.encode(i)).length),getUint8Memory0().subarray(o,o+h.length).set(h),WASM_VECTOR_LEN=h.length,o;for(var h,r=i.length,n=t(r),l=getUint8Memory0(),a=0;a<r;a++){var s=i.charCodeAt(a);if(127<s)break;l[n+a]=s}return a!==r&&(n=e(n,r,r=a+3*(i=0!==a?i.slice(a):i).length),h=getUint8Memory0().subarray(n+a,n+r),a+=encodeString(i,h).jW),WASM_VECTOR_LEN=a,n}var cachegetInt32Memory0=null;function getInt32Memory0(){return cachegetInt32Memory0=null!==cachegetInt32Memory0&&cachegetInt32Memory0.buffer===wasm.memory.buffer?cachegetInt32Memory0:new Int32Array(wasm.memory.buffer)}function addHeapObject(i){heap_next===heap.length&&heap.push(heap.length+1);var t=heap_next;return heap_next=heap[t],heap[t]=i,t}var RSAPublicKeyPair=function(){function e(){var i=wasm.rsapublickeypair_new();return e.XW(i)}return e.XW=function(i){var t=Object.create(e.prototype);return t.UW=i,t},e.prototype.VW=function(){var i=this.UW;this.UW=0,wasm.__wbg_rsapublickeypair_free(i)},e.prototype.init=function(){wasm.rsapublickeypair_init(this.UW)},e.prototype.encode=function(i){try{var t=passStringToWasm0(i,wasm.__wbindgen_malloc,wasm.__wbindgen_realloc),e=WASM_VECTOR_LEN;return wasm.rsapublickeypair_encode(8,this.UW,t,e),getStringFromWasm0(o=getInt32Memory0()[2],h=getInt32Memory0()[3])}finally{var o=getInt32Memory0()[2],h=getInt32Memory0()[3];wasm.__wbindgen_free(o,h)}},e}();function loadSync(i,t){var e=new WebAssembly.Module(i);return{module:i,instance:new WebAssembly.Instance(e,t)}}function initSync(i){var t={wbg:{}};t.wbg.__wbg_new_59cb74e423758ede=function(){return addHeapObject(new Error)},t.wbg.__wbg_stack_558ba5917b466edd=function(i,t){var t=passStringToWasm0(getObject(t).stack,wasm.__wbindgen_malloc,wasm.__wbindgen_realloc),e=WASM_VECTOR_LEN;getInt32Memory0()[i/4+1]=e,getInt32Memory0()[i/4+0]=t},t.wbg.__wbg_error_4bb6c2a97407129a=function(i,t){try{console.error(getStringFromWasm0(i,t))}finally{wasm.__wbindgen_free(i,t)}},t.wbg.__wbindgen_object_drop_ref=function(i){takeObject(i)},t.wbg.__wbindgen_throw=function(i,t){throw new Error(getStringFromWasm0(i,t))},i=loadSync(i,t).instance,wasm=i.exports}var RSAWorker=function(){function i(i,t){this.parent=i}return i.prototype.transform=function(i){if(this.instance)return this.instance.encode(i)},i.prototype.dE=function(i){initSync(base64ToBuffer(data)),this.instance=new RSAPublicKeyPair,this.instance.init(),i&&i(null)},i}(),env;function base64ToBuffer(i){for(var t=atob(i),e=new Uint8Array(t.length),o=0,h=t.length;o<h;o++)e[o]=t.charCodeAt(o);return e.buffer}var env=polyfill.Support.DW?{movingDraw:sharedChunk.movingDraw,db:sharedChunk.db,nebulaVersion:sharedChunk.nebulaVersion,host:sharedChunk.host}:{movingDraw:window.movingDraw},AMapWorker=function(h){function i(i,t,e){var o=h.call(this)||this,t=(o.key=t,o.GW=e,o.lQ={},o.Zw=!1,o._id="-1",o.protocol="https",o.Yw=XHR,o.jQ=new polyfill.MY,o.QZ="",o.$w=[],o.Uh=new polyfill.Bh(i,o),o.self=i,o.z_=new ImageManagerWorker);return o.R_=new polyfill.jb({parent:o,z_:t}),o.IW=new polyfill.xW(o,XHR),o.Ww=new NebulaSourceWorker(o),o.NQ=new InnerLabelsSourceWorker(o),o.lQ[o.Ww.id]=o.Ww,o.yw=new LabelWorker(o),o.BW=new OverlayWorker(o),polyfill.Support.wasm&&(o.PW=new RSAWorker(o)),o.Fb(),o.yY=new polyfill.wY({render:function(){o.jQ.exec(10)},check:function(){return o.jQ.xY()}}),o}return polyfill.Ei(i,h),i.prototype.initCryptWorker=function(i,t,e){e()},i.prototype.setId=function(i,t,e){this._id=t,e()},i.prototype.loadNebulaSourceTile=function(i,t,e){var o=this,h=t.url,r=t.ya,n=t.zoom,l=t.projectionId,a=t.optimalZoom,s=t.Ca,f=t.mS,u=t.viewMode,p=t.showBuildingBlock,d=t.ZL,x=t.hH,t=t.kZ;return this.Ww.bw(h,r,n,a,l,s,f,u,p,d,x,function(i,t){o.Zw?o.$w.push({done:e,type:"NebulaSourceTile",data:t}):e(i,t)},t)},i.prototype.decodeNebulaSourceTile=function(i,t,e){var o=t.url,h=(t.ya,t.zoom),r=t.projectionId,n=t.optimalZoom,l=(t.Ca,t.mS),a=t.viewMode,s=t.showBuildingBlock,f=t.ZL,t=(t.hH,t.buffer);return this.Ww.pQ(t,r,h,a,s,l,n,f,e,o)},i.prototype.loadNebulaSourceTileSdf=function(i,t,e){var o=this,h=t.url,r=t.ya,n=(t.zoom,t.projectionId),l=(t.optimalZoom,t.Ca,t.mS,t.viewMode,t.showBuildingBlock,t.mH),t=t.ZL;return this.Ww.bW(h,r,n,t,l,function(i,t){o.Zw?o.$w.push({done:e,type:"NebulaSourceTileSdf",data:t}):e(i,t)})},i.prototype.decodeNebulaSourceTileSdf=function(i,t,e){var o=this,h=t.url,r=t.ya,n=(t.zoom,t.projectionId),l=(t.optimalZoom,t.Ca,t.mS,t.viewMode,t.showBuildingBlock,t.mH),a=t.ZL,t=t.buffer,h=-1!==h.indexOf("/oversea"),s=new polyfill.vH;return this.Ww.HQ(t,h,n,r,s,l,a,function(i,t){o.Zw?o.$w.push({done:e,type:"NebulaSourceTileSdf",data:t}):e(i,t)}),{cancel:s.cancel}},i.prototype.loadDistrictSourceTile=function(i,t,e){var o=t.url,h=t.tileCoord,r=t.projectionId,n=t.tileSize;return t.styles,this._getDistrictSourceWorker(),this.kW.bw(o,h,r,n,e)},i.prototype.loadMapboxVTSourceTile=function(i,t,e){var o=this,h=t.url,r=t.tileCoord,n=t.projectionId,l=t.tileSize,t=t.styles;return this._getMapboxVTSourceWorker(),this.QJ.bw(h,r,n,l,t,function(i,t){o.Zw?o.$w.push({done:e,type:"loadMapboxVTSourceTile",data:t}):e(i,t)})},i.prototype.reBufferMapboxVTSource=function(i,t,e){var o=t.MX,t=t.styles;return this._getMapboxVTSourceWorker(),this.QJ.mX(o,t,e)},i.prototype.loadMapboxSourceTile=function(i,t,e){var o=t.url,h=t.tileCoord,r=t.projectionId,n=t.tileSize,l=t.styles,t=t.adcode;return this._getMapboxSourceWorker(),this.vQ.bw(o,h,r,n,l,t,e)},i.prototype.updateMapStyle=function(i,t,e){polyfill.Support.amapRunTime&&!polyfill.Support.amapRunTime["style-parse-begin"]&&(polyfill.Support.amapRunTime["style-parse-begin"]=Date.now());var o=JSON.parse(t.value);polyfill.Support.amapRunTime&&!polyfill.Support.amapRunTime["style-parse-end"]&&(polyfill.Support.amapRunTime["style-parse-end"]=Date.now()),this.vn=new polyfill.StyleParser(t.TY),this.vn.jY(o),this.Ww.emit("styleReady")},i.prototype.updateUserStyle=function(i,t,e){this.vn&&this.vn.setStyle(t.Kd),e&&e()},i.prototype.sendHttp=function(i,t){this.R_.protocol=t.protocol,this.protocol=t.protocol},i.prototype.updateParams=function(i,t){this.params=polyfill.assign(this.params,t),t.langForeign&&(this.langForeign=t.langForeign),t.QG&&(this.QG=t.QG)},i.prototype.getSDFData=function(i,t,e){this.R_.loadData(t,{cb:function(i){e(null,i)}})},i.prototype.getImages=function(i,t){var r=this,n=t.data,l=t.cb,a=this.z_;a.loadImages(n,{cb:function(i){for(var t=[],e=0,o=n;e<o.length;e++){var h=o[e];t.push({url:h,data:a.getImage(h)})}r.Uh.send("imageLoaded",{data:t,cb:l})},type:"icon"})},i.prototype.setPathWebgl=function(i,t,e){this.BW.setPathWebgl(t,e)},i.prototype.sendIndoorRequest=function(i,t,e){var o=this;this.BW.AW(t,function(i,t){o.Zw?o.$w.push({done:e,type:"sendIndoorRequest",data:t}):e(i,t)})},i.prototype.Qw=function(i){this.Uh.send("NebulaTileSdfLoaded",polyfill.ca)},i.prototype.setMainThreadBusy=function(i,t){if(env.movingDraw)this.Zw=!1;else{if(this.Zw=t,!this.Zw)for(var e=0,o=this.$w;e<o.length;e++){var h=o[e];h.done?h.done(null,h.data):this.Uh.send(h.type,h.data)}this.$w=[]}},i.prototype.loadWordsByFront=function(i){this.Uh.send("loadWordsByFront",i.Es,i.cb)},i.prototype.innerLabelsLoadData=function(i,t,e){this.NQ.loadData(t,e)},i.prototype.dQ=function(i){return this.lQ[i]},i.prototype.deleteTileStaticSDF=function(i,t){this.IW.NW(t)},i.prototype.PQ=function(i,t){this.QZ=t},i.prototype._getNebulaSourceWorker=function(){return this.Ww||(this.Ww=new NebulaSourceWorker(this)),this.Ww},i.prototype._getDistrictSourceWorker=function(){return this.kW||(this.kW=new DistrictSourceWorker(this)),this.kW},i.prototype._getMapboxVTSourceWorker=function(){return this.QJ||(this.QJ=new polyfill.bX),this.QJ},i.prototype._getMapboxSourceWorker=function(){var i;return this.vQ||(i=this.vQ=new MapboxSourceWorker(this),this.lQ[i.id]=i),this.vQ},i.prototype.Fb=function(){var o=this;this.z_.on("iconImageLoaded",function(i){delete i.type,o.Uh.send("iconImageLoaded",i)}),this.R_.on("dynamicTextSDFInfoLoaded",function(i){delete i.type,o.Uh.send("dynamicTextSDFInfoLoaded",i.data)}),this.yw.on("dynamicTextVerticeLoaded",function(i){var t,e=i;o.Zw?(t=i.type,delete i.type,o.$w.push({type:t,data:e})):(delete i.type,o.Uh.send("dynamicTextVerticeLoaded",e))}),this.yw.on("dynamicTextVerticeLoadedByTile",function(i){var t,e=i;o.Zw?(t=i.type,delete i.type,o.$w.push({type:t,data:e})):(delete i.type,o.Uh.send("dynamicTextVerticeLoadedByTile",e))})},i}(polyfill.Event);return polyfill.Support.DW&&(self.Wh=new AMapWorker(self,sharedChunk.key,env),self.StyleParser=polyfill.StyleParser),AMapWorker}),define(["./shared"],function(_){var P={"AMap.MouseTool":["AMap.RangingTool"],"AMap.Adaptor":["AMap.CallAMap"]},j=new _.tS;function B(t){try{var i,n=localStorage.getItem("_AMap_"+t);return n&&((i=JSON.parse(n)).version===_.Module.eS.iS?(window._jsload_(t,i.script,!0),i.css&&window._cssload_(t,i.css,!0),j.add([t],void 0),j.finish(t),1):void window.localStorage.removeItem("_AMap_"+t))}catch(t){}}function W(t){for(var i=[],n=0,s=t;n<s.length;n++){var e=s[n],r=e;if(!j.has(e)){if(r=P[r])for(var h=0,o=r;h<o.length;h++){var a=o[h];!t[a]&&i.indexOf(a)<0&&(B(a)||i.push(a))}i.indexOf(e)<0&&(B(e)||i.push(e))}}return i}function F(t,i){var n=document.createElement("script");n.type="text/javascript",(document.body?(n.onload=function(){document.body.removeChild(n),i()},n.src=t,document.body):(n.onload=function(){document.head.removeChild(n),i()},n.src=t,document.head)).appendChild(n)}(G=document.getElementById("AMap_Dynamic_style"))||((G=document.createElement("style")).type="text/css",G.id="AMap_Dynamic_style",(ct=document.head||document.getElementsByTagName("head")[0]).childNodes.length<2?ct.appendChild(G):ct.insertBefore(G,ct.childNodes[1]));function N(t){G.appendChild(document.createTextNode(t))}window._cssload_=function(t,i,n){try{!n&&window.localStorage&&i&&""!==i&&window.localStorage.setItem("_AMap_"+t,JSON.stringify({css:i,version:_.Module.eS.iS}))}catch(t){}N(i)},window._jsload_=function(t,i,n){try{var s;!n&&i&&""!==i&&(s=window.localStorage["_AMap_"+t]||"{}",(s=JSON.parse(s)).version!==_.Module.eS.iS||s.script?window.localStorage.setItem("_AMap_"+t,JSON.stringify({version:_.Module.eS.iS,script:i})):window.localStorage.setItem("_AMap_"+t,JSON.stringify({version:_.Module.eS.iS,script:i,css:s.css})))}catch(t){}_.Module.nS(t,i)},window.cZ=_.Module;var G,U="function"==typeof Float32Array;function Y(t,i){return 1-3*i+3*t}function Z(t,i){return 3*i-6*t}function X(t,i,n){return((Y(i,n)*t+Z(i,n))*t+3*i)*t}function J(t,i,n){return 3*Y(i,n)*t*t+2*Z(i,n)*t+3*i}V.prototype.t=function(t){for(var i=0,n=1;10!==n&&this.i[n]<=t;++n)i+=.1;var s=i+(t-this.i[--n])/(this.i[n+1]-this.i[n])*.1,e=J(s,this.o,this.s);if(.001<=e){for(var r=t,h=s,o=this.o,a=this.s,u=0;u<4;++u){var c=J(h,o,a);if(0===c)return h;h-=(X(h,o,a)-r)/c}return h}if(0===e)return s;for(var f,l,d=t,v=i,p=i+.1,m=this.o,y=this.s,b=0;0<(f=X(l=v+(p-v)/2,m,y)-d)?p=l:v=l,1e-7<Math.abs(f)&&++b<10;);return l},V.prototype.h=function(t){return 0===t?0:1===t?1:X(this.t(t),this.l,this.u)},V.prototype.p=function(t){return t};var H=V;function V(t,i,n,s){if(!(0<=t&&t<=1&&0<=n&&n<=1))throw new Error("bezier x values must be in [0, 1] range");this.o=t,this.l=i,this.s=n,this.u=s,this.i=new(U?Float32Array:Array)(11);for(var e=0;e<11;++e)this.i[e]=X(.1*e,t,n)}var q,K,w={getViewport:function(t){return t?[t.clientWidth,t.clientHeight]:[0,0]},getStyle:function(t,i){var n,s=t.style[i];return"auto"===(s=(s=(s=s&&"auto"!==s||!document.defaultView?s:(n=document.defaultView.getComputedStyle(t,null))?n[i]:null)&&"auto"!==s||"height"!==i?s:t.clientHeight+"px")&&"auto"!==s||"width"!==i?s:t.clientWidth+"px")?null:s},getViewportOffset:function(t){var i,n=0,s=0,e=t,r=document.body,h=document.documentElement;do{if(n+=e.offsetTop||0,s+=e.offsetLeft||0,n+=parseInt(w.getStyle(e,"borderTopWidth"),10)||0,s+=parseInt(w.getStyle(e,"borderLeftWidth"),10)||0,i=w.getStyle(e,"position"),e.offsetParent===r&&"absolute"===i)break;if("fixed"===i){n+=r.scrollTop||h.scrollTop||0,s+=r.scrollLeft||h.scrollLeft||0;break}}while(e=e.offsetParent);for(e=t;e!==r&&(n-=e.scrollTop||0,s-=e.scrollLeft||0,!w.m()&&_.Support.webkit&&(s+=e.scrollWidth-e.clientWidth),e=e.parentNode););return[s,n]},m:function(){return q||(K="ltr"===w.getStyle(document.body,"direction"),q=!0),K},create:function(t,i,n,s){return t=document.createElement(t),n&&(t.className=n),i&&(s&&"before"===s?(n=i.firstChild,i.insertBefore(t,n)):i.appendChild(t)),t},toggleClass:function(t,i,n){n?this.addClass(t,i):this.removeClass(t,i)},hasClass:function(t,i){if(t&&i)return 0<t.className.length&&new RegExp("(^|\\\\s)"+i+"(\\\\s|$)").test(t.className)},addClass:function(t,i){t&&i&&(t.classList&&t.classList.add?t.classList.add(i):this.hasClass(t,i)||(t.className+=(t.className?" ":"")+i))},setClass:function(t,i){t&&(t.className=i||"")},removeClass:function(t,n){t&&n&&(t.classList&&t.classList.remove?t.classList.remove(n):t.className=t.className.replace(/(\\S+)\\s*/g,function(t,i){return i===n?"":t}).replace(/(^\\s+|\\s+$)/,""))},watchSize:function(n,s,e){var i=document.createElement("iframe"),r=(i.style.cssText="width: 100%;height: 100%;position: absolute;pointEvents:none; opacity:0; margin: 0;padding: 0;border: none;",i.onload=function(){i&&(i.contentWindow.onresize=t)},n.appendChild(i),i.src="javascript:void(0)",0),h=0;function t(){e.k=n.getBoundingClientRect(),e.M=[n.clientLeft,n.clientTop];var t=n.offsetWidth,i=n.offsetHeight;t===r&&i===h||(s(t,i),r=t,h=i)}return t(),e.resize=t,window.onscroll=t,function(){var t;e.resize&&(e.resize=null),window.onscroll&&(window.onscroll=null),i.contentWindow&&(i.contentWindow.onresize=null,i.contentWindow.document.write(""),i.parentNode.removeChild(i),null!=(t=i.contentWindow))&&t.close()}},watchSize2:function(n,s,e){var r,h,o=document.createElement("_"),a=(o.className="expand",o.appendChild(document.createElement("_"))),u=(a.className="shrink",o.appendChild(document.createElement("_"))),t=(u.className="expandChild",a.appendChild(document.createElement("_")));return t.className="shrinkChild",a.style.cssText=o.style.cssText="height:100%;left:0;opacity:0;overflow:hidden;pointer-events:none;position:absolute;top:0;transition:0s;width:100%;z-index:-1",t.style.cssText=u.style.cssText="display:block;height:100%;transition:0s;width:100%",t.style.width=t.style.height="200%",n.appendChild(o),c(),function(){f(),n.removeChild(o)};function c(){f(),e.k=n.getBoundingClientRect(),e.M=[n.clientLeft,n.clientTop];var t=n.offsetWidth,i=n.offsetHeight;t===r&&i===h||(r=t,h=i,u.style.width=2*t+"px",u.style.height=2*i+"px",o.scrollLeft=o.scrollWidth,o.scrollTop=o.scrollHeight,a.scrollLeft=a.scrollWidth,a.scrollTop=a.scrollHeight,s(t,i)),a.addEventListener("scroll",c),o.addEventListener("scroll",c)}function f(){a.removeEventListener("scroll",c),o.removeEventListener("scroll",c)}},mousePos:function(t,i,n){return t&&(n.k=t.getBoundingClientRect(),n.M=[t.clientLeft,t.clientTop]),t=n.k,[(i=i.touches&&i.changedTouches?0<i.touches.length?i.touches[0]:i.changedTouches[i.changedTouches.length-1]:i).clientX-t.left-n.M[0],i.clientY-t.top-n.M[1]]},remove:function(t){t&&t.parentNode&&t.parentNode.removeChild(t)},empty:function(t){for(;t.firstChild;)t.removeChild(t.firstChild)},closest:function(t,i){return t?this.hasClass(t,i)?t:(t=t.parentElement)?w.closest(t,i):null:null},fillText:function(t,i){if(t)return void 0!==t.textContent?t.textContent=i:void 0!==t.innerText?t.innerText=i:t.innerHTML=i,t},_L:function(t){for(var i=document.documentElement.style,n=0;n<t.length;n+=1)if(t[n]in i)return t[n];return!1},rotate:function(t,i,n){var s,e=w.kL;n=n||{x:t.clientWidth/2,y:t.clientHeight/2},e?(s="",t.style[e]=s+=" rotate("+i+"deg)",t.style[w.ML[e]+"-origin"]=n.x+"px "+n.y+"px"):(s=Math.cos(i*Math.PI/180),e=Math.sin(i*Math.PI/180),t.style.filter="progid:DXImageTransform.Microsoft.Matrix()",0<t.filters.length&&((i=t.filters.item(0)).Dx=-n.x*s+n.y*e+n.x,i.Dy=-n.x*e-n.y*s+n.y,i.M11=i.M22=s,i.M12=-(i.M21=e)))},setCss:function(t,i){t=t instanceof Array?t:[t];for(var n=0;n<t.length;n+=1)for(var s in i)i.hasOwnProperty(s)&&(t[n].style[s]=i[s]);return this},setOpacity:function(t,i){t.style&&("opacity"in t.style?t.style.opacity=""+i:"filter"in t.style&&(i=Math.round(100*i),t.style.filter="",100!==i)&&(t.style.filter=" progid:DXImageTransform.Microsoft.Alpha(opacity="+i+")"))},ML:{},kL:K=q=!1},Q=(w.kL=w._L(["WebkitTransform","OTransform","MozTransform","msTransform","transform"]),w.ML={transform:"transform",WebkitTransform:"-webkit-transform",OTransform:"-o-transform",MozTransform:"-moz-transform",msTransform:"-ms-transform"},t.prototype.isEnabled=function(){return"disabled"!==this.R},t.prototype.isActive=function(){return"active"===this.R},t.prototype.enable=function(){this.isEnabled()||(this.R="enabled")},t.prototype.disable=function(){this.isEnabled()&&(this.R,this.R="disabled")},t.prototype.L=function(t){this.A&&(this.A=!1),t.ctrlKey||0!==t.button||(document.addEventListener("mousemove",this.T),document.addEventListener("mouseup",this.I),this.D(t))},t.prototype.P=function(t){this.Xdt=t.Hdt,1<t.touches.length?(this.j.removeEventListener("touchmove",this.T),this.R="enabled"):(this.A&&(this.A=!1),"enabled"===this.R&&(this.j.addEventListener("touchmove",this.T,{capture:!0,passive:!0}),document.addEventListener("touchend",this.oS),this.D(t)))},t.prototype.D=function(t){this.$=this.U=this.B=w.mousePos(this.j,t,this._map),this.YF=this._map.getView().getStatus().centerCoord,this.XF=this._map.containerToCoord(this.$),this.W=[[Date.now(),this.$]],this.R="active"},t.prototype.Z=function(t){var i=(new Date).getTime(),n=this.Xdt;"touchmove"===t.type&&1<t.touches.length||i-n<50||(this.W.length<2&&"active"===this.R&&this.G("dragstart",t),"touchmove"===t.type&&this.G("touchmove",t),this.G("dragging",t),this.isEnabled()&&("active"===this.R&&(this.R="pending"),"disabled"!==this.R)&&this._map.getStatus().dragEnable&&(i=w.mousePos(this.j,t,this._map),this.q=t,this.B=_.set(_.create(),i[0],i[1]),this.Y(),this.W.push([Date.now(),this.B]),this.W.length<2||(n=this._map.getView(),t=this._map.containerToCoord(i),i=[this.XF[0]-t[0]+this.YF[0],this.XF[1]-t[1]+this.YF[1]],n.setOptions({center:this._map.getProjection().unproject(i[0],i[1])}))))},t.prototype.tt=function(t){if(0===t.button)if(this.it())this.S(),this.C();else switch(this.R){case"active":this.R="enabled",this.S(),this.C();break;case"pending":this.R="enabled",this.S(),this.C(),this.et(t),this.G("dragend",t);break;default:this.R="enabled",this.S(),this.G("dragend",t)}},t.prototype.N=function(t){if(0<t.touches.length)this.$=this.U=this.B=w.mousePos(this.j,t,this._map),this.YF=this._map.getView().getStatus().centerCoord,this.XF=this._map.containerToCoord(this.$);else if(this.it())this.S(),this.C(),this.R="enabled",this.G("dragend",t);else switch(this.R){case"active":this.R="enabled",this.S(),this.C();break;case"pending":this.R="enabled",this.S(),this.C(),this.G("dragend",t),this.et(t);break;default:this.G("dragend",t),this.S()}},t.prototype.it=function(){var t,i,n,s,e=this._map.getLimitBounds();if(e=e&&e.toJSON())return t=this._map.getBounds().toJSON(),i=[],s=[(n=this._map.getCenter().toJSON())[0],n[1]],(t[0]<e[0]||t[1]<e[1]||t[2]>e[2]||t[3]>e[3])&&(i[0]=t[0]-e[0],i[1]=t[1]-e[1],i[2]=t[2]-e[2],i[3]=t[3]-e[3],i[0]<0&&0<i[2]?s[0]=(e[0]+e[2])/2:i[0]<0?s[0]=n[0]-i[0]:0<i[2]&&(s[0]=n[0]-i[2]),i[1]<0&&0<i[3]?s[1]=(e[1]+e[3])/2:i[1]<0?s[1]=n[1]-i[1]:0<i[3]&&(s[1]=n[1]-i[3]),this._map.panTo(s,100),!0)},t.prototype.S=function(){this.j.removeEventListener("touchmove",this.T),document.removeEventListener("touchend",this.oS),document.removeEventListener("mousemove",this.T),document.removeEventListener("mouseup",this.I)},t.prototype.C=function(){delete this.q,delete this.$,delete this.U,delete this.B},t.prototype.Y=function(){for(var t=this.W,i=Date.now();0<t.length&&60<i-t[0][0];)t.shift()},t.prototype.et=function(t){var i,n,s,e,r,h,o,a,u,c,f,l,d,v;function p(){this.isEnabled()&&this.A||(h=-1);var t=Date.now()-a,t=(u<t&&(h=-1),[l[0]*t+d[0]*t*t/2,l[1]*t+d[1]*t*t/2]);o=[o[0]+(t[0]-v[0]),o[1]+(t[1]-v[1])],v=t,h<=0?this.A=!1:(s.setOptions({center:_.ProjectionManager.getProjection(e.projectionId).unproject(o[0],o[1])}),_.Util.requestAnimFrame(p.bind(this)),h--)}this._map.getStatus().jogEnable&&(this.A=!0,this.Y(),(i=this.W).length<2||(n=i[i.length-1],f=i[0],c=[n[1][0]-f[1][0],n[1][1]-f[1][1]],0==(r=(n[0]-f[0])/1e3)||_.equals(n[1],f[1])?this.G("moveend",t):(f=[c[0]/(.3/r),c[1]/(.3/r)],t=Math.sqrt(f[0]*f[0]+f[1]*f[1])/750,s=this._map.getView(),r=(e=s.getStatus()).rotation,f=h=parseInt((1e3*t+400)/17+"",10),new H(.1,0,1,.1),_.V[e.projectionId].nt(-c[0]/7,c[1]/7,e.zoom),o=_.ProjectionManager.getProjection(e.projectionId).project(e.center[0],e.center[1]),a=Date.now(),u=17*f,t=i[i.length-Math.min(i.length,3)],c=[n[1][0]-t[1][0],n[1][1]-t[1][1]],0!==r&&(c=this.J(r,c)),c=_.V[e.projectionId].nt(c[0],-c[1],e.zoom),f=Math.min(t[0]-n[0],-15),l=[c[0]/f,c[1]/f],d=[-l[0]/u,-l[1]/u],v=[0,0],_.Util.requestAnimFrame(p.bind(this)))))},t.prototype.J=function(t,i){var n=Math.sqrt(i[0]*i[0]+i[1]*i[1]),s=Math.atan2(i[1],i[0]),t=t/180*Math.PI-s;return i[0]=n*Math.cos(t),i[1]=-n*Math.sin(t),i},t.prototype.G=function(t,i){this._map.getBindHandler().fireEvent(t,i)},t);function t(t,i){this.st="mouse",this.Xdt=0,this._map=i,this.W=[],this.j=t,this.R="disabled",this.T=this.Z.bind(this),this.I=this.tt.bind(this),this.oS=this.N.bind(this)}i.prototype.isEnabled=function(){return"disabled"!==this.R},i.prototype.isActive=function(){return"active"===this.R},i.prototype.enable=function(){this.isEnabled()||(this.rt=!0,this.R="enabled")},i.prototype.ht=function(){return!!this.lt},i.prototype.disable=function(){if(this.isEnabled())switch(this.R){case"enabled":case"active":this.R="disabled",this.S(),this.C();break;case"pending":this.R="disabled",this.S();break;default:this.R="disabled"}},i.prototype.ut=function(t){t.preventDefault(),"enabled"===this.R&&this._map.getStatus().doubleClickZoom&&!t.ctrlKey&&0===t.button&&this.D(t)},i.prototype.P=function(t,i){var n=this;this.$=w.mousePos(this.j,t,this._map),2===t.touches.length?(this.rt=!1,this.ct=0):(this.rt=!0,this.ct++,this.ft=i,this.lt=!1,setTimeout(function(){1===n.ct&&(n.ct=0)},300),this.pt=[t.changedTouches[0].clientX,t.changedTouches[0].clientY],this.j.addEventListener("touchmove",this.dt),2<=this.ct&&this.j.addEventListener("touchend",this.N.bind(this)))},i.prototype.vt=function(t){var i=this;this.rt&&(this.yt++,setTimeout(function(){i.yt=0},300),2===this.yt&&!this.lt&&this._map.getStatus().doubleClickZoom&&(t.preventDefault(),this.yt=0,this.ct=0,this.D(t)),2===this.ct)&&(this.ct=0)},i.prototype.D=function(i){var n,s,e=this,r=(this.lt=!0,this.R="active",this.G("zoomstart"),400),h=0,o=this._map.getView().getStatus().zoom,a=new H(.4,0,.15,1);o>=this.xt[1]||(s=0,n=function(){h+=16;var t=o+a.h(h/r);t>=e.xt[1]||(e.bt(i,t),o+1<=t&&(_.Util.cancelAnimFrame(s),e.lt=!1,e.R="enabled",e.tt(),e.N()),(e.lt||h<400)&&(s=_.Util.requestAnimFrame(n)))},s=_.Util.requestAnimFrame(n))},i.prototype.gt=function(t){var i,n,s=w.mousePos(this.j,t,this._map);s[0]-this.$[0]==0&&s[1]-this.$[1]==0||(this.yt=-1,this.ct<2?this.ct=0:this.rt&&(this.lt=!0,this.wt=!0,this.ft.disable(),s=t.changedTouches.length,i=this._map.getView(),n=this._map.getView().getStatus().zoom-(t.changedTouches[s-1].clientY-this.pt[1])/100,i.setOptions({zoom:n}),this.pt=[t.changedTouches[s-1].clientX,t.changedTouches[s-1].clientY]))},i.prototype.N=function(){this.wt&&2<=this.ct&&(this.ft.enable(),this.tt(),this.lt=!1,this.wt=!1)},i.prototype.bt=function(t,i){var n,s,e,r=this._map.getView(),o=(h=r.getStatus()).center,a=h.zoom,u=h.rotation,h=h.projectionId;this._map.getStatus().zoomEnable&&(t=w.mousePos(this.j,t,this._map),e=[this.j.clientWidth/2,this.j.clientHeight/2],s=this._t(e,t),n=Math.atan((t[1]-e[1])/(t[0]-e[0])),u=-u/180*Math.PI+n,n=[-Math.cos(u)*s,Math.sin(u)*s],t[0]-e[0]<0&&(n[0]=-n[0],n[1]=-n[1]),u=_.V[h].nt(n[0],n[1],a),s=_.V[h].nt(n[0],n[1],i),e=Math.pow(2,i-a),r.setOptions({kt:{pos:t,Mt:i,Rt:s,zt:u,scale:e,center:_.set(_.create(),o[0],o[1])}}),this.G("zooming"))},i.prototype.tt=function(t){t&&0!==t.button||(this.S(),this.C(),this.G("zoomend"))},i.prototype.S=function(){this.j.removeEventListener("dblclick",this.St),this.j.removeEventListener("touchmove",this.dt)},i.prototype.C=function(){delete this.$,delete this.U,delete this.U},i.prototype._t=function(t,i){var n=i[0]-t[0],i=i[1]-t[1];return Math.sqrt(n*n+i*i)},i.prototype.G=function(t,i){this._map.getBindHandler().fireEvent(t,i)};var $=i;function i(t,i){this.lt=!1,this.wt=!1,this.rt=!0,this.xt=_.zoomRange,this.yt=0,this.ct=0,this.pt=[0,0],this._map=i,this.j=t,this.R="disabled",this.St=this.ut.bind(this),this.dt=this.gt.bind(this)}it.prototype.isEnabled=function(){return"disabled"!==this.R},it.prototype.isActive=function(){return"active"===this.R},it.prototype.enable=function(){this.isEnabled()||(this.R="enabled")},it.prototype.disable=function(){if(this.isEnabled())switch(w.removeClass(this.j,"mapboxgl-touch-drag-pan"),this.R){case"active":this.R="disabled",this.S(),this.G("zoomstart");break;case"pending":this.R="disabled",this.S();break;default:this.R="disabled"}},it.prototype.ht=function(){return!!this.lt},it.prototype.P=function(t){2===t.touches.length&&(t.stopPropagation(),this.G("zoomstart"),this.$=[{clientX:t.touches[0].clientX,clientY:t.touches[0].clientY,pageX:t.touches[0].pageX,pageY:t.touches[0].pageY},{clientX:t.touches[1].clientX,clientY:t.touches[1].clientY,pageX:t.touches[1].pageX,pageY:t.touches[1].pageY}],this.B=this.$,t=this._map.getView(),this.zY=t.getStatus(),this.j.addEventListener("touchmove",this.T),this.j.addEventListener("touchend",this.At))},it.prototype.Z=function(t){var i,n,s,e,r,h,o,a,u,c,f,l,d,v,p,m,y,b,g,M,k;t.touches.length<2||(this.G("touchmove"),this._map.getStatus().touchZoom&&this.isEnabled()&&(this.lt=!0,i=-this.CF(t),s=(c=(n=this._map.getView()).getStatus()).rotation,e=c.center,r=c.zoom,g=c.projectionId,g=void 0===(h=c.Tt)?g:h,h=c.pitch,o=(c=this._map.getStatus()).rotateEnable,a=c.zoomEnable,u=c.pitchEnable,c=c.touchZoomCenter,f=this.MW.CY,d=l=!1,y=this.It(this.B[0],this.B[1]),p=this.It(t.touches[0],t.touches[1]),v=this.Dt(this.$[0],this.$[1]),k=this.Dt(t.touches[0],t.touches[1]),p=r+(p-y)/180,y=[((y=_.Pt(w.mousePos(this.j,this.$[0],this._map),w.mousePos(this.j,this.$[1],this._map)))[0]+y[2])/2,(y[1]+y[3])/2],b=[this.j.clientWidth/2,this.j.clientHeight/2],m=this.jt(b,y),M=Math.atan((y[1]-b[1])/(y[0]-b[0])),M=s*Math.PI/180+M,M=[-Math.cos(M)*m,Math.sin(M)*m],y[0]-b[0]<0&&(M[0]=-M[0],M[1]=-M[1]),m=_.V[g].nt(M[0],M[1],r),y=_.V[g].nt(M[0],M[1],p),b=Math.pow(2,p-r),g=this.zY.rotation+(k-v),10<Math.abs(k-v)&&(this.MW.CY=!0),.1<Math.abs(i)&&(l=f=!(d=!0)),.01<Math.abs(p-r)&&(l=!0),M=w.mousePos(this.j,this.$[0],this._map),k=w.mousePos(this.j,this.$[1],this._map),1===c?n.setOptions({pitch:u&&d?h+i:h,zoom:a&&l?p:r,rotation:o&&f?g:s}):n.setOptions({pitch:u&&d?h+i:h,kt:a&&l&&{Mt:p,Rt:y,zt:m,pos:[(M[0]+k[0])/2,(M[1]+k[1])/2],scale:b,center:_.set(_.create(),e[0],e[1])},rotation:o&&f?g:s}),this.B=[{clientX:t.touches[0].clientX,clientY:t.touches[0].clientY,pageX:t.touches[0].pageX,pageY:t.touches[0].pageY},{clientX:t.touches[1].clientX,clientY:t.touches[1].clientY,pageX:t.touches[1].pageX,pageY:t.touches[1].pageY}]))},it.prototype.CF=function(t){var i,n=this.B,s=this.$,n=[w.mousePos(this.j,n[0],this._map),w.mousePos(this.j,n[1],this._map)],s=(w.mousePos(this.j,s[0],this._map),w.mousePos(this.j,s[1],this._map),[w.mousePos(this.j,t.touches[0],this._map),w.mousePos(this.j,t.touches[1],this._map)]),t=Math.sqrt(Math.pow(n[0][0]-n[1][0],2)+Math.pow(n[0][1]-n[1][1],2)),e=Math.sqrt(Math.pow(s[0][0]-s[1][0],2)+Math.pow(s[0][1]-s[1][1],2));return 2<Math.abs(e-t)||(e=s[0][0]-n[0][0],t=s[0][1]-n[0][1],i=s[1][0]-n[1][0],s=s[1][1]-n[1][1],Math.abs(t)<Math.abs(e))||Math.abs(s)<Math.abs(i)?0:-(t+s)/2/4},it.prototype.Et=function(t){this.MW.CY=!1,this.G("zoomend"),this.S()},it.prototype.It=function(t,i){var n=i.clientX-t.clientX,i=i.clientY-t.clientY;return Math.sqrt(n*n+i*i)},it.prototype.jt=function(t,i){var n=i[0]-t[0],i=i[1]-t[1];return Math.sqrt(n*n+i*i)},it.prototype.Dt=function(t,i){var n=t.pageX-i.pageX,t=t.pageY-i.pageY;return Math.atan2(t,n)/Math.PI*180},it.prototype.S=function(){this.j.removeEventListener("touchstart",this.Nt),this.j.removeEventListener("touchmove",this.T),this.j.removeEventListener("touchend",this.At)},it.prototype.G=function(t,i){this._map.getBindHandler().fireEvent(t,i)};var tt=it;function it(t,i){this.MW={CY:!1},this._map=i,this.j=t,this.R="disabled",this.T=this.Z.bind(this),this.At=this.Et.bind(this)}var nt=4.000244140625,st=(et.prototype.isEnabled=function(){return"disabled"!==this.R},et.prototype.isActive=function(){return"active"===this.R},et.prototype.enable=function(){this.isEnabled()||(this.R="enabled")},et.prototype.disable=function(){this.isEnabled()&&(this.R="disabled",this.C(),this.G("zoomend"))},et.prototype.Ut=function(t){t.preventDefault();var i,n,s,e=this._map.getStatus();this.G("zoomstart"),this.isEnabled()&&(i=t.deltaMode===WheelEvent.DOM_DELTA_LINE?40*t.deltaY:t.deltaMode===WheelEvent.DOM_DELTA_PAGE?400*t.deltaY:t.deltaY,s=(n=Date.now())-(this.Bt||0),this.Bt=n,0!==i&&i%nt==0?this.Wt="wheel":0!==i&&Math.abs(i)<4?this.Wt="trackpad":400<s?(this.Wt=null,this.Gt=i):this.Wt||(this.Wt=Math.abs(s*i)<200?"trackpad":"wheel",this.Zt&&(i+=this.Gt)),t.shiftKey&&i&&(i/=4),e&&e.zoomSpeed&&(i*=e.zoomSpeed),this.Wt)&&(this.$t-=i,this.isActive()||this.D(t))},et.prototype.D=function(t){var i,n,s,e,r,h,o,a,u;this.$t&&(a=(e=(i=this._map.getView()).getStatus()).rotation,n=e.zoom,s=e.center,e=e.projectionId,h="wheel"===this.Wt&&Math.abs(this.$t)>nt?1/450:.01,h=2/(1+Math.exp(-Math.abs(this.$t*h))),this.$t<0&&0!==h&&(h=1/h),r=this.Yt(n),r=Math.min(this._map.getZooms()[1],Math.max(2,this.Vt(r*h))),h=w.mousePos(this.j,t,this._map),t=[this.j.clientWidth/2,this.j.clientHeight/2],u=this._t(t,h),o=Math.atan((h[1]-t[1])/(h[0]-t[0])),a=-a/180*Math.PI+o,o=[-Math.cos(a)*u,Math.sin(a)*u],h[0]-t[0]<0&&(o[0]=-o[0],o[1]=-o[1]),a=_.V[e].nt(o[0],o[1],n),u=_.V[e].nt(o[0],o[1],r),t=Math.pow(2,r-n),this._map.XT(o),i.setOptions({kt:{pos:h,Mt:r,Rt:u,zt:a,scale:t,center:_.set(_.create(),s[0],s[1])}}),this.$t=0)},et.prototype.Yt=function(t){return Math.pow(2,t)},et.prototype.Vt=function(t){return Math.log(t)/Math.LN2},et.prototype._t=function(t,i){var n=i[0]-t[0],i=i[1]-t[1];return Math.sqrt(n*n+i*i)},et.prototype.C=function(){delete this.q,delete this.$,delete this.U,delete this.B},et.prototype.G=function(t,i){this._map.getBindHandler().fireEvent(t,i)},et);function et(t,i){this._map=i,this.j=t,this.R="disabled",this.Wt="wheel",this.$t=0}ht.prototype.isEnabled=function(){return"disabled"!==this.R},ht.prototype.isActive=function(){return"active"===this.R},ht.prototype.enable=function(){this.isEnabled()||(this.R="enabled")},ht.prototype.disable=function(){if(this.isEnabled()){switch(this.R){case"active":this.S(),this.C();break;case"pending":this.S()}this.R="disabled"}},ht.prototype.L=function(t){this.A&&clearInterval(this.A),(2===t.button||t.ctrlKey&&0===t.button)&&(this.j.addEventListener("mousemove",this.T,{passive:!0}),this.j.addEventListener("mouseup",this.I),this.j.addEventListener("mouseleave",this.I),this.D(t))},ht.prototype.D=function(t){this.$=this.U=this.B=w.mousePos(this.j,t,this._map),this.W=[[Date.now(),this.$]],this.R="active"},ht.prototype.Z=function(t){var i,n,s;this.W.length<2&&"active"===this.R&&this.G("dragstart",t),this.G("dragging",t),this.isEnabled()&&(n=w.mousePos(this.j,t,this._map),this.q=t,this.B=_.set(_.create(),n[0],n[1]),this.Y(),this.W.push([Date.now(),this.B]),this.W.length<2||("active"===this.R&&(this.R="pending"),"disabled"!==this.R&&(i=(n=(t=this._map.getView()).getStatus()).rotation,n=n.pitch,s=[this.B[0]-this.W[this.W.length-2][1][0],this.B[1]-this.W[this.W.length-2][1][1]],(!this._map.getStatus().pitchEnable||Math.abs(s[0])>Math.abs(s[1]))&&(s[1]=0),(!this._map.getStatus().rotateEnable||Math.abs(s[0])<Math.abs(s[1]))&&(s[0]=0),15<Math.abs(this.B[0]-this.$[0])&&(this.B[1]>this.j.clientHeight/2?i-=s[0]/10:i+=s[0]/10),n-=s[1]/this._map.getZooms()[1]*2,t.setOptions({rotation:i,pitch:n}))))},ht.prototype.tt=function(t){switch(this.R){case"active":this.R="enabled",this.C();break;case"pending":this.R="enabled",this.G("dragend",t);break;default:this.G("dragend",t)}this.S()},ht.prototype.S=function(){this.j.removeEventListener("mousemove",this.T),this.j.removeEventListener("mouseup",this.I),this.j.removeEventListener("mouseleave",this.I)},ht.prototype.C=function(){delete this.q,delete this.$,delete this.U,delete this.B},ht.prototype.Y=function(){for(var t=this.W,i=Date.now();0<t.length&&160<i-t[0][0];)t.shift()},ht.prototype.G=function(t,i){this._map.getBindHandler().fireEvent(t,i)};var rt=ht;function ht(t,i){this._map=i,this.W=[],this.j=t,this.R="disabled",this.T=this.Z.bind(this),this.I=this.tt.bind(this)}n.prototype.Xt=function(){this._container.addEventListener("mouseenter",this.DL.bind(this)),this._container.addEventListener("mouseover",this.OL.bind(this)),this._container.addEventListener("mouseleave",this.PL.bind(this)),this._container.addEventListener("mouseup",this.tt.bind(this)),this._container.addEventListener("mouseout",this.BL.bind(this)),this._container.addEventListener("mousemove",this.jL.bind(this)),this._container.addEventListener("mousedown",this.Jt.bind(this)),this._container.addEventListener("touchend",this.N.bind(this)),this._container.addEventListener("touchstart",this.Kt.bind(this),!1),this._container.addEventListener("touchmove",this.gt.bind(this),!1),this._container.addEventListener("wheel",this.Qt.bind(this),{passive:!1}),this._container.addEventListener("contextmenu",this.EL.bind(this)),this._container.addEventListener("keydown",this.ii.bind(this))},n.prototype.fireEvent=function(t,i){if(i){i.Adt=t;var n=this._map.getStatus();if("scrollWheel"===t){if(!n.scrollWheel)return void this.oi.disable();this.oi.enable()}var s,r=(e=w.mousePos(this._container,i,this._map))[0],e=e[1],o=(h=this._map.getView().containerTolnglat(r,e))[0],h=h[1];if("mousemove"===t&&this.ri&&this.ri.P$)s=this.ri;else if("dragstart"===t||"dragging"===t||"dragend"===t)switch(t){case"dragstart":s=!n.pickWhenMoving&&this._map.TL()?this.ri:this.si(i),this.ri=s;break;case"dragging":s=this.ri;break;case"dragend":s=this.ri,this.ri=void 0}else s=!n.pickWhenMoving&&this._map.TL()?this.ri:this.si(i);var a=this.hi(s,t),u=new _.LngLat(o,h),o={lnglat:u,target:s,pixel:r=new _.Pixel(r,e),originEvent:i,pos:e=this._map.getProjection().project(o,h),vectorIndex:0},h=(s&&(o.vectorIndex=s&&s.iE&&i.lnglat&&s.iE(i.lnglat)||0),-1!==["mouseover","mousemove","mouseout","mouseenter","mouseleave"].indexOf(t)?this.ui(t,o):s&&this.ci(s,t,o),o.target),o={lnglat:u,target:s,pixel:r,originEvent:i,pos:e};h&&"poi"!==h.type&&!a||(o.target=this._map),s&&"poi"===s.type||s&&a?this._map.emit(t,o):"dblclick"===t&&s?this.fi.disable():"dragstart"!==t&&"dragging"!==t&&"dragend"!==t||!s||!s.getDraggable()&&"AMap.InfoWindow"!==s.type&&"AMap.ContextMenu"!==s.type?s||(n.dragEnable||"dragging"!==t&&"dragstart"!==t&&"dragend"!==t)&&this._map.emit(t,o):"dragend"===t?this.ft.enable():this.ft.disable()}},n.prototype.hi=function(t,i){return!!t&&"poi"!==t.type&&!("dragstart"===i||"dragging"===i||"dragend"===i||!this._map.getStatus().allBubble&&!Boolean(t.getOptions().bubble))},n.prototype.ti=function(t){this.fi.enable(),this.fireEvent("dblclick",t),this.fi.ut(t)},n.prototype.Jt=function(t){this._map.cancelMapAnimate(),this.Ht="mousedown",this.fireEvent("mousedown",t),this.ft.enable(),this.ft.L(t),this.ei.L(t),this.$=w.mousePos(this._container,t,this._map)},n.prototype.OL=function(t){this.fireEvent("mouseover",t)},n.prototype.DL=function(t){this.fireEvent("mouseenter",t)},n.prototype.PL=function(t){this.fireEvent("mouseleave",t)},n.prototype.BL=function(t){this.fireEvent("mouseout",t)},n.prototype.tt=function(t){var i=this;"mousedown"!==this.Ht||t.ctrlKey||(setTimeout(function(){i.nB=0},300),this.Ht="false",2===t.button?this.fireEvent("rightclick",t):(this.nB++,2<=this.nB?(this.fi.enable(),this.fireEvent("dblclick",t),this.fi.ut(t),this.nB=0):this.fireEvent("click",t))),this.fireEvent("mouseup",t)},n.prototype.FL=function(t){"move"!==this.Ht&&this.fireEvent("click",t)},n.prototype.jL=function(t){var i;"mousedown"===this.Ht&&(i=w.mousePos(this._container,t,this._map),1<Math.abs(this.$[0]-i[0])||1<Math.abs(this.$[1]-i[1]))&&(this.Ht="move"),this.fireEvent("mousemove",t)},n.prototype.Kt=function(t){var i=this;"infoWindow"!==t.cH&&"markerContent"!==t.cH&&t.cancelable&&t.preventDefault(),this.oB="touchstart",this.$=w.mousePos(this._container,t,this._map),this._map.cancelMapAnimate(),this.fireEvent("touchstart",t),this.rB=(new Date).getTime(),t.Hdt=this.rB,this.ft.enable(),this.ft.P(t),this.fi.P(t,this.ft),this.ni.P(t),clearTimeout(this.aB),1===t.touches.length&&(this.aB=setTimeout(function(){i.fireEvent("rightclick",t)},800))},n.prototype.gt=function(t){this.$&&(t=w.mousePos(this._container,t,this._map),1<Math.abs(t[0]-this.$[0])||1<Math.abs(t[1]-this.$[1]))&&"touchstart"===this.oB&&(this.oB="touchmove")},n.prototype.N=function(t){var i=this,n=(new Date).getTime();this.fireEvent("touchend",t),clearTimeout(this.aB),"touchstart"===this.oB&&n-this.rB<800&&(this.oB="false",this.fireEvent("click",t),setTimeout(function(){i.dH=0},300),this.dH++,2<=this.dH)&&(this.fireEvent("dblclick",t),this.dH=0),this.fi.vt(t)},n.prototype.Qt=function(t){this._map.cancelMapAnimate(),this.fireEvent("mousewheel",t),this._map.getStatus().scrollWheel&&(t.preventDefault(),this.ft.disable(),this.oi.Ut(t))},n.prototype.EL=function(t){t.ctrlKey,t.preventDefault()},n.prototype.si=function(t){for(var i,s=(n=this._map).DF(),e=n.pi,r=n.di,n=n.vm,h=s.concat([e,r,n]),e=(s=w.mousePos(this._container,t,this._map))[0],r=s[1],s=(n=this._map.getView().containerTolnglat(e,r))[0],n=n[1],o=(t.lnglat=new _.LngLat(s,n),t.pixel=new _.Pixel(e,r),h.length-1);0<=o;o--){var a=h[o];if(a=a&&a.vi(t)){if(!a.getOptions){i=a;break}if(!0!==a.getOptions().noSelect){i=a;break}}}return i},n.prototype.ui=function(t,i){var s=void 0===(s=(n=this.mi).yi)?null:s,e=void 0===(e=n.xi)?null:e,n=n.vectorIndex,r=i.target;"mousemove"!==t&&"mouseleave"!==t||("mousemove"===t?s?r?s.hS!==r.hS||(void 0===n?-1:n)!==i.vectorIndex?(this.ci(s,"mouseout",e),this.ci(r,"mouseover",i)):this.ci(r,"mousemove",i):this.ci(s,"mouseout",e):r&&this.ci(r,"mouseover",i):"mouseleave"===t&&s&&this.ci(s,"mouseout",e),this.mi.yi=r,this.mi.vectorIndex=i.vectorIndex,this.mi.xi=i)},n.prototype.ci=function(t,i,n){"poi"===t.type?this._map.getStatus().isHotspot&&this.bi(t,i,n):t.emit(i,n)},n.prototype.bi=function(t,i,n){var s,e,r,h="hotspot";switch(i){case"click":this._map.setCursor("pointer"),s=h+i;break;case"mouseover":this._map.setCursor("pointer"),s=h+"over";break;case"mouseout":this._map.setCursor(""),s=h+"out"}s&&(e=(r=this._map.getProjection().unproject(t.lnglat[0],t.lnglat[1]))[0],r=r[1],t={type:s,id:t.id,name:t.name,lnglat:new _.LngLat(e,r),originEvent:n.originEvent},this._map.emit(s,t))},n.prototype.ii=function(t){var i,n;this._map.getStatus().keyboardEnable&&(i=this._map.getZoom(),n=this._map.getRotation(),"="===t.key?this._map.setZoom(i+1,!0):"-"===t.key&&this._map.setZoom(i-1,!0),t.ctrlKey?"ArrowLeft"===t.key?this._map.setRotation(n-90,!0):"ArrowRight"===t.key&&this._map.setRotation(n+90,!0):"ArrowUp"===t.key?this._map.panBy(0,300):"ArrowDown"===t.key?this._map.panBy(0,-300):"ArrowLeft"===t.key?this._map.panBy(300,0):"ArrowRight"===t.key&&this._map.panBy(-300,0))};var ot=n;function n(t){this.Ht="false",this.oB="false",this.nB=0,this.dH=0,this.aB=0,this.rB=0,this.mi={yi:null,xi:null},this._map=t,this._container=this._map.getMapsContainer(),this.ft=new Q(this._container,t),this.ft.enable(),this.oi=new st(this._container,t),this.oi.enable(),this.fi=new $(this._container,t),this.fi.enable(),this.ni=new tt(this._container,t),this.ni.enable(),this.ei=new rt(this._container,t),this.ei.enable()}var at,ut=new _.rW({}),ct=(at=_.Event,_.Ei(ft,at),ft.prototype.lo=function(){return this.Oo},ft.prototype.destroy=function(){},ft.prototype.Fo=function(t){!t||t===this.Oo||this.pS||this.Oo||(this.pS=!0,this.Oo=!0,this.emit("complete"))},ft.prototype.VE=function(t,i,n){for(var s=this.lZ(),e=[],r=0;r<t.length;r++){var h=t[r],h=_.ProjectionManager.getProjection("EPSG:3857").unproject(h[0],h[1]);e.push(h)}var o=s.boundsP16;i&&"china"===i?o=[o[0]]:i&&"oversea"===i&&(o=s.nebulaOutSea);for(var a=0;a<o.length;a++){var u=o[a];if(ut.isRingInRingByOutsea(e,u[0]))return!0}return!1},ft.prototype.rG=function(t,i){for(var n=this.lZ(),s=[],e=0;e<t.length;e++){var r=t[e],r=_.ProjectionManager.getProjection("EPSG:3857").unproject(r[0],r[1]);s.push(r)}for(var h=n.boundsP16,o=0;o<h.length;o++){var a=h[o];if(ut.isRingInRingByMapbox(s,a[0]))return!0}return!1},ft.prototype.aU=function(t,i){for(var n=this.lZ(),s=[],e=0;e<t.length;e++){var r=t[e],r=_.ProjectionManager.getProjection("EPSG:3857").unproject(r[0],r[1]);s.push(r)}for(var h=n.boundsP16,o=0;o<h.length;o++){var a=h[o];if(ut.isRingInRingByMapboxB(s,a[0]))return!0}return!1},ft.prototype.sU=function(t){for(var i=this.lZ().boundsP16,n=i.length,s=t.projectionId,e=[],r=0;r<n;r++){var h=i[r],h=_.V[s].Xs(h[0],h[1],16);e.push(h[0]),e.push(h[1])}return e},ft.prototype.UH=function(t){},ft.prototype.Eo=function(){this.map.setNeedUpdate(!0)},ft.prototype.lZ=function(){var t=this.map.getOutseaDataType();return _.vZ(t)},_.dZ([_.pZ("Source")],ft));function ft(t,i,n,s){var e=at.call(this)||this;return e.map=n,e.layer=s,e.Oo=!1,e.pS=!1,e._id=t.id,e.Wt=t.type,e._tileUrl=t.tileUrl,t.url&&(e.$o=t.url),e}Object.defineProperty(dt.prototype,"size",{get:function(){return _.keys(this.VL).length},eb:!1,nb:!0}),dt.prototype.clear=function(){this.VL={}},dt.prototype.set=function(t,i){this.VL[t]=i},dt.prototype.get=function(t){return this.VL[t]},dt.prototype.delete=function(t){delete this.VL[t]},dt.prototype.has=function(t){return void 0!==this.VL[t]};var lt=dt;function dt(){this.VL={}}var h="newer",o="older",s=(e.prototype.Uo=function(t){var i=this.Bo;(this.Bo=t)<i&&this.MN()},e.prototype.keys=function(){return new pt(this.Wo)},e.prototype.values=function(){return new yt(this.Wo)},e.prototype.entries=function(){return this},e.prototype.forEach=function(t,i){"object"!=typeof i&&(i=this);for(var n=this.Wo;n;)t.call(i,n.value,n.key,this),n=n[h]},e.prototype.toJSON=function(){for(var t=new Array(this.size),i=0,n=this.Wo;n;)t[i++]={key:n.key,value:n.value},n=n[h];return t},e.prototype.toString=function(){for(var t="",i=this.Wo;i;)t+=String(i.key)+":"+i.value,(i=i[h])&&(t+=" < ");return t},e.prototype.Go=function(t){t!==this.Zo&&(t[h]&&(t===this.Wo&&(this.Wo=t[h]),t[h][o]=t[o]),t[o]&&(t[o][h]=t[h]),t[h]=void 0,t[o]=this.Zo,this.Zo&&(this.Zo[h]=t),this.Zo=t)},e.prototype.assign=function(t){for(var i,n=this.Bo||Number.MAX_VALUE,s=(this.qo.clear(),t),e=s.next();!e.done;e=s.next()){var r=new vt(e.value[0],e.value[1]);if(this.qo.set(r.key,r),i?(i[h]=r)[o]=i:this.Wo=r,i=r,0==n--)throw new Error("overflow")}this.Zo=i,this.size=this.qo.size},e.prototype.get=function(t,i){if(t=this.qo.get(t))return i&&this.Go(t),t.value},e.prototype.set=function(t,i){var n=this.qo.get(t);return n?(n.value=i,this.Go(n)):(this.qo.set(t,n=new vt(t,i)),this.Zo?(this.Zo[h]=n)[o]=this.Zo:this.Wo=n,this.Zo=n,++this.size,this.size>this.Bo&&this.MN()),this},e.prototype.shift=function(){var t=this.Wo;if(t)return this.Wo[h]?(this.Wo=this.Wo[h],this.Wo[o]=void 0):(this.Wo=void 0,this.Zo=void 0),t[h]=t[o]=void 0,t.value.destroy(),this.qo.delete(t.key),--this.size,[t.key,t.value]},e.prototype.find=function(t){return(t=this.qo.get(t))?t.value:void 0},e.prototype.has=function(t){return this.qo.has(t)},e.prototype.delete=function(t){if(t=this.qo.get(t))return this.qo.delete(t.key),t[h]&&t[o]?(t[o][h]=t[h],t[h][o]=t[o]):t[h]?(t[h][o]=void 0,this.Wo=t[h]):t[o]?(t[o][h]=void 0,this.Zo=t[o]):this.Wo=this.Zo=void 0,this.size--,t.value},e.prototype.clear=function(){this.Wo=this.Zo=void 0,this.size=0,this.qo.clear()},e.prototype.AN=function(t){return"loaded"!==t.value.status||(t=t.value.stamp)&&this.wN&&t===this.wN},e.prototype.QF=function(t){this.wN=t},e.prototype.MN=function(){if(this.Wo&&this.Zo)for(var t=this.Wo,i=this.Zo.key;t&&i&&t.key!==i;){if(this.AN(t))this.Go(t);else if(this.shift(),this.size<=this.Bo)return;t=this.Wo}},e);function e(t,i){this.entries=i,"number"!=typeof(this.Bo=t)&&(i=t,t=0),this.size=0,this.Bo=t,this.Wo=this.Zo=void 0,this.qo=new("undefined"!=typeof Map?Map:lt),i&&(this.assign(i),t<1)&&(this.Bo=this.size)}var vt=function(t,i){this.key=t,this.value=i,this[h]=void 0,this[o]=void 0},pt=(mt.prototype.next=function(){var t=this.Yo;return t?(this.Yo=t[h],{done:!1,value:t.key}):{done:!0,value:void 0}},mt);function mt(t){this.Vo=t}bt.prototype.next=function(){var t=this.Yo;return t?(this.Yo=t[h],{done:!1,value:t.value}):{done:!0,value:void 0}};var yt=bt;function bt(t){this.Vo=t}gt=s,_.Ei(kt,gt),kt.prototype.shift=function(){var t=this.Wo;if(t)return this.Wo[h]?(this.Wo=this.Wo[h],this.Wo[o]=void 0):(this.Wo=void 0,this.Zo=void 0),t[h]=t[o]=void 0,this.qo.delete(t.key),this.emit("delete",{key:t.key}),--this.size,[t.key,t.value]},kt.prototype.on=function(t,i,n,s){void 0===n&&(n=this),void 0===s&&(s=!1);for(var e=0,r=Array.isArray(t)?t:[t];e<r.length;e++){var h=r[e];this._on(h,i,n,s)}return this},kt.prototype.off=function(t,i,n){void 0===n&&(n=this);var s=this.vI;if(t in s)for(var e=0;e<s[t].length;e+=1)if(s[t][e].fn===i&&s[t][e].context===n)return s[t].splice(e,1),this;return this},kt.prototype.hasEvents=function(t,i,n){void 0===n&&(n=this);var s=this.vI;if(t&&i&&t in s)for(var e=0;e<s[t].length;e+=1)if(s[t][e].fn===i&&s[t][e].context===n)return!0;return!1},kt.prototype.clearEvents=function(t){return t?this.vI[t]&&delete this.vI[t]:this.vI={},this},kt.prototype.emit=function(t,i){if(void 0===i&&(i={}),t in this.vI)for(var n=_.Ln(_.Ln({},i),{type:t}),s=this.vI[t],e=0,r=s.length;e<r;e+=1){var h=s[e];h.fn&&(h.fn.call(h.context,n),h.once)&&(this.vI[t].splice(e,1),--e,--r)}return this},kt.prototype._on=function(t,i,n,s){var e;return void 0===s&&(s=!1),this.hasEvents(t,i,n=void 0===n?this:n)||((e=this.vI)[t]=e[t]||[],e[t].push({fn:i,context:n||this,once:s})),this};var gt,Mt=kt;function kt(){var t=null!==gt&&gt.apply(this,arguments)||this;return t.vI={},t}wt=_.Event,_.Ei(At,wt),At.prototype.QF=function(t){this.Ho.QF(t)},At.prototype.Xo=function(t){this.Ho.Uo(t)},At.prototype.Jo=function(t){var i=this.ia(t.zo);this.keys[i]=1,this.Ho.set(i,t)},At.prototype.Qo=function(t){var i=this.ia(t.zo);this.Ho.set(i,t)},At.prototype.getTile=function(t,i){return void 0===i&&(i=!0),this.Ko(t)?this.Ho.get(this.ia(t),i):null},At.prototype.xf=function(t,i){return void 0===i&&(i=!1),this.Ho.has(t)?this.Ho.get(t,i):null},At.prototype.ea=function(t){var i=this.ia(t.zo);return!!this.Ko(t.zo)&&(this.Ho.delete(i),delete this.keys[i],!0)},At.prototype.Ko=function(t){return t=this.ia(t),!!this.Ho.has(t)},At.prototype.destroy=function(){this.Ho.clear()},At.prototype.forEach=function(t){this.Ho.forEach(t)},At.prototype.ia=function(t){var i;return t.key||(i=t.z+","+t.x+","+t.y,t.key=i)};var wt,xt=_.dZ([_.pZ("TileCache")],At);function At(t){void 0===t&&(t=500);var i=wt.call(this)||this;return i.keys={},i.na=t,i.Ho=new Mt(i.na),i}zt=xt,_.Ei(St,zt),St.prototype.MD=function(t,i){void 0===i&&(i=_.zB.ALL);var n="";return t?i!==t&&(n="all"===t?"":i===_.zB.ALL?t?t===_.zB.LITE?_.zB.LEFT:_.zB.LITE:_.zB.ALL:i):n=i,n},St.prototype.ea=function(t){return t.rN(),zt.prototype.ea.call(this,t)};var zt,Ct=St;function St(t){return t=zt.call(this,t=void 0===t?500:t)||this,_.Event.extend("delete",t.Ho,t),t}Tt=xt,_.Ei(It,Tt);var Tt,Lt=It;function It(t){return t=Tt.call(this,t=void 0===t?500:t)||this,_.Event.extend("delete",t.Ho,t),t}Ot.prototype.Uo=function(t){this.Bo=t},Ot.prototype._B=function(t,i,n,s){void 0===s&&(s=this.Bo);for(var e=n||"china",r=0;r<t.length;r+=s){var h=t.slice(r,r+s),o=this.qN++,h={wD:this.target(h,o,i,e),ZN:h,id:o};this.KN.push(h),this.YN[o]=h}},Ot.prototype.qH=function(t){for(var i=[],n=[],s=0,e=this.KN;s<e.length;s++)for(var r=e[s],h=0;h<r.ZN.length;h++){var o=r.ZN[h];if(this.QN(t,o)){Array.prototype.push.apply(i,r.ZN);break}h===r.ZN.length-1&&n.push(r)}for(var a=0,u=n;a<u.length;a++){(r=u[a]).wD&&r.wD.cancel();var c=this.KN.indexOf(r);this.KN.splice(c,1),delete this.YN[r.id],this.JN(r.ZN)}return{yB:i,SB:n}},Ot.prototype.QN=function(t,i){return-1<t.indexOf(i.slice(0,-2))},Ot.prototype.CB=function(t){var i=this.YN[t];delete this.YN[t],i&&(t=this.KN.indexOf(i),this.KN.splice(t,1))};var Dt=Ot;function Ot(t,i,n){void 0===n&&(n=5),this.target=t,this.JN=i,this.Bo=n,this.qN=0,this.KN=[],this.YN={}}var Rt,Et=_.Support.scale,s=(Rt=ct,_.Ei(r,Rt),r.prototype.loadData=function(t,i,n,s){var e=this;if("optimise"===s.loadData()&&s.TL())return!1;this.aa=t,this.sa=[];for(var r=t.bounds,h=this.ra(t.optimalZoom),o=this.ha(r,h),a=[],u=t.optimalZoom,r=_.map(o,function(t){var i=e.fa(t.x,t.z);return t.z+","+i+","+t.y}),c=this.QH.qH(r),f=[],l=0;l<o.length;l++){var d,v,p=o[l],m=new _.ca(p.z,this.fa(p.x,p.z),p.y),y=new _.ca(p.z,p.x,p.y),b=_.Util.kD(m.key,u),g=this.ua.getTile(m,!0);g?(d=this.ua.MD(g.tag,b))&&(g.tag=b,v=p.key+","+_.Util.SD(d),c.yB.indexOf(v)<0)&&f.push(v):(v=m.key+","+_.Util.SD(b),c.yB.indexOf(v)<0&&((m=new _.pa(m)).status=_.TileState.LOADING,m.xB=_.TileState.LOADING,this.ua.Jo(m),m.tag=b,m.gB=b,f.push(v))),!g||g.status!==_.TileState.LOADED&&g.status!==_.TileState.RELOADING||this.sa.push(y),g&&(g.status===_.TileState.LOADED||g.status===_.TileState.RELOADING)||a.push(p),g&&g.status===_.TileState.LOADED&&g.version&&g.version!==this.VH&&(this.sa.push(y),g.status=_.TileState.RELOADING,f.push(p.key+","+_.Util.SD(g.tag)),d=this.ua.MD(g.tag,b))&&(v=p.key+","+_.Util.SD(d),c.yB.indexOf(v)<0)&&f.push(v)}this.da(t,this.sa,a,s);var M,k,w,x,r=this.map.getOutseaState(),A=this.map.getOutseaDataType();return r&&!A?9.8<=h?(M=(w=this.OE(f)).overseaTile,x=w.chinaTile,k=w.mapboxTile,this.PE(M,"oversea"),this.PE(x,"china"),this.PE(k,"mapbox"),this.zD(x,t,h,s,n),this.zD(M,t,h,s,n,void 0,"outsea")):(this.PE(f,"china"),this.zD(f,t,h,s,n,void 0,"a00")):r&&A&&"mapbox"===A?9.8<=u?(x=(w=this.OE(f)).chinaTile,this.PE(x,"china"),this.zD(x,t,h,s,n,void 0)):(this.PE(f,"china"),this.zD(f,t,h,s,n,void 0,"a00")):(this.PE(f,"china"),this.zD(f,t,h,s,n,void 0)),0===f.length},r.prototype.getData=function(i){var n=this,t=i.bounds,s=this.ra(i.optimalZoom),e=this.ha(t,s),r=[],h={},o=(14===s&&(h=this.ha(t,15,!0)),this.map.qF());if(this.ua.QF(o),this.sa.sort(function(t){return n.ra(i.optimalZoom)===t.z?1:-1}),0<this.sa.length)for(var a=0;a<this.sa.length;a++){var u,c=this.sa[a],f=this.ua.getTile(c,!0),l=0,d=0,v=[0,0],p=i.centerCoord;f?(p=_.lcs.getLocalByCoord([p[0],p[1]]),i.optimalZoom>=_.Ra?(u=_.lcs.getSize(),l=f.localCoord.x-p.x,d=f.localCoord.y-p.y,0!=l&&(l*=u[0],v[0]=l),0!=d&&(d*=u[1],v[1]=d),i.optimalZoom>=_.Ra&&_.za>=f.zo.z&&(v[0]=-p.center[0],v[1]=-p.center[1])):i.optimalZoom<_.Ra&&_.za<f.zo.z&&(v[0]=p.center[0],v[1]=p.center[1])):(l=new _.ca(c.z,this.fa(c.x,c.z),c.y),(d=this.ua.getTile(l,!0))&&(f=new _.pa(c),u=1<<c.z,(c.x<0||c.x>=u)&&(p=Math.floor(c.x/u),v[0]+=20037508.342789244*p*2),l=d.tag,f.Ro=d.Ro,f.ID(d),f.Sa=v,f.status=d.status,f.tag=l)),f&&(f.stamp=o,f.Sa=v,r.push(f))}var m=i.optimalZoom,t=_.every(e,function(s){return _.some(r,function(t){var i=t.zo.key,n=t.zo.z,n=_.Util.VF(n,m),t=t.tag,t=_.Util.LD(t,n);return i===s.key&&t})}),y=this.map.getOutseaState(),b=this.map.getOutseaDataType(),e=(y&&!b&&(t=!(b=_.filter(e,function(t){return!(t=n.NE.getTile(t))||!t.boundsStatus||!1!==t.boundsStatus.isInNebulaOversea})).length||_.every(b,function(s){return _.some(r,function(t){var i=t.zo.key,n=t.zo.z,n=_.Util.VF(n,m),t=t.tag,t=_.Util.LD(t,n);return i===s.key&&t})})),this.jE(r)),b=(t&&(this.a_=!0,this.map.bZ.dynamic.set("firstAllLoaded",!0)),e&&this.map.bZ.dynamic.set("firstLabelDataAllLoaded",!0),{s_:this.a_,fo:!!t&&e,yZ:e,tiles:r,Ca:h,outseaData:void 0});return 0!==r.length&&!t||this.Fo(!0),y&&r.length&&(e=this.map.bZ.MZ.wZ.gZ(),b.outseaData=e),b.tiles=this.UE(r,s),b},r.prototype.pe=function(t){return t=new _.ca(t[0],t[1],t[2]),this.ua.getTile(t)},r.prototype.ZE=function(t){return!1},r.prototype.OE=function(t){for(var i=t.length,n=[],s=[],e=[],r=0;r<i;r++){var h=void 0,o=void 0,a=t[r],u=a.split(","),c=new _.ca(u[0],u[1],u[2]),f=this.NE.getTile(c);if(f&&f.boundsStatus)h=f.boundsStatus.isInChina,o=f.boundsStatus.isInNebulaOversea;else{if(!(f=_.wa.ga(parseInt(u[1],10),parseInt(u[2],10),parseInt(u[0],10),"EPSG:3857")))continue;u=[[f[0],f[1]],[f[2],f[1]],[f[2],f[3]],[f[0],f[3]]],h=this.VE(u,"china",a),o=this.VE(u,"oversea",a),(f=new _.pa(c)).boundsStatus={isInChina:h,isInNebulaOversea:o},this.NE.Jo(f)}h&&n.push(a),o&&s.push(a),h||o||e.push(a)}return{chinaTile:n,overseaTile:s,mapboxTile:e}},r.prototype.ra=function(t){return("fast"!==this.map.bZ.MZ.drawMode||this.map.bZ.dynamic.get("firstPaint")?{2:3,3:3,4:3,5:3,6:6,7:6,8:8,9:8,10:10,11:10,12:10,13:12,14:12,15:14,16:14,17:14,18:14,19:14,20:14,21:14,22:14,23:14,24:14,25:14,26:14,27:14,28:14,29:14,30:14}:{2:3,3:3,4:3,5:3,6:6,7:6,8:8,9:8,10:8,11:8,12:8,13:12,14:12,15:14,16:14,17:14,18:14,19:14,20:14,21:14,22:14,23:14,24:14,25:14,26:14,27:14,28:14,29:14,30:14})[t]},r.prototype.YE=function(t){var i=this;return t(null,{GW:"worker",cb:function(t){i.dynamicTextVerticeLoadedByTile(t)}}),!0},r.prototype.destroy=function(){this.ua.forEach(function(t){t.status!==_.TileState.LOADED&&t.request&&(t.request.cancel(),delete t.request),t.destroy()}),this.ua.destroy(),this.sa=[],this.la=[],this.mapStyle&&this.mapStyle.destroy&&(this.mapStyle.destroy(),delete this.mapStyle),this.R_&&this.R_.destroy&&(this.R_.destroy(),delete this.R_)},r.prototype.reload=function(){this.ua.forEach(function(t){t.status!==_.TileState.LOADED&&t.request&&(t.request.cancel(),delete t.request),t.reload()}),this.sa=[],this.la=[]},r.prototype.Aa=function(t){var i;t.zo&&(i=this.ua.getTile(t.zo))&&(i.rO({Ta:!0},t.tag),i.xa({Ta:!0},t.tag),i.JE({Ta:!0},t.tag))},r.prototype.setTileCacheSize=function(t){t=t||(_.Support.$e?50:200),this.ua.Xo(t)},r.prototype.UH=function(t){this.VH=t},r.prototype.dynamicTextVerticeLoaded=function(t){console.log("errorr")},r.prototype.dynamicTextVerticeLoadedByTile=function(t){for(var i=0,n=t.data;i<n.length;i++){var s=n[i];this.dynamicTextVerticeLoaded({data:s.data,tag:s.tag,XE:s.XE})}},r.prototype.Ia=function(){this.map.on("tileSdfInfoFinished",this.Aa.bind(this))},r.prototype.zD=function(t,i,n,s,e,r,h){void 0===r&&(r="road,building,region");var a={},o=((o=this.cP())&&(a=o.getState().vS),a=_.Ln(_.Ln({},a),{buildingColor:_.Ln({},s.getBuildingColor())}),{zoom:i.zoom,optimalZoom:i.optimalZoom,projectionId:i.projectionId,mS:a,viewMode:i.viewMode,showBuildingBlock:this.map.yS(),ZL:i.zoom,hH:r});this.QH._B(t,o,h)},r.prototype.cP=function(){for(var t,i=this.map.getLayers(),n=0;n<i.length;n++)if("AMap.Buildings"===(s=i[n]).CLASS_NAME&&!s.getState().u$){t=s;break}if(!t)for(var s,n=0;n<i.length;n++)if("AMap.Buildings"===(s=i[n]).CLASS_NAME){t=s;break}return t},r.prototype.ma=function(t,i){var n,s=new RegExp(/\\{(\\w|\\,)+\\}/g);return s.test(this._tileUrl)?(n=this._tileUrl.match(s)[0].replace(/[\\{|\\}]/g,"").split(","),this._tileUrl.replace(s,n[(t+i)%4])):this._tileUrl},r.prototype.AD=function(){var t=new RegExp(/\\{(\\w|\\,)+\\}/g),i=this._tileUrl.match(t)[0].replace(/[\\{|\\}]/g,"").split(","),n=i.length,t=this._tileUrl.replace(t,i[this.$D%n]);return this.$D=(this.$D+1)%n,t},r.prototype.ha=function(t,i,n){void 0===n&&(n=!1);var s=[t[0],t[3]],t=[t[2],t[1]],s=this.Ga(s,i),t=this.Ga(t,i),e=s[0],r=s[1],h=t[0],o=t[1];if(n)return{ja:e,Fa:r,Oa:h,Ea:o,z:i};this.Pa={ja:e,Fa:r,Oa:h,Ea:o,z:i};for(var a=[],u=e;u<=h;u+=1)for(var c=r;c<=o;c+=1)a.push(new _.ca(i,u,c));return this.Da(a),a},r.prototype.da=function(t,i,n,s){var e=[3,6,8,10,12,14],r=this.ra(t.optimalZoom);if(this.Za)for(var h=Math.min(14,r+3),o=r+1;n.length&&o<=h;o+=1)if(-1!==e.indexOf(o)){for(var a=o-r,u=[],c=[],f=n.length-1;0<=f;--f)for(var l=n[f].x<<a,d=n[f].y<<a,v=1<<a;0<=v;--v)for(var p=1<<a;0<=p;--p){var m=new _.ca(o,this.fa(l+v,o),d+p),y=new _.ca(o,l+v,d+p);((M=this.ua.getTile(m,!0))&&M.status===_.TileState.LOADED?c:u).push(y)}c.length&&i.push.apply(i,c),n=u}if(this.qa)for(var b=this.xt[0],o=r-1;n.length&&b<=o;--o)if(-1!==e.indexOf(o)){for(var c=[],u=[],g={},f=n.length-1;0<=f;--f){var M,k=n[f],a=o,w=k.z-a,v=k.x>>w,p=k.y>>w;g[k=(m=new _.ca(a,v,p)).key]||(w=new _.ca(a,this.fa(v,a),p),y=new _.ca(a,v,p),M=this.ua.getTile(w,!0),g[k]=!0,(M&&M.status===_.TileState.LOADED?c:u).push(y))}c.length&&i.push.apply(i,c),n=u}return i},r.prototype.Da=function(t){var e,r,h;t.length&&(e=this.Pa.z,r=(this.Pa.ja+this.Pa.Oa)/2,h=(this.Pa.Fa+this.Pa.Ea)/2,t.sort(function(t,i){var n=(t.x<<e-t.z)-r,t=(t.y<<e-t.z)-h,s=(i.x<<e-i.z)-r;return n*n+t*t<=s*s+(i=(i.y<<e-i.z)-h)*i?-1:1}))},r.prototype.Ga=function(t,i){var n=180/(i=Math.pow(2,i));return[Math.floor(t[0]/(360/i))+i/2,i/2-Math.ceil(t[1]/n)]},r.prototype.fa=function(t,i){for(var n=1<<(i=i||this.aa.optimalZoom);t<0||n<=t;)t=n<=t?t-n:t<0?n+t:t;return t},r.prototype.sD=function(){var e,r,h=this;this.map.bZ.dynamic.get("_preloadNebulaIcons")||(this.map.bZ.dynamic.set("_preloadNebulaIcons",!0),e=this.hD,(r=this.z_).loadImages(e,{type:"icon",imageBitmap:_.Support.imageBitmap,cb:function(){for(var t=[],i=0;i<e.length;i++){var n=e[i],s=r.getImage(n);t.push({img:s.img,name:n,hv:i,width:s.width,height:s.height})}h.map.so.sv(t)}},this.Bdt))},r.prototype.PE=function(t,i){for(var n=0,s=t;n<s.length;n++){var e=s[n].split(",").slice(0,3).join(",");(e=this.ua.xf(e))&&(e.region=i)}},r.prototype.UE=function(t,i){void 0===t&&(t=[]);var n=[];if(10<=i){for(var s=0,e=t;s<e.length;s++){var r=e[s];"china"!==r.region&&"oversea"!==r.region||n.push(r)}return n}return t},r.prototype.jE=function(t){for(var i=!!t.length,n=0,s=t;n<s.length;n++){var e=s[n].data;if(i)for(var r=0,h=e;r<h.length;r++){var o=h[r];if(!(i=i&&!!o.Ta))break}}return i},r);function r(t,i,n,s){var a=Rt.call(this,t,i,n,s)||this,i=(a.xt=_.zoomRange,a.sa=[],a.la=[],a.qa=!0,a.Za=!0,a.a_=!1,a.$D=0,a.hD=[AMap.getConfig().protocol+"://vdata.amap.com/style_icon/2.0/icon-normal-big.png",AMap.getConfig().protocol+"://vdata.amap.com/style_icon/2.0/icon-biz-big.png"],a.VH="",a.Bdt="",a.wH=function(t){!a.map.yH||parseInt(t.key.split(",")[0],10)<10||a.map.yH.kH(t.key)},a.Xa=t.tileSize,a._tileUrl=t.tileUrl,a.tG=null,_.Support.$e?30:200);return a.ua=new Ct(i),a.NE=new Lt(i),n.Wdt&&(a.hD=n.Wdt),window.xZ=a.ua,n.gn.Ha({scale:Et,showLabel:n.showLabel,DD:-1!==location.search.indexOf("forceAll")}),a.R_=n.R_,a.z_=n.z_,n.gn.Ja(AMap.getConfig().protocol),a.Bdt=AMap.getConfig().key,a.mapStyle=n.mapStyle,a.mapStyle.pn(function(t){n&&n.gn&&n.gn.Ka({value:t,TY:"fast"===a.map.bZ.MZ.drawMode})}),a.Ia(),a.sD(),a.ua.on("delete",a.wH),a.QH=new Dt(function(t,h,i,o){var n=a.AD(),s=a.map.bZ.dynamic.get("firstLabelDataAllLoaded")||!1;return!o||"outsea"!==o&&"a00"!==o||(n=n.replace("/nebula/","/oversea/")),!s&&_.Support.wasm&&(n=n.replace("/v3","/v2")),new _.vH(a.map.gn.va({url:n,zoom:i.zoom,optimalZoom:i.optimalZoom,projectionId:i.projectionId,mS:i.mS,viewMode:i.viewMode,showBuildingBlock:i.showBuildingBlock,ya:t,ZL:i.zoom,hH:i.hH,kZ:s},function(t){a.QH.CB(h);for(var i=0,n=t;i<n.length;i++){var s,e=n[i],r=e&&a.ua.getTile(e.zo);r&&(delete r.request,o&&"outsea"===o?r.JE(e.ba,e.tag):r.xa(e.ba,e.tag),a.map.Mv.t0(r.zo),r.status=_.TileState.LOADED,e=_.wa.ga(r.zo.x,r.zo.y,r.zo.z,"EPSG:3857"),s=_.lcs.getLocalByCoord([e[0],e[1]]),r.localCoord=s,r.Ro=e,a.map.mm)&&r.LY(a.map.mm.context)}a.map.setNeedUpdate(!0)}))},function(t){for(var i=0,n=t;i<n.length;i++){var s=n[i];(s=a.ua.xf(s.slice(0,-2)))&&s.status!==_.TileState.LOADED&&a.ua.ea(s)}},"fast"===n.bZ.MZ.drawMode?1:5),"fast"===n.bZ.MZ.drawMode&&a.map.bZ.dynamic.subscribe("firstPaint",function(){a.QH.Uo(5)},a,!0),a}function a(){}a.prototype.Qa=function(t){for(var i=this.createEmpty(),n=0,s=t.length;n<s;n+=1)this.extendCoordinate(i,t[n]);return i},a.prototype.ns=function(t,i,n){var s=Math.min.apply(null,t),t=Math.max.apply(null,t),e=Math.min.apply(null,i),i=Math.max.apply(null,i);return this.os(s,t,e,i,n)},a.prototype.buffer=function(t,i){t[0]-=i,t[1]-=i,t[2]+=i,t[3]+=i},a.prototype.clone=function(t){return t.slice()},a.prototype.ss=function(t,i){return t[0]<=i[0]&&i[0]<=t[2]&&t[1]<=i[1]&&i[1]<=t[3]},a.prototype.rs=function(t,i){return t[0]<=i[0]&&i[2]<=t[2]&&t[1]<=i[1]&&i[3]<=t[3]},a.prototype.createEmpty=function(){return[1/0,1/0,-1/0,-1/0]},a.prototype.os=function(t,i,n,s,e){return void 0!==e?(e[0]=t,e[2]=i,e[1]=n,e[3]=s,e):[t,n,i,s]},a.prototype.empty=function(t){return t[0]=t[1]=1/0,t[2]=t[3]=-1/0,t},a.prototype.equals=function(t,i){return t[0]===i[0]&&t[2]===i[2]&&t[1]===i[1]&&t[3]===i[3]},a.prototype.extend=function(t,i){i[0]<t[0]&&(t[0]=i[0]),i[2]>t[2]&&(t[2]=i[2]),i[1]<t[1]&&(t[1]=i[1]),i[3]>t[3]&&(t[3]=i[3])},a.prototype.extendCoordinate=function(t,i){+i[0]<t[0]&&(t[0]=i[0]),+i[0]>t[2]&&(t[2]=i[0]),+i[1]<t[1]&&(t[1]=i[1]),+i[1]>t[3]&&(t[3]=i[1])},a.prototype.hs=function(t){return[t[0],t[1]]},a.prototype.ls=function(t){return[t[2],t[1]]},a.prototype.getCenter=function(t){return[(t[0]+t[2])/2,(t[1]+t[3])/2]},a.prototype.us=function(t,i,n,s,e){for(var r,h,o=i*s[0]/2,i=i*s[1]/2,a=Math.cos(n),u=Math.sin(n),c=[-o,-o,o,o],f=[-i,i,-i,i],l=0;l<4;l+=1)r=c[l],h=f[l],c[l]=t[0]+r*a-h*u,f[l]=t[1]+r*u+h*a;return this.ns(c,f,e)},a.prototype.getHeight=function(t){return t[3]-t[1]},a.prototype.getSize=function(t){return[t[2]-t[0],t[3]-t[1]]},a.prototype.cs=function(t){return[t[0],t[3]]},a.prototype.fs=function(t){return[t[2],t[3]]},a.prototype.getWidth=function(t){return t[2]-t[0]},a.prototype.intersects=function(t,i){return t[0]<=i[2]&&t[2]>=i[0]&&t[1]<=i[3]&&t[3]>=i[1]},a.prototype.isEmpty=function(t){return t[2]<t[0]||t[3]<t[1]},a.prototype.normalize=function(t,i){return[(i[0]-t[0])/(t[2]-t[0]),(i[1]-t[1])/(t[3]-t[1])]},a.prototype.ps=function(t,i){var n=(t[2]-t[0])/2*(i-1),i=(t[3]-t[1])/2*(i-1);t[0]-=n,t[2]+=n,t[1]-=i,t[3]+=i},a.prototype.touches=function(t,i){return this.intersects(t,i)&&(t[0]===i[2]||t[2]===i[0]||t[1]===i[3]||t[3]===i[1])},a.prototype.transform=function(t,i,n){return i(t=[t[0],t[1],t[0],t[3],t[2],t[1],t[2],t[3]],t,2),this.ns([t[0],t[2],t[4],t[6]],[t[1],t[3],t[5],t[7]],n)};var Pt=new a,l=(u.from=function(t){for(var i=1/0,n=1/0,s=-1/0,e=-1/0,r=0,h=t;r<h.length;r++)var o=h[r],i=Math.min(i,o.southWest.KL),n=Math.min(n,o.southWest.kT),s=Math.max(s,o.northEast.KL),e=Math.max(e,o.northEast.kT);return new u(new _.LngLat(i,n),new _.LngLat(s,e))},u.xS=function(t){if(t)return t=_.jsonLngLatData(t),new u(Pt.Qa(t))},u.bS=function(t){if(t&&t.length){for(var i,n=0,s=_.jsonLngLatData(t);n<s.length;n++){var e,r=s[n];i?(e=u.ds(r))&&i.union(e):i=u.xS(r)}return i}},u.ds=function(t){if(t)return t=_.jsonLngLatData(t),_.ys(t)?u.xS(t):u.xS(t[0])},u.ms=function(t){if(t&&t.length){for(var i,n=0,s=_.jsonLngLatData(t);n<s.length;n++){var e,r=s[n];i?(e=u.ds(r))&&i.union(e):i=u.ds(r)}return i}},u.prototype.getSouthWest=function(){return this.southWest},u.prototype.getNorthEast=function(){return this.northEast},u.prototype.getNorthWest=function(){return new _.LngLat(this.southWest.KL,this.northEast.kT,!0)},u.prototype.getSouthEast=function(){return new _.LngLat(this.northEast.KL,this.southWest.kT,!0)},u.prototype.contains=function(t){var i,n,s=this.southWest,e=this.northEast;return!_.xs(t)&&(t=_.parseLngLatData(t),i=s.KL,(n=e.KL)<i&&(n+=360),t.KL>=i)&&t.kT>=s.kT&&t.KL<=n&&t.kT<=e.kT},u.prototype.intersects=function(t){var i=this.southWest,n=this.northEast,s=t.southWest,e=(t=t.northEast).kT>=i.kT&&s.kT<=n.kT,t=t.KL>=i.KL&&s.KL<=n.KL;return e&&t},u.prototype.getCenter=function(){var t=this.southWest.KL>this.northEast.KL?(this.southWest.KL+this.northEast.KL+360)/2%360:(this.southWest.KL+this.northEast.KL)/2,i=(this.southWest.kT+this.northEast.kT)/2;return new _.LngLat(t,i)},u.prototype.extend=function(t){return this.southWest.setLng(Math.min(this.southWest.KL,t.KL)),this.southWest.setLat(Math.min(this.southWest.kT,t.kT)),this.northEast.setLng(Math.max(this.northEast.KL,t.KL)),this.northEast.setLat(Math.max(this.northEast.kT,t.kT)),this},u.prototype.union=function(t){return this.extend(t.southWest).extend(t.northEast)},u.prototype.toString=function(){return this.southWest.toString()+";"+this.northEast.toString()},u.prototype.toJSON=function(){return[this.southWest.lng,this.southWest.lat,this.northEast.lng,this.northEast.lat]},u.prototype.getWidth=function(){return Math.abs(this.northEast.lng-this.southWest.lng)},u.prototype.getHeight=function(){return Math.abs(this.southWest.lat-this.northEast.lat)},u.prototype.clone=function(){return u.from([this])},u.prototype.check=function(){return!!(this.northEast&&this.southWest&&this.northEast.lat&&this.southWest.lat)},u);function u(){this.className="AMap.Bounds";var i,n,s,e,r,h="undefined"!=typeof Float64Array;if(1===arguments.length&&(arguments[0]instanceof Array||h&&arguments[0]instanceof Float64Array))e=new _.LngLat(arguments[0][0],arguments[0][1],!0),r=new _.LngLat(arguments[0][2],arguments[0][3],!0);else if(2===arguments.length)e=_.parseLngLatData(arguments[0]),r=_.parseLngLatData(arguments[1]);else if(4===arguments.length)e=new _.LngLat(arguments[0],arguments[1]),r=new _.LngLat(arguments[2],arguments[3]);else{if(0!==arguments.length)throw Error("Invalid Object: Bounds("+arguments+")");e=new _.LngLat(-180,-90),r=new _.LngLat(180,90)}(e.KL>r.KL||e.kT>r.kT)&&(h=Math.max(e.KL,r.KL),i=Math.min(e.KL,r.KL),n=Math.max(e.kT,r.kT),s=Math.min(e.kT,r.kT),e=new _.LngLat(i,s),r=new _.LngLat(h,n)),this.southWest=e,this.northEast=r}jt=ct,_.Ei(Wt,jt),Wt.prototype.loadData=function(t,i,n){return this.ze=i,!(this.Oo&&!this.io||!this.map.isDOMMode()&&!i||(t=this.c0(t,i,n),this.io?t(this.io,"canvas"):((i=new Image).crossOrigin="",i.onload=t,i.src=this.gs.getImageUrl(),this.Rs=i),0))},Wt.prototype.reLoadImgage=function(t){var s=this;t&&this.Rs&&((t=new Image).crossOrigin="",t.onload=function(t,i){var n;"image"===(i=void 0===i?"image":i)?n=t.target:"canvas"===i&&(n=t),s._s&&s._s.update(n),s.Fo(!0)},t.src=this.gs.getImageUrl(),this.Rs=t)},Wt.prototype.c0=function(t,s,e){var r=this;return function(t,i){var n;void 0===i&&(i="image"),s&&(n=void 0,"image"===i?n=t.target:"canvas"===i&&(n=t),r._s?r._s.update(n):(r._s=s.createTexture(n,{Zi:!0}),r._s.bind(s.gl.CLAMP_TO_EDGE,s.gl.LINEAR,s.gl.LINEAR)),r.Fo(!0)),e()}},Wt.prototype.getData=function(t){if(this.Oo&&this._s){(i=this.gs.getBounds())instanceof l&&(i=i.toJSON());var n=_.lcs.getLocalByCoord([t.centerCoord[0],t.centerCoord[1]]),e=(s=_.ProjectionManager.getProjection(t.projectionId)).project(i[0],i[1]),s=s.project(i[2],i[3]),r=[0,0,0,0];if(t.optimalZoom>=_.Ra){for(var i=_.lcs.getLocalByCoord([e[0],e[1]]),t=_.lcs.getLocalByCoord([s[0],s[1]]),h=_.lcs.getSize(),r=[i.x-n.x,i.y-n.y,t.x-n.x,t.y-n.y],o=0;o<r.length;o++)0!==r[o]&&(r[o]*=h[0]);r=[r[0]-i.center[0],r[1]-i.center[1],r[2]-t.center[0],r[3]-t.center[1]]}return this.ze&&(this.ks=this.ze.fe(new Float32Array([e[0]+r[0],e[1]+r[1],0,1,s[0]+r[2],e[1]+r[1],1,1,e[0]+r[0],s[1]+r[3],0,0,s[0]+r[2],e[1]+r[1],1,1,s[0]+r[2],s[1]+r[3],1,0,e[0]+r[0],s[1]+r[3],0,0]),16)),{Ro:this.ws,image:this.Rs,texture:this._s,zs:this.ks,Sa:[0,0]}}},Wt.prototype.destroy=function(){this.Rs&&delete this.Rs,this._s&&this._s.destroy&&(this._s.destroy(),delete this._s),this.ks&&delete this.ks,this.gs};var jt,Bt=Wt;function Wt(t,i,n,s){return(t=jt.call(this,t,i,n,s)||this).gs=s,t.io=s.canvas,t}Ft=ct,_.Ei(Nt,Ft),Nt.prototype.add=function(t,i,n){void 0===t&&(t={}),void 0===i&&(i={}),Object.keys(t).length&&(this.Ls=t,this.HB=!0,this.OB=i,n)&&n()},Nt.prototype.remove=function(t,i,n){void 0===i&&(i={}),this.Ls=t=void 0===t?{}:t,this.HB=!0,this.OB=i,n&&n()},Nt.prototype.update=function(t,i){void 0===t&&(t={}),this.HB=!0,this.OB=t,i&&i()},Nt.prototype.clear=function(){this.Ls={},this.Ts=[],this.gS=null},Nt.prototype.getData=function(){return{other:this.gS}},Nt.prototype.Ds=function(t){return this.Ls[t]||null},Nt.prototype.zL=function(t){return this.CL&&this.CL.zL(t)},Nt.prototype.destroy=function(){this.R_&&this.R_.destroy&&(this.R_.destroy(),delete this.R_),this.z_&&this.z_.destory&&(this.z_.destory(),delete this.z_)},Nt.prototype.loadData=function(t,i,n){var s=this;return 0===Object.keys(this.Ls).length&&this.Fo(!0),this.HB&&(this.HB=!1,this.As(this.OB,function(){s.Fo(!0),s._map.bZ.dynamic.set("firstLabelLayerDataAllLoaded",!0),n()})),!0},Nt.prototype.As=function(i,n){var t,s,e,r=this,h=(void 0===i&&(i={}),this.R_),o=this.z_,a=this.Ls;for(t in this.Ts=[],a)a.hasOwnProperty(t)&&(s=a[t],s=this.Ps(s),this.Ts.push(s));this.Ts.length?(e=this.Ts[0].data.position,this.Os(e),o.loadImages(Object.keys(this.Fs),{cb:function(){var t;h&&"SDFManagerBase"!==h.CLASS_NAME?(t=Object.keys(r.Es),h.getData(t,function(t){r.qL(i,n)})):r.qL(i,n)}})):(this.clear(),n())},Nt.prototype.qL=function(t,i){void 0===t&&(t={});var n=this.R_,s=this.z_,n=this.CL=new _.eG({R_:n,z_:s}),s=this.Us,e={from:"labelsLayer",zoom:this._map.getView().getOptions().zoom,center:s.center},t=(_.assign(e,t),n.Ns(this.Ts,e));this._map&&this._map.isDOMMode()?this.gS=t:this.gS=new _.La(null,t),this.gS.zo=s,i&&i(t)},Nt.prototype.Ps=function(t){var i,n,s,e,r,h,o,a,u,c,f,l,d,v,p,m,y,b;if(!t||"AMap.LabelMarker"===t.type)return i=this._map.getProjection(),this.AL={},c=t.getOptions(),(n=t._position)?(s=[_.tc.Mp,_.tc.Rp],e=void 0===(e=c.zooms)?s:e,r=c.opacity,h=c.rank,v=c.icon,o=c.text,a=c.zIndex,u=c.rotation,c=void 0===(c=c.visible)||c,f=_.Bs(n)?n.toJSON():n,l=o&&o.content||"",d=o&&o.style,v&&v.image&&(this.Fs[v.image]=1),o&&o.content&&this.Ws(o.content),v=v&&v.image?[{type:"image",image:v.image||"",size:v.size,clipOrigin:v.clipOrigin,clipSize:v.clipSize,offset:v.offset,anchor:v.anchor,retina:v.retina}]:{},b=m=0,d&&(m=!d.strokeWidth&&d.strokeColor?1:d.strokeWidth||0,p=!d.strokeColor&&d.strokeWidth?"#fcfcfc":d.strokeColor,b=!d.borderWidth&&d.borderColor?1:d.borderWidth||0,y=!d.borderColor&&d.strokeWidth?"#ccc":d.borderColor),p=d?{fontFamily:d.fontFamily,fontSize:d.fontSize,fontWeight:d.fontWeight,fillColor:d.fillColor,strokeColor:p,strokeWidth:m,borderColor:y,borderWidth:b,padding:this.Gs(d.padding||[3]),backgroundColor:d.backgroundColor,fold:d.fold}:{},m=_.labelsUtil.Jj(e,o&&o.zooms||s),y=o&&l?{txt:o.content||"",direction:o.direction,offset:o.offset,zooms:m,style:p}:{},b=i.project(f[0],f[1]),{data:{id:t.hS,name:l,txt:l,position:[b[0],b[1],n[2]||0],positionType:"lnglat",extData:{id:t.hS},rank:h,rotation:u,zooms:e},opts:{visible:c,opacity:r,zooms:e,zIndex:a,icon:v,text:y,rotation:u,height:n[2]||0}}):null},Nt.prototype.Ws=function(t){void 0===t&&(t="");for(var i=0;i<t.length;i++)this.Es[t.substr(i,1)]=1},Nt.prototype.Os=function(t){_.Bs(t)?this.Us=_.lcs.getLocalByCoord([t.KL,t.kT]):this.Us=_.lcs.getLocalByCoord(t)},Nt.prototype.Gs=function(t){if("string"==typeof t&&(t=(t=t.trim()).split(" ")),"[object Array]"!==Object.prototype.toString.apply(t))return[3,3,3,3];for(var i=t.length,n=0;n<i;n++){var s="string"==typeof(s=t[n])?parseInt(s,10):s;isNaN(s)?t[n]=3:t[n]=s}switch(i){case 0:t=[3,3,3,3];break;case 1:t=[t[0],t[0],t[0],t[0]];break;case 2:t=[t[0],t[1],t[0],t[1]];break;case 3:t=[t[0],t[1],t[2],t[1]]}return t};var Ft,Gt=Nt;function Nt(t,i,n,s){return(t=Ft.call(this,t,i,n,s)||this).Fs={},t.Es={},t.Ts=[],t.HB=!1,t.Ls={},t.AL={},i=n.R_,s=n.z_,t.R_=i,t.z_=s,t._map=n,t}_t=ct,_.Ei(Yt,_t),Yt.prototype.setTileUrl=function(t){this._tileUrl=t=void 0===t?"":t},Yt.prototype.loadData=function(t,i,n,s){var h=this;if(!i&&"d"!==s.baseRender)return!1;this.aa=t,this.ze=i,this.Zs=[],this.sa=[];var e=t.projectionId,r=[],o=t.boundsCoord,a=t.optimalZoom,u=t.optimalResolution,c=this.ha(o,a,u),o=(this.ua.forEach(function(t){var i=t.zo,n=!1;if(t.status!==_.TileState.LOADED){for(var s=c.ja;s<=c.Oa;s+=1)for(var e=c.Fa;e<=c.Ea;e+=1){var r=h.fa(s,c.z);i.z===c.z&&i.y===e&&r===i.x&&(n=!0)}n||(t.data.src="",h.ua.ea(t))}}),this.qs(t,this.Zs,r));return this.Ys(o,i,e,n),this.da(t,this.sa,r,s),this.sa=this.sa.concat(this.Zs),0===o.length},Yt.prototype.getData=function(){var t=this.aa,i=[],n=this.map.qF();if(this.ua.QF(n),0<this.sa.length)for(var s=0;s<this.sa.length;s++){for(var e=this.sa[s],r=[],h=0;h<e.length;h++){var o,u,f,l,d,a,c,m=[0,0],y=t.centerCoord,b=this.ua.getTile(e[h]),y=_.lcs.getLocalByCoord([y[0],y[1]]);b||(o=this.ua.getTile(new _.ca(e[h].z,this.fa(e[h].x,e[h].z),e[h].y)),b=new _.Vs(e[h]),o&&o.data.texture&&(l=this.aa.projectionId,f=_.ProjectionManager.getProjection(l).getResolution(b.zo.z),u=(a=b.zo.x*this.Xa*f)+this.Xa*f,f=(c=b.zo.y*this.Xa*f)+this.Xa*f,d=_.V[l].Xs(a,c),l=_.V[l].Xs(u,f),a=d[0],u=l[0],c=l[1],f=d[1],b.Ro=[a,c,u,f],l=_.lcs.getLocalByCoord([b.Ro[0],b.Ro[1]]),this.aa.optimalZoom>=_.Ra&&(b.Ro[0]-=l.center[0],b.Ro[1]-=l.center[1],b.Ro[2]-=l.center[0],b.Ro[3]-=l.center[1]),this.ze?b.data={Hs:l,texture:o.data.texture,Js:o.data.Js,zs:this.ze.fe(new Float32Array([b.Ro[0],b.Ro[1],0,1,b.Ro[2],b.Ro[1],1,1,b.Ro[0],b.Ro[3],0,0,b.Ro[2],b.Ro[1],1,1,b.Ro[2],b.Ro[3],1,0,b.Ro[0],b.Ro[3],0,0]),16)}:(b.data=o.data,b.data.Hs=l),b.data)&&(b.status=_.TileState.LOADED)),b.data&&(t.optimalZoom>=_.Ra&&b.data.Hs?(d=_.lcs.getSize(),a=b.data.Hs.x-y.x,c=b.data.Hs.y-y.y,0!=a&&(a*=d[0],m[0]=a),0!=c&&(c*=d[1],m[1]=c),t.optimalZoom>=_.Ra&&_.za>=b.zo.z&&(m[0]=-y.center[0],m[1]=-y.center[1])):t.optimalZoom<_.Ra&&_.za<b.zo.z&&(m[0]=y.center[0],m[1]=y.center[1]),b.data.Sa=m,b.stamp=n,r.push(b))}i.push(r)}return{tiles:i}},Yt.prototype.setTileCacheSize=function(t){t=t||(_.Support.$e?50:200),this.ua.Xo(t)},Yt.prototype.reload=function(){this.ua.forEach(function(t){t.status!==_.TileState.LOADED&&t.request&&t.request.cancel&&(t.request.cancel(),delete t.request)}),this.ua.destroy(),this.sa=[],this.pS=!1,this.Fo(!1)},Yt.prototype.getTileCache=function(){return this.ua},Yt.prototype.Da=function(t,i){var e,r,h;t.length&&(e=this.Pa.z,r=(this.Pa.ja+this.Pa.Oa)/2,h=(this.Pa.Fa+this.Pa.Ea)/2,t.sort(function(t,i){var n=(t.x<<e-t.z)-r,t=(t.y<<e-t.z)-h,s=(i.x<<e-i.z)-r;return n*n+t*t<=s*s+(i=(i.y<<e-i.z)-h)*i?-1:1}))},Yt.prototype.ha=function(t,i,n){var s=this.aa.projectionId,s=_.ProjectionManager.getProjection(s),s=(this.TB()&&(n=s.getResolution(++i)),i<this.Qs[0]?(i=this.Qs[0],n=s.getResolution(i)):i>this.Qs[1]&&(i=this.Qs[1],n=s.getResolution(i)),this.Xa),e=20037508.342789244,r=t[0]+e,h=-(t[3]-e),o=t[2]+e,r=r/n,h=h/n,t=-(t[1]-e)/n;return{Oa:Math.floor(o/n/s),Ea:Math.min((1<<i)-1,Math.floor(t/s)),ja:Math.floor(r/s),Fa:Math.max(Math.floor(h/s),0),z:i}},Yt.prototype.qs=function(t,i,n){for(var s=t.optimalZoom,e=t.optimalResolution,r=t.boundsCoord,h=_.ProjectionManager.getProjection(t.projectionId),r=this.ha(r,s,e),o=(this.TB()&&s++,s<this.Qs[0]?s=this.Qs[0]:s>this.Qs[1]&&(s=this.Qs[1]),h.getResolution(s),[]),a=[],u=!0,c=r,f=c.ja;f<=c.Oa;f+=1)for(var l=c.Fa;l<=c.Ea;l+=1){var d=new _.ca(s,this.fa(f,s),l),v=this.ua.getTile(d),p=(this.PF(d,t.projectionId),new _.ca(s,f,l));(v?v.status===_.TileState.LOADED||v.status===_.TileState.ERROR?a:(u=!1,n):(u=!1,o.push(d),n)).push(p)}return a.length&&i.push(a),this.Pa=r,this.Fo(u),o},Yt.prototype.da=function(t,i,n,s){if(t=t.optimalZoom,this.Za="overlay"!==this.layer.type,this.qa="overlay"!==this.layer.type,this.Za)for(var e=Math.min(this.xt[1],t+2),r=t+1;n.length&&r<=e;r+=1){for(var h=[],o=[],a=r,u=n.length-1;0<=u;--u)for(var c=n[u],f=c.x<<1,l=c.y<<1,d=1;0<=d;--d)for(var v=1;0<=v;--v){var p=new _.ca(a,this.fa(f+d,a),l+v),m=this.ua.getTile(p),y=new _.ca(a,f+d,l+v);(m&&m.status===_.TileState.LOADED?o:h).push(y)}o.length&&i.push(o),n=h}if(this.qa)for(var b=this.xt[0],r=t-1;n.length&&b<=r;--r){for(var o=[],h=[],g={},u=n.length-1;0<=u;--u){var M=n[u],a=r,k=M.z-a,d=M.x>>k,v=M.y>>k;g[M=(p=new _.ca(a,this.fa(d,a),v)).key]||(m=this.ua.getTile(p),g[M]=!0,(m&&m.status===_.TileState.LOADED?o:h).push(new _.ca(a,d,v)))}o.length&&i.push(o),n=h}return i},Yt.prototype.ma=function(){var t,i=new RegExp(/\\{(\\w|\\,)+\\}/g);return i.test(this._tileUrl)?(t=this._tileUrl.match(i)[0].replace(/[\\{|\\}]/g,"").split(","),this.tr++,t&&this.tr>=t.length&&(this.tr=0),this._tileUrl.replace(i,t[this.tr])):this._tileUrl},Yt.prototype.Ys=function(l,d,v,p){var m;if(!(this.aa.optimalZoom<this.xt[0]||this.aa.optimalZoom>this.xt[1])){this.Da(l);for(var y=this,i=0,n=l.length;i<n;i+=1)!function(t){var n=y.layer.getLayerConfig(),t=l[t],s=y.ma().replace("[z]",t.z+"").replace("[x]",t.x+"").replace("[y]",t.y+""),h=new _.Vs(t),e=(y.ua.Qo(h),n.getTileUrl&&(s=n.getTileUrl(t.x,t.y,t.z)),_.ProjectionManager.getProjection(v).getResolution(t.z)),r=t.x*y.Xa*e,o=r+y.Xa*e,a=t.y*y.Xa*e,e=a+y.Xa*e,u=_.V[v].Xs(r,a),c=_.V[v].Xs(o,e);function f(t){var i,n,s,e,r;d&&((t=d.createTexture(t.target||t,{Zi:!0})).bind(d.gl.CLAMP_TO_EDGE,d.gl.LINEAR,d.gl.LINEAR),i=_.lcs.getLocalByCoord([h.Ro[0],h.Ro[1]]),h.zo.z>_.za&&(h.Ro[0]-=i.center[0],h.Ro[1]-=i.center[1],h.Ro[2]-=i.center[0],h.Ro[3]-=i.center[1]),n=d.fe(new Float32Array([h.Ro[0],h.Ro[1],0,1,h.Ro[2],h.Ro[1],1,1,h.Ro[0],h.Ro[3],0,0,h.Ro[2],h.Ro[1],1,1,h.Ro[2],h.Ro[3],1,0,h.Ro[0],h.Ro[3],0,0]),16),(e=(s=document.createElement("canvas")).getContext("2d"))&&(r=this.Xa,s.height=s.width=r,s.style.height=s.style.width=r+"px",e.beginPath(),e.moveTo(0,0),e.lineTo(r,0),e.lineTo(r,r),e.lineTo(0,r),e.lineTo(0,0),e.lineWidth=1,e.font="20px Verdana",e.fillStyle="#ff0000",e.strokeStyle="#FF0000",e.strokeRect(0,0,r,r),e.fillText("z: "+h.zo.z,10,30),e.fillText("x: "+h.zo.x,10,60),e.fillText("y: "+h.zo.y,10,90),e.stroke()),(r=d.createTexture(s,{Zi:!0})).bind(d.gl.MIRRORED_REPEAT,d.gl.LINEAR,d.gl.LINEAR_MIPMAP_NEAREST),h.data={texture:t,zs:n,Js:r,Hs:i}),h.status=_.TileState.LOADED,p()}r=u[0],o=c[0],a=c[1],e=u[1],h.Ro=[r,a,o,e],h.status=_.TileState.LOADING,"AMap.TileLayer.Flexible"===y.layer.CLASS_NAME||"AMap.TileLayer.WMTS"===y.layer.CLASS_NAME||"AMap.TileLayer.WMS"===y.layer.CLASS_NAME?n.createTile(t.x,t.y,t.z,function(t){d?f.call(this,t):(h.data=t,h.status=_.TileState.LOADED)}.bind(y),function(){h.status=_.TileState.ERROR,p()}):(c=new Image,"w"===(null==(m=y.map)?void 0:m.baseRender)&&(c.crossOrigin="anonymous"),c.onload=f.bind(y),"d"===(null==(m=y.map)?void 0:m.baseRender)&&0<s.indexOf("traffictile")&&(s+="&hash="+Math.random()),c.src=s,(h.data=c).addEventListener("dragstart",function(t){return t.preventDefault(),!1}))}(i)}},Yt.prototype.fa=function(t,i){i=i||this.aa.optimalZoom;for(var n=this.Xa/256,s=(n<1?n=1/n:n--,1<<(i+=n));t<0||s<=t;)t=s<=t?t-s:t<0?s+t:t;return t},Yt.prototype.PF=function(t,i){var n=_.ProjectionManager.getProjection(i).getResolution(t.z),s=(e=t.x*this.Xa*n)+this.Xa*n,n=(t=t.y*this.Xa*n)+this.Xa*n,t=_.V[i].Xs(e,t),i=_.V[i].Xs(s,n),e=t[0],s=i[0],n=(i[1],t[1]);return!(s<(i=this.map.getView().getStatus().boundsCoord)[0]&&n<i[1]||e>i[2]&&s>i[3])},Yt.prototype.TB=function(){var t=!1;return this.layer.getState().detectRetina&&(t=!0),!("d"!==_.Support.baseRender||!_.Support.Ue||!_.Support.$e)||t};var _t,Ut=Yt;function Yt(t,i,n,s){return(i=_t.call(this,t,i,n,s)||this).ua=new xt(_.Support.$e?200:400),i.Xa=256,i.sa=[],i.Zs=[],i.tr=-1,i.qa=!0,i.Za=!0,i.xt=t.zooms,i.Qs=t.dataZooms,i.Xa=t.tileSize,i._tileUrl=t.tileUrl,i}Zt=ct,_.Ei(Jt,Zt),Jt.prototype.loadData=function(t,i,n){return this.ze=i,this.Oo||(this.Fo(!0),n()),!0},Jt.prototype.getData=function(t){if(this.ir=t.bounds,this.Oo){var i=_.lcs.getLocalByCoord([t.centerCoord[0],t.centerCoord[1]]),s=(n=_.ProjectionManager.getProjection(t.projectionId)).project(this.ir[0],this.ir[1]),n=n.project(this.ir[2],this.ir[3]),e=[0,0,0,0];if(t.optimalZoom>=_.Ra){for(var t=_.lcs.getLocalByCoord([s[0],s[1]]),s=_.lcs.getLocalByCoord([n[0],n[1]]),r=_.lcs.getSize(),e=[t.x-i.x,t.y-i.y,s.x-i.x,s.y-i.y],h=0;h<e.length;h++)0!==e[h]&&(e[h]*=r[0]);e=[e[0]-t.center[0],e[1]-t.center[1],e[2]-s.center[0],e[3]-s.center[1]]}return{texture:this._s,zs:this.ks,Sa:[0,0]}}};var Zt,Xt=Jt;function Jt(t,i,n,s){return(t=Zt.call(this,t,i,n,s)||this).ir=n.getView().getStatus().bounds,t.io=s.canvas,t}Ht=ct,_.Ei(qt,Ht),qt.prototype.hasOverlay=function(t){return-1<this._overlays.indexOf(t)},qt.prototype.getAllOverlays=function(){return this._overlays},qt.prototype.add=function(t){this.hasOverlay(t)||_.er(t)&&(this._overlays.push(t),t.Zx(this.map),t.init(),t._bindEvents&&t._bindEvents(),(_.GB(t)||_.VB(t))&&this.YB.push(t),t._afterSetMap&&t._afterSetMap(this.map),this.map.setNeedUpdate(!0))},qt.prototype.remove=function(t){this.hasOverlay(t)&&_.er(t)&&(t._beforeRemoveMap&&t._beforeRemoveMap(),this.ar(t),this.map.setNeedUpdate(!0),t.Zx(null))},qt.prototype.getData=function(t,i){this.nr();var n=0,s=0,e=this._overlays.length,r=[],h=new l(t.bounds);if(this.map.isDOMMode())return{sr:this._overlays};for(;n<8&&s<e;){var o,a=this._overlays[s];s++,a&&(o=Date.now(),a._needUpdate&&(a.ZB(i),this.map.setNeedUpdate(!0)),n+=Date.now()-o)}for(var u=0,c=this._overlays;u<c.length;u++){var f=(a=c[u]).getBounds();a.visible&&f&&h.intersects(f)&&r.push(a)}return{sr:r}},qt.prototype.loadData=function(){return!0},qt.prototype.destroy=function(){this.map&&this.map.off("zoomend",this.W_);for(var t=0,i=this._overlays.slice(0);t<i.length;t++){var n=i[t];this.remove(n),n.destroy()}this._overlays=[]},qt.prototype.rr=function(t){for(var i=t.lnglat,n=t.pixel,s=this._overlays.length-1;0<=s;s--){var e=this._overlays[s];if(!e._opts.noSelect&&e.visible)if(_.sB(e)&&n){if(e.containsWithPixel(n))return e}else if(e.contains(i,t))return e}},qt.prototype.W_=function(){for(var t=0,i=this.YB;t<i.length;t++){var n=i[t];n.W_&&n.W_()}},qt.prototype.nr=function(){this._overlays.sort(function(t,i){return t._opts.zIndex-i._opts.zIndex})},qt.prototype.ar=function(t){var i=this._overlays.indexOf(t);-1<i&&this._overlays.splice(i,1),(_.GB(t)||_.VB(t))&&-1<(i=this.YB.indexOf(t))&&this.YB.splice(i,1)};var Ht,Kt,Vt=qt;function qt(t,i,n,s){return(t=Ht.call(this,t,i,n,s)||this)._overlays=[],t.YB=[],t.Fo(!0),t.W_=t.W_.bind(t),n.on("zoomend",t.W_),t}function c(t,i,n,s){return(i=Kt.call(this,t,i,n,s)||this).type="vector",i.Ya=!1,i.Va=!1,i.Xa=256,i.sa=[],i.la=[],i.xt=[2,22],i.qa=!0,i.Za=!0,i.a_=!1,i.Xa=t.tileSize,i._tileUrl=t.tileUrl,s=_.Support.$e?50:200,i.ua=new xt(s),i.NE=new Lt(s),(i.map=n).gn.Ja(AMap.getConfig().protocol),i}Kt=ct,_.Ei(c,Kt),c.prototype.loadData=function(s,t,e,i){for(var r=this,n=(this.aa=s,this.sa=[],s.optimalResolution),h=s.boundsCoord,o=s.zoom,a=s.optimalZoom,u=this.ha(h,a,n,s),c=[],f=_.map(u,function(t){return t.key}),l=[],d=0,v=this.la;d<v.length;d++){var p=v[d];f.indexOf(p.key)<0&&(b=this.ua.getTile(p))&&b.status!==_.TileState.LOADED&&b.request&&(b.request.cancel(),delete b.request,this.ua.ea(b))}for(var m=[],y=((h=i.getMapState()).panning,h.zooming,0);y<u.length;y++){var b,g=u[y],M=new _.ca(g.z,this.fa(g.x,g.z),g.y),k=new _.ca(g.z,g.x,g.y);(b=this.ua.getTile(M))?b.status===_.TileState.LOADED?this.sa.push(k):l.push(g):((k=new _.Sw(M)).nG(this.type),k.status=_.TileState.LOADING,this.ua.Jo(k),m.push(M),l.push(g)),b&&b.status===_.TileState.LOADED||c.push(g)}return this.da(s,this.sa,c,i),this.la=l,0===m.length||(_.map(m,function(t){var i,n=r.ua.getTile(t);n&&(i=r.AD(t.x,t.y,t.z),r.bw(n,{url:i,zo:t,zoom:o,viewState:s},e))}),0===m.length)},c.prototype.bw=function(t,i,s){var n,e=this,r=i.url,h=i.zo,o=i.zoom,i=i.viewState;"AMap.MapboxVectorTileLayer"===this.layer.CLASS_NAME&&(n=this.layer.cX&&this.layer.cX()),this.lX(t,{url:r,ya:h.key,zoom:o,optimalZoom:i.optimalZoom,projectionId:i.projectionId,tileCoord:h,tileSize:this.Xa,styles:n},function(t){var i,n=t&&e.ua.getTile(t.zo);n&&(delete n.request,n.status=_.TileState.LOADED,n.localCoord=t.zS,n.Ro=t.Ro,n.stencil=t.stencil,i=_.lcs.getLocalByCoord([n.Ro[0],n.Ro[1]]),n.data=_.Ln(_.Ln({},t),{Hs:i}),s())})},c.prototype.getData=function(t){var i=t.optimalResolution,n=t.optimalZoom,s=t.boundsCoord,s=this.ha(s,n,i,t),i=this.aa.projectionId,e=_.ProjectionManager.getProjection(i),r=[],h=this.map.qF();if(this.ua.QF(h),this.sa.sort(function(t){return n===t.z+1?1:-1}),0<this.sa.length)for(var o=0;o<this.sa.length;o++){var u,a,c=this.sa[o],f=this.ua.getTile(c),l=[0,0],d=t.centerCoord,d=_.lcs.getLocalByCoord([d[0],d[1]]);!f&&(a=this.fa(c.x,c.z),a=this.ua.getTile(new _.ca(c.z,a,c.y)))&&(f=new _.Sw(c),u=e.getResolution(c.z),c=c.x-a.zo.x,l[0]+=u*this.Xa*c,f.Ro=a.Ro,f.localCoord=a.localCoord,f.data=a.data,f.Sa=l,f.status=a.status),f&&10<n&&(n>=_.Ra&&f.data.Hs?(u=_.lcs.getSize(),c=f.data.Hs.x-d.x,a=f.data.Hs.y-d.y,0!=c&&(c*=u[0],l[0]=c),0!=a&&(a*=u[1],l[1]=a),n>=_.Ra&&_.za>=f.zo.z&&(l[0]=-d.center[0],l[1]=-d.center[1])):n<_.Ra&&_.za<f.zo.z&&(l[0]=d.center[0],l[1]=d.center[1])),f&&(f.Sa=l,f.stamp=h,r.push(f))}return i=_.every(s,function(i){return _.some(r,function(t){return t.zo.key===i.key})}),this.Fo(i),s=this.jE(r),i&&(this.a_=!0,this.map.bZ.dynamic.set("firstAllLoaded",!0)),this.a_&&this.map.bZ.dynamic.set("firstLabelDataAllLoaded",!0),{s_:this.a_,yZ:s,fo:!!i,tiles:r}},c.prototype.destroy=function(){this.ua.forEach(function(t){t.status!==_.TileState.LOADED&&t.request&&(t.request.cancel(),delete t.request),t.destroy()}),this.ua.destroy(),this.sa=[],this.la=[]},c.prototype.forEachTileCache=function(t){this.ua.forEach(t)},c.prototype.reload=function(){this.ua.forEach(function(t){t.status!==_.TileState.LOADED&&t.request&&(t.request.cancel(),delete t.request)}),this.ua.destroy(),this.sa=[],this.la=[]},c.prototype.setTileUrl=function(t){this._tileUrl=t||this._tileUrl},c.prototype.getTileCache=function(){return this.ua},c.prototype.setTileCacheSize=function(t){t=t||(_.Support.$e?50:200),this.ua.Xo(t)},c.prototype.AD=function(t,i,n){return this._tileUrl.replace("[x]",t.toString()).replace("[y]",i.toString()).replace("[z]",n.toString()).replace("{1234}",(Math.abs(t+i)%4+1).toString())},c.prototype.Da=function(t,i){var e,r,h;t.length&&(e=this.Pa.z,r=(this.Pa.ja+this.Pa.Oa)/2,h=(this.Pa.Fa+this.Pa.Ea)/2,t.sort(function(t,i){var n=(t.x<<e-t.z)-r,t=(t.y<<e-t.z)-h,s=(i.x<<e-i.z)-r;return n*n+t*t<=s*s+(i=(i.y<<e-i.z)-h)*i?-1:1}))},c.prototype.ha=function(t,i,n,s){for(var e=this.layer.getSourceConfig().dataZooms,e=(i=+Math.max(Math.min(i,e[1]),e[0]),n=_.ProjectionManager.getProjection(s.projectionId).getResolution(i),this.Xa),s=20037508.342789244,r=t[0]+s,h=-(t[3]-s),o=t[2]+s,r=r/n,h=h/n,t=-(t[1]-s)/n,a=Math.floor(o/n/e),u=Math.min((1<<i)-1,Math.floor(t/e)),s=Math.floor(r/e),c=Math.max(Math.floor(h/e),0),f=(this.Pa={Oa:a,Ea:u,ja:s,Fa:c,z:i},[]),l=s;l<=a;l+=1)for(var d=c;d<=u;d+=1)f.push(new _.ca(i,l,d));return this.Da(f),f},c.prototype.da=function(t,i,n,s){if(t=t.optimalZoom-1,this.Za="overlay"!==this.layer.type,this.qa="overlay"!==this.layer.type,this.Za)for(var e=Math.min(this.xt[1]-1,2+t),r=1+t;n.length&&r<=e;r+=1){for(var h=[],o=[],a=r,u=n.length-1;0<=u;--u)for(var c=n[u],f=c.x<<1,l=c.y<<1,d=1;0<=d;--d)for(var v=1;0<=v;--v){var p=new _.ca(a,this.fa(f+d,a),l+v),m=this.ua.getTile(p),y=new _.ca(a,f+d,l+v);(m&&m.status===_.TileState.LOADED?o:h).push(y)}o.length&&i.push.apply(i,o),n=h}if(this.qa)for(var b=this.xt[0]-1,r=t-1;n.length&&b<=r;--r){for(var o=[],h=[],g={},u=n.length-1;0<=u;--u){var M=n[u],a=r,k=M.z-a,d=M.x>>k,v=M.y>>k;g[M=(p=new _.ca(a,this.fa(d,a),v)).key]||(m=this.ua.getTile(p),g[M]=!0,(m&&m.status===_.TileState.LOADED?o:h).push(new _.ca(a,d,v)))}o.length&&i.push.apply(i,o),n=h}return i},c.prototype.fa=function(t,i){for(var n=1<<(i=i||this.aa.optimalZoom);t<0||n<=t;)t=n<=t?t-n:t<0?n+t:t;return t},c.prototype.vX=function(t,i){var n=[-180,-90],s=[180,90],r=(e=_.ProjectionManager.getProjection("EPSG:3857")).project(256*t+n[0],s[1]-256*i),e=e.project(256*(t+1)+n[0],s[1]-256*(i+1));return[r[0],r[1],e[0],e[1]]},c.prototype.jE=function(t){for(var i=!!t.length,n=0,s=t;n<s.length;n++){var e=s[n].data;if(i)for(var r=0,h=e;r<h.length;r++){var o=h[r];if(!(i=i&&!!o.Ta))break}}return i},$t=Qt=c,_.Ei(ii,$t),ii.prototype.ha=function(t,i,n,s){for(var e=this.layer.getSourceConfig().dataZooms,e=(i=Math.max(Math.min(i,e[1]),e[0])-1,n=_.ProjectionManager.getProjection(s.projectionId).getResolution(i),this.Xa),s=20037508.342789304,r=t[0]+s,h=-(t[3]-s),o=t[2]+s,r=r/n,h=h/n,t=-(t[1]-s)/n,a=Math.floor(o/n/e),u=Math.min((1<<i)-1,Math.floor(t/e)),s=Math.floor(r/e),c=Math.max(Math.floor(h/e),0),f=(this.Pa={Oa:a,Ea:u,ja:s,Fa:c,z:i},[]),l=s;l<=a;l+=1)for(var d=c;d<=u;d+=1)f.push(new _.ca(i,l,d));return this.Da(f),f};var $t,ti=ii;function ii(t,i,n,s){return(t=$t.call(this,t,i,n,s)||this).lX=t.map.gn.loadDistrictSourceTile.bind(t.map.gn),t}ni=Qt,_.Ei(ei,ni),ei.prototype.reStyle=function(i,s){var e=this;this.ua.forEach(function(n){var t;n.status===_.TileState.LOADED?(n.zo.z+1!==s&&e.ua.ea(n),t=_.Ln(_.Ln({},n.data),{dX:null,Dc:null,A_:null,$c:null,pX:null,labels:null}),e.yX.mX(t,i,function(t,i){n.data.Oc=i.Oc,n.data.Fc=i.Fc,n.data.w0=i.w0,n.data.Uc=i.Uc,n.data.dX=i.dX,n.data.IX=i.IX,n.data.labels=i.labels,e.map.setNeedUpdate(!0)})):n.status===_.TileState.LOADING&&(null!=(t=n.request)&&t.cancel(),e.ua.ea(n))})},ei.prototype.ha=function(t,i,n,s){for(var e=this.layer.getSourceConfig().dataZooms,e=(i=Math.max(Math.min(i-1,e[1]),e[0]),n=_.ProjectionManager.getProjection(s.projectionId).getResolution(i),this.Xa),s=20037508.342789244,r=t[0]+s,h=-(t[3]-s),o=t[2]+s,r=r/n,h=h/n,t=-(t[1]-s)/n,a=Math.floor(o/n/e),u=Math.min((1<<i)-1,Math.floor(t/e)),s=Math.floor(r/e),c=Math.max(Math.floor(h/e),0),f=(this.Pa={Oa:a,Ea:u,ja:s,Fa:c,z:i},[]),l=s;l<=a;l+=1)for(var d=c;d<=u;d+=1)f.push(new _.ca(i,l,d));return this.Da(f),f};var ni,si=ei;function ei(t,i,n,s){return(t=ni.call(this,t,i,n,s)||this).yX=new _.bX,t._tileUrl=s.getSourceConfig().tileUrl,t.lX=t.map.gn.gX.bind(t.map.gn),t}ri=ct,_.Ei(oi,ri),oi.prototype.loadData=function(t,i,n){return this.ze=i,this.Oo||(this.Fo(!0),n()),!0},oi.prototype.getData=function(t){return this.ir=t.bounds,{Sa:[0,0]}};var ri,hi=oi;function oi(t,i,n,s){return(t=ri.call(this,t,i,n,s)||this).ir=n.getView().getStatus().bounds,t.io=s.canvas,t}ai=ct,_.Ei(ci,ai),ci.prototype.loadData=function(t,i,n){return!0},ci.prototype.getData=function(t){return!0},ci.prototype.destroy=function(){this.gs&&this.gs.destroy&&this.gs.destroy()};var ai,ui=ci;function ci(t,i,n,s){return(t=ai.call(this,t,i,n,s)||this).gs=s,t}fi=ct,_.Ei(di,fi),di.prototype.CS=function(){this.AS=!1},di.prototype.loadData=function(t,i,n){return!0},di.prototype.getData=function(t){var i,r,e,h,n,o,a,u=this,s=this.gs.getState().path;return this.AS||!s||(i=_.GeometryUtil.typePolygon(s),r={type:"Polygon",$S:new Array,polygons:new Array,BM:new Array,LS:{x:0,y:0}},i&&"Polygon"===i?(s[0][0]instanceof _.LngLat?r.LS=_.lcs.getLocalByLnglat(s[0][0].toString()):r.LS=_.lcs.getLocalByLnglat(s[0][0]),e=(n=r.LS).x,h=n.y,_.forEach(s,function(t,i){var s;0===i?_.forEach(t,function(t){t instanceof _.LngLat&&(t=t.toArray());var t=_.lcs.getLocalByLnglat(t),n=(i=u.DS(e,h,t.x,t.y))[0],i=i[1];r.$S.push(t.Sa[0]+n,t.Sa[1]+i)}):(s=[],_.forEach(t,function(t){t instanceof _.LngLat&&(t=t.toArray());var t=_.lcs.getLocalByLnglat(t),n=(i=u.DS(e,h,t.x,t.y))[0],i=i[1];s.push(t.Sa[0]+n,t.Sa[1]+i)}),r.BM.push(s))})):i&&"MultiPolygon"===i&&(r.type="MultiPolygon",s[0][0][0]instanceof _.LngLat?r.LS=_.lcs.getLocalByLnglat(s[0][0][0].toArray()):r.LS=_.lcs.getLocalByLnglat(s[0][0][0]),o=(n=r.LS).x,a=n.y,_.forEach(s,function(t){var e=[],n=[];_.forEach(t,function(t,i){var s;0===i?_.forEach(t,function(t){t instanceof _.LngLat&&(t=t.toArray());var t=_.lcs.getLocalByLnglat(t),n=(i=u.DS(o,a,t.x,t.y))[0],i=i[1];e.push(t.Sa[0]+n,t.Sa[1]+i)}):(s=[],_.forEach(t,function(t){t instanceof _.LngLat&&(t=t.toArray());var t=_.lcs.getLocalByLnglat(t),n=(i=u.DS(o,a,t.x,t.y))[0],i=i[1];s.push(t.Sa[0]+n,t.Sa[1]+i)}),n.push(s))}),r.BM.push(n),r.polygons.push(e)})),this.AS=this.zw(r),this.AS)},di.prototype.zw=function(t){if(t.Oc=new _._w,!t.Dc){t.Dc=new _.K_;var i=[],n=[];"Polygon"===t.type?(i=[t.$S],n=[t.BM]):"MultiPolygon"===t.type&&(i=t.polygons,n=t.BM);for(var s=0;s<i.length;s++){for(var e=i[s],r=[],h=0;h<n[s].length;h++){var o=n[s][h];r.push(e.length/2),e.push.apply(e,o)}var a=t.Dc.Nx(e,r);0<a&&t.Oc.add(99,99,a,_.zoomRange[0],_.zoomRange[1])}return t}},di.prototype.DS=function(t,i,n,s){return n-=t,t=s-i,[n*(s=_.lcs.getSize())[0],t*s[1]]};var fi,li=di;function di(t,i,n,s){return(t=fi.call(this,t,i,n,s)||this).gs=s,t}vi=Qt,_.Ei(mi,vi),mi.prototype.YE=function(t){var i=this;return t(null,{GW:"worker",cb:function(t){i.dynamicTextVerticeLoadedByTile(t)}}),!0},mi.prototype.dynamicTextVerticeLoadedByTile=function(t){for(var i=0,n=t.data;i<n.length;i++){var s=n[i];this.dynamicTextVerticeLoaded({data:s.data,tag:s.tag,XE:s.XE})}},mi.prototype.dynamicTextVerticeLoaded=function(t){var i=t.data,t=t.XE;if(i instanceof _.ca)this.ua.getTile(i);else{var n=i[Object.keys(i)[0]];if((n=this.ua.getTile(n.zo,!0))&&n.data){var s,e,r={};for(s in i)i.hasOwnProperty(s)&&(e=i[s],r[s]=new _.La(e.zo,e));n.data.labels=r,n.data.XE=t,n.data.Ta=!0,this.Eo()}}},mi.prototype.Aa=function(t){t.zo&&(t=this.ua.getTile(t.zo))&&(t.data.Ta=!0)},mi.prototype.loadData=function(s,t,e,i){var h=this,n=(this.aa=s,this.sa=[],s.optimalResolution),r=s.boundsCoord,o=s.zoom,a=s.optimalZoom;if(a<9.8)return!1;for(var u=this.ha(r,a,n,s),c=[],f=_.map(u,function(t){return t.key}),l=[],d=0,v=this.la;d<v.length;d++){var p=v[d];f.indexOf(p.key)<0&&(x=this.ua.getTile(p))&&x.status!==_.TileState.LOADED&&x.request&&(x.request.cancel(),delete x.request,this.ua.ea(x))}for(var m,y,b,g=[],M=(r=i.getMapState()).panning,k=r.zooming,w=0;w<u.length;w++){var x,A=u[w],z=new _.ca(A.z,this.fa(A.x,A.z),A.y),C=new _.ca(A.z,A.x,A.y);!(x=this.ua.getTile(z))&&M&&!k||(x?x.status===_.TileState.LOADED?this.sa.push(C):l.push(A):((C=new _.Sw(z)).nG(this.type),C.status=_.TileState.LOADING,this.ua.Jo(C),g.push(z),l.push(A)),x&&x.status===_.TileState.LOADED)||c.push(A)}return this.da(s,this.sa,c,i),this.la=l,0!==g.length&&(m=this.map.getMapboxStyle(),y=[],b=256,_.map(g,function(t){var i=t.x,n=t.y,s=t.z,e=h.NE.getTile(t),r=null,n=(e&&e.boundsStatus?r=e.boundsStatus.isInNebulaOversea:(e=h.aa.projectionId,e=[_.V[e].Xs(i*b,n*b,s),_.V[e].Xs((i+1)*b,n*b,s),_.V[e].Xs((i+1)*b,(n+1)*b,s),_.V[e].Xs(i*b,(n+1)*b,s)],r=h.rG(e,t.key),(i=new _.pa(t)).boundsStatus={isInNebulaOversea:r},h.NE.Jo(i)),r||y.push(t),h.NE.getTile(t));(s=h.ua.getTile(t))&&n&&n.boundsStatus&&(s.sG=n.boundsStatus)}),_.map(g=y,function(t){var i,n=h.ua.getTile(t);n&&(i=h.AD(t.x,t.y,t.z),h.bw(n,{url:i,zo:t,zoom:o,viewState:s,styles:m},e))}),0===g.length)},mi.prototype.oG=function(t,i,n,s){void 0===s&&(s="lnglat");var e=[-180,-90],r=[180,90],h=_.ProjectionManager.getProjection("EPSG:3857");return"lnglat"===s?[256*t+e[0],r[1]-256*i,256*(t+1)+e[0],r[1]-256*(i+1)]:"EPSG:3857"===s?(s=h.project(256*t+e[0],r[1]-256*i),h=h.project(256*(t+1)+e[0],r[1]-256*(i+1)),[s[0],s[1],h[0],h[1]]):[0,0,0,0]},mi.prototype.bw=function(t,i,s){var e=this,n=i.url,r=i.zo,h=i.zoom,o=i.viewState,i=i.styles;this.map.gn.aG(t,{url:n,ya:r.key,zoom:h,optimalZoom:o.optimalZoom,projectionId:o.projectionId,tileCoord:r,tileSize:this.Xa,styles:i},function(t){var i,n=t&&e.ua.getTile(t.zo);n&&(delete n.request,n.status=_.TileState.LOADED,n.localCoord=t.zS,n.Ro=t.Ro,n.stencil=t.stencil,i=_.lcs.getLocalByCoord([n.Ro[0],n.Ro[1]]),n.data=_.Ln(_.Ln({},t),{Hs:i}),s())})},mi.prototype.getData=function(t){var i=this,n=t.optimalResolution,s=t.boundsCoord,e=t.optimalZoom;if(e<10)return this.Fo(!0),!1;var s=this.ha(s,e,n,t),n=t.projectionId,r=_.ProjectionManager.getProjection(n),h=[],o=this.map.qF();if(this.ua.QF(o),this.sa.sort(function(t){return e===t.z+1?1:-1}),0<this.sa.length)for(var a=0;a<this.sa.length;a++){var c,u,f=this.sa[a],l=this.ua.getTile(f),d=[0,0],v=t.centerCoord,v=_.lcs.getLocalByCoord([v[0],v[1]]);l||(u=this.ua.getTile(new _.ca(f.z,this.fa(f.x,f.z),f.y)))&&((l=new _.Sw(f)).nG(this.type),c=r.getResolution(f.z),f=f.x-u.zo.x,d[0]+=c*this.Xa*f,l.Ro=u.Ro,l.localCoord=u.localCoord,l.data=u.data,l.Sa=d,l.status=u.status),l&&(e>=_.Ra&&l.data.Hs?(c=_.lcs.getSize(),f=l.data.Hs.x-v.x,u=l.data.Hs.y-v.y,0!=f&&(f*=c[0],d[0]=f),0!=u&&(u*=c[1],d[1]=u),d[0]=-v.center[0],d[1]=-v.center[1]):(d[0]=v.center[0],d[1]=v.center[1])),l&&(l.Sa=d,l.stamp=o,h.push(l))}return s=!(n=_.filter(s,function(t){return!(!(t=i.NE.getTile(t))||!t.boundsStatus||!1!==t.boundsStatus.isInNebulaOversea)})).length||_.every(n,function(i){return _.some(h,function(t){return t.zo.key===i.key})}),n=this.jE(h),s&&(this.a_=!0,this.map.bZ.dynamic.set("firstAllLoaded",!0)),this.a_&&this.map.bZ.dynamic.set("firstLabelDataAllLoaded",!0),s&&this.Fo(!0),{s_:this.a_,fo:!!s,yZ:n,tiles:h}},mi.prototype.Ia=function(){this.map.on("tileSdfInfoFinished",this.Aa.bind(this))},mi.prototype.ha=function(t,i,n,s){for(var e=this.layer.getSourceConfig().dataZooms,e=(i=Math.max(Math.min(i,e[1]),e[0])-1,n=_.ProjectionManager.getProjection(s.projectionId).getResolution(i),this.Xa),s=20037508.342789244,r=t[0]+s,h=-(t[3]-s),o=t[2]+s,r=r/n,h=h/n,t=-(t[1]-s)/n,a=Math.floor(o/n/e),u=Math.min((1<<i)-1,Math.floor(t/e)),s=Math.floor(r/e),c=Math.max(Math.floor(h/e),0),f=(this.Pa={Oa:a,Ea:u,ja:s,Fa:c,z:i},[]),l=s;l<=a;l+=1)for(var d=c;d<=u;d+=1)f.push(new _.ca(i,l,d));return this.Da(f),f},mi.prototype.jE=function(t){for(var i=!!t.length,n=0,s=t;n<s.length;n++){var e=s[n].data;if(i)for(var r=0,h=e;r<h.length;r++){var o=h[r];if(!(i=i&&!!o.Ta))break}}return i};var vi,pi=mi;function mi(t,i,n,s){return(t=vi.call(this,t,i,n,s)||this).type="mapbox",t.hD=[AMap.getConfig().protocol+"://vdata.amap.com/style_icon/2.0/icon-normal-big.png",AMap.getConfig().protocol+"://vdata.amap.com/style_icon/2.0/icon-biz-big.png"],t.Ia(),t}var yi={ielt9:"ActiveXObject"in window&&!document.addEventListener,opts:{callback:"callback",type:"json",charset:"utf-8"},setOptions:function(t){this.opts=_.assign(this.opts,t)},bv:function(){},gv:function(){this.emit("error",{info:"TIME_OUT_A"})},JSONP:function(i,n,t){function s(){window[e]=null,r.onerror=null,r.parentNode&&r.parentNode.removeChild(r)}void 0===t&&(t={}),i=encodeURI(i);var e=_.Util.getGuid("jsonp_",6)+"_",r=document.createElement("script"),h=(r.type="text/javascript",r.charset="utf-8",r.async=!0,t=_.assign({},this.opts,t),r.onerror=function(t){s(),n&&n("error",{url:i,info:"Request Error"})},window[e]=function(t){s(),n&&n("complete",{info:"ok",url:i,data:t})},"?"),h=(-1!==i.indexOf("?")&&(h="&"),i+h+t.callback+"="+e);r.src=h,(document.getElementsByTagName("body")[0]||document.getElementsByTagName("head")[0]).appendChild(r)},Ajax:function(i,t,n){var s,e;return void 0===window.XMLHttpRequest&&window.wv?((s=this._v=new window.wv).onerror=function(t){n("error",{info:"Request Error",url:i,data:""})},s.onload=function(){n("complete",{url:i,data:s.responseText})},s.open(t.type||"GET",i),setTimeout(function(){s.send(t.content||null)},0),s):window.XMLHttpRequest?((e=new XMLHttpRequest).onreadystatechange=function(){var t;4===e.readyState&&(200===e.status?(t="arraybuffer"===e.responseType?e.response:e.responseText,n("complete",{info:"ok",url:i,data:t})):(e.abort(),n("error",{info:e.status,url:i,data:""})))},e.onerror=function(t){e.abort(),n("error",{info:"Request Error",url:i,data:""})},e.open(t.type||"GET",i,!0),e.responseType=t.responseType||"text","POST"===t.type&&e.setRequestHeader("Content-Type",t.requestContentType||"application/x-www-form-urlencoded"),e.send(t.content||null),e):void n("error",{info:"Not Support Ajax",url:i,data:""})}},bi=(gi.prototype.add=function(t,i,n,s,e){Mi.getKey(t,i,e,s)!==(this.WM?this.WM.getKey():"-1")&&(this.XR=t,this.qR=i,this.VM+=this.WM?this.WM.length:0,this.WM=new Mi(t,i,this.VM,s,e),this.jc.push(this.WM)),this.WM.add(n)},gi);function gi(){this.jc=[],this.XR=0,this.qR=0,this.VM=0}ki.getKey=function(t,i,n,s){return t+":"+i+":"+n+":"+s},ki.prototype.add=function(t){this.length+=t},ki.prototype.getKey=function(){return this.color+":"+this.width+":"+this.maxzoom+":"+this.minzoom};var Mi=ki;function ki(t,i,n,s,e){this.color=t,this.width=i,this.offset=n,this.minzoom=s,this.maxzoom=e,this.length=0}wi=Ut,_.Ei(Ai,wi),Ai.prototype.loadData=function(t,i,n,s){var h=this,e=(this.aa=t,this.ze=i,this.Zs=[],this.sa=[],t.projectionId),r=[],o=t.boundsCoord,a=t.optimalZoom,u=t.optimalResolution,c=this.ha(o,a,u),o=(this.ua.forEach(function(t){var i=t.zo,n=!1;if(t.status!==_.TileState.LOADED){for(var s=c.ja;s<=c.Oa;s+=1)for(var e=c.Fa;e<=c.Ea;e+=1){var r=h.fa(s,c.z);i.z===c.z&&i.y===e&&r===i.x&&(n=!0)}n||(t.request&&t.request.abort&&t.request.abort(),h.ua.ea(t))}}),this.qs(t,this.Zs,r));return this.Ys(o,i,e,n),this.da(t,this.sa,r,s),this.sa=this.sa.concat(this.Zs),0===o.length},Ai.prototype.Ys=function(o,t,z,C){if(!(this.aa.optimalZoom<this.xt[0]||this.aa.optimalZoom>this.xt[1])){this.Da(o);var i=this.map.mapStyle.vn.MS("traffic");i&&i.multiFillColors&&((i=i.multiFillColors).congested&&i.congested,i.slow&&i.slow,i.smooth&&i.smooth,i.seriousCongested&&i.seriousCongested,i.unknown)&&i.unknown;for(var S=this.layer.getOptions().rZ,a=this,n=0,s=o.length;n<s;n+=1)!function(t){var t=o[t],M=_.Util.Rg(t.x,t.y,t.z),i=a.ll(M),k=new _.Sw(t),w=(a.ua.Qo(k),_.ProjectionManager.getProjection(z).getResolution(t.z)),n=(h=t.x*a.Xa*w)+a.Xa*w,s=(t=t.y*a.Xa*w)+a.Xa*w,e=_.V[z].Xs(h,t),r=_.V[z].Xs(n,s),h=e[0],n=r[0],t=r[1],s=e[1],x=(k.Ro=[h,t,n,s],k.status=_.TileState.LOADING,_.lcs.getLocalByCoord([k.Ro[0],k.Ro[1]])),A=k.zo.z>_.za;A&&(k.Ro[0]-=x.center[0],k.Ro[1]-=x.center[1],k.Ro[2]-=x.center[0],k.Ro[3]-=x.center[1]),k.request=yi.Ajax(i,{},function(t,i){k.data={};try{i=JSON.parse(i.data)}catch(t){return k.status=_.TileState.LOADED,void C()}if(i=i.data[M.join("_")],"complete"===t&&i){for(var n=new bi,s=new _.J_,e=0,r=i.length;e<r;e++)for(var h=i[e],o=0,a=h.length;o<a;o++)for(var u=h[o],c=.6*u[0]*S,f=0,l=u[1].length;f<l;f++){for(var d=[],v=_.Util.Eg(u[1][f]),p=0,m=v.length;p<m;p+=2){var y=w*(256*k.zo.x+v[p]),b=w*(256*k.zo.y+v[p+1]),y=_.V[z].Xs(y,b);A&&(y[0]-=x.center[0],y[1]-=x.center[1]),d.push(y[0],y[1])}var g=s.hb(d).Iw;n.add(e,c,g,8,20)}k.data={$c:s,Uc:n,Hs:x}}k.status=_.TileState.LOADED,C()})}(n)}};var wi,xi=Ai;function Ai(t,i,n,s){return(t=wi.call(this,t,i,n,s)||this).Qs=[3,17],t.Xa=256,t.Za=t.qa=!1,t.ll=function(t){return AMap.getConfig().protocol+"://vdata.amap.com/traffic?key="+AMap.getConfig().key+"&v="+AMap.getConfig().version+"&t="+t+"&w="+(new Date).getTime()},t}var zi,Si={nebula:"tile",mapbox:"tile",nebulaLabel:"tile",indoor:"other"},Ti=(zi=ct,_.Ei(Li,zi),Li.prototype.loadData=function(e,t,i,r,n){var s,h=this,o=this.Yh;for(s in Object.keys(o).length,o)!function(s){o.hasOwnProperty(s)&&o[s].YE(function(t,i){var n=i.GW,i=i.cb;"worker"===(void 0===n?"main":n)?(h.Ye[s]=i,r.gn.innerLabelsLoadData({id:s,bounds:e.bounds.slice(),zoom:e.optimalZoom},function(t){Object.keys(t).length})):(t=function(t,i){var n,s,e=i.R_,r=i.z_,h={};for(n in t)t.hasOwnProperty(n)&&(s=t[n],s=new _.eG({R_:e,z_:r}).Ns(s.data,{zoom:s.zoom,from:"inner",center:s.center}),h[n]=new _.La(n,s));return h}(t,{R_:h.Mf,z_:h.ac}),i&&i(t))})}(s);return!0},Li.prototype.getData=function(t){var i,n,s,e,r=this.Yh,h={tile:[],other:[]},o=!0;for(i in r)r.hasOwnProperty(i)&&(e=r[i],n=Si[i]||"other",e)&&(s=e.getData(t),e=e.lo(),h[n].push(s),o=o&&e);return this.Oo=o,this.Fo(o),h},Li.prototype.getSources=function(){return this.Yh},Li.prototype.addSource=function(t,i){this.Yh[t]=i},Li.prototype.Xh=function(t){delete this.Yh[t]},Li.prototype.uU=function(t){var i=t.id,n=this.Ye;n[i]&&n[i](t)},Li.prototype.destroy=function(){var t,i,n=this.Yh;for(t in n)n.hasOwnProperty(t)&&(i=n[t])&&i.destroy()},Li.prototype.reload=function(){var t,i,n=this.Yh;for(t in n)n.hasOwnProperty(t)&&(i=n[t])&&i.reload&&i.reload()},Li.prototype.Ia=function(){this.map.gn.on("dynamicTextVerticeLoadedByTile",this.uU.bind(this))},Li);function Li(t,i,n,s){return(t=zi.call(this,t,i,n,s)||this).Yh={},t.Ye={},t.Mf=n.R_,t.ac=n.z_,t.Ia(),t}var Ii,Di=_.Support.scale,Oi=(Ii=s,_.Ei(Ri,Ii),Ri.prototype.loadData=function(t,i,n,s){var e=this;if(!s.gn.dE)return!1;this.aa=t,this.sa=[];for(var r=t.bounds,h=this.ra(t.optimalZoom),o=this.ha(r,h),r=_.map(o,function(t){var i=e.fa(t.x,t.z);return t.z+","+i+","+t.y}),a=this.QH.qH(r).yB,u=[],c=0;c<o.length;c++){var f,l,d=o[c],v=new _.ca(d.z,this.fa(d.x,d.z),d.y),p=new _.ca(d.z,d.x,d.y),m=_.zB.ALL,y=this.ua.getTile(v,!0);y?(f=this.ua.MD(y.tag,m))&&(y.tag=m,l=d.key+","+_.Util.SD(f),a.indexOf(l)<0)&&u.push(l):(l=v.key+","+_.Util.SD(m),a.indexOf(l)<0&&((d=new _.pa(v)).status=_.TileState.LOADING,this.ua.Jo(d),d.tag=m,u.push(l))),!y||y.status!==_.TileState.LOADED&&y.status!==_.TileState.RELOADING||this.sa.push(p)}var b=(r=this.OE(u)).overseaTile,g=r.chinaTile,r=r.mapboxTile;return this.PE(b,"oversea"),this.PE(g,"china"),this.PE(r,"mapbox"),this.da(t,this.sa,[],s),this.zD(u,t,h,s,n,"building"),0===u.length},Ri.prototype.destroy=function(){this.mapStyle&&this.mapStyle.destroy&&(this.mapStyle.destroy(),delete this.mapStyle),this.R_&&this.R_.destroy&&(this.R_.destroy(),delete this.R_)},Ri.prototype.reload=function(){var i=this;this.ua.forEach(function(t){t.status!==_.TileState.LOADED&&t.request&&(t.request.cancel(),delete t.request),t.destroy(),i.ua.ea(t)}),this.sa=[],this.la=[]},Ri);function Ri(t,i,n,s){return(i=Ii.call(this,t,i,n,s)||this).Xa=t.tileSize,i._tileUrl=t.tileUrl,s=_.Support.$e?50:200,i.ua=new Ct(s),n.gn.Ha({scale:Di,showLabel:n.showLabel,DD:-1!==location.search.indexOf("forceAll")}),i.R_=n.R_,i.z_=n.z_,n.gn.Ja(AMap.getConfig().protocol),i.mapStyle=n.mapStyle,i.mapStyle.pn(function(){}),i.Ia(),i.sD(),i}Ei=ct,_.Ei(ji,Ei),ji.prototype.loadData=function(t,i,n,s,e){var r;if(!(e=e.getSource("nebula")))return this.gs&&(r=this.gs.VR.showId)&&this.GR([r]),!1;for(var h=e.getData(t).tiles,o=h.length,a=[],u=0;u<o;u++)for(var c=0,f=h[u].data||[];c<f.length;c++){var l=f[c];if(l.indoorInfo)for(var d=l.indoorInfo,v=d.length,p=0;p<v;p++){for(var m=d[p],y=!1,b=0;b<a.length;b++)m===a[b]&&(y=!0);y||a.push(m)}}return this.GR(a),this.Fo(!0),!0},ji.prototype.getData=function(){return this._indoorData},ji.prototype.lo=function(){return!0},ji.prototype.GR=function(t,i){if(!t||t.length<1)return null;if(!this.map.isDOMMode()){for(var s=(n=this.gs).VR,e=(n._map,[]),n=this._config.server+"/v3/indoor/indoormaps?",r=t,h=r.length,o=[],a=[],t=[],u=!1,c=0;c<h;c++){var f=r[c],l=1,d=(this._indoorData.data[f]||(this._indoorData.data[f]={}),s.floorInfo&&s.floorInfo[f]&&(d=s.floorInfo[f])&&(l=d),this._indoorData.data[f]);d&&d.data&&d.data[l]||(u=!0,o.push(l),a.push(0),e.push(f))}this.LL=e,t.push("poiid="+e.join(";")),t.push("floor="+o.join(";")),t.push("version="+a.join(";")),t.push("s=rsv3"),t.push("from=indoorH5Map"),t.push("servicetype=unify"),t.push("key="+this._config.key),this._config.jscode?t.push("jscode="+this._config.jscode):this._config.gaodeserver&&(n=this._config.gaodeserver+"/v3/indoor/indoormaps?"),n+=t.join("&"),u&&this.ZR.url!==n?(this.ZR.url=n,this.YR(n,this.jF)):(this.jF(),i&&i())}},ji.prototype.JR=function(t,i,n){var s=this;if(!t||!i)return!1;this.GR([t],function(){s.gs&&s.gs._map&&s.gs._map.setNeedUpdate(!0),n&&n()})},ji.prototype.YR=function(t,u){var c=this,i=new XMLHttpRequest;i.onreadystatechange=function(){4===i.readyState&&200===i.status&&c.map.gn.JB(i.response,function(t,i){if(t)console.log(t);else for(var n=0,s=Object.keys(i);n<s.length;n++)for(var e=s[n],r=(c._indoorData.data[e]&&c._indoorData.data[e].data||(c._indoorData.data[e].data={}),c._indoorData.data[e].building=i[e].building,i[e].data),h=0,o=Object.keys(r);h<o.length;h++){var a=o[h];c._indoorData.data[e].data[a]=r[a]}u()})},i.open("GET",t,!0),i.responseType="arraybuffer",i.send()};var Ei,Pi=ji;function ji(t,i,n,s){var e=Ei.call(this,t,i,n,s)||this;return e.jF=function(){var t;e.gs&&(t=e.gs.getRender())&&t.render(e._indoorData)},e.gs=s,e._config=AMap.getConfig(),e._indoorData={extData:{},data:{}},e.LL=[],e.ZR={url:null,status:!1},e}var Bi,Wi,Fi=_.Support.scale,ct=(Bi=ct,_.Ei(f,Bi),f.prototype.loadData=function(t,i,n,s){var e=this;if("optimise"===s.loadData()&&s.TL())return!1;this.aa=t,this.sa=[];for(var r=t.bounds,h=this.ra(t.optimalZoom),o=this.ha(r,h),a=[],u=t.optimalZoom,r=_.map(o,function(t){var i=e.fa(t.x,t.z);return t.z+","+i+","+t.y}),c=this.KH.qH(r),f=[],l=0;l<o.length;l++){var d,v,p=o[l],m=new _.ca(p.z,this.fa(p.x,p.z),p.y),y=new _.ca(p.z,p.x,p.y),b=_.Util.kD(m.key,u),g=this.ua.getTile(m,!0);g?(d=this.ua.MD(g.gB,b))&&(g.gB=b,v=p.key+","+_.Util.SD(d),c.yB.indexOf(v)<0)&&f.push(v):(v=m.key+","+_.Util.SD(b),c.yB.indexOf(v)<0&&((m=new _.pa(m)).status=_.TileState.LOADING,m.xB=_.TileState.LOADING,this.ua.Jo(m),m.tag=b,m.gB=b,f.push(v))),!g||g.xB!==_.TileState.LOADED&&g.xB!==_.TileState.RELOADING||this.sa.push(y),g&&(g.xB===_.TileState.LOADED||g.xB===_.TileState.RELOADING)||a.push(p),g&&g.xB===_.TileState.LOADED&&g.version&&g.version!==this.VH&&(this.sa.push(y),g.xB=_.TileState.RELOADING,f.push(p.key+","+_.Util.SD(g.gB)),d=this.ua.MD(g.gB,b))&&(v=p.key+","+_.Util.SD(d),c.yB.indexOf(v)<0)&&f.push(v)}this.da(t,this.sa,a,s);var M,k,w,r=this.map.getOutseaState(),x=this.map.getOutseaDataType();return r&&!x?9.8<=h?(h=(k=this.OE(f)).overseaTile,w=k.chinaTile,M=k.mapboxTile,this.PE(h,"oversea"),this.PE(w,"china"),this.PE(M,"mapbox"),s.showLabel&&this.bB(k.chinaTile,t),s.showLabel&&this.bB(k.overseaTile,t,"outsea")):(this.PE(f,"china"),s.showLabel&&this.bB(f,t,"a00")):r&&x&&"mapbox"===x?9.8<=u?(w=(k=this.OE(f)).chinaTile,this.PE(w,"china"),s.showLabel&&this.bB(f,t)):(this.PE(f,"china"),s.showLabel&&this.bB(f,t,"a00")):(this.PE(f,"china"),s.showLabel&&this.bB(f,t)),0===f.length},f.prototype.getData=function(i){var n=this,t=i.bounds,s=this.ra(i.optimalZoom),e=this.ha(t,s),r=[],h={},o=(14===s&&(h=this.ha(t,15,!0)),this.map.qF());if(this.ua.QF(o),this.sa.sort(function(t){return n.ra(i.optimalZoom)===t.z?1:-1}),0<this.sa.length)for(var a=0;a<this.sa.length;a++){var u,c,f,l=this.sa[a],d=this.ua.getTile(l,!0),v=0,p=0,m=[0,0],y=i.centerCoord;d?(d.localCoord||(c=_.wa.ga(d.zo.x,d.zo.y,d.zo.z,"EPSG:3857"),u=_.lcs.getLocalByCoord([c[0],c[1]]),d.localCoord=u,d.Ro=c),u=_.lcs.getLocalByCoord([y[0],y[1]]),i.optimalZoom>=_.Ra?(f=_.lcs.getSize(),v=d.localCoord.x-u.x,p=d.localCoord.y-u.y,0!=v&&(v*=f[0],m[0]=v),0!=p&&(p*=f[1],m[1]=p),i.optimalZoom>=_.Ra&&_.za>=d.zo.z&&(m[0]=-u.center[0],m[1]=-u.center[1])):i.optimalZoom<_.Ra&&_.za<d.zo.z&&(m[0]=u.center[0],m[1]=u.center[1])):(c=new _.ca(l.z,this.fa(l.x,l.z),l.y),(y=this.ua.getTile(c,!0))&&(d=new _.pa(l),f=1<<l.z,(l.x<0||l.x>=f)&&(v=Math.floor(l.x/f),m[0]+=20037508.342789244*v*2),p=y.gB,d.Ro=y.Ro,d.ID(y),d.Sa=m,d.status=y.status,d.tag=p,d.gB=p)),d&&(d.stamp=o,d.Sa=m,r.push(d))}var b=i.optimalZoom,t=_.every(e,function(s){return _.some(r,function(t){var i=t.zo.key,n=t.zo.z,n=_.Util.VF(n,b),t=t.gB,t=_.Util.LD(t,n);return i===s.key&&t})}),g=this.map.getOutseaState(),M=this.map.getOutseaDataType(),e=(g&&!M&&(t=!(M=_.filter(e,function(t){return!(t=n.NE.getTile(t))||!t.boundsStatus||!1!==t.boundsStatus.isInNebulaOversea})).length||_.every(M,function(s){return _.some(r,function(t){var i=t.zo.key,n=t.zo.z,n=_.Util.VF(n,b),t=t.gB,t=_.Util.LD(t,n);return i===s.key&&t})})),r&&0<=r.length&&this.Fo(!0),this.jE(r)),M=(t&&(this.a_=!0,this.map.bZ.dynamic.set("firstAllLoaded",!0)),e&&this.map.bZ.dynamic.set("firstLabelDataAllLoaded",!0),t&&e&&this.Fo(!0),{s_:this.a_,fo:!!t&&e,yZ:e,tiles:r,Ca:h,outseaData:void 0});return g&&r.length&&(t=this.map.bZ.MZ.wZ.gZ(),M.outseaData=t),M.tiles=this.UE(r,s),M},f.prototype.pe=function(t){return t=new _.ca(t[0],t[1],t[2]),this.ua.getTile(t)},f.prototype.ZE=function(t){return!1},f.prototype.OE=function(t){for(var i=t.length,n=[],s=[],e=[],r=0;r<i;r++){var h=void 0,o=void 0,a=t[r],u=a.split(","),c=new _.ca(u[0],u[1],u[2]),f=this.NE.getTile(c);if(f&&f.boundsStatus)h=f.boundsStatus.isInChina,o=f.boundsStatus.isInNebulaOversea;else{if(!(f=_.wa.ga(parseInt(u[1],10),parseInt(u[2],10),parseInt(u[0],10),"EPSG:3857")))continue;u=[[f[0],f[1]],[f[2],f[1]],[f[2],f[3]],[f[0],f[3]]],h=this.VE(u,"china",a),o=this.VE(u,"oversea",a),(f=new _.pa(c)).boundsStatus={isInChina:h,isInNebulaOversea:o},this.NE.Jo(f)}h&&n.push(a),o&&s.push(a),h||o||e.push(a)}return{chinaTile:n,overseaTile:s,mapboxTile:e}},f.prototype.ra=function(t){return("fast"!==this.map.bZ.MZ.drawMode||this.map.bZ.dynamic.get("firstPaint")?{2:3,3:3,4:3,5:3,6:6,7:6,8:8,9:8,10:10,11:10,12:10,13:12,14:12,15:15,16:15,17:15,18:15,19:15,20:15,21:15,22:15,23:15,24:15,25:15,26:15,27:15,28:15,29:15,30:15}:{2:3,3:3,4:3,5:3,6:6,7:6,8:8,9:8,10:8,11:8,12:8,13:12,14:12,15:15,16:15,17:15,18:15,19:15,20:15,21:15,22:15,23:15,24:15,25:15,26:15,27:15,28:15,29:15,30:15})[t]},f.prototype.YE=function(t){var i=this;return t(null,{GW:"worker",cb:function(t){i.dynamicTextVerticeLoadedByTile(t)}}),!0},f.prototype.destroy=function(){this.ua.forEach(function(t){t.status!==_.TileState.LOADED&&t.request&&(t.request.cancel(),delete t.request),t.destroy()}),this.ua.destroy(),this.sa=[],this.la=[],this.mapStyle&&this.mapStyle.destroy&&(this.mapStyle.destroy(),delete this.mapStyle),this.R_&&this.R_.destroy&&(this.R_.destroy(),delete this.R_)},f.prototype.reload=function(){this.ua.forEach(function(t){t.status!==_.TileState.LOADED&&t.request&&(t.request.cancel(),delete t.request),t.reload()}),this.sa=[],this.la=[]},f.prototype.Aa=function(t){var i;t.zo&&(i=this.ua.getTile(t.zo))&&(i.rO({Ta:!0},t.tag),i.xa({Ta:!0},t.tag),i.JE({Ta:!0},t.tag))},f.prototype.setTileCacheSize=function(t){t=t||(_.Support.$e?30:100),this.ua.Xo(t)},f.prototype.UH=function(t){this.VH=t},f.prototype.dynamicTextVerticeLoaded=function(t){var i=t.data,n=t.XE;if(i instanceof _.ca)return(s=this.ua.getTile(i))?(s.data||s.xa({},t.tag),void s.rO({},t.tag)):void 0;var s=i[Object.keys(i)[0]];if(s=this.ua.getTile(s.zo,!0)){s.data||s.xa({},t.tag);var e,r,h={};for(e in i)i.hasOwnProperty(e)&&(r=i[e],h[e]=new _.La(r.zo,r));s.rO({Ta:!0,labels:h,XE:n},t.tag),s.xa({Ta:!0},t.tag),s.JE({Ta:!0},t.tag),s.xB=_.TileState.LOADED,this.map.Mv.t0(s.zo),this.Eo()}},f.prototype.dynamicTextVerticeLoadedByTile=function(t){for(var i=0,n=t.data;i<n.length;i++){var s=n[i];this.dynamicTextVerticeLoaded({data:s.data,tag:s.tag,XE:s.XE})}},f.prototype.Ia=function(){this.map.on("tileSdfInfoFinished",this.Aa.bind(this))},f.prototype.bB=function(t,i,n){i={zoom:i.zoom,projectionId:i.projectionId,mH:_.Support.mH},this.KH._B(t,i,n)},f.prototype.cP=function(){for(var t,i=this.map.getLayers(),n=0;n<i.length;n++)if("AMap.Buildings"===(s=i[n]).CLASS_NAME&&!s.getState().u$){t=s;break}if(!t)for(var s,n=0;n<i.length;n++)if("AMap.Buildings"===(s=i[n]).CLASS_NAME){t=s;break}return t},f.prototype.ma=function(t,i){var n,s=new RegExp(/\\{(\\w|\\,)+\\}/g);return s.test(this._tileUrl)?(n=this._tileUrl.match(s)[0].replace(/[\\{|\\}]/g,"").split(","),this._tileUrl.replace(s,n[(t+i)%4])):this._tileUrl},f.prototype.AD=function(){var t=new RegExp(/\\{(\\w|\\,)+\\}/g),i=this._tileUrl.match(t)[0].replace(/[\\{|\\}]/g,"").split(","),n=i.length,t=this._tileUrl.replace(t,i[this.$D%n]);return this.$D=(this.$D+1)%n,t},f.prototype.ha=function(t,i,n){void 0===n&&(n=!1);var s=[t[0],t[3]],t=[t[2],t[1]],s=this.Ga(s,i),t=this.Ga(t,i),e=s[0],r=s[1],h=t[0],o=t[1];if(n)return{ja:e,Fa:r,Oa:h,Ea:o,z:i};this.Pa={ja:e,Fa:r,Oa:h,Ea:o,z:i};for(var a=[],u=e;u<=h;u+=1)for(var c=r;c<=o;c+=1)a.push(new _.ca(i,u,c));return this.Da(a),a},f.prototype.da=function(t,i,n,s){var e=[3,6,8,10,12,15],r=this.ra(t.optimalZoom);if(this.Za)for(var h=Math.min(14,r+3),o=r+1;n.length&&o<=h;o+=1)if(-1!==e.indexOf(o)){for(var a=o-r,u=[],c=[],f=n.length-1;0<=f;--f)for(var l=n[f].x<<a,d=n[f].y<<a,v=1<<a;0<=v;--v)for(var p=1<<a;0<=p;--p){var m=new _.ca(o,this.fa(l+v,o),d+p),y=new _.ca(o,l+v,d+p);((M=this.ua.getTile(m,!0))&&M.status===_.TileState.LOADED?c:u).push(y)}c.length&&i.push.apply(i,c),n=u}if(this.qa)for(var b=this.xt[0],o=r-1;n.length&&b<=o;--o)if(-1!==e.indexOf(o)){for(var c=[],u=[],g={},f=n.length-1;0<=f;--f){var M,k=n[f],a=o,w=k.z-a,v=k.x>>w,p=k.y>>w;g[k=(m=new _.ca(a,v,p)).key]||(w=new _.ca(a,this.fa(v,a),p),y=new _.ca(a,v,p),M=this.ua.getTile(w,!0),g[k]=!0,(M&&M.status===_.TileState.LOADED?c:u).push(y))}c.length&&i.push.apply(i,c),n=u}return i},f.prototype.Da=function(t){var e,r,h;t.length&&(e=this.Pa.z,r=(this.Pa.ja+this.Pa.Oa)/2,h=(this.Pa.Fa+this.Pa.Ea)/2,t.sort(function(t,i){var n=(t.x<<e-t.z)-r,t=(t.y<<e-t.z)-h,s=(i.x<<e-i.z)-r;return n*n+t*t<=s*s+(i=(i.y<<e-i.z)-h)*i?-1:1}))},f.prototype.Ga=function(t,i){var n=180/(i=Math.pow(2,i));return[Math.floor(t[0]/(360/i))+i/2,i/2-Math.ceil(t[1]/n)]},f.prototype.fa=function(t,i){for(var n=1<<(i=i||this.aa.optimalZoom);t<0||n<=t;)t=n<=t?t-n:t<0?n+t:t;return t},f.prototype.sD=function(){var e,r,h=this;this.map.bZ.dynamic.get("_preloadNebulaIcons")||(this.map.bZ.dynamic.set("_preloadNebulaIcons",!0),e=this.hD,(r=this.z_).loadImages(e,{type:"icon",imageBitmap:_.Support.imageBitmap,cb:function(){for(var t=[],i=0;i<e.length;i++){var n=e[i],s=r.getImage(n);t.push({img:s.img,name:n,hv:i,width:s.width,height:s.height})}h.map.so.sv(t)}}))},f.prototype.PE=function(t,i){for(var n=0,s=t;n<s.length;n++){var e=s[n].split(",").slice(0,3).join(",");(e=this.ua.xf(e))&&(e.region=i)}},f.prototype.UE=function(t,i){void 0===t&&(t=[]);var n=[];if(10<=i){for(var s=0,e=t;s<e.length;s++){var r=e[s];"china"!==r.region&&"oversea"!==r.region||n.push(r)}return n}return t},f.prototype.jE=function(t){for(var i=!!t.length,n=0,s=t;n<s.length;n++){var e=s[n].data;if(i)for(var r=0,h=e;r<h.length;r++){var o=h[r];if(!(i=i&&!!o.Ta))break}}return i},f);function f(t,i,n,s){var a=Bi.call(this,t,i,n,s)||this,i=(a.xt=_.zoomRange,a.sa=[],a.la=[],a.qa=!0,a.Za=!0,a.a_=!1,a.$D=0,a.hD=[AMap.getConfig().protocol+"://vdata.amap.com/style_icon/2.0/icon-normal-big.png",AMap.getConfig().protocol+"://vdata.amap.com/style_icon/2.0/icon-biz-big.png"],a.VH="",a.wH=function(t){!a.map.yH||parseInt(t.key.split(",")[0],10)<10||a.map.yH.kH(t.key)},a.Xa=t.tileSize,a._tileUrl=t.tileUrl,a.tG=null,_.Support.$e?30:200);return a.ua=new Ct(i),a.NE=new Lt(i),window.xZ=a.ua,n.gn.Ha({scale:Fi,showLabel:n.showLabel,DD:-1!==location.search.indexOf("forceAll")}),a.R_=n.R_,a.z_=n.z_,n.gn.Ja(AMap.getConfig().protocol),a.mapStyle=n.mapStyle,a.mapStyle.pn(function(t){n&&n.gn&&n.gn.Ka({value:t,TY:"fast"===a.map.bZ.MZ.drawMode})}),a.Ia(),a.sD(),a.ua.on("delete",a.wH),a.KH=new Dt(function(t,o,i,n){var s=a.AD();return!n||"outsea"!==n&&"a00"!==n||(s=_.Support.wasm?s.replace("/nebula/v3","/oversea/v3"):s.replace("/nebula/v2","/oversea/v2")),new _.vH(a.map.gn.RD({url:s,projectionId:i.projectionId,ya:t,ZL:i.zoom,mH:i.mH},function(t,i){if(a.Eo(),a.KH.CB(o),t)console.log(t),a.map.emit("TileDecodeError",{type:"nebulasdf",err:t});else if(i)for(var n=0,s=Object.keys(i);n<s.length;n++){var e,r,h=s[n].slice(0,-2);(h=a.ua.xf(h))&&(h.status=_.TileState.LOADED,h.xB=_.TileState.LOADED,e=_.wa.ga(h.zo.x,h.zo.y,h.zo.z,"EPSG:3857"),r=_.lcs.getLocalByCoord([e[0],e[1]]),h.localCoord=r,h.Ro=e)}else console.log("no data"),a.map.emit("TileDecodeError",{type:"nebulasdf",err:"no data"})}))},function(t){for(var i=0,n=t;i<n.length;i++){var s=n[i];(s=a.ua.xf(s.slice(0,-2)))&&s.status!==_.TileState.LOADED&&a.ua.ea(s)}}),_.Support.$e&&!_.Support.iPad&&(a.map.on("zoomend",function(){15<=a.map.getZoom()?a.ua.Xo(6):a.ua.Xo(20)}),15<=a.map.getZoom())&&a.ua.Xo(6),a}function Ni(t,i,n,s){return(t=Wi.call(this,t,i,n,s)||this).Rs=null,t}Wi=Ut,_.Ei(Ni,Wi),Ni.prototype.Ys=function(a,u,c,f){var l=this;if(!(this.aa.optimalZoom<this.xt[0]||this.aa.optimalZoom>this.xt[1])){this.Da(a);for(var d=this,i=0,n=a.length;i<n;i+=1)!function(t){var n=d.layer.getLayerConfig(),t=a[t],h=(d.ma().replace("[z]",t.z+"").replace("[x]",t.x+"").replace("[y]",t.y+""),new _.Vs(t)),n=(d.ua.Qo(h),n.getTileUrl&&n.getTileUrl(t.x,t.y,t.z),_.ProjectionManager.getProjection(c).getResolution(t.z)),e=(s=t.x*d.Xa*n)+d.Xa*n,n=(t=t.y*d.Xa*n)+d.Xa*n,r=_.V[c].Xs(s,t),o=_.V[c].Xs(e,n),s=r[0],e=o[0];t=o[1],n=r[1],h.Ro=[s,t,e,n],h.status=_.TileState.LOADING,setTimeout(function(){var t,i;if(u){if(t=_.lcs.getLocalByCoord([h.Ro[0],h.Ro[1]]),h.zo.z>_.za&&(h.Ro[0]-=t.center[0],h.Ro[1]-=t.center[1],h.Ro[2]-=t.center[0],h.Ro[3]-=t.center[1]),i=u.fe(new Float32Array([h.Ro[0],h.Ro[1],0,1,h.Ro[2],h.Ro[1],1,1,h.Ro[0],h.Ro[3],0,0,h.Ro[2],h.Ro[1],1,1,h.Ro[2],h.Ro[3],1,0,h.Ro[0],h.Ro[3],0,0]),16),!l.Rs){var n=document.createElement("canvas"),s=n.getContext("2d");if(s){n.height=n.width=256,n.style.height=n.style.width="256px",s.font="14px Verdana",s.fillStyle="rgba(76,83,98,0.15)",s.rotate(-15*Math.PI/180);for(var e="暂未获得高德开放平台商用授权",r=0;r<e.length;r++)s.fillText(e[r],17*r-35,180);s.stroke()}l.Rs=n}(n=u.createTexture(l.Rs,{Zi:!0})).bind(u.gl.MIRRORED_REPEAT,u.gl.LINEAR,u.gl.LINEAR_MIPMAP_NEAREST),h.data={texture:n,zs:i,Js:n,Hs:t}}h.status=_.TileState.LOADED,f()},10)}(i)}};var _i={nebula:s,nebulaLabel:ct,building:Oi,sky:ui,mask:li,inner:Ti,image:Bt,custom:Xt,gl_custom:hi,raster:Ut,overlay:Vt,labelsLayer:Gt,vectorTile:Qt,districtVectorTile:ti,mapboxVectorTile:si,indoor:Pi,mapbox:pi,vectortraffic:xi,markLayer:Ni},Ui=(Yi.addSource=function(t,i){_i[t]||(_i[t]=i)},Yi.prototype.addSource=function(t,i,n){return("nebula"===t.id||"indoor"===t.id)&&this.Yh[t.id]||this.Yh[t.id]||(this.Yh[t.id]=new _i[t.type](t,i,this.map,n),n.source=this.Yh[t.id]),this.Yh[t.id]},Yi.prototype.getSource=function(t){return this.Yh[t]},Yi.prototype.Xh=function(t){delete this.Yh[t]},Yi.prototype.getData=function(t,i,n){return this.Yh[t].getData(i,n)},Yi.prototype.loadData=function(t,i,n){for(var s=0,e=i.Zdt()||[];s<e.length;s++){var h=(r=e[s]).getOptions(),r=r.getSource();_.Util.dS(i.getZoom(),h.zooms)&&r&&h.visible&&0<h.opacity&&r.loadData(t,n,function(){i.setNeedUpdate(!0)},i,this)}},Yi.prototype.destroy=function(){for(var t in this.Yh)this.Yh[t]&&this.Yh[t].destroy();this.Yh={}},Yi.prototype.UH=function(t){for(var i in this.Yh)this.Yh[i]&&this.Yh[i].UH&&this.Yh[i].UH(t)},Yi.prototype.i0=function(t,i){if(this.Yh[t])return this.Yh[t].ua.getTile(i,!1)},Yi.prototype.t0=function(t){var i=this.i0(_.n0.nebulaLabel,t);(t=15===t.z?this.i0(_.n0.nebula,t.s0(14)):this.i0(_.n0.nebula,t))&&i&&i.KE(t.data)},_.dZ([_.pZ("SourceManager")],Yi));function Yi(t){this.map=t,this.Yh={}}Zi=_.Event,_.Ei(d,Zi),d.prototype.onAdd=function(){},d.prototype.v$=function(){},d.prototype.Hh=function(t){this.uo=t},d.prototype.Do=function(t){return this.Jh=t,this.Jh},d.prototype.setMap=function(t){var i,n=this;null===t&&this.map?this.map.removeLayer(this):(this.map=t)&&(i=t.getLayers(),_.find(i,function(t){return t.getLayerConfig().id===n.getLayerConfig().id})||t.addLayer(this))},d.prototype.Kh=function(t){var i=this;(this.source=t)&&this.source.on("complete",function(){i.emit("complete")})},d.prototype.setzIndex=function(t){this.Qh=t,this.map&&this.map.setNeedUpdate(!0)},d.prototype.setOpacity=function(t){this.tl=t,this.map&&this.map.setNeedUpdate(!0)},d.prototype.getOpacity=function(){return this.tl},d.prototype.getSource=function(){if(this.uo)return this.uo.getSource(this.co())},d.prototype.getzIndex=function(){return this.getLayerConfig().zIndex},d.prototype.getMap=function(){return this.map},d.prototype.getRender=function(){return this.Jh},d.prototype.getLayerConfig=function(){return{id:this._id,zooms:this.xt,zIndex:this.Qh,opacity:this.tl,visible:this.il,createTile:void 0,rejectMapMask:this._rejectMapMask}},d.prototype.getOptions=function(){var t=this.getLayerConfig(),i=this._opts||{};return _.assign({},i,t)},d.prototype.getZooms=function(){return this.xt},d.prototype.setZooms=function(t){this.xt=t,this.map&&this.map.setNeedUpdate(!0)},d.prototype.getVisible=function(){return this.il},d.prototype.beforeRender=function(){},d.prototype.afterRender=function(){},d.prototype.get=function(t){return this.getOptions()[t]},d.prototype.vi=function(t){return null},d.prototype.lo=function(){if(this.source)return this.source.lo()},d.prototype.T$=function(){return this._id},d.prototype.show=function(){this.il=!0,this.map&&this.map.setNeedUpdate(!0)},d.prototype.hide=function(){this.il=!1,this.map&&this.map.setNeedUpdate(!0)},d.prototype.destroy=function(){this.Jh&&this.Jh.destroy&&(this.Jh.destroy(),delete this.Jh)},d.prototype.onCreated=function(){this.map&&this.map.addLayer(this)};var Zi,s=_.dZ([_.pZ("Layer")],d);function d(t){void 0===t&&(t={});var i=Zi.call(this)||this;return i.el="AMap.Layer",i.CLASS_NAME="AMap.Layer",i.hS=_.Util.stamp(i),i.il=!0,i.tl=1,i.xt=_.zoomRange,i._id="layer",i.nl=!0,i._id="layer_"+_.Util.uuid(),i.xt=t.zooms||_.zoomRange,i.tl=void 0===t.opacity?1:t.opacity,i.Qh=t.zIndex||1,i._rejectMapMask=void 0!==t.rejectMapMask&&t.rejectMapMask,i.il=void 0===t.visible||t.visible,i.AF=void 0!==t.depthTest&&Boolean(t.depthTest),i.IF=void 0!==t.ce&&Boolean(t.ce),i.wl=t.cacheSize,i.map=t&&t.map||null,i._opts=t,i}Xi=s,_.Ei(Hi,Xi),Hi.prototype.getState=function(){return{ol:!0,al:!0,visible:this.il,opacity:this.tl,layer:this,rejectMapMask:this._rejectMapMask,depthTest:this.AF,ce:this.IF,cacheSize:this.wl}},Hi.prototype.getLayerConfig=function(){var t=Xi.prototype.getLayerConfig.call(this);return t.mapNumber="GS(2021)6375",t},Hi.prototype.getSourceConfig=function(){return{id:"nebula",type:"nebula",tileUrl:AMap.getConfig().protocol+(_.Support.wasm?"://{vdata,vdata01,vdata02,vdata03,vdata04}.amap.com/nebula/v3":"://{vdata,vdata01,vdata02,vdata03,vdata04}.amap.com/nebula/v2"),tileSize:0,zooms:_.zoomRange}},Hi.prototype.co=function(){return"nebula"},Hi.prototype.destroy=function(){this.Jh&&this.Jh.destroy&&(this.Jh.destroy(),delete this.Jh)},Hi.prototype.show=function(){Xi.prototype.show.call(this);var t=this.iP();t&&t.show(),(t=this.map&&this.map.getLayerByClass("AMap.Inner.LabelsLayer"))&&t.oP()&&t.show()},Hi.prototype.hide=function(){Xi.prototype.hide.call(this);var t=this.iP();t&&t.hide(),this.rP()},Hi.prototype.v$=function(){Xi.prototype.v$.call(this);var t=this.iP();t&&this.map.removeLayer(t),this.rP()},Hi.prototype.Hh=function(t){this.uo=t,this.uo.getSource(this.co()).setTileCacheSize(this.wl)},Hi.prototype.rP=function(){var t=this.map&&this.map.getLayerByClass("AMap.Inner.LabelsLayer");t&&t.aP()&&t.hide()},Hi.prototype.iP=function(){var t;if(this.map)for(var i=null==(t=this.map)?void 0:t.getLayers(),n=0;n<i.length;n++){var s=i[n];if("AMap.Buildings"===s.CLASS_NAME&&s.getState().u$)return s}};var Xi,Ji=Hi;function Hi(){var t=null!==Xi&&Xi.apply(this,arguments)||this;return t.CLASS_NAME="AMap.NebulaLayer",t}var Vi,qi="inner.labelsLayer",Qi="inner",$i=(Vi=s,_.Ei(tn,Vi),tn.prototype.getState=function(){return _.assign({},{layer:this,rejectMapMask:this._rejectMapMask},Vi.prototype.getLayerConfig.call(this))},tn.prototype.getSourceConfig=function(){return{id:Qi,type:Qi,tileUrl:AMap.getConfig().protocol+(_.Support.wasm?"://{vdata,vdata01,vdata02,vdata03,vdata04}.amap.com/nebula/v3":"://{vdata,vdata01,vdata02,vdata03,vdata04}.amap.com/nebula/v2"),tileSize:0,zooms:_.zoomRange}},tn.prototype.co=function(){return Qi},tn.prototype.sl=function(){this.source.reload(),this.Jh&&this.Jh.reset()},tn.prototype.vi=function(t,i){return void 0===i&&(i=!1),this.fz?this.fz.vi(t,this.hS,i):null},tn.prototype.Do=function(t){return t=Vi.prototype.Do.call(this,t),this.map&&this.uz(this.map),t},tn.prototype.aP=function(){var t,i=this.map;return!!i&&(t=i&&i.getLayerByClass("AMap.TileLayer.RoadNet"),i=i&&i.getLayerByClass("AMap.NebulaLayer"),t=t&&t.getVisible(),i=i&&i.getVisible(),!t)&&!i},tn.prototype.oP=function(){var t,i,n=this.map;return!!n&&(t=n&&n.getLayerByClass("AMap.TileLayer.RoadNet"),i=n&&n.getLayerByClass("AMap.NebulaLayer"),t=t&&t.getVisible(),i=i&&i.getVisible(),n.showLabel)&&(t||i)},tn.prototype.destroy=function(){this.Jh&&this.Jh.destroy&&(this.Jh.destroy(),delete this.Jh),this.source&&this.source.destroy&&(this.source.destroy(),delete this.source)},tn.prototype.uz=function(t){(this.fz=t.fS()).add(this)},tn);function tn(t){var i=Vi.call(this,t=void 0===t?{}:t)||this;return i.CLASS_NAME="AMap.Inner.LabelsLayer",i._opts={id:qi,type:qi,opacity:1,visible:1,collision:!0,allowCollision:!1},i._opts=_.assign({},i._opts,t),i.Qh=t.labelzIndex||100,i.il=!1!==t.showLabel,i.tl=void 0===t.opacity?1:t.opacity,i}nn=s,_.Ei(sn,nn),sn.prototype.getState=function(){return{ol:!0,al:!0,visible:this.il,opacity:this.tl,layer:this,zooms:this.xt,zIndex:this.Qh,rejectMapMask:this._rejectMapMask,depthTest:this.AF,ce:this.IF,HY:this.rX()}},sn.prototype.getLayerConfig=function(){var t=nn.prototype.getLayerConfig.call(this);return t.mapNumber="",t},sn.prototype.getSourceConfig=function(){return{id:"vectortraffic",type:"vectortraffic",tileUrl:"",tileSize:256,zooms:this.xt}},sn.prototype.co=function(){return"vectortraffic"},sn.prototype.destroy=function(){this.Jh&&this.Jh.destroy&&(this.Jh.destroy(),delete this.Jh)},sn.prototype.onAdd=function(){var t=this;this.map.on("styleChanged",this.reload,this),this.dl&&(this.iT=setInterval(function(){t.reload()},1e3*this.vl))},sn.prototype.v$=function(){this.map.off("styleChanged",this.reload,this),clearInterval(this.iT),delete this.iT},sn.prototype.reload=function(){var t=this.getSource();t&&this.map&&(t.reload(),this.map.setNeedUpdate(!0))},sn.prototype.rX=function(){var t,i=["fff93a43","fffcac19","ff20a962","ff83171c","ffadadad"];this.map&&(t=this.map.mapStyle.vn.MS("traffic"))&&t.multiFillColors&&((t=t.multiFillColors).congested&&(i[0]=t.congested),t.slow&&(i[1]=t.slow),t.smooth&&(i[2]=t.smooth),t.seriousCongested&&(i[3]=t.seriousCongested),t.unknown)&&(i[4]=t.unknown);for(var n=0,s=i.length;n<s;n++)i[n]=_.Util.qg(i[n]);return i};var nn;function sn(){var t=null!==nn&&nn.apply(this,arguments)||this;return t.vl=60,t.dl=!0,t}var en,rn={opacity:1,visible:!0,zIndex:4,zooms:[7,_.zoomRange[1]],dataZooms:[7,17],interval:60,ml:!0,depthTest:!1,rZ:1},Oi=(en=sn,_.Ei(hn,en),hn);function hn(t){var i=this;return(t=void 0===t?rn:t).id=_.Util.uuid(),t.opacity=(void 0===t.opacity?rn:t).opacity,t.visible=(void 0===t.visible?rn:t).visible,t.zIndex=(void 0===t.zIndex?rn:t).zIndex,t.zooms=(void 0===t.zooms?rn:t).zooms,t.interval=(void 0===t.interval?rn:t).interval,t.ml=(void 0===t.ml?rn:t).ml,t.depthTest=(void 0===t.depthTest?rn:t).depthTest,t.rZ=(void 0===t.rZ?rn:t).rZ,(i=en.call(this,t)||this).vl=Math.max(30,t.interval||i.vl),i.dl=void 0!==t.ml&&i.dl,i.CLASS_NAME="AMap.TileLayer.Traffic",i.onCreated(),i}on=s,_.Ei(an,on),an.prototype.getSourceConfig=function(){return{id:this._id||"tile",tileUrl:this._tileUrl||"",type:"raster",tileSize:this.Xa||256,zooms:this.xt,dataZooms:this.Qs||[7,17],projection:this.hl||"EPS3857"}},an.prototype.co=function(){return this._id},an.prototype.getState=function(){return{visible:this.il,opacity:this.tl,rejectMapMask:this._rejectMapMask,depthTest:this.AF,ce:this.IF,detectRetina:this.yl}},an.prototype.Hh=function(t){this.uo=t,this.uo.getSource(this.co()).setTileCacheSize(this.wl)};var on,ui=an;function an(t){var i=on.call(this,t)||this;return i.CLASS_NAME="AMap.RasterLayer",i._tileUrl=t.tileUrl,i.xt=t.zooms||_.zoomRange,i.Qs=t.dataZooms,i.tl=void 0===t.opacity?1:t.opacity,i.Qh=t.zIndex||1,i.il=void 0===t.visible||t.visible,i.Xa=t.tileSize||256,i.hl=t.projection,i.AF=void 0!==t.depthTest&&Boolean(t.depthTest),i.yl=void 0===t.detectRetina||Boolean(t.detectRetina),i.wl=t.cacheSize,i}var un,cn={id:"tile_"+_.Util.uuid(),tileUrl:void 0,zooms:_.zoomRange,dataZooms:[2,18],opacity:1,tileSize:256,visible:!0,projection:"EPSG:3857",zIndex:2},fn={id:"satellite"+_.Util.uuid(),tileUrl:"http://webst0{1,2,3,4}.is.autonavi.com/appmaptile?style=6&x=[x]&y=[y]&z=[z]",zooms:_.zoomRange,dataZooms:[3,18],opacity:1,tileSize:256,visible:!0,projection:"EPSG:3857",zIndex:2},ln={id:"traffic"+_.Util.uuid(),tileUrl:"http://tm.amap.com/trafficengine/mapabc/traffictile?v=1.0&t=1&zoom=[z]&x=[x]&y=[y]",zooms:[7,_.zoomRange[1]],dataZooms:[7,17],opacity:1,tileSize:256,visible:!0,projection:"EPSG:3857",zIndex:4,getTileUrl:function(t,i,n){return AMap.getConfig().protocol+"://tm.amap.com/trafficengine/mapabc/traffictile?v=1.0\\n&t=1&zoom="+(17-n)+"&x="+t+"&y="+i}},dn={id:"roadnet"+_.Util.uuid(),tileUrl:"http://wprd0{1,2,3,4}.is.autonavi.com/appmaptile?x=[x]&y=[y]&z=[z]&lang=zh_cn&size=1&scl=1&style=8&ltype=11",zooms:_.zoomRange,dataZooms:[3,18],opacity:1,tileSize:256,visible:!0,projection:"EPSG:3857",zIndex:3},vn={id:"flexible"+_.Util.uuid(),zooms:_.zoomRange,dataZooms:_.zoomRange,opacity:1,tileSize:256,visible:!0,projection:"EPSG:3857",zIndex:3},pn={id:"wms"+_.Util.uuid(),url:"",zooms:_.zoomRange,dataZooms:_.zoomRange,opacity:1,tileSize:512,visible:!0,projection:"EPSG:3857",zIndex:3},v=(un=ui,_.Ei(mn,un),mn.prototype.setTileUrl=function(t){t=0===(t=t.replace(/^\\/\\//,"").replace("http://","")).indexOf("http")?t:AMap.getConfig().protocol+"://"+t,this._tileUrl=t,this.reload()},mn.prototype.getTileUrl=function(){return this._tileUrl},mn.prototype.getLayerConfig=function(){var t="";return this._tileUrl!==AMap.getConfig().qT&&this._tileUrl!==AMap.getConfig().YT||(t="GS(2021)6375"),{id:this._id,tileUrl:this._tileUrl,zooms:this.xt,zIndex:this.Qh,opacity:this.tl,visible:this.il,getTileUrl:this.ll,mapNumber:t}},mn.prototype.reload=function(){var t=this.getSource();t&&(t.setTileUrl(this._tileUrl),t.reload(),t.Fo(!1),this.map)&&this.map.setNeedUpdate(!0)},_.dZ([_.pZ("TileLayer")],mn));function mn(t){var i=this,n={};return(t=void 0===t?cn:t).getTileUrl&&"string"==typeof t.getTileUrl&&(t.tileUrl=t.getTileUrl,delete t.getTileUrl),n.tileUrl=void 0===t.tileUrl?AMap.getConfig().y_:t.tileUrl,n.tileUrl&&(n.tileUrl=n.tileUrl.replace(/^\\/\\//,"").replace("http://","")),t&&t.name&&"AMap.TileLayer.Mark"===t.name||(n.tileUrl=n.tileUrl&&0===n.tileUrl.indexOf("http")?n.tileUrl:AMap.getConfig().protocol+"://"+n.tileUrl),n.id=t.id||"tile_"+_.Util.uuid(),n.tileSize=t.tileSize||cn.tileSize,"d"===_.Support.baseRender&&_.Support.$e&&(cn.dataZooms=[2,20]),n.dataZooms=t.dataZooms||cn.dataZooms,n.zooms=t.zooms||cn.zooms,n.projection=t.projection||cn.projection,n.opacity=(void 0===t.opacity?cn:t).opacity,n.visible=(void 0===t.visible?cn:t).visible,n.zIndex=(void 0===t.zIndex?cn:t).zIndex,n.rejectMapMask=t.rejectMapMask,n.depthTest=void 0!==t.depthTest&&Boolean(t.depthTest),n.map=t.map,n.detectRetina=void 0!==t.detectRetina&&t.detectRetina,n.cacheSize=t.cacheSize,(i=un.call(this,n)||this).type=t.type||"base",i.ll=t.getTileUrl,i.CLASS_NAME="AMap.TileLayer",i.onCreated(),i}yn=v,_.Ei(bn,yn),bn.prototype.getLayerConfig=function(){var t=yn.prototype.getLayerConfig.call(this);return t.mapNumber="GS京(2022)1061",t.OY=!0,t};var yn,li=bn;function bn(t){var i=this;return(t=void 0===t?fn:t).id="satellite_"+_.Util.uuid(),t.tileUrl=fn.tileUrl,t.zooms=(void 0===t.zooms?fn:t).zooms,t.opacity=(void 0===t.opacity?fn:t).opacity,t.visible=(void 0===t.visible?fn:t).visible,t.zIndex=(void 0===t.zIndex?fn:t).zIndex,(i=yn.call(this,t)||this).CLASS_NAME="AMap.TileLayer.Satellite",i.type=t.type||"base",i.onCreated(),i}gn=v,_.Ei(Mn,gn),Mn.prototype.ul=function(){clearInterval(this.cl)},Mn.prototype.pl=function(){var t=this;this.dl&&0<this.vl&&(this.cl=setInterval(function(){t.reload()},1e3*this.vl))};var gn,Ti=Mn;function Mn(t){var i=this;return(t=void 0===t?ln:t).id="traffic_"+_.Util.uuid(),t.tileUrl=ln.tileUrl,t.zooms=(void 0===t.zooms?ln:t).zooms,t.opacity=(void 0===t.opacity?ln:t).opacity,t.visible=(void 0===t.visible?ln:t).visible,t.zIndex=(void 0===t.zIndex?ln:t).zIndex,t.getTileUrl=t.getTileUrl||ln.getTileUrl,(i=gn.call(this,t)||this).vl=Math.max(30,t.interval||60),i.dl=void 0===t.ml||t.ml,i.CLASS_NAME="AMap.TileLayer.Traffic",i.type=t.type||"overlay",i.onCreated(),i.pl(),i}kn=v,_.Ei(wn,kn),wn.prototype.show=function(){kn.prototype.show.call(this);var t=this.map&&this.map.getLayerByClass("AMap.Inner.LabelsLayer");t&&t.oP()&&t.show()},wn.prototype.hide=function(){kn.prototype.hide.call(this);var t=this.map&&this.map.getLayerByClass("AMap.Inner.LabelsLayer");t&&t.aP()&&t.hide()},wn.prototype.v$=function(){kn.prototype.v$.call(this);var t=this.map&&this.map.getLayerByClass("AMap.Inner.LabelsLayer");t&&t.aP()&&t.hide()};var kn,Bt=wn;function wn(t){var i,n=this;return(t=void 0===t?dn:t).id="roadNet_"+_.Util.uuid(),t.tileUrl=dn.tileUrl,"d"===_.Support.baseRender&&(t.tileUrl=null==(i=t.tileUrl)?void 0:i.replace("&ltype=11","")),t.zooms=(void 0===t.zooms?dn:t).zooms,t.opacity=(void 0===t.opacity?dn:t).opacity,t.visible=(void 0===t.visible?dn:t).visible,t.zIndex=(void 0===t.zIndex?dn:t).zIndex,(n=kn.call(this,t)||this).CLASS_NAME="AMap.TileLayer.RoadNet",n.type=t.type||"overlay",n.onCreated(),n}xn=v,_.Ei(An,xn),An.prototype.getLayerConfig=function(){return{id:this._id,zooms:this.xt,zIndex:this.Qh,opacity:this.tl,visible:this.il,createTile:this.bl,cacheSize:this.wl,getTileUrl:this.ll,rejectMapMask:this._rejectMapMask}},An.prototype.Hh=function(t){this.uo=t,this.uo.getSource(this.co()).setTileCacheSize(this.wl)};var xn,Xt=An;function An(t){var i=this;return(t=void 0===t?vn:t).id=vn.id,t.id="flexible_"+_.Util.uuid(),t.zooms=(void 0===t.zooms?vn:t).zooms,t.opacity=(void 0===t.opacity?vn:t).opacity,t.visible=(void 0===t.visible?vn:t).visible,t.zIndex=(void 0===t.zIndex?vn:t).zIndex,(i=xn.call(this,t)||this).bl=t.createTile,i.CLASS_NAME="AMap.TileLayer.Flexible",i.type=t.type||"base",i.onCreated(),i}zn=v,_.Ei(Cn,zn),Cn.prototype._l=function(){this.kl.TileMatrixSet=this.kl.TileMatrixSet||"EPSG:3857",this.kl.Request="GetTile",this.kl.Service="WMTS",this.kl.Format=this.kl.Format||"image/png",this._tileUrl=this.Ml+"?"+_.Util.join(this.kl,"&"),this.map&&this.map.setNeedUpdate(!0)},Cn.prototype.setParams=function(t){this.kl=_.assign({},t),this._l()},Cn.prototype.getParams=function(){return this.kl},Cn.prototype.getUrl=function(){return this.Ml},Cn.prototype.setUrl=function(t){this.Ml=t,this._l()},Cn.prototype.getLayerConfig=function(){return{id:this._id,zooms:this.xt,zIndex:this.Qh,opacity:this.tl,visible:this.il,Ll:this.kl,createTile:this.bl,getTileUrl:this.ll}};var zn,hi=Cn;function Cn(t){var o=this;return(t=void 0===t?vn:t).id="wmts_"+_.Util.uuid(),t.cacheSize=vn.cacheSize,t.zooms=(void 0===t.zooms?vn:t).zooms,t.opacity=(void 0===t.opacity?vn:t).opacity,t.visible=(void 0===t.visible?vn:t).visible,t.zIndex=(void 0===t.zIndex?vn:t).zIndex,(o=zn.call(this,t)||this).kl=t.params||{},o.CLASS_NAME="AMap.TileLayer.WMTS",o.type=t.type||"base",o._tileUrl=t.url,o.Ml=t.url,o.bl=function(t,i,n,s,e){var r,h=document.createElement("img");"w"===(null==(r=o.map)?void 0:r.baseRender)&&(h.crossOrigin="anonymous"),h.onload=function(){s(h)},h.onerror=function(){e(h)},h.src=o._tileUrl+"&TileMatrix="+n+"&TileRow="+i+"&TileCol="+t},o._l(),o.onCreated(),o}Sn=v,_.Ei(Tn,Sn),Tn.prototype._l=function(){this.kl.WIDTH=this.Xa,this.kl.HEIGHT=this.Xa,this.kl.CRS=this.kl.CRS||"EPSG:3857",this.kl.REQUEST="GetMap",this.kl.SERVICE="WMS",this.kl.FORMAT=this.kl.FORMAT||"image/png",this.kl.TRANSPARENT=void 0===this.kl.TRANSPARENT?"true":this.kl.TRANSPARENT,delete this.kl.BBOX,this._tileUrl=this.Ml+"?"+_.Util.join(this.kl,"&")},Tn.prototype.setParams=function(t){this.kl=_.assign({},t),this._l()},Tn.prototype.getParams=function(){return this.kl},Tn.prototype.getUrl=function(){return this.Ml},Tn.prototype.setUrl=function(t){this.Ml=t,this._l()},Tn.prototype.getLayerConfig=function(){return{id:this._id,zooms:this.xt,zIndex:this.Qh,opacity:this.tl,visible:this.il,Ll:this.kl,createTile:this.bl,getTileUrl:this.ll}};var Sn,Ut=Tn;function Tn(t){var o=this;return(t=void 0===t?pn:t).id="wms_"+_.Util.uuid(),t.cacheSize=vn.cacheSize,t.zooms=(void 0===t.zooms?vn:t).zooms,t.opacity=(void 0===t.opacity?vn:t).opacity,t.visible=(void 0===t.visible?vn:t).visible,t.zIndex=(void 0===t.zIndex?vn:t).zIndex,(o=Sn.call(this,t)||this)._tileUrl=t.url,o.Ml=t.url,o.kl=t.params||{},o.CLASS_NAME="AMap.TileLayer.WMS",o.type=t.type||"base",o.bl=function(t,i,n,s,e){var r=[(n=2*_.x_/256/Math.pow(2,n)*o.Xa)*t-_.x_,_.x_-n*(i+1)],t=[n*(t+1)-_.x_,_.x_-n*i],h=document.createElement("img");"w"===(null==(n=o.map)?void 0:n.baseRender)&&(h.crossOrigin="anonymous"),h.onload=function(){s(h)},h.onerror=function(){e(h)},o._l(),h.src=o._tileUrl+"&BBOX="+r+","+t},o.bl=o.bl.bind(o),o.onCreated(),o}Ln=v,_.Ei(In,Ln),In.prototype.getLayerConfig=function(){return Ln.prototype.getLayerConfig.call(this)},In.prototype.getTileUrl=function(){return _.Util.getMarkUrl()};var Ln,Vt=In;function In(t){var i=this;return t.id="mark_"+_.Util.uuid(),t.tileUrl=_.Util.getMarkUrl(),t.zooms=[2,30],t.opacity=1,t.visible=!0,t.zIndex=999999,t.name="AMap.TileLayer.Mark",(i=Ln.call(this,t)||this).CLASS_NAME="AMap.TileLayer.Mark",i.type=t.type||"base",i.onCreated(),i}function Dn(){this.Wl=!0,this._position=_.Dl(),_.Pl(this._position,0,0,10),this.Gl=_.Dl(),_.Pl(this.Gl,0,0,-1),this.jl=_.Dl(),_.Pl(this.jl,0,0,-1),this.El=_.Dl(),_.Pl(this.El,0,1,0),this.Nl=_.Zl(),this.Fl=_.Il(),this.Bl=_.Il(),this.ql=_.Il(),this.Yl=_.Il()}v.RoadNet=Bt,v.Satellite=li,v.Traffic="d"===_.Support.baseRender?Ti:Oi,v.Flexible=Xt,v.WMTS=hi,v.WMS=Ut,v.Mark=Vt,Dn.prototype.lookAt=function(t){var i,n,s,e,r,h,o,a,u,c=_.Il(),f=_.Dl();_.Pl(this.jl,t[0],t[0],t[2]),f=_.Ol(f,this.Fl),c=_.lookAt(c,f,t,this.El),f=this.Nl,c=(t=c)[0],n=t[4],s=t[8],e=t[1],r=t[5],h=t[9],o=t[2],a=t[6],0<(u=c+r+(t=t[10]))?(i=.5/Math.sqrt(u+1),f[3]=.25/i,f[0]=(a-h)*i,f[1]=(s-o)*i,f[2]=(e-n)*i):r<c&&t<c?(i=2*Math.sqrt(1+c-r-t),f[3]=(a-h)/i,f[0]=.25*i,f[1]=(n+e)/i,f[2]=(s+o)/i):t<r?(i=2*Math.sqrt(1+r-c-t),f[3]=(s-o)/i,f[0]=(n+e)/i,f[1]=.25*i,f[2]=(h+a)/i):(i=2*Math.sqrt(1+t-c-r),f[3]=(e-n)/i,f[0]=(s+o)/i,f[1]=(h+a)/i,f[2]=.25*i),this.$l()},Dn.prototype.setPosition=function(t){_.Pl(this._position,t[0],t[1],t[2]),this.$l()},Dn.prototype.getPosition=function(){return this._position},Dn.prototype.$l=function(){var h,u,c,f,t=this.Fl,i=this._position,n=this.Nl,s=n[0],e=n[1],r=n[2],o=s*(c=s+s),a=s*(f=e+e);s*=h=r+r,u=e*f,e*=h,c*=n=n[3],f*=n,n*=h,t[0]=1-(u+(r*=h)),t[1]=a+n,t[2]=s-f,t[3]=0,t[4]=a-n,t[5]=1-(o+r),t[6]=e+c,t[7]=0,t[8]=s+f,t[9]=e-c,t[10]=1-(o+u),t[11]=0,t[12]=i[0],t[13]=i[1],t[14]=i[2],t[15]=1,_.Ul(this.Bl,this.Fl)},On=Gt=Dn,_.Ei(En,On),En.prototype.Vl=function(){var t=_.Il();return _.multiply(t,this.ql,this.Xl),_.multiply(t,t,this.Bl),t},En.prototype.setOptions=function(t,i,n,s,e,r){this.Hl=void 0!==t?t:-1,this.Jl=void 0!==i?i:1,this.Kl=void 0!==n?n:1,this.Ql=void 0!==s?s:-1,this.tu=void 0!==e?e:.1,this.iu=void 0!==r?r:1,this.eu()},En.prototype.scale=function(t){void 0===t&&(t=1);var i=_.Il();i.set([t,0,0,0,0,t,0,0,0,0,1,0,0,0,0,1]),_.multiply(this.Xl,this.Xl,i)},En.prototype.setRotation=function(t){var i=_.Il(),n=(t-this.nu)/180*Math.PI;0!==(this.nu=t)&&(i.set([Math.cos(n),-Math.sin(n),0,0,Math.sin(n),Math.cos(n),0,0,0,0,1,0,0,0,0,1]),_.multiply(this.Xl,this.Xl,i))},En.prototype.kt=function(t,i,n){var s,e,r,h,o,a;void 0!==t&&(s=t.Rt,e=t.zt,r=t.center,t=t.scale,h=_.Il(),a=_.Il(),o=_.Il(),h.set([1,0,0,0,0,1,0,0,0,0,1,0,e[0],e[1],0,1]),a.set([t,0,0,0,0,t,0,0,0,0,1,0,0,0,0,1]),o.set([1,0,0,0,0,1,0,0,0,0,1,0,-s[0],-s[1],0,1]),_.multiply(h,h,a),_.multiply(h,h,o),_.multiply(this.Xl,this.Xl,h),a=[(t=_.ProjectionManager.getProjection(i).project(r[0],r[1]))[0]-e[0]+s[0],t[1]-e[1]+s[1]],n(_.ProjectionManager.getProjection(i).unproject(a[0],a[1])))},En.prototype.Cu=function(){return this.Yl},En.prototype.lB=function(){return{left:this.Hl,right:this.Jl,top:this.Kl,bottom:this.Ql,rotation:this.nu,far:this.iu,near:this.tu,position:this._position}},En.prototype.eu=function(){var t=(this.Jl-this.Hl)/(2*this.bt),i=(this.Kl-this.Ql)/(2*this.bt),n=(this.Jl+this.Hl)/2,s=(this.Kl+this.Ql)/2;_.ou(this.ql,n-t,n+t,s-i,s+i,this.tu,this.iu),_.Ul(this.Yl,this.ql)};var On,Rn=En;function En(t,i,n,s,e,r){var h=On.call(this)||this;return h.type="OthoCamera",h.bt=1,h.nu=0,h.Xl=_.Il(),h.Hl=void 0!==t?t:-1,h.Jl=void 0!==i?i:1,h.Kl=void 0!==n?n:1,h.Ql=void 0!==s?s:-1,h.tu=void 0!==e?e:.1,h.iu=void 0!==r?r:1,h.eu(),h}Pn=_.Event,_.Ei(p,Pn),p.prototype.au=function(){return this.su},p.prototype.ru=function(){return _.ProjectionManager.getProjection(this.su)},p.prototype.setOptions=function(t,i){void 0===i&&(i=!0),t.projectionId&&(this.su=t.projectionId);var n=_.ProjectionManager.getProjection(this.su);if(t.center&&(this.hu=t.center,s=this.lu(n),e=n.unproject(s[0],s[1]),this.hu=e,_.Pl(this.uu,s[0],s[1],0),this.cu.setPosition(this.fu())),void 0!==t.zoom&&(t.zoom=Math.min(Math.max(t.zoom,this.map.getZooms()[0]),this.map.getZooms()[1]),this.pu=Math.pow(2,t.zoom-this.bt),this.bt=t.zoom,this.du=n.getResolution(this.bt),this.vu(),this.cu.setPosition(this.fu())),t.size&&(this.map.emit("resize"),this._size=t.size,this.vu()),void 0!==t.rotation&&"w"===_.Support.baseRender&&(360<t.rotation?t.rotation-=360:t.rotation<-360&&(t.rotation+=360),this.cu.setRotation(t.rotation),this.nu=t.rotation),t.kt){if(!this.map.getStatus().zoomEnable)return;var s,e,r=t.kt.Mt;this.mu=t.kt,r<=this.map.getZooms()[1]&&r>=this.map.getZooms()[0]&&(this.bt=r,this.du=n.getResolution(this.bt),r=(t=this.mu).Rt,t=t.zt,(s=this.lu(n))[0]=s[0]-t[0]+r[0],s[1]=s[1]-t[1]+r[1],e=n.unproject(s[0],s[1]),this.hu=e,_.Pl(this.uu,s[0],s[1],0),this.vu(),this.cu.setPosition(this.fu()),this.mu=void 0)}!this.h_()&&i&&this.map.setNeedUpdate(!0)},p.prototype.getOptions=function(){return{zoom:this.bt,center:this.hu,rotation:this.nu,projectionId:this.su,pitch:0}},p.prototype.getStatus=function(){var t=_.Zl(),i=_.Zl(),n=_.Zl(),s=(this.xu(t,i,n),_.Util.getOptimalZoom(this.bt));return{pitch:this.Pu,size:this._size,rotation:this.nu,zoom:this.bt,optimalZoom:s,resolution:this.du,optimalResolution:_.ProjectionManager.getProjection(this.su).getResolution(s),center:this.hu,bounds:t,boundsCoord:i,transformedBoundsCoord:n,centerCoord:this.uu,projectionId:this.su,mvpMatrix:this.cu.Vl(),viewMode:this.type,skyHeight:this.EF(),fov:60}},p.prototype.bu=function(t){this.hu=[t[0],t[1]],t=_.ProjectionManager.getProjection(this.su).project(this.hu[0],this.hu[1]),_.Pl(this.uu,t[0],t[1],0)},p.prototype.containerTolnglat=function(t,i,n){var s,r=(e=this.getStatus()).centerCoord,e=e.rotation,r=_.V[this.su].transform(r[0],r[1],n),h=(r=0!==e?(n=e/180*Math.PI,e=t-this._size[0]/2,s=-(i-this._size[1]/2),h=Math.sqrt(e*e+s*s),e=Math.atan(e/s)-n,s<0&&(e+=Math.PI),n=h*Math.sin(e),s=h*Math.cos(e),[r[0]+n*this.du,r[1]-s*this.du]):[r[0]+(t-this._size[0]/2)*this.du,r[1]+(i-this._size[1]/2)*this.du],r=_.V[this.su].Xs(r[0],r[1]),_.ProjectionManager.getProjection(this.su).unproject(r[0],r[1]));return h[0]=180<h[0]?h[0]-360:h[0]<-180?h[0]+360:h[0],h},p.prototype.lnglatToContainer=function(t,i,n,s){s=s||this.bt;var r=(e=this.getStatus()).rotation,e=e.centerCoord,i=[(t=_.ProjectionManager.getProjection(this.su).project(t,i))[0],t[1]],t={center:e,rotation:r,size:this._size};return _.V[this.su].wu(i[0],i[1],s,t)},p.prototype._u=function(t,i){(n=this.getStatus()).optimalZoom;var s=n.zoom,e=n.rotation,n={center:n.centerCoord,rotation:e,size:this._size};return _.V[this.su].wu(t,i,s,n)},p.prototype.ku=function(t,i){(n=this.getStatus()).optimalZoom,n.centerCoord,n.zoom,n.rotation;var n=this.containerTolnglat(t,i);return(t=_.ProjectionManager.getProjection(this.su)).project.apply(t,n)},p.prototype.h_=function(){return _.Ru(this.Xl,this.cu.Vl())},p.prototype.aD=function(){return this.Xl=this.cu.Vl(),this.Xl},p.prototype.EF=function(){return 1},p.prototype.pz=function(){return this.cu},p.prototype.xu=function(t,i,n){var s=this.nu/180*Math.PI,e=this._size,e=[(Math.abs(e[0]*Math.cos(s))+Math.abs(e[1]*Math.sin(s)))/2*this.du,(Math.abs(e[0]*Math.sin(s))+Math.abs(e[1]*Math.cos(s)))/2*this.du],s=_.ProjectionManager.getProjection(this.su),r=this.uu[0]-e[0],h=this.uu[0]+e[0],o=this.uu[1]-e[1],e=this.uu[1]+e[1],a=s.unproject(r,o),s=s.unproject(h,e),r=(i[0]=r,i[1]=o,i[2]=h,i[3]=e,t[0]=a[0],t[1]=a[1],t[2]=s[0],t[3]=s[1],_.V[this.su].transform(i[0],i[3])),o=_.V[this.su].transform(i[2],i[1]);return n[0]=r[0],n[1]=r[1],n[2]=o[0],n[3]=o[1],t},p.prototype.vu=function(){var i=(t=this._size)[0]*this.du,t=t[1]*this.du;this.cu.setOptions(-i/2,i/2,t/2,-t/2,1,11e5)},p.prototype.fu=function(){var t,i=_.Dl();return _.Util.getOptimalZoom(this.bt)<_.Ra?_.Pl(i,this.uu[0],this.uu[1],this.cz):(t=_.lcs.getDeltaCoord([this.uu[0],this.uu[1]]),_.Pl(i,t[0],t[1],this.cz)),i},p.prototype.lu=function(t){return this.hu[0]=180<this.hu[0]?this.hu[0]-360:this.hu[0]<-180?this.hu[0]+360:this.hu[0],t.project(this.hu[0],this.hu[1])};var Pn,jn=p;function p(t,i){var n=Pn.call(this)||this;return n.type="2D",n.Pu=0,n.hu=[0,0],n.bt=12,n._size=[0,0],n.pu=1,n.nu=0,n.cu=new Rn(-1,1,1,-1,10,1e3),n.su="EPSG:3857",n.uu=_.Dl(),n.cz=1e6,n.du=_.ProjectionManager.getProjection(n.su).getResolution(12),n.Xl=_.Il(),n.bt=void 0!==t.zoom?t.zoom:12,n.map=i,n.setOptions(t),n.vu(),n.Xl=n.cu.Vl(),n}Bn=Gt,_.Ei(m,Bn),m.prototype.Vl=function(){var t=[];return _.multiply(t,this.ql,this.zu),t},m.prototype.Su=function(){return this.ql},m.prototype.Cu=function(){return this.Yl},m.prototype.Lu=function(){return this.zu},m.prototype.Au=function(){return this.cu},m.prototype.setOptions=function(t,i,n,s,e){void 0===t&&(t=[1,1]),void 0===n&&(n=1),void 0===s&&(s=1),void 0===e&&(e=10),this.Tu=this.Iu(i=void 0===i?60:i),this.tu=s,this.iu=e,this.Du=n,this._size=t,this.eu()},m.prototype.setSize=function(t){this._size=t},m.prototype.setPitch=function(t){this.Pu=void 0!==t?t:this.Pu;var t=this._size[1]/2/Math.tan(this.Tu/2),i=this.Iu(this.Pu),n=this.Iu(this.nu),s=t*Math.sin(i),e=this.jl[0]-s*Math.sin(n),s=this.jl[1]-s*Math.cos(n),n=t*Math.cos(i);_.Pl(this._position,e,s,n),this.ju()},m.prototype.setRotation=function(t){this.nu=void 0!==t?-t:this.nu;var t=this.Iu(this.nu),i=Math.sin(t),t=Math.cos(t);_.Pl(this.El,i,t,0),this.Ou()},m.prototype.Fu=function(t,i,n){_.Pl(this.jl,t,i,n),this.ju()},m.prototype.Ou=function(t,i,n){void 0!==t&&void 0!==i?(_.Pl(this._position,t,i,void 0===n?this._position[2]:n),this.ju()):(t=this._size[1]/2/Math.tan(this.Tu/2),_.Pl(this._position,this.jl[0],this.jl[1],t),this.setPitch())},m.prototype.Eu=function(t){var i=this._size;this.cz=t||i[1]/2/Math.tan(this.Tu/2)||0,_.Pl(this._position,this._position[0],this._position[1],this.cz),this.setPitch()},m.prototype.Nu=function(t,i,n){_.Pl(this.El,t=void 0===t?0:t,i=void 0===i?1:i,n=void 0===n?0:n),this.ju()},m.prototype.dz=function(){return this.cz},m.prototype.lB=function(){return{fov:this.Tu,target:this.jl,up:this.El,position:this._position,far:this.iu,near:this.tu}},m.prototype.eu=function(){_.perspective(this.ql,this.Tu,this.Du,this.tu,this.iu),_.Ul(this.Yl,this.ql)},m.prototype.ju=function(){_.lookAt(this.zu,this._position,this.jl,this.El),_.Ul(this.cu,this.zu)},m.prototype.Iu=function(t){return t*Math.PI/180};var Bn,Wn=m;function m(t,i,n,s,e){void 0===t&&(t=[1,1]),void 0===i&&(i=60),void 0===n&&(n=1),void 0===s&&(s=10),void 0===e&&(e=2e4);var r=Bn.call(this)||this;return r.Wt="PerspectiveCamera",r.Pu=0,r.nu=0,r.cu=_.Il(),r.zu=_.Il(),r.cz=0,r.Tu=r.Iu(i),r.tu=s,r.iu=e,r.Du=n,_.Pl(r.El,0,1,0),r._size=t,r.eu(),r}Fn=_.Event,_.Ei(y,Fn),y.prototype.setOptions=function(t){var i=_.ProjectionManager.getProjection(this.su);if(t.projectionId&&(this.su=t.projectionId),t.size&&(this.map.emit("resize"),this._size=t.size,this.vu(),this.cu.Ou()),void 0!==t.rotation&&"w"===_.Support.baseRender&&(this.cu.setRotation(t.rotation),this.nu=t.rotation),void 0!==t.zoom&&(t.zoom=Math.min(Math.max(t.zoom,this.map.getZooms()[0]),this.map.getZooms()[1]),n=this.bt,this.bt=t.zoom,this.du=i.getResolution(this.bt),e=this.fu(),(_.Util.getOptimalZoom(t.zoom)<_.Ra&&_.Util.getOptimalZoom(n)>=_.Ra||_.Util.getOptimalZoom(t.zoom)>=_.Ra&&_.Util.getOptimalZoom(n)<_.Ra)&&(s=this.fu(),this.cu.Fu(s[0],s[1],0),this.cu.Ou(),this.vu()),this.cu.Fu(e[0],e[1],0),this.cu.Ou(),this.vu()),void 0!==t.pitch&&"w"===_.Support.baseRender&&(t.pitch>this.$u()||this.Pu>this.$u()?t.pitch=this.$u():(t.pitch<0||this.Pu<0)&&(t.pitch=0),this.Pu=Math.min(t.pitch,this.$u()),this.cu.setPitch(t.pitch)),t.center&&(this.hu=t.center,r=this.lu(i),_.Pl(this.uu,r[0],r[1],0),e=this.fu(),s=i.unproject(r[0],r[1]),this.hu=s,this.cu.Fu(e[0],e[1],0),this.cu.Ou()),t.kt){if(!this.map.getStatus().zoomEnable)return;var n=this.bt,n=(this.bt=Math.min(Math.max(t.kt.Mt,this.map.getZooms()[0]),this.map.getZooms()[1]),this.du=i.getResolution(this.bt),(_.Util.getOptimalZoom(t.kt.Mt)<_.Ra&&_.Util.getOptimalZoom(n)>=_.Ra||_.Util.getOptimalZoom(t.kt.Mt)>=_.Ra&&_.Util.getOptimalZoom(n)<_.Ra)&&(s=this.fu(),this.cu.Fu(s[0],s[1],0),this.cu.Ou()),this.lu(i)),s=t.kt.pos,i=this.X(s[0],s[1]),t=_.lcs.getLocalByCoord([n[0],n[1]]),e=(this.vu(),this.fu());this.cu.Fu(e[0],e[1],0),this.cu.Ou();var s=[(s=this.X(s[0],s[1]))[0]-i[0],s[1]-i[1]],i=[e[0]-s[0],e[1]-s[1]],r=[n[0]-s[0],n[1]-s[1]],e=_.lcs.getLocalByCoord(r);this.bt>=_.Ra&&(e.x!==t.x||t.y!==e.y)&&(n=e.x-t.x,s=e.y-t.y,i[0]-=n*_.lcs.getSize()[0],i[1]-=s*_.lcs.getSize()[1]),this.cu.Fu(i[0],i[1],0),this.cu.Ou(),this.bu(r)}this.h_()||this.map.setNeedUpdate(!0)},y.prototype.bu=function(t){var i=_.ProjectionManager.getProjection(this.su),i=(_.Pl(this.uu,t[0],t[1],0),i.unproject(t[0],t[1]));this.hu=i},y.prototype.getOptions=function(){return{size:this._size,zoom:this.bt,center:this.hu,rotation:this.nu,projectionId:this.su,pitch:this.Pu,resolution:this.du}},y.prototype.au=function(){return this.su},y.prototype.ru=function(){return _.ProjectionManager.getProjection(this.su)},y.prototype.getStatus=function(){var t=_.Zl(),i=_.Zl(),n=_.Zl(),s=(this.xu(t,i,n),_.Util.getOptimalZoom(this.bt));return{size:this._size,pitch:this.Pu,rotation:this.nu,zoom:this.bt,optimalZoom:s,resolution:this.du,optimalResolution:_.ProjectionManager.getProjection(this.su).getResolution(s),center:this.hu,bounds:t,boundsCoord:i,transformedBoundsCoord:n,centerCoord:this.uu,projectionId:this.su,mvpMatrix:this.cu.Vl(),modelMatrix:this.cu.Au(),viewMode:this.type,skyHeight:this.EF(),fov:this.cu.Tu}},y.prototype.$u=function(t){return 80},y.prototype.Uu=function(t){var t=void 0!==t?t:this.Pu,i=this.bt,t=Math.max(t/100-.4,0),i=Math.max(4*(i-22),0)/100;return this._size[1]*(t-i)-10},y.prototype.EF=function(){var t=1;return 0<(t=this.Uu())?1-t/this._size[1]*2:1},y.prototype.X=function(t,i){var n,s=this.cu.Cu(),e=this.cu.Au(),r=this._size;return t=t/r[0]*2-1,i=1-i/r[1]*2,s?(r=_.Bu(t,i,-1,1),this.Wu(r,this.tu),n=_.Zl(),_.Gu(n,r,s),r=_.Bu(t,i,1,1),this.Wu(r,this.iu),t=_.Zl(),_.Gu(t,r,s),i=_.Zl(),_.Gu(i,n,e),r=_.Zl(),_.Gu(r,t,e),s=+i[2]/(i[2]-r[2]),[i[0]-s*(i[0]-r[0]),i[1]-s*(i[1]-r[1])]):[0,0]},y.prototype.ku=function(t,i){var n=_.Util.getOptimalZoom(this.bt),s=this.uu,e=this.X(t,i);return t=e[0],i=e[1],n>=_.Ra&&(t+=(e=_.lcs.getLocalByCoord([s[0],s[1]])).center[0],i+=e.center[1]),[t,i]},y.prototype.H=function(t,i,n){void 0===n&&(n=0);var s=this.cu.Su(),e=this.cu.Lu(),t=((r=this.fG)[0]=t,r[1]=i,r[2]=n,this.uG),i=this.cG,n=(_.Gu(t,r,e),_.Gu(i,t,s),_.scale(i,i,1/i[3]),(i[0]+1)/2*this._size[0]),r=(1-i[1])/2*this._size[1];return this.lG(i),this.lG(t),[n,r]},y.prototype._u=function(t,i,n){void 0===n&&(n=0);var s=_.Util.getOptimalZoom(this.bt),e=this.uu;return s>=_.Ra&&(t-=(s=_.lcs.getLocalByCoord([e[0],e[1]])).center[0],i-=s.center[1]),this.H(t,i,n)},y.prototype.containerTolnglat=function(t,i){var t=this.X(t,i),i=0,n=0,s=(_.Util.getOptimalZoom(this.bt)>=_.Ra&&(i=(s=_.lcs.getLocalByCoord([this.uu[0],this.uu[1]]).center)[0],n=s[1]),t[0]+=i,t[1]+=n,_.ProjectionManager.getProjection(this.su).unproject(t[0],t[1]));return s[0]=180<s[0]?s[0]-360:s[0]<-180?s[0]+360:s[0],s},y.prototype.lnglatToContainer=function(t,i,n,s){return void 0===n&&(n=0),t=_.ProjectionManager.getProjection(this.su).project(t,i),_.Util.getOptimalZoom(this.bt)>=_.Ra&&(i=_.lcs.getLocalByCoord([this.uu[0],this.uu[1]]),t[0]-=i.center[0],t[1]-=i.center[1]),this.H(t[0],t[1],n)},y.prototype.pz=function(){return this.cu},y.prototype.h_=function(){return _.Ru(this.Xl,this.cu.Vl())},y.prototype.aD=function(){return this.Xl=this.cu.Vl(),this.Xl},y.prototype.xu=function(t,i,n){var s=0,e=0,r=this.Uu(),h=(_.Util.getOptimalZoom(this.bt)>=_.Ra&&(s=(h=_.lcs.getLocalByCoord([this.uu[0],this.uu[1]]).center)[0],e=h[1]),_.ProjectionManager.getProjection(this.su)),o=this.X(0,r),a=this.X.apply(this,this._size),r=this.X(this._size[0],r),u=this.X(0,this._size[1]),c=Math.min(o[0],u[0],r[0],a[0])+s,s=Math.max(o[0],u[0],r[0],a[0])+s,f=Math.min(o[1],u[1],r[1],a[1])+e,o=Math.max(o[1],u[1],r[1],a[1])+e,u=h.unproject(c,f),r=h.unproject(s,o),a=(i[0]=c,i[1]=f,i[2]=s,i[3]=o,t[0]=u[0],t[1]=u[1],t[2]=r[0],t[3]=r[1],_.V[this.su].transform(i[0],i[3])),e=_.V[this.su].transform(i[2],i[1]);return n[0]=a[0],n[1]=a[1],n[2]=e[0],n[3]=e[1],t},y.prototype.vu=function(){var t=this._size,i=t[0]*this.du,n=t[1]*this.du,s=(this.cu.setSize([i,n]),this.cu.Eu(),this.cu.dz()),s=(this.tu=s/10,this.iu=50*s,56-this.bt);this.cu.setOptions([i,n],s,t[0]/t[1],this.tu,this.iu),this.cu.Eu()},y.prototype.fu=function(){var t;return _.Util.getOptimalZoom(this.bt)<_.Ra?[this.uu[0],this.uu[1]]:[(t=_.lcs.getDeltaCoord([this.uu[0],this.uu[1]]))[0],t[1]]},y.prototype.lu=function(t){return this.hu[0]=180<this.hu[0]?this.hu[0]-360:this.hu[0]<-180?this.hu[0]+360:this.hu[0],t.project(this.hu[0],this.hu[1])},y.prototype.Wu=function(t,i){t[0]*=i,t[1]*=i,t[2]*=i,t[3]*=i},y.prototype.lG=function(t){for(var i=t.length,n=0;n<i;n++)t[n]=0};var Fn,Gn=y;function y(t,i){var n=Fn.call(this)||this;return n.type="3D",n.Pu=0,n.hu=[116.397128,39.916527],n.bt=12,n.tu=1e3,n.iu=1<<30,n._size=[0,0],n.nu=0,n.cu=new Wn,n.su="EPSG:3857",n.uu=_.Dl(),n.du=_.ProjectionManager.getProjection(n.su).getResolution(12),n.Xl=_.Il(),n.fG=[0,0,0,1],n.uG=[0,0,0,0],n.cG=[0,0,0,0],n.map=i,n.setOptions(t),n.cu.Ou(n.uu[0],n.uu[1]),n.Xl=n.cu.Vl(),n}var Nn={Fe:["water","buildings","sky","atmosphere","bg","traffic"],aX:{regions:{subType:{land:{styleMap:[{mainkey:30001,subkey:[1,4,5]}],name:["区域面","陆地"]},green:{styleMap:[{mainkey:30001,subkey:[3,7,8,9,10,12,37]}],name:["区域面","绿地"]},"water:ocean":{styleMap:[{mainkey:30001,subkey:[6]},{mainkey:10002,subkey:[38]}],name:["区域面","海洋"]},"water:watersystem":{styleMap:[{mainkey:30001,subkey:[2,11,13]},{mainkey:20014},{mainkey:10002,subkey:[13]}],name:["区域面","其他水系"]},edu:{styleMap:[{mainkey:30002,subkey:[3,31]},{mainkey:30005,subkey:[1,2,3,4,5,6]}],name:["区域面","教育体育"]},scenicSpot:{styleMap:[{mainkey:30002,subkey:[5,33,41]}],name:["区域面","景区"]},sports:{styleMap:[{mainkey:30002,subkey:[9,10,13,19,20,21,34,37,39]}],name:["区域面","运动场所"]},parkingLot:{styleMap:[{mainkey:30002,subkey:[1]}],name:["区域面","停车场"]},subway:{styleMap:[{mainkey:30003}],name:["区域面","地铁设施"]},servicearea:{styleMap:[{mainkey:30002,subkey:[42,43]}],name:["区域面","高速服务区"]},desert:{styleMap:[{mainkey:30002,subkey:[41]}],name:["区域面","沙漠沙地"]},culture:{styleMap:[{mainkey:30002,subkey:[7,35]}],name:["区域面","文化"]},public:{styleMap:[{mainkey:30002,subkey:[4,12,22,32,42,43]},{mainkey:30005,subkey:[7]}],name:["区域面","公共设施"]},health:{styleMap:[{mainkey:30002,subkey:[8,36]}],name:["区域面","医疗卫生"]},business:{styleMap:[{mainkey:30002,subkey:[11,23,24,25,26,27,28,29,30,38]}],name:["区域面","商业场所"]},transporthub:{styleMap:[{mainkey:30002,subkey:[6,14,40]},{mainkey:30004}],name:["区域面","交通枢纽"]}}},roads:{subType:{"highWay:highway":{styleMap:[{mainkey:20001,subkey:[1,5]}],name:["道路","高速"]},"highWay:highwayTunnel":{styleMap:[{mainkey:20001,subkey:[3]}],name:["道路","高速隧道"]},"highWay:highwayOthers":{styleMap:[{mainkey:20001,subkey:[2,6]}],name:["道路","高速其他路"]},"ringRoad:ringRoad":{styleMap:[{mainkey:20002,subkey:[1,5]}],name:["道路","环路"]},"ringRoad:ringRoadTunnel":{styleMap:[{mainkey:20002,subkey:[3]}],name:["道路","环路隧道"]},"ringRoad:ringRoadOthers":{styleMap:[{mainkey:20002,subkey:[2]}],name:["道路","环路其他路"]},"nationalRoad:nationalRoad":{styleMap:[{mainkey:20003,subkey:[1]}],name:["道路","国道"]},"nationalRoad:nationalRoadTunnel":{styleMap:[{mainkey:20003,subkey:[3]}],name:["道路","国道隧道"]},"nationalRoad:nationalRoadOthers":{styleMap:[{mainkey:20003,subkey:[2,5]}],name:["道路","国道其他路"]},"provincialRoad:provincialRoad":{styleMap:[{mainkey:20004,subkey:[1]}],name:["道路","省道"]},"provincialRoad:provincialRoadTunnel":{styleMap:[{mainkey:20004,subkey:[3]}],name:["道路","省道隧道"]},"provincialRoad:provincialRoadOthers":{styleMap:[{mainkey:20004,subkey:[2]}],name:["道路","省道其他路"]},secondaryRoad:{styleMap:[{mainkey:20007},{mainkey:20031},{mainkey:20032}],name:["道路","二级道路"]},levelThreeRoad:{styleMap:[{mainkey:20008}],name:["道路","三级道路"]},levelFourRoad:{styleMap:[{mainkey:20009},{mainkey:20026}],name:["道路","四级道路"]},roadsBeingBuilt:{styleMap:[{mainkey:20018},{mainkey:20023}],name:["道路","在建道路"]},railway:{styleMap:[{mainkey:20010,subkey:[1,3]}],name:["道路","铁路"]},highSpeedRailway:{styleMap:[{mainkey:20010,subkey:[2]}],name:["道路","高铁"]},subway:{styleMap:[{mainkey:20015,subkey:[3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,31,32,33,34,35,36,37,38,39,40,41,42,44,45,46,47,48,50,51,52,54,55,56,57,58,59,60,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,86,87,89,90,91,92,93,94,95,96,97,98,99,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190]}],name:["道路","地铁"]},subwayBeingBuilt:{styleMap:[{mainkey:20015,subkey:[1,2]},{mainkey:20019}],name:["道路","在建地铁"]},overPass:{styleMap:[{mainkey:20012}],name:["道路","天桥"]},underPass:{styleMap:[{mainkey:20013}],name:["道路","地道"]},other:{styleMap:[{mainkey:20011},{mainkey:20017},{mainkey:20020},{mainkey:20024},{mainkey:20028}],name:["道路","其他线路"]},guideBoards:{styleMap:[{mainkey:40001}],name:["道路","道路路牌"]}}},labels:{subType:{"building:officebuilding":{styleMap:[{mainkey:10001,subkey:[5,74,75,76,77,78,79]},{mainkey:10004,subkey:[12]}],name:["标注","商务大厦"]},"building:residence":{styleMap:[{mainkey:10001,subkey:[6,80,81]}],name:["标注","住宅"]},"building:landmark":{styleMap:[{mainkey:10007,subkey:[187,188,189,190,192,193,195,196,198]}],name:["标注","地标建筑"]},"repast:restaurant":{styleMap:[{mainkey:10001,subkey:[19,20,114,115,116,117,118,119]},{mainkey:10007,subkey:[179,180,181]},{mainkey:10010,subkey:[5,6]}],name:["标注","餐厅"]},"repast:tearoom":{styleMap:[{mainkey:10007,subkey:[167]}],name:["标注","茶馆"]},"repast:cafe":{styleMap:[{mainkey:10001,subkey:[22]},{mainkey:10007,subkey:[215]}],name:["标注","咖啡厅"]},"repast:dessert":{styleMap:[{mainkey:10007,subkey:[166]}],name:["标注","甜品店"]},"entertainment:mall":{styleMap:[{mainkey:10001,subkey:[7,68,82,83,84,85,93,94,98]},{mainkey:10004,subkey:[8,18]},{mainkey:10007,subkey:[175,200,201,202,203,204]}],name:["标注","购物商场"]},"entertainment:market":{styleMap:[{mainkey:10001,subkey:[8,92]},{mainkey:10007,subkey:[1,2,3,4,5,6,10,168]}],name:["标注","便利超市"]},"entertainment:cinema":{styleMap:[{mainkey:10001,subkey:[60]},{mainkey:10007,subkey:[178]}],name:["标注","影剧院"]},"entertainment:entertainment":{styleMap:[{mainkey:10001,subkey:[61,62]},{mainkey:10007,subkey:[169]}],name:["标注","娱乐场所"]},"entertainment:pedestrainmall":{styleMap:[{mainkey:10001,subkey:[99]}],name:["标注","步行街"]},"entertainment:hotel":{styleMap:[{mainkey:10001,subkey:[9,133,134,135,136]}],name:["标注","酒店"]},"entertainment:zoo":{styleMap:[{mainkey:10001,subkey:[38,103]}],name:["标注","动物园"]},"entertainment:funfair":{styleMap:[{mainkey:10001,subkey:[37,73,184,185,188,203,204,205]}],name:["标注","游乐场"]},"scenic:attraction":{styleMap:[{mainkey:10001,subkey:[4,12,104,105,106,107,108,109,110,111,112,120,167,168,171,213]},{mainkey:10004,subkey:[3,13,21]},{mainkey:10007,subkey:[48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,216,217,218,219,220,221,222,223,224,225,227,228,229,230,231,236]},{mainkey:10008}],name:["标注","风景名胜"]},"scenic:park":{styleMap:[{mainkey:10001,subkey:[14,69,100,101,102]}],name:["标注","公园"]},"scenic:mountain":{styleMap:[{mainkey:10001,subkey:[18]}],name:["标注","山"]},"traffic:busstop":{styleMap:[{mainkey:10001,subkey:[24]}],name:["标注","公交站"]},"traffic:port":{styleMap:[{mainkey:10001,subkey:[36]}],name:["标注","港口"]},"traffic:transporthub":{styleMap:[{mainkey:10001,subkey:[2,27,28,29,30,31,172,175]},{mainkey:10004,subkey:[4,10,14,20]}],name:["标注","交通枢纽"]},"traffic:trainstation":{styleMap:[{mainkey:10001,subkey:[26]}],name:["标注","火车站"]},"traffic:airportterminal":{styleMap:[{mainkey:10001,subkey:[23,176,177,178]},{mainkey:10009}],name:["标注","机场航站楼"]},"traffic:coachstation":{styleMap:[{mainkey:10001,subkey:[25]}],name:["标注","长途汽车站"]},culture:{styleMap:[{mainkey:10001,subkey:[10,11,13,35,138,139,140,141,142,143,163,164,165,166,170]},{mainkey:10004,subkey:[1,5,11,15]},{mainkey:10007,subkey:[43,44,45,46,47,176,177]}]},"service:lifestyle":{styleMap:[{mainkey:10001,subkey:[58,63,64,65,66,67,121,122,123,173,214]},{mainkey:10007,subkey:[28,29,30,58]}],name:["标注","生活服务"]},"service:bank":{styleMap:[{mainkey:10007,subkey:[14,15,16,17]}],name:["标注","银行"]},"service:restroom":{styleMap:[{mainkey:10001,subkey:[59]}],name:["标注","卫生间"]},"medical:medicalcenter":{styleMap:[{mainkey:10001,subkey:[70]},{mainkey:10004,subkey:[6,16]}],name:["标注","大型医院"]},"medical:hospital":{styleMap:[{mainkey:10001,subkey:[32,33,169,206,207,208,209,210]},{mainkey:10007,subkey:[170]}],name:["标注","医院"]},"medical:emergencycenter":{styleMap:[{mainkey:10001,subkey:[132]}],name:["标注","急救中心"]},"medical:clinic":{styleMap:[{mainkey:10001,subkey:[131]},{mainkey:10007,subkey:[209]}],name:["标注","诊所"]},"medical:pharmacy":{styleMap:[{mainkey:10001,subkey:[57]}],name:["标注","药店"]},"casual:golf":{styleMap:[{mainkey:10004,subkey:[7,17]}],name:["标注","高尔夫"]},"casual:swimmingpool":{styleMap:[{mainkey:10007,subkey:[171]}],name:["标注","游泳馆"]},"casual:basketballcourt":{styleMap:[{mainkey:10001,subkey:[129]}],name:["标注","篮球馆"]},"casual:soccerfield":{styleMap:[{mainkey:10001,subkey:[130]}],name:["标注","足球场"]},"casual:tenniscourt":{styleMap:[{mainkey:10007,subkey:[174]}],name:["标注","网球场"]},"casual:otherstadium":{styleMap:[{mainkey:10001,subkey:[15,16,17,124,125,126,127,128]},{mainkey:10007,subkey:[172,173]}],name:["标注","其他体育馆"]},"point:toll":{styleMap:[{mainkey:10001,subkey:[218]}],name:["标注","收费站"]},"point:trafficlight":{styleMap:[{mainkey:10001,subkey:[2]}],name:["标注","红绿灯"]},"point:tunnel":{styleMap:[{mainkey:10002,subkey:[16]}],name:["标注","隧道"]},insurance:{styleMap:[{mainkey:10001,subkey:[42,55]}],name:["标注","金融保险"]},motorcycleservices:{styleMap:[{mainkey:10001,subkey:[113]}],name:["标注","摩托车服务"]},automobileservices:{styleMap:[{mainkey:10001,subkey:[39,40,41,71,72]},{mainkey:10007,subkey:[40,41,42]}],name:["标注","汽车服务"]},subway:{styleMap:[{mainkey:10005},{mainkey:10006}],name:["标注","地铁站"]},transportfacilities:{styleMap:[{mainkey:10001,subkey:[149,150,215,216,217]},{mainkey:10002,subkey:[11]},{mainkey:11001,subkey:[1,2,3]},{mainkey:10004,subkey:[22,23]}],name:["标注","道路附属设施"]},bizcircle:{styleMap:[{mainkey:10002,subkey:[10]}],name:["标注","商圈"]},others:{styleMap:[{mainkey:10001,subkey:[1,3,34,43,137]},{mainkey:10002,subkey:[12,14,15,21,23,28,36]},{mainkey:10004,subkey:[2]},{mainkey:10007,subkey:[208,210,211,212,213,214]},{mainkey:10011},{mainkey:10012},{mainkey:10013},{mainkey:10014},{mainkey:10015},{mainkey:10016}],name:["标注","其他"]}}},districtsname:{subType:{continent:{styleMap:[{mainkey:10002,subkey:[20]}],name:["行政区名","大洲名"]},country_cn:{styleMap:[{mainkey:10002,subkey:[18]}],name:["行政区名","中国国家名"]},country_global:{styleMap:[{mainkey:10002,subkey:[19]}],name:["行政区名","世界国家名"]},capital_global:{styleMap:[{mainkey:10002,subkey:[24,35]}],name:["行政区名","境外首都名"]},state:{styleMap:[{mainkey:10002,subkey:[1,3,4,22,26,30,32,33,34]}],name:["行政区名","省/直辖市/特别行政区名"]},"city:provincial_capital":{styleMap:[{mainkey:10002,subkey:[2,31]}],name:["行政区名","省会名"]},"city:city":{styleMap:[{mainkey:10002,subkey:[5,7,25,27]}],name:["行政区名","地级市名"]},"city:district":{styleMap:[{mainkey:10002,subkey:[6]}],name:["行政区名","县级市名"]},district:{styleMap:[{mainkey:10002,subkey:[8,37]}],name:["行政区名","区县名"]},town:{styleMap:[{mainkey:10002,subkey:[9]}],name:["行政区名","乡镇名"]},village:{styleMap:[{mainkey:10002,subkey:[17]}],name:["行政区名","村庄名"]}}},borders:{subType:{global:{styleMap:[{mainkey:20016,subkey:[3,4,8,10,11,14]}],name:["行政区边界","外国国界/停火线/主张线"]},provincial:{styleMap:[{mainkey:20016,subkey:[5,6,7,12]}],name:["行政区边界","省界线"]}}},buildings:{subType:{default:{styleMap:[{mainkey:50001,subkey:[1,2]}],name:["楼块","默认楼块"]},education:{styleMap:[{mainkey:50002,subkey:[1,2,3,4]}],name:["楼块","高校教学"]}}},environment:{subType:{sky:{styleMap:[{mainkey:"00001",subkey:[1]}],name:["环境","天空"]},atmosphere:{styleMap:[{mainkey:"00001",subkey:[2]}],name:["环境","大气"]}}},bg:{styleMap:[{mainkey:"00001",subkey:[3]}]}},uX:{regions:{name:"区域面",subType:{land:{name:"陆地",keyMap:["regions#land"],styleMap:[{mainkey:30001,subkey:[1,4,5]}]},green:{name:"绿地",keyMap:["regions#green:greenspace","regions#green:grass","regions#green:woodland","regions#green:mountain","regions#green:golf"],styleMap:[{mainkey:30001,subkey:[3,7,8,9,10,12]}]},edu:{name:"教育体育",keyMap:["regions#edu"],styleMap:[{mainkey:30002,subkey:[3,31]}]},public:{name:"公共设施",keyMap:["regions#public"],styleMap:[{mainkey:30002,subkey:[4,12,22,32]}]},traffic:{name:"交通枢纽",keyMap:["regions#transporthub"],styleMap:[{mainkey:30002,subkey:[6,14,40]},{mainkey:30004,subkey:[6,14,40]}]},scenicSpot:{name:"景区",keyMap:["regions#scenicSpot"],styleMap:[{mainkey:30002,subkey:[5,33]}]},culture:{name:"文化",keyMap:["regions#culture"],styleMap:[{mainkey:30002,subkey:[7,35]}]},health:{name:"医疗卫生",keyMap:["regions#health"],styleMap:[{mainkey:30002,subkey:[8,36]}]},sports:{name:"运动场所",keyMap:["regions#sports"],styleMap:[{mainkey:30002,subkey:[9,10,13,19,20,21,34,37,39]}]},business:{name:"商业场所",keyMap:["regions#business"],styleMap:[{mainkey:30002,subkey:[11,23,24,25,26,27,28,29,30,38]}]},parkingLot:{name:"停车场",keyMap:["regions#parkingLot"],styleMap:[{mainkey:30002,subkey:[1]}]},subway:{name:"地铁设施",keyMap:["regions#subway"],styleMap:[{mainkey:30003,allSubKey:!0}]}}},water:{name:"水系",keyMap:["regions#water:ocean","regions#water:watersystem"],styleMap:[{mainkey:30001,subkey:[2,6,11,13]},{mainkey:20014,subkey:[1,2]},{mainkey:10002,subkey:[13,38]}]},buildings:{name:"建筑物",keyMap:["buildings#default","buildings#residence","buildings#education","buildings#life","buildings#event","buildings#landmark"],styleMap:[{mainkey:50001,subkey:[1,2]},{mainkey:50002,subkey:[1,2,3,4]},{mainkey:50003,subkey:[1]},{mainkey:50004,subkey:[1]},{mainkey:30002,subkey:[2,15,16,17,18]}]},roads:{name:"道路",subType:{highWay:{name:"高速公路",keyMap:["roads#highWay:highway","roads#highWay:highwayTunnel","roads#highWay:highwayOthers"],styleMap:[{mainkey:20001,subkey:[1,2,3,5,6]}]},ringRoad:{name:"城市环线",keyMap:["roads#ringRoad:ringRoad","roads#ringRoad:ringRoadTunnel","roads#ringRoad:ringRoadOthers"],styleMap:[{mainkey:20002,subkey:[1,2,3]}]},nationalRoad:{name:"国道",keyMap:["roads#nationalRoad:nationalRoad","roads#nationalRoad:nationalRoadTunnel","roads#nationalRoad:nationalRoadOthers"],styleMap:[{mainkey:20003,subkey:[1,2,3,5]}]},provincialRoad:{name:"省道",keyMap:["roads#provincialRoad:provincialRoad","roads#provincialRoad:provincialRoadTunnel","roads#provincialRoad:provincialRoadOthers"],styleMap:[{mainkey:20004,subkey:[1,2,3]}]},secondaryRoad:{name:"二级公路",keyMap:["roads#secondaryRoad"],styleMap:[{mainkey:20007,subkey:[1,2,3]}]},levelThreeRoad:{name:"三级公路",keyMap:["roads#levelThreeRoad"],styleMap:[{mainkey:20008,subkey:[1,2,4,5]}]},levelFourRoad:{name:"四级道路",keyMap:["roads#levelFourRoad"],styleMap:[{mainkey:20009,subkey:[1,2,3,5,6,7]}]},roadsBeingBuilt:{name:"在建道路",keyMap:["roads#roadsBeingBuilt"],styleMap:[{mainkey:20018,subkey:[2,3,4,5,6,7,8,9,10,11]}]},railway:{name:"铁路",keyMap:["roads#railway"],styleMap:[{mainkey:20010,subkey:[1]}]},highSpeedRailway:{name:"高铁",keyMap:["roads#highSpeedRailway"],styleMap:[{mainkey:20010,subkey:[2]}]},subway:{name:"地铁",keyMap:["roads#subway"],styleMap:[{mainkey:20015,allSubKey:!0,subkey0:[1,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,31,32,33,34,35,36,37,38,39,40,41,42,44,45,46,47,48,50,51,52,54,55,56,57,58,59,60,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,86,87,89,90,91,92,93,94,95,96,97,98,99,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,131,132,133,143]}]},subwayBeingBuilt:{name:"在建地铁",keyMap:["roads#subwayBeingBuilt"],styleMap:[{mainkey:20015,subkey:[1,2]},{mainkey:20019,subkey:[1]}]},overPass:{name:"天桥",keyMap:["roads#overPass"],styleMap:[{mainkey:20012,subkey:[1,2,3]}]},underPass:{name:"地道",keyMap:["roads#underPass"],styleMap:[{mainkey:20013,subkey:[1,2,3]}]},other:{name:"其他线条",keyMap:["roads#other"],styleMap:[{mainkey:20011,subkey:[1]},{mainkey:20017,subkey:[1,2,3,4,8]},{mainkey:20020,subkey:[1,2,3]},{mainkey:20024,subkey:[1,2]},{mainkey:20028,subkey:[1]}]},guideBoards:{name:"道路路牌",keyMap:["roads#guideBoards"],styleMap:[{mainkey:40001,subkey:[2800,110100,110101,110102,110103,110104,110105]}]}}},labels:{name:"标注",subType:{pois:{name:"兴趣点",subType:{hotel:{name:"住宿",keyMap:["labels#entertainment:hotel"],isDetailedType:!0,detailedCode:0,styleMap:[{mainkey:10001,subkey:[9,133,134,135,136,155,156,157,158,159,160,161,162,186]},{mainkey:10007,subkey:[31,32,33,34,35,36,37,38,39,164,165]}]},restaurant:{name:"餐饮",keyMap:["labels#repast:restaurant"],isDetailedType:!0,detailedCode:1,styleMap:[{mainkey:10001,subkey:[19,20,21,22,114,115,116,117,118,119,183,187]},{mainkey:10007,subkey:[1,2,3,4,166,167,168,179,180,181,203,205,206,215]}]},shop:{name:"购物",keyMap:["labels#entertainment:mall"],isDetailedType:!0,detailedCode:2,styleMap:[{mainkey:10001,subkey:[7,8,68,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99]},{mainkey:10007,subkey:[5,6,7,8,9,10,11,12,13,175,200,201,202,204]}]},scenicSpot:{name:"风景名胜",keyMap:["labels#repast:restaurant","labels#scenic:park"],isDetailedType:!0,detailedCode:3,styleMap:[{mainkey:10001,subkey:[4,12,14,38,69,100,101,102,103,104,105,106,107,108,109,110,111,112,120,167,171,188,189,190,191,192]},{mainkey:10008,allSubKey:!0},{mainkey:10007,subkey:[48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,187,188,190,192,193,194,195,196,198,216,217,218,219,220,221,223,224,225]}]},traffic:{name:"交通设施",isDetailedType:!0,detailedCode:4,styleMap:[{mainkey:10001,subkey:[23,24,25,26,31,36,148,154,168,172,175,176,177,178]},{mainkey:10002,subkey:[11,16]},{mainkey:10009,allSubKey:!0}]},bank:{name:"金融保险",isDetailedType:!0,detailedCode:5,styleMap:[{mainkey:10001,subkey:[42,44,45,46,47,48,49,50,51,52,53,54,55,144,145,146,147]},{mainkey:10007,subkey:[14,15,16,17,18,19,20,21,22,23,24,25,26,27]}]},edu:{name:"科教文化",isDetailedType:!0,detailedCode:6,styleMap:[{mainkey:10001,subkey:[10,11,13,35,138,139,140,141,142,143,163,164,165,166,170]},{mainkey:10007,subkey:[43,44,45,46,47,176,177]}]},live:{name:"生活服务",isDetailedType:!0,detailedCode:7,styleMap:[{mainkey:10001,subkey:[58,63,64,65,66,67,121,122,123]},{mainkey:10007,subkey:[28,29,30]}]},hospital:{name:"医疗保健",isDetailedType:!0,detailedCode:8,styleMap:[{mainkey:10001,subkey:[32,33,57,70,131,132,169,193,206,207,208,209,210]},{mainkey:10007,subkey:[170,209]}]},pe:{name:"休闲体育",isDetailedType:!0,detailedCode:9,styleMap:[{mainkey:10001,subkey:[15,16,17,37,60,61,62,73,124,125,126,127,128,129,130,180,181,182,184,185,194,195,196,197,198,199,200,201,202,203,204,205,213,214]},{mainkey:10007,subkey:[169,171,172,173,174,178,197,207]}]},public:{name:"公共设施",isDetailedType:!0,detailedCode:10,styleMap:[{mainkey:10001,subkey:[59,173,215]}]},buidling:{name:"商务住宅",isDetailedType:!0,detailedCode:11,styleMap:[{mainkey:10001,subkey:[5,6,74,75,76,77,78,79,80,81,179]},{mainkey:10007,subkey:[189,191]}]},gov:{name:"政府机构及社会团体",isDetailedType:!0,detailedCode:12,styleMap:[{mainkey:10001,subkey:[3,34,43,137]}]},moto:{name:"摩托车服务",isDetailedType:!0,detailedCode:13,styleMap:[{mainkey:10001,subkey:[113]}]},vehicle:{name:"汽车服务",isDetailedType:!0,detailedCode:14,styleMap:[{mainkey:10001,subkey:[39,40,41,71,72,151,152,153]},{mainkey:10007,subkey:[40,41,42,182,183,184,185,186]}]},pass:{name:"通行设施",isDetailedType:!0,detailedCode:15,styleMap:[{mainkey:10001,subkey:[27,28,149,150,174]},{mainkey:10002,subkey:[21]}]},subway:{name:"地铁站",isDetailedType:!0,detailedCode:16,styleMap:[{mainkey:10005,subkey:[1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,54,55,56,57,59,86,87,88,89,90,91,92,93,94,95,96,97,98,99,103,104,105]},{mainkey:10006,subkey:[1,2]}]},roadFacilities:{name:"道路附属设施",isDetailedType:!0,detailedCode:17,styleMap:[{mainkey:10001,subkey:[2,29,30]},{mainkey:10017,allSubKey:!0}]},address:{name:"地名",isDetailedType:!0,detailedCode:18,styleMap:[{mainkey:10001,subkey:[18]},{mainkey:10002,subkey:[10,12,14,15,23,36]}]},other:{name:"其他",isDetailedType:!0,detailedCode:19,styleMap:[{mainkey:10001,subkey:[1,211,212]},{mainkey:10002,subkey:[28]},{mainkey:10007,subkey:[208,210,211,212,213,214]},{mainkey:10010},{mainkey:10011},{mainkey:10012},{mainkey:10013},{mainkey:10014},{mainkey:10015},{mainkey:10016,allSubKey:!0}]}}},aois:{name:"区域标注",keyMap:["labels#building:officebuilding","labels#entertainment:mall","labels#traffic:transporthub","labels#medical:medicalcenter","labels#casual:golf"],styleMap:[{mainkey:10004,allSubKey:!0,subkey:[1,3,4,5,6,7,8,11,12,13,14,15,16,17,18,21,22,23]}]},continent:{name:"大洲",keyMap:["districtsname#continent"],styleMap:[{mainkey:10002,subkey:[20]}]},country:{name:"国家",keyMap:["districtsname#country_cn"],styleMap:[{mainkey:10002,subkey:[18,19,29]}]},province:{name:"省/直辖市/自治区/特别行政区",keyMap:["districtsname#state"],styleMap:[{mainkey:10002,subkey:[22,26,33]}]},city:{name:"城市",keyMap:["districtsname#city:provincial_capital","districtsname#city:city"],styleMap:[{mainkey:10002,subkey:[1,2,3,4,5,7,24,25,27,30,31,32,34,35]}]},district:{name:"区县",keyMap:["districtsname#city:district"],styleMap:[{mainkey:10002,subkey:[6,8,37]}]},town:{name:"乡镇",keyMap:["districtsname#town"],styleMap:[{mainkey:10002,subkey:[9]}]},village:{name:"村庄",keyMap:["districtsname#village"],styleMap:[{mainkey:10002,subkey:[17]}]}}},borders:{name:"行政区边界",subType:{China:{name:"中国国界",keyMap:["borders#China"],styleMap:[{mainkey:20016,subkey:[1,2,9]}]},foreign:{name:"外国国界/停火线/主张线",keyMap:["borders#global"],styleMap:[{mainkey:20016,subkey:[3,4,8,10,11,14,16]}]},provincial:{name:"省界线",keyMap:["borders#provincial"],styleMap:[{mainkey:20016,subkey:[5,6,7,12]}]}}},sky:{name:"天空",keyMap:["environment#sky"],styleMap:[{mainkey:"00001",subkey:[1]}]},atmosphere:{name:"大气",keyMap:["environment#atmosphere"],styleMap:[{mainkey:"00001",subkey:[2]}]},bg:{name:"背景网格线",keyMap:["bg"],styleMap:[{mainkey:"00001",subkey:[3]}]}}},_n=(Un.prototype.pn=function(t){this.qe?t(this.ON):this.Ye.push(t)},Un.prototype.dn=function(t,i,n){return this.vn.dn(t,i,n)},Un.prototype.mn=function(t,i){return this.vn.mn(t,i)},Un.prototype.setStyle=function(t,i,n){var s=t;this.vn.setStyle(s),t.layer&&this.vn.EY(t.layer),this.vn.kF(t),n.gn.bn(s,function(){n.emit("styleChanged")})},Un.prototype.setStyleByPlat=function(t,i){var n;_.Module.eS.BY&&(n=this.xn(t),this.vn.setStyle(n),t.layer&&this.vn.EY(t.layer),this.vn.kF(t),i.gn.bn(n,function(){i.emit("styleChanged")}))},Un.prototype.destroy=function(){this.vn&&this.vn.destroy(),this.Ze={},this.ON=""},Un.prototype.w_=function(t){var i;return this.Ze&&this.Ze[t]?(i=[],Object.keys(this.Ze[t]).forEach(function(t){t=parseFloat(t),i.push(t)}),i):null},Un.prototype.VY=function(t){var t={style:t},i=new XMLHttpRequest;i.onreadystatechange=function(){4===i.readyState&&200===i.status?console.log("qqqqq"):404===i.status&&i.abort()},i.open("POST","http://webapi.amap.com/formatstyle"),i.setRequestHeader("Content-type","application/json"),i.send(JSON.stringify(t))},Un.prototype.xn=function(t){for(var i={},n=t.version&&"2.0"===t.version?t.mapStyle:t,s=t.version&&"2.0"===t.version?Nn.aX:Nn.uX,e=Object.keys(n),r=0;r<e.length;r++){var h=e[r],o=n[h];if(s[h]){var a=s[h];if(a.styleMap){for(var u=a.styleMap,c=0;c<u.length;c++)if(i[A=u[c].mainkey]||(i[A]={}),u[c].subkey)for(var f=0;f<u[c].subkey.length;f++){var l=u[c].subkey[f],d=_.yn(o);if(o.styles)for(var v=Object.keys(o.styles),p=0;p<v.length;p++){var m=v[p],y=o.styles[m].transitional,b=o.styles[m].nodes;d.styles[m]={nodes:b,transitional:y||void 0,nodesObj:{}};for(var g=0;g<b.length;g++){var M=b[g].zoom,k=b[g].value;d.styles[m].nodesObj[M]=k}}i[A][l]=d}}else if(a.subType&&o.subType)for(var w=Object.keys(o.subType),c=0;c<w.length;c++){var x=w[c];if(a.subType[x]&&a.subType[x].styleMap){for(u=a.subType[x].styleMap,f=0;f<u.length;f++)if(u[f].mainkey){i[A=u[f].mainkey]||(i[A]={});var A,z=u[f].subkey;if(z=(u[f].allSubKey?this.w_(A):z)||["all"])for(var C=0;C<z.length;C++){var l=z[C],S=o.subType[x];if((d=_.yn(S)).styles)for(v=Object.keys(S.styles),p=0;p<v.length;p++)for(m=v[p],y=S.styles[m].transitional,b=S.styles[m].nodes,d.styles[m]={nodes:b,nodesObj:{},transitional:y||void 0},g=0;g<b.length;g++)M=b[g].zoom,k=b[g].value,d.styles[m].nodesObj[M]=k;i[A][l]=d}}}else if(a.subType[x]&&a.subType[x].subType)for(var T=a.subType[x].subType,j=Object.keys(T),S=o.subType[x],d=_.yn(S),L=0;L<j.length;L++){var I=j[L];if(T[I].styleMap)for(var D=0;D<T[I].styleMap.length;D++){var O=T[I].styleMap[D];if(O.mainkey&&O.subkey){i[O.mainkey]||(i[O.mainkey]={});for(var R=0;R<O.subkey.length;R++){var B=O.subkey[R];if(d.detailedType&&d.detailedType[I]){var E=d.detailedType[I],P=_.yn(E);if(E.styles)for(v=Object.keys(E.styles),p=0;p<v.length;p++)for(m=v[p],b=E.styles[m].nodes,P.styles[m]={nodes:b,nodesObj:{}},g=0;g<b.length;g++)M=b[g].zoom,k=b[g].value,P.styles[m].nodesObj[M]=k;i[O.mainkey][B]=P}else i[O.mainkey][B]=d}}}}}}}return i},Un.prototype.wn=function(t){for(var i=0,n=this.Ye.length;i<n;i+=1)(0,this.Ye[i])(t);this.Ye=[]},Un.prototype.fn=function(t){var i=this,n=(_.Support.amapRunTime&&!_.Support.amapRunTime["style2.0-request"]&&(_.Support.amapRunTime["style2.0-request"]=(new Date).getTime()),window.amap_sdk_log&&window.amap_sdk_log("style-request:"+t+"-"+Date.now()),new XMLHttpRequest);n.onreadystatechange=function(){4===n.readyState&&200===n.status?(_.Support.amapRunTime&&!_.Support.amapRunTime["style2.0-loaded"]&&(_.Support.amapRunTime["style2.0-loaded"]=(new Date).getTime()),window.amap_sdk_log&&window.amap_sdk_log("style-loaded:"+t+"-"+Date.now()),i.zZ(n.response),_.Support.amapRunTime&&!_.Support.amapRunTime["style2.0-decoded"]&&(_.Support.amapRunTime["style2.0-decoded"]=(new Date).getTime()),window.amap_sdk_log&&window.amap_sdk_log("style-decoded:"+t+"-"+Date.now())):404===n.status&&n.abort()},n.open("GET",t,!0),n.responseType="arraybuffer",n.send()},Un.prototype.zZ=function(t){_.Support.amapRunTime&&!_.Support.amapRunTime["style2.0-parseStylesFromText-End"]&&(_.Support.amapRunTime["style2.0-parseStylesFromText-End"]=(new Date).getTime()),t=_.CZ(t),_.Support.amapRunTime&&!_.Support.amapRunTime["style2.0-jsonParse-End"]&&(_.Support.amapRunTime["style2.0-jsonParse-End"]=(new Date).getTime()),window["amapjsapi-style2-local"]?this.Ze=window["amapjsapi-style2-local"]:this.Ze=_.StyleParser.SZ(t),_.Support.amapRunTime&&!_.Support.amapRunTime["style2.0-format-End"]&&(_.Support.amapRunTime["style2.0-format-End"]=(new Date).getTime()),this.vn.jY(this.Ze),this.Ze.Rn=_._n.create("fcf9f2"),this.Ze.zn=24,this.qe=!0,this.ON=JSON.stringify(this.Ze),this.wn(this.ON)},Un);function Un(t){this._map=t,this.vz=null,this.qe=!1,this.Ne=_.Support.$e&&!_.Support.Ue,this._tileUrl=window.__AMapStyleSource||_.Ge||AMap.getConfig().protocol+"://vdata.amap.com/style/2.0.1",this.Ze={},this.Ye=[],this.Ve=null,this.fn(this._tileUrl),this.vn=new _.StyleParser("fast"===t.bZ.MZ.drawMode)}Yn=_.vG,_.Ei(b,Yn),b.prototype.getData=function(t,i){for(var n=this,s=[],e=0,r=t;e<r.length;e++){var h=r[e];s.push(h.charCodeAt(0).toString())}var o=this.Zu(s),a=this._map.gn;switch(o.status){case _.qu.AllLoaded:i();break;case _.qu.AllUnLoaded:var u=this.Yu(i);a&&a.getSDFData(o.Vu,function(t,i){n.Xu[u]=i=void 0===i?{}:i,n.Hu()});break;case _.qu.SomeLoading:var c=this.Yu(i);a&&a.getSDFData(o.Vu,function(t,i){n.Xu[c]=i=void 0===i?{}:i,n.Hu()});break;case _.qu.AllLoading:var f=this.Yu(i);this.Xu[f]=[],this.Hu()}},b.prototype.Ju=function(t){for(var i={},n=0,s=t;n<s.length;n++){var r=(e=s[n]).range,h=e.info,e=e.pos,o=this.info;o[r],o[r]={info:((o={})[r]=h,o),pos:e},this.range.push(r),i[r]=1}return i},b.prototype.mz=function(t,i){var n=this.info||[];return!(i=void 0===i?!1:i)&&n.hasOwnProperty(t)&&(i=n[t]).pos&&i.info[t]?{key:t,index:_.cY.dynamic,char:i.info[t],pos:i.pos}:null},b.prototype.measureText=function(t,i){for(var n=_.PY,s=_.tc.ic,e=0,r=this.info,h=i/this._size,o=this.nc,a=0,u=t;a<u.length;a++){var c=u[a],f=void 0,l=c;(f=13312<=l&&l<=40959?n:o[l])||r.hasOwnProperty(l)&&(l=r[l].info[l])&&(this.nc[c]=f=l[4]),e+=(f+s)*h}return e},b.prototype.destroy=function(){this.range=[],this.info={},this.sc=[],this.Xu&&(this.Xu={}),this._c=[],this.nc={},this.xc=[],this.bc={},this.Xu={}},b.prototype._bindEvents=function(){this.dG.on("loadWordsByFront",this.pG.bind(this))},b.prototype.fc=function(){var t=_.tc.pc,i=t[this.dc];return this.dc=(this.dc+1)%t.length,i},b.prototype.vc=function(t){void 0===t&&(t={});var i=(t=(Object.keys(t)||[]).sort(function(t,i){return t-i})).length;return 2<=i?t[0]+"-"+t[i-1]:1===i?t[0]:""},b.prototype.mc=function(){},b.prototype.Yu=function(t,i){void 0===i&&(i={});var n=this.yc+=1;return this.xc.push(n),this.bc&&(this.bc[n]=t,this.bc[n]={cb:t,params:i}),n},b.prototype.Hu=function(){var t,i,n=this.xc[0];n&&(t=this.Xu[n])&&(this.xc.shift(),(i=this.bc[n])?i.cb(t):console.error("sdf task error"),delete this.Xu[n],delete this.bc[n],this.Hu())},b.prototype.gc=function(t){for(var i=this.range||[],n=this.info||{},s=parseInt(t,10),e=0,r=i;e<r.length;e++){var h=r[e];if(h.indexOf("-")<0){if(s===+h&&(n[h]&&n[h].info||{})[t])return!0}else{var o=h.split("-"),a=parseInt(o[0]||"",10),o=parseInt(o[1]||"",10);if(a<=s&&s<=o&&(n[h]&&n[h].info||{})[t])return!0}}return!1},b.prototype.pG=function(t){var i=this,n=t.mG,s=t.cb,t=this._map.bZ.MZ.lY.add("LangSDF",n);this._map.bZ.MZ.yY.setNeedUpdate(!0),this._map.bZ.MZ.lY.on("task:"+t,function(t){t=i._map.bZ.MZ.lY.add("SDFCombine",t.data),i._map.bZ.MZ.yY.setNeedUpdate(!0),i._map.bZ.MZ.lY.on("task:"+t,function(t){i.Ju(t.data),s(t.data)},i,!0)},this,!0)},b.prototype._G=function(t){for(var i="",n=0,s=t.split("|");n<s.length;n++){var e=s[n];i+=String.fromCharCode(parseInt(e,10))}return i},b.prototype.wc=function(t){return-1!==this._c.indexOf(t)},b.prototype.Zu=function(t){for(var i=[],n=(this.range,0),s=0,e=0,r=t;e<r.length;e++){var h=r[e];this.gc(h)||(this.wc(h)?s+=1:(n+=1,i.push(h)))}return 0===s&&0===n?{status:_.qu.AllLoaded,Vu:i}:0<n&&0===s?{status:_.qu.AllUnLoaded,Vu:i}:0===n&&0<s?{status:_.qu.AllLoading,Vu:i}:{status:_.qu.SomeLoading,Vu:i}};var Yn,Zn=b;function b(t,i){var n=Yn.call(this)||this;return n._map=i,n.CLASS_NAME="SDFManager",n.range=[],n.info={},n.sc=[],n.dc=0,n._c=[],n._size=24,n.nc={},n.xc=[],n.bc={},n.Xu={},n.yc=1,n.ac=t,n.yG=new _.bG,n.dG=n._map.gn,n._bindEvents(),n}Jn.prototype.play=function(t){for(var i=t,n=Date.now(),s=this.result;0<i&&this.offset<this.mG.length;){var e=this.mG[this.offset],r={},h=this._G(e),o=_.bG.gG(e),h=(o=this.lang.D$(o).Ce(h)).bitmap,o=o.info;r.range=e,r.info=o,r.data=h,s.push(r),this.offset++,i=t-(Date.now()-n)}return this.result},Jn.prototype._G=function(t){for(var i="",n=0,s=t.split("|");n<s.length;n++){var e=s[n];i+=String.fromCharCode(parseInt(e,10))}return i},Object.defineProperty(Jn.prototype,"status",{get:function(){return this.offset>=this.mG.length?_.vY.finish:_.vY.pause},eb:!1,nb:!0});var Xn=Jn;function Jn(t,i){this.lang=t,this.mG=i,this.type="LangSDFTask",this.offset=0,this.result=[]}var Hn={Fdt:["vdata.amap.com","pre-lbs-jsapi-vdata.amap.com"],Gdt:function(i){return Hn.Fdt.some(function(t){return-1<i.indexOf(t)&&-1===i.indexOf("key=")})},getKeyUrl:function(t,i){return Hn.Gdt(t)&&(-1<t.indexOf("?")?t+="&key="+i:t+="?key="+i),t}},Vn=(qn.prototype.loadImage=function(t,i,n){var s=i.name,e=(i.type,i.cb),r=this.Fs[s=s||t];r&&r.status===_.uc.LOADED?e(r,i):r&&r.status===_.uc.LOADING?(this.Mc[s]||(this.Mc[s]=[]),this.Mc[s].push({cb:e,opts:i})):t?this.Rc(t,i,n):e(null,i)},qn.prototype.TZ=function(t,i){this.Rc(t.data,{name:t.hash,cb:i})},qn.prototype.loadImages=function(t,i,n){var s=t.length,e=i.cb,r=0;if(t.length){i.cb=function(){(r+=1)===s&&e()};for(var h=0,o=t;h<o.length;h++){var a=o[h];this.loadImage(a,i,n)}}else e()},qn.prototype.imageLoaded=function(t,i){var n=i.data,i=i.cb,s=this.zc[i];s&&(s(n),delete this.zc[i])},qn.prototype.addImageData=function(t,i){this.Fs[t]||(this.Fs[t]=i)},qn.prototype.getImage=function(t){return this.Fs[t=void 0===t?"":t]||{}},qn.prototype.destory=function(){this.Fs={},this.Mc&&(this.Mc={}),this.zc&&(this.zc={})},qn.prototype.Rc=function(t,e,i){var r=this,n=e.name,h=e.ext,s=e.type,o=void 0===s?"other":s,a=e.cb,u=this.Fs,c=new Image,f=n||t;u[f]={type:o,img:c,ext:h,width:c.width,height:c.height,status:_.uc.LOADING},c.crossOrigin="anonymous",c.onload=function(){if(e.imageBitmap)createImageBitmap(c).then(function(t){if(u[f]={type:o,img:t,ext:h,width:t.width,height:t.height,status:_.uc.LOADED},a(u[f],e),r.Mc[f])for(var i=0,n=r.Mc[f];i<n.length;i++){var s=n[i];s.cb(u[f],s.opts)}c.onload=null,c.onerror=null});else{if(u[f]={type:o,img:c,ext:h,width:c.width,height:c.height,status:_.uc.LOADED},a(u[f],e),r.Mc[f])for(var t=0,i=r.Mc[f];t<i.length;t++){var n=i[t];n.cb(u[f],n.opts)}c.onload=null,c.onerror=null}},c.onerror=function(){a(null,e),c.onload=null,c.onerror=null},t=Hn.getKeyUrl(t,i),c.src=t},qn.prototype.Sc=function(t){var i,n=(n=(t=void 0===t?{}:t).img)&&n.context?(i=n.width||0,n.height||0):(i=t.width||0,t.height||0);return[i,n]},qn);function qn(){this.Fs={},this.Cc=16,this.zc={},this.Mc={}}var Kn,Qn=0;function $n(t){var i=Kn.call(this,t=void 0===t?{}:t)||this;return i.CLASS_NAME="AMap.VectorLayer",i.zF="AMap.VectorLayer"+Qn++,i.pC=!1,i.Qh=t.zIndex||110,i}Kn=s,_.Ei($n,Kn),$n.prototype.add=function(t){for(var i=0,n=t=Array.isArray(t)?t:[t];i<n.length;i++){var s=n[i];this.source.add(s)}},$n.prototype.remove=function(t){for(var i=0,n=t=Array.isArray(t)?t:[t];i<n.length;i++){var s=n[i];this.source.remove(s)}},$n.prototype.getSourceConfig=function(){return{id:this.zF,type:"overlay",url:""}},$n.prototype.co=function(){return this.zF},$n.prototype.getState=function(){return{visible:this.il,opacity:1,rejectMapMask:this._rejectMapMask,depthTest:this.AF,ce:this.IF}},$n.prototype.vi=function(t){var i=this.source;if(i)return i.rr(t)||null},$n.prototype.getAllOverlays=function(i){return this.source.getAllOverlays().filter(function(t){return!i||-1<t.className.toLocaleLowerCase().indexOf(i)})},$n.prototype.destroy=function(){this.source&&this.source.destroy&&this.source.destroy(),this._container&&delete this._container},ts=$n,_.Ei(ns,ts),ns.prototype.has=function(t){return!!this.source&&-1<this.source.getAllOverlays().indexOf(t)},ns.prototype.clear=function(){var t;this.source&&(t=this.source.getAllOverlays(),this.remove(t.slice(0)))},ns.prototype.setOptions=function(t){if(this.source)for(var i=0,n=this.source.getAllOverlays();i<n.length;i++)n[i].setOptions(t)},ns.prototype.query=function(t){if(this.source)return this.source.rr({lnglat:t})},ns.prototype.getBounds=function(){if(this.source){var t=this.getAllOverlays();if(0<t.length){for(var i,n=void 0,s=0;s<t.length;s++)n?(i=t[s].getBounds())&&n.union(i):n=(n=t[s].getBounds())&&n.clone();return n}}};var ts,is=ns;function ns(){return null!==ts&&ts.apply(this,arguments)||this}var ss,es=!1,rs=(ss=_.Event,_.Ei(g,ss),g.prototype.va=function(t,n,i){var s,e=this,r=this.jD();return _.Support.LZ&&r.UD?(window.amap_sdk_log&&(s=t.url+"t="+t.ya.join(";"),window.amap_sdk_log("loadNebulaTile"+s+"-"+Date.now())),AMap.getConfig().vdataProxy&&(t.url=AMap.getConfig().vdataProxy+"/"+t.url.split("/")[3]+"/"+t.url.split("/")[4]),r.send("loadNebulaSourceTile",t,function(t,i){t&&e._map.emit("TileDecodeError",{type:"nebula",err:t}),i&&i.nebulaDatas&&(_.Support.amapRunTime&&(_.Support.amapRunTime.workerTime=i.amapRunTime),n(i.nebulaDatas))})):this.DZ.va(t,n)},g.prototype.RD=function(t,i){return AMap.getConfig().vdataProxy&&(t.url=AMap.getConfig().vdataProxy+"/"+t.url.split("/")[3]+"/"+t.url.split("/")[4]),this.Uh.send("loadNebulaSourceTileSdf",t,i)},g.prototype.loadDistrictSourceTile=function(t,i,n){t.request=this.Uh.send("loadDistrictSourceTile",i,function(t,i){i&&n(i)})},g.prototype.gX=function(t,i,n){t.request=this.Uh.send("loadMapboxVTSourceTile",i,function(t,i){i&&n(i)})},g.prototype.kX=function(t,i,n,s){t.request=this.Uh.send("reBufferMapboxVTSource",{MX:i,styles:n},function(t,i){i&&s(i)})},g.prototype.aG=function(t,i,n){var s=this;t.request=this.Uh.send("loadMapboxSourceTile",i,function(t,i){t&&s._map.emit("TileDecodeError",{type:"mapbox",err:t}),i&&n(i)})},g.prototype._C=function(t){this.Uh.send("processLabels",{id:t})},g.prototype.deleteTileStaticSDF=function(t){this.Uh.send("deleteTileStaticSDF",t)},g.prototype.Ha=function(i){this.Uh.send("updateParams",i),_.forEach(this.ED,function(t){t.send("updateParams",i)})},g.prototype.Ka=function(i){this.Uh.send("updateMapStyle",i),_.forEach(this.ED,function(t){t.send("updateMapStyle",i)})},g.prototype.bn=function(t,i){this.Uh.send("updateUserStyle",{Kd:t},i)},g.prototype.Ja=function(i){this.Uh.send("sendHttp",{protocol:i}),_.forEach(this.ED,function(t){t.send("sendHttp",{protocol:i})})},g.prototype.innerLabelsLoadData=function(t,i){this.Uh.send("innerLabelsLoadData",t,i)},g.prototype.signal=function(t,i){},g.prototype.dynamicTextSDFInfoLoaded=function(t,i){this.emit("dynamicTextSDFInfoLoaded",{data:i})},g.prototype.dynamicTextVerticeLoaded=function(t,i){this.emit("dynamicTextVerticeLoaded",i)},g.prototype.dynamicTextVerticeLoadedByTile=function(t,i){this.emit("dynamicTextVerticeLoadedByTile",i)},g.prototype.iconImageLoaded=function(t,i){this.emit("iconImageLoaded",i)},g.prototype.getSDFData=function(t,i){this.Uh.send("getSDFData",t,function(t){i&&i(t)})},g.prototype.loadWordsByFront=function(t,i,n){this.emit("loadWordsByFront",{mG:i,cb:n})},g.prototype.QB=function(t,i){this.jD().send("setPathWebgl",t,i)},g.prototype.JB=function(t,i){this.jD().send("sendIndoorRequest",t,i)},g.prototype.destroy=function(){this.jD().send("destroy","destroy"),this.Wh&&this.Wh.terminate();for(var t=0,i=this.HD;t<i.length;t++){var n=i[t];n&&n.terminate()}this.DZ&&delete this.DZ,this.Wh&&delete this.Wh},g.prototype.request=function(t,n,s){window.amap_sdk_log&&window.amap_sdk_log("data-request:"+n+"-"+Date.now());var e=new XMLHttpRequest;return e.onreadystatechange=function(){var t,i;4===e.readyState&&200===e.status&&(window.amap_sdk_log&&window.amap_sdk_log("data-loaded:"+n+"-"+Date.now()),t=e.getResponseHeader("content-type"),i=e.response,"application/x-protobuf"===t?s(null,i):es||(es=!0,console.log("<AMap JSAPI> KEY异常。")))},e.onerror=function(t){s("error")},e.open("GET",n,!0),e.responseType="arraybuffer",e.send(),{cancel:function(){e.abort()}}},g.prototype.jD=function(){var t=this.GD%this.ND;return this.GD=1+t,this.ED[t]},g.prototype.updateDataVersion=function(t,i){this.emit("updateDataVersion",{version:i})},g.prototype.tv=function(){var t=this;this._map.on("movestart",function(){t.iv=!0,t.ev()}),this._map.on("moveend",function(){t.iv=!1,t.ev()}),this._map.on("dragstart",function(){t._dragging=!0,t.ev()}),this._map.on("dragend",function(){t._dragging=!1,t.ev()}),this._map.on("zoomstart",function(){t.lt=!0,t.ev()}),this._map.on("zoomend",function(){t.lt=!1,t.ev()})},g.prototype.ev=function(){var i=!1;(this._dragging||this.lt||this.iv)&&(i=!0),this.nv!==i&&(this.Uh.send("setMainThreadBusy",i),_.forEach(this.ED,function(t){t.send("setMainThreadBusy",i)})),this.nv=i},g.prototype.WD=function(){for(var t=0;t<this.ND;t++)if(!this.ED[t].UD)return!1;return!0},g);function g(t){var i=ss.call(this)||this;if(i._map=t,i.dE=!1,i._dragging=!1,i.lt=!1,i.nv=!1,i.iv=!1,i.GD=0,i.ND=1,i.HD=[],i.ED=[],i.VD=[],i.ZD=[],i.YD=0,i.DZ=new hs(i),i.pE=function(){window.amap_sdk_log&&window.amap_sdk_log("initWorker:"+Date.now()),i.YD+=1,i.YD===i.ED.length+1&&(i.dE=!0,i._map.setNeedUpdate(!0))},window._PreLoadedWorker){var n=window._PreLoadedWorker,s=new _.Bh(n,i,"AMap.nebula");i.HD.push(n),i.ED.push(s),s.UD=!0,i.pE()}else{for(var e=0;e<i.ND;e++)n=new Worker(AMap.getConfig().workerUrl),s=new _.Bh(n,i,"AMap.nebula"),i.HD.push(n),i.ED.push(s);for(var r=0,h=i.ED;r<h.length;r++)!function(t){t.send("initCryptWorker",!0,function(){t.UD=!0,i.pE()})}(s=h[r])}return i.Wh=new Worker(AMap.getConfig().workerUrl),i.Uh=new _.Bh(i.Wh,i,"AMap.SDF"),i.Uh.send("initCryptWorker",!0,function(){i.Uh.UD=!0,i.pE()}),i.tv(),i}os.prototype.va=function(n,s){var e=this,r=(AMap.getConfig().vdataProxy&&(n.url=AMap.getConfig().vdataProxy+"/"+n.url.split("/")[3]+"/"+n.url.split("/")[4]),n.url+("?key="+AMap.getConfig().key+"&flds="+n.hH)+"&t="+n.ya.join(";")),h=(r=(r=r.replace("nebula/v3","nebula/v2")).replace("oversea/v3","oversea/v2"),r+="&p=3",window.amap_sdk_log&&window.amap_sdk_log("data-request:"+r+"-"+Date.now()),_.Support.amapRunTime&&!_.Support.amapRunTime.workerTime["data-request"]&&(_.Support.amapRunTime.workerTime["data-request"]=Date.now()),new _.vH),t=yi.Ajax(r,{responseType:"arraybuffer"},function(t,i){window.amap_sdk_log&&window.amap_sdk_log("data-loaded:"+r+"-"+Date.now()),_.Support.amapRunTime&&!_.Support.amapRunTime.workerTime["data-loaded"]&&(_.Support.amapRunTime.workerTime["data-loaded"]=Date.now()),"complete"===t&&(n.buffer=i.data,t=e.parent.jD().send("decodeNebulaSourceTile",n,function(t,i){t&&e.parent._map.emit("TileDecodeError",{type:"nebula",err:t}),i&&i.nebulaDatas&&(_.Support.amapRunTime&&!_.Support.amapRunTime.workerTime["data-decode-begin"]&&(_.Support.amapRunTime.workerTime["data-decode-begin"]=i.amapRunTime["data-decode-begin"]),_.Support.amapRunTime&&!_.Support.amapRunTime.workerTime["data-decode-end"]&&(_.Support.amapRunTime.workerTime["data-decode-end"]=i.amapRunTime["data-decode-end"]),_.Support.amapRunTime&&!_.Support.amapRunTime.workerTime["style-parse-begin"]&&(_.Support.amapRunTime.workerTime["style-parse-begin"]=i.amapRunTime["style-parse-begin"]),_.Support.amapRunTime&&!_.Support.amapRunTime.workerTime["style-parse-end"]&&(_.Support.amapRunTime.workerTime["style-parse-end"]=i.amapRunTime["data-decode-end"]),s(i.nebulaDatas))}),h._H(t))});return h._H({cancel:t.abort.bind(t)}),h},os.prototype.RD=function(n,s){var e=this,r=(t=(t=(t=n.url+("?key="+AMap.getConfig().key)+"&flds=poi,roadname&t="+n.ya.join(";")).replace("nebula/v3","nebula/v2")).replace("oversea/v3","oversea/v2"),t+="&p=3",new _.vH),t=yi.Ajax(t,{responseType:"arraybuffer"},function(t,i){"complete"===t&&(n.buffer=i.data,t=e.parent.Uh.send("decodeNebulaSourceTileSdf",n,function(t,i){s(t,i)}),r._H(t))});return r._H({cancel:t.abort.bind(t)}),r};var hs=os;function os(t){this.parent=t}us.prototype.ov=function(t){var i=t.gl;if(this.buffer||(this.buffer=new _.yp(t,new Uint16Array(0),8)),this.texture||(this.texture=t.createTexture({height:1024,width:1024,data:null},{Yi:!0}),this.texture.bind(i.CLAMP_TO_EDGE,i.NEAREST,i.LINEAR)),this.av||(this.av=t.createFramebuffer(1024,1024)),!this.Pc){for(var n=new Uint16Array(192),s=0;s<32;s++){var e=6*s,r=4*s;n[e]=r,n[1+e]=1+r,n[2+e]=2+r,n[3+e]=r,n[4+e]=2+r,n[5+e]=3+r}this.Pc=t.ve(n)}},us.prototype.sv=function(t){for(var i=0,n=t;i<n.length;i++){var s=n[i];this.rv[s.hv]=s.name,this.images[s.name]=s.img,this.lv.push(s.name),this.jG[s.name]={width:s.width,height:s.height}}},us.prototype.update=function(t){this.ov(t.context),this.uv(t,this.lv),this.lv=[]},us.prototype.uv=function(t,i){if(0!==i.length){for(var n=t.context,s=n.gl,e=0,r=i;e<r.length;e++){var h,o=r[e];this.De[o]||((h=n.createTexture(this.images[o],{Yi:!0})).bind(s.CLAMP_TO_EDGE,s.LINEAR,s.LINEAR),this.De[o]=h)}for(var a=[],u=0,c=this.rv.length;u<c;u++){var f=this.rv[u],d=void 0===(l=(f=this.jG[f]||{}).width)?512:l,v=void 0===(l=f.height)?1024:l,f=4*u*4,l=this.cv(u);a[f]=0,a[1+f]=0,a[2+f]=l[0],a[3+f]=l[1],a[4+f]=0,a[5+f]=v,a[6+f]=l[0],a[7+f]=l[1]+v,a[8+f]=d,a[9+f]=v,a[10+f]=l[0]+d,a[11+f]=l[1]+v,a[12+f]=d,a[13+f]=0,a[14+f]=l[0]+d,a[15+f]=l[1]}var p=n.fe(new Uint16Array(a),8),m=t.Hn(),y=(this.fv(),this.av.Wi.set(this.texture.texture),this.getSize()),i=(n.bindFramebuffer.set(this.av.framebuffer),n.be.current);for(n.be.set([0,0,y[0],y[1]]),u=0,c=this.rv.length;u<c;u++){var b=this.rv[u],g=this.jG[b]||{},M=g.width,d=void 0===M?512:M,v=void 0===(M=g.height)?1024:M;b&&m.Ce({u_sourceTexture:this.De[b],u_sourceTextureSize:[d,v],u_targetTextureSize:y},{a_sourceTexturePos:{buffer:p,type:"vec2",Re:8,offset:0},a_targetTexturePos:{buffer:p,type:"vec2",Re:8,offset:4}},6,this.Pc,void 0,void 0,void 0,void 0,void 0,6*u)}n.bindTexture.set(null),this.texture.bind(s.CLAMP_TO_EDGE,s.NEAREST,s.LINEAR),n.be.set(i),n.bindFramebuffer.set(null)}},us.prototype.getSize=function(){return[1024,1024*this.rv.length]},us.prototype.destroy=function(){this.buffer&&(this.buffer.destroy(),delete this.buffer),this.texture&&(this.texture.destroy(),delete this.texture);for(var t=0,i=this.De;t<i.length;t++)i[t].destroy();this.av&&(this.av.destroy(),delete this.av),this.Pc&&(this.Pc.context.deleteBuffer(this.Pc),delete this.Pc),this.images={},this.lv=[],this.rv=[],this.De={}},us.prototype.fv=function(){var t=this.getSize();this.texture.update({width:t[0],height:t[1],data:null},{resize:!0})},us.prototype.cv=function(t){return[0,1024*t]};var as=us;function us(){this.pv=0,this.lv=[],this.rv=[],this.images={},this.jG={},this.De={},this.dv=[256,256]}var cs,fs="labelsLayer",ds={visible:!0,zIndex:120,opacity:1,collision:!0,animation:!0,allowCollision:!1,zooms:_.zoomRange,VT:!1};function vs(t){var i=cs.call(this,t=void 0===t?{}:t)||this;return i.CLASS_NAME="AMap.LabelsLayer",i._opts={id:fs,type:fs,opacity:1,visible:1},i._opts=_.assign({},ds,t),i.xt=i._opts.zooms,i.Qh=void 0===t.zIndex?120:t.zIndex,i.il=void 0===t.visible||t.visible,i.tl=void 0===t.opacity?1:t.opacity,i}cs=s,_.Ei(vs,cs),vs.prototype.getSourceConfig=function(){return{id:this.hS,type:fs}},vs.prototype.getState=function(){return cs.prototype.getLayerConfig.call(this)},vs.prototype.co=function(){return this.hS},vs.prototype.vi=function(t){var i=this.fz;return(i=i&&i.vi(t,this.hS)||"")?this.getSource().Ds(i):null},vs.prototype.Do=function(t){return t=cs.prototype.Do.call(this,t),this.map&&this.uz(this.map),t},vs.prototype.v$=function(){this.fz&&this.fz.remove(this)},vs.prototype.destroy=function(){this.Jh&&this.Jh.destroy&&(this.Jh.destroy(),delete this.Jh)},vs.prototype.IL=function(t){var i=this.fz,n=this.source;return!!(t&&i&&n&&(i=i.$f||{},n=n.zL(t)))&&!!i[n]},vs.prototype.uz=function(t){(this.fz=t.fS()).add(this)},ps=vs,_.Ei(M,ps),M.prototype.getCollision=function(){return this._opts.collision},M.prototype.setCollision=function(t){this._opts.collision=t=void 0===t||t,this.to({vv:!1})},M.prototype.getAllowCollision=function(){return this._opts.allowCollision},M.prototype.setAllowCollision=function(t){this._opts.allowCollision=t=void 0===t||t,this.to({vv:!1})},M.prototype.getOpacity=function(){return this._opts.opacity},M.prototype.setOpacity=function(t){void 0!==t&&(this._opts.opacity=t,this.tl=t,this.to({vv:!0}))},M.prototype.getZooms=function(){return this._opts.zooms},M.prototype.setZooms=function(t){void 0!==t&&(this._opts.zooms=t,this.xt=t,this.to({vv:!0}))},M.prototype.getzIndex=function(){return this._opts.zIndex},M.prototype.setzIndex=function(t){void 0!==t&&(this._opts.zIndex=t,this.Qh=t,this.to({vv:!0}))},M.prototype.add=function(t){Array.isArray(t)||(t=[t]),this._add(t),(t=this.getSource())&&t.add(this.mv,this._opts,this.to.bind(this))},M.prototype.remove=function(t){Array.isArray(t)||(t=[t]),this._remove(t),(t=this.getSource())&&t.remove(this.mv,this._opts,this.to.bind(this))},M.prototype.clear=function(){this.mv={};var t=this.getSource();t&&(t.clear(),this.to({vv:!1}))},M.prototype.show=function(){ps.prototype.show.call(this)},M.prototype.hide=function(){ps.prototype.hide.call(this)},M.prototype.getAllOverlays=function(){var t,i,n=this.mv,s=[];for(t in n)n.hasOwnProperty(t)&&(i=n[t])&&s.push(i);return s},M.prototype.getState=function(){var t=this._opts;return{zIndex:this.Qh,zooms:this.xt,visible:this.il,opacity:this.tl,collision:t.collision,animation:t.animation,rejectMapMask:this._rejectMapMask,depthTest:this.AF,ce:this.IF}},M.prototype.setTop=function(t,i){var n=this.Kl;t&&(i?(n&&n.hS!==t.hS&&n.setTop(!1),this.Kl=t):this.Kl=null)},M.prototype.Kh=function(t){ps.prototype.Kh.call(this,t);var i=this.mv;Object.keys(i).length&&t.add(i,this._opts,this.to.bind(this,{vv:!1}))},M.prototype.to=function(t,i){var n=this,t=(t=void 0===t?{}:t).vv;this.map&&(void 0===t||t?(t=this.getSource())&&t.update(this._opts,function(){i&&(i(),AMap.Util.requestAnimFrame(function(){n.emit("complete")})),n.map&&n.map.setNeedUpdate(!0)}):this.map.setNeedUpdate(!0))},M.prototype.onAdd=function(){var t,i=this.mv;for(t in i)i.hasOwnProperty(t)&&i[t].Cs(this)},M.prototype.v$=function(){ps.prototype.v$.call(this);var t,i=this.mv;for(t in i)i.hasOwnProperty(t)&&i[t].Cs(null)},M.prototype._add=function(t){for(var i=0,n=t;i<n.length;i++){var s=n[i];(this.mv[s.hS]=s).Cs(this)}},M.prototype._remove=function(t){for(var i=0,n=t;i<n.length;i++){var s=n[i];delete this.mv[s.hS],s.Cs(null)}};var ps,ms=_.dZ([_.pZ("LabelsLayer")],M);function M(t){return(t=ps.call(this,t=void 0===t?{}:t)||this).mv={},t}bs.prototype.addImage=function(e,r){var h=this;this.getImage(e)?console.log("there is already a image named "+e):(this.zH.SH(e,function(t,i){r.cb&&r.cb(t,i)}),this.zH.has(e)||this.zH.nS(e,function(s){h.map.z_.loadImage(r.url,{name:e,type:"userImage",cb:function(t){var i,n;t&&t.img?(n=h.map.getContext())&&(t=n.createTexture(t.img,{Zi:!0}),i=r.filter?n.gl[r.filter]:n.gl.LINEAR,n=r.wrap?n.gl[r.wrap]:n.gl.CLAMP_TO_EDGE,t.bind(n,i,i),h.De[e]=t,s(null,t)):s(new Error("no img"))}})}))},bs.prototype.addImageBitmap=function(e,r){var h=this,o=r.url;this.getImage(o)?console.log("there is already a image named "+o):(this.zH.SH(o,function(t,i){r.cb&&r.cb(t,i)}),this.zH.has(o)||this.zH.nS(o,function(t){var i={img:e,startX:0,startY:0,status:_.uc.LOADED,height:e.height,width:e.width,type:"userImage"};h.map.z_.addImageData(o,i);var i=(n=h.map.getContext()).createTexture(i.img,{Zi:!0}),s=r.filter?n.gl[r.filter]:n.gl.LINEAR,n=r.wrap?n.gl[r.wrap]:n.gl.CLAMP_TO_EDGE;i.bind(n,s,s),t(null,h.De[o]=i)}))},bs.prototype.getImage=function(t){return this.De[t]},bs.prototype.RH=function(t){var i=this.De[t];i&&(delete this.De[t],i.destroy())},bs.prototype.MH=function(t){return this.zH.has(t)},bs.prototype.L_=function(){var t=w.create("canvas",null),i=(t.getContext||console.error("createArrowTexture error"),t.height=64,t.width=64,t.getContext("2d"));i?(i.fillStyle="white",i.beginPath(),i.moveTo(8,56),i.lineTo(32,36),i.lineTo(58,56),i.lineTo(58,36),i.lineTo(32,14),i.lineTo(8,36),i.fill(),(t=(i=this.map.getContext()).createTexture(t,{Zi:!0})).bind(i.gl.CLAMP_TO_EDGE,i.gl.LINEAR,i.gl.LINEAR),this.De.AMapArrow=t):console.error("createArrowTexture error")},bs.prototype.AH=function(){this.addImage("emptyTexture",{url:"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"})};var ys=bs;function bs(t){this.map=t,this.De={},this.zH=new _.IH,this.L_(),this.AH()}gs=s,_.Ei(ks,gs),ks.prototype.getSourceConfig=function(){return{id:this._id,type:"sky"}},ks.prototype.destroy=function(){this._id&&(this._id="")},ks.prototype.co=function(){return this._id},ks.prototype.getState=function(){return{visible:this.il,opacity:1,skyColor:this.$C,layer:this,rejectMapMask:this._rejectMapMask,depthTest:this.AF,ce:this.IF}},ks.prototype.lo=function(){return!0};var gs,Ms=ks;function ks(t){var i=gs.call(this,t=void 0===t?{visible:!0}:t)||this;return i.CLASS_NAME="AMap.SkyLayer",i._id="sky_"+_.Util.uuid(),i.il=void 0===t.visible||t.visible,i.$C=t.skyColor,i.$C=i.$C&&_.Util.color2RgbaArray(i.$C),i.Qh=t.zIndex||500,i._rejectMapMask=!0,i}k.prototype.cS=function(t,i,n){for(var s=(this.wf=i).viewState,e=s.projectionId,r=s.viewMode,h=(s.zoom,this.If=_.V[e],this._viewMode=r,this.reset(),this.Of(),this._map),o={},a=0,u=this.Tw();a<u.length;a++){var c=u[a],f=c.getLayerConfig(),l=c._opts,d=c.hS,v=c.getRender();if(v){var p,m=n[d];if(m)for(var y in m)m.hasOwnProperty(y)&&(p=m[y],"AMap.Inner.LabelsLayer"===c.CLASS_NAME&&"other"===y||"AMap.LabelsLayer"===c.CLASS_NAME&&"tile"===y||p&&(y=v.Hz(t,i,this,p,h,f))&&(o[d]=y,(l.collision||l.allowCollision)&&(this.YL=!1),l.allowCollision)&&(this.UT=!1))}}this.Ps=o,e=(s=this._map.getMapState()).rotating,r=s.zooming,s=s.panning,r||s||this.reset(),this.YL&&this.UT&&(e||r||s)||this.Ff(),s=void 0===(r=(e=this.Ef()).Uf)?{}:r,r=e.$f,this.$f=void 0===r?{}:r,this.Uf=s},k.prototype.uS=function(){return this.LC},k.prototype.add=function(t){this.LC[t.hS]=t},k.prototype.remove=function(t){t&&delete this.LC[t.hS]},k.prototype.destroy=function(){this.LC&&(this.LC={}),this.Uf&&(this.Uf={},delete this.Uf),this.$f&&(this.$f={},delete this.$f)},k.prototype.vi=function(t,i,n){if((void 0===n&&(n=!1),this._map)&&((this._map.getStatus().pickWhenMoving||!this._map.TL())&&t&&this._p)){var s=this._map.getMapsContainer(),t=(s=w.mousePos(s,t,this._map))[0],s=s[1],e=this._p.search({ja:t-1,Fa:s-1,Oa:t+1,Ea:s+1});if(e.length){if(e=this.NL(e,i),(i=this.sP(e))&&i.path&&0<i.path.length&&(e=i.path,!this.ss([t,s],e)))return null;if(!i)return null;if(t=i.id,(s=this.DC(t))&&s.Nf&&(i=(e=s.Nf[t])&&e.data.extData||{},this.Uf[t])){if(n)return[i.Lp,i.Ap];if("poi"===i.type)return{type:i.type,id:i.id,lnglat:e.data.position,name:e.data.name};if(!i.type)return i.id}}}return null},k.prototype.search=function(t){for(var i=[],n=0,s=this._p.search(t);n<s.length;n++){var e,r=s[n],h=r.id;(e=this.FC(h))&&"AMap.Inner.LabelsLayer"===e.CLASS_NAME&&this.TC(h)&&i.push(r)}return i},k.prototype.reset=function(){this.Uf={},this.$f={}},k.prototype.tC=function(){return this._p},k.prototype.iC=function(t,i,n,s){var e=void 0===(e=(t=void 0===t?{}:t).x)?0:e,r=void 0===(r=t.y)?0:r,h=void 0===(h=t.width)?0:h,t=void 0===(t=t.height)?0:t,o=(i=void 0===i?{}:i).id,a=i.rank,u=i.padding,c=void 0===(c=i.type)?"":c,i=i.name,f=_.tc._d,u=u||f||0;return n&&0<n.length&&void 0!==s&&0!==s?(n=(f=this.Ddt(n[0],n[1],{ja:e-u,Fa:r-u,Oa:e+h+u,Ea:r+t+u},s))&&f.Ro||[],s=f&&f.path||[],{id:o,name:i,type:c,rank:a||1,ja:n[0],Fa:n[1],Oa:n[2],Ea:n[3],path:s}):{id:o,name:i,type:c,rank:a||1,ja:e-u,Fa:r-u,Oa:e+h+u,Ea:r+t+u}},k.prototype.NL=function(t,i){for(var n=[],s=0,e=t=void 0===t?[]:t;s<e.length;s++){var r,h=e[s];h.id&&(r=this.FC(h.id))&&r.hS===i&&n.push(h)}return n},k.prototype.sP=function(t){for(var i=this.Uf||{},n=[],s=0,e=t;s<e.length;s++){var r=e[s];i[r.id]&&n.push(r)}for(var h=-1/0,o=null,a=0,u=n;a<u.length;a++){var c=u[a],f=c.rank;h<f&&(h=f,o=c)}return o},k.prototype.Tw=function(){var t,i,n=this.LC,s=[];for(t in n)n.hasOwnProperty(t)&&(i=n[t],s.push(i));return s.sort(function(t,i){return i.Qh-t.Qh}),s},k.prototype.Rdt=function(t,i,n){var s=n.x,n=n.y,e=t[0],t=t[1],r=s+(e-s)*Math.cos(i*Math.PI/180)-(t-n)*Math.sin(i*Math.PI/180),e=n+(e-s)*Math.sin(i*Math.PI/180)+(t-n)*Math.cos(i*Math.PI/180);return[this.Pdt(r,2),this.Pdt(e,2)]},k.prototype.Pdt=function(t,i){return Math.round(t*Math.pow(10,i))/Math.pow(10,i)},k.prototype.ss=function(t,i,n){for(var s=t[0],e=t[1],r=!1,h=i.length,o=0,a=h-1;o<h;a=o,o+=1){var u=!1,c=i[o][0],f=i[o][1],l=i[a][0],d=i[a][1];if(c===s&&f===e||l===s&&d===e)return!!n;if(f<e==e<=d){if(s===(l=(l-c)*(e-f)/(d-f)+c))return!!n;u=s<l}u&&(r=!r)}return r},k.prototype.Ddt=function(t,i,n,s){var e,r,t={x:t,y:i};return void 0!==s&&0!==s?(i=[n.ja,n.Fa],s=this.Rdt(i,i=-s,t),e=[n.Oa,n.Fa],e=this.Rdt(e,i,t),r=[n.Oa,n.Ea],r=this.Rdt(r,i,t),n=[n.ja,n.Ea],s=[s,e,r,this.Rdt(n,i,t)],{Ro:Pt.Qa(s),path:s}):null},k.prototype.rd=function(t,i){var n=i.anchorOffset,s=(i=void 0===(i=i.size)?[0,0]:i)[0],i=i[1];return{x:(t=_.vector.add(t,n))[0],y:t[1],width:s,height:i}},k.prototype.hd=function(t,i,n,s){var e=i.offsetX,r=i.offsetY,h=i.w,i=i.h;return{x:t[0]+(void 0===e?0:e)*n,y:t[1]+(void 0===r?0:r)*n,width:(void 0===h?0:h)*n,height:(void 0===i?0:i)*n}},k.prototype.Ff=function(){var t=this.Ps,i=this.wf&&this.wf.viewState,n=this.ad,s=this.$f;if(i){var e,r={viewState:i,size:this.wf.size,transform:this.If,view:this._view,viewMode:this._viewMode,positionType:"relative"},h=i.zoom;for(e in t)if(t.hasOwnProperty(e)&&t[e]){var o=t[e],a=o.coords,u=o.style,c=o.Nf;if(o=this.LC[e]){var f,l,d,v,p,m,y,b,g,M,k=o.getRender().Jz(),w=k.Sa,x=o.Qh;for(f in a)a.hasOwnProperty(f)&&(g=(M=a[f]).origin,m=M.icon,M=M.padding,(l=u[f]).forceShow,this.TC(f)||(s[f]=1),s[f]||(d=(b=c[f]).data&&b.data.rotation||0,v=(y=b.data.extData||{}).Sa||w||[0,0],v=(g=_.vector.add(g,[v[0],v[1],0]))[0],p=g[1],g=g[2],r.centerCoord=k.centerCoord,v=_.LabelsRenderUtil.r0(v,p,g,h,r),p={id:f,rank:_.LabelsRenderUtil.getRank(b,{forceShow:l.forceShow,_z:x}),name:b.data.name,type:y.type||""},g=this.rd(v,m),y=this.PC(l)||_.zoomRange,m=_.Util.dS(h,y),l.showIcon&&m&&g.width&&g.height&&(y=this.iC(g,p,v,d),n.push(y)),m=1,b.data.extData.Lp&&b.data.extData.Ap&&(m=(g=this._map.mapStyle.dn(b.data.extData.Lp,b.data.extData.Ap,i.optimalZoom))&&l.text?g.fontSize/l.text.style.fontSize:1),y=this.hd(v,M,m),b=this.OC(l)||[2,20],g=_.Util.dS(h,b),l.showText&&g&&y.width&&y.height&&(M=this.iC(y,p,v,d),n.push(M))))}}this.ld(n)}},k.prototype.Ef=function(){var t={},i=this.$f;if(!this.wf)return{};var n=(this.wf&&this.wf.viewState).zoom,s=this.Ps,e={};if(this.YL){for(var r in s)if(s.hasOwnProperty(r)&&s[r]){var h,o=s[r],a=o.Nf,u=void 0===a?{}:a;for(h in o.coords,o.style,u)u.hasOwnProperty(h)&&(t[h]=1)}}else{for(var r in s)if(s.hasOwnProperty(r)&&s[r]){var c,f,l=s[r],d=l.Nf,v=void 0===d?{}:d;l.coords;var j=void 0===(d=l.style)?{}:d,B=(w=this.LC[r]).Qh;for(c in v)v.hasOwnProperty(c)&&(f=j[c],e[f=_.LabelsRenderUtil.getRank(v[c],{forceShow:f.forceShow,_z:B})]||(e[f]={}),e[f][c]=v[c])}for(var p,m=_.labelsUtil.rank(Object.keys(e)),W=m.length,y=this.wf,b={viewState:y.viewState,size:y.size,transform:this.If,view:this._view,viewMode:this._viewMode,positionType:"relative"},g=W-1;0<=g;g--)for(var M,F=e[m[g]],k=(M=Object.keys(F)).length-1;0<=k;k--){var w,x=M[k];if(!i[x]&&(w=this.FC(x)))if(!(A=w._opts||{}).collision&&this.UT||A.VT)t[x]=1;else{var A,z=(A=w.getRender().Jz()).Sa,C=(E=this.DC(x)).style,S=E.coords;if((E=E.Nf)[x].data&&E[x].data.rotation,(C=C[x])&&C.forceShow)t[x]=1;else{if(O=(S=S[x]).icon||{},p=S.padding||{},S=S.origin||{},z=((E=E[x]).data.extData||{}).Sa||z||[0,0],z=(S=_.vector.add(S,[z[0],z[1],0]))[0],L=S[1],S=S[2],b.centerCoord=A.centerCoord,A=_.LabelsRenderUtil.r0(z,L,S,n,b),(z=O.size)[0]&&z[1])for(var T,L=this.rd(A,O),S=this.iC(L),G=(T=this._p.search(S)).length,I=0;I<G;I++){var D=T[I];D.id===x?t[D.id]=1:this.BC(x,D.id)&&(i[D.id]=1)}var z=this.wf&&this.wf.viewState,O=1;if(E.data.extData.Lp&&E.data.extData.Ap&&(O=(L=this._map.mapStyle.dn(E.data.extData.Lp,E.data.extData.Ap,z.optimalZoom))&&C.text?L.fontSize/C.text.style.fontSize:1),(S=this.hd(A,p,O)).width&&S.height)for(var R,E=this.iC(S),N=(R=this._p.search(E)).length,I=0;I<N;I++){var P=R[I];P.id===x?t[P.id]=1:this.BC(x,P.id)&&(i[P.id]=1)}}}}}return{Uf:t,$f:i}},k.prototype.ld=function(t){this._p&&(this._p.clear(),this._p.load(t))},k.prototype.Of=function(){this._p&&(this._p.clear(),this.ad=[])},k.prototype.DC=function(t){var i,n,s=this.Ps;for(n in s)if(s.hasOwnProperty(n)){var e=s[n];if(e&&e.Nf&&e.Nf[t]){i=e;break}}return i||{}},k.prototype.jC=function(t){var i,n=this.Ps,s="";for(i in n)if(n.hasOwnProperty(i)){var e=n[i]||{};if(e.Nf&&e.Nf[t]){s=i;break}}return s},k.prototype.FC=function(t){return(t=this.jC(t))?this.LC[t]:null},k.prototype.TC=function(t){var i=this.DC(t),n=this._map.qz(),s=this._map.getLayerByClass("AMap.MaskLayer"),e=this._map.jH();if(i){var r=i.Nf;if(!(i=i.style[t]))return!1;var h=r[t].data.extData||{};if("poi"===h.type&&!1===n)return!1;if(!i.visible)return!1;if(n=this.EC(i),i=this.wf.viewState.zoom,!_.Util.dS(i,n))return!1;if(i=this._map.getLayerByClass("AMap.IndoorMap"),r[t]&&h.bz&&i&&i.yD().show)return!1;if(s){if(n=s.getRender(),e)return!0;if(n&&!n.EH(r[t].data.position,this.wf))return!1}return!0}return!1},k.prototype.BC=function(t,i,n){if(void 0===n&&(n=!1),s=this.DC(i)){var s=s.style,e=(t=this.FC(t))&&t._opts||{},r=this.FC(i),h=r&&r._opts||{};if(s[i].forceShow)return n&&console.log("","   -1- ",1),!1;if(t&&r){if(t.hS!==r.hS&&!e.allowCollision&&!h.allowCollision)return n&&console.log("","   -2- ",1),!1;if(t.hS===r.hS&&!h.collision)return n&&console.log("","   -3- ",1),!1}}return n&&console.log("","   -4- ",1),!0},k.prototype.EC=function(t){var n=(i=this.PC(t)||[])[0],i=i[1],s=(t=this.OC(t)||[])[0],t=t[1];return[n&&s?n<=s?n:s:n||s||2,n&&s?i<=t?t:i:i||t||_.zoomRange[1]]},k.prototype.PC=function(t){return t.icon&&t.icon[0]&&t.icon[0].zooms},k.prototype.OC=function(t){return t.text&&t.text.zooms};var ws=_.dZ([_.pZ("LabelsManager")],k);function k(t){this.LC={},this.Uf={},this.$f={},this.Ps={},this._p=_.rbush(),this.ad=[],this._viewMode="2D",this.YL=!0,this.UT=!0,this._map=t,this._view=t.getView()}xs=s,_.Ei(zs,xs),zs.prototype.getState=function(){return{visible:this.il,opacity:this.tl,zIndex:this.Qh,layer:this,path:this.$x,depthTest:this.AF,ce:this.IF}},zs.prototype.setMask=function(t){t&&(this.$x=t,this.getSource().CS(),null!=(t=this.map))&&t.setNeedUpdate(!1)},zs.prototype.getSourceConfig=function(){return{id:this._id,type:"mask",zooms:_.zoomRange}},zs.prototype.co=function(){return this._id},zs.prototype.lo=function(){return!0};var xs,As=zs;function zs(t){var i=xs.call(this,t)||this;return i.CLASS_NAME="AMap.MaskLayer",i.$x=t.path,i.Qh=t.zIndex||-100,i.tl=void 0===t.opacity?1:t.opacity,i.il=void 0===t.visible||t.visible,i.xt=t.zooms||_.zoomRange,i}var Cs,Ss="Nebula.labelsLayer",Ls="nebulaLabel",Is=(Cs=s,_.Ei(Ds,Cs),Ds.prototype.getState=function(){return _.assign({},{layer:this,rejectMapMask:this._rejectMapMask},Cs.prototype.getLayerConfig.call(this))},Ds.prototype.getSourceConfig=function(){var t=AMap.getConfig().protocol;return{id:Ls,type:Ls,tileUrl:t+(_.Support.wasm?"://{vdata,vdata01,vdata02,vdata03,vdata04}.amap.com/nebula/v3":"://{vdata,vdata01,vdata02,vdata03,vdata04}.amap.com/nebula/v2"),tileSize:0,zooms:_.zoomRange}},Ds.prototype.co=function(){return Ls},Ds.prototype.vi=function(t){return null},Ds.prototype.destroy=function(){this.Jh&&this.Jh.destroy&&(this.Jh.destroy(),delete this.Jh)},Ds.prototype.Do=function(t){return Cs.prototype.Do.call(this,t)},Ds);function Ds(t){var i=Cs.call(this,t=void 0===t?{}:t)||this;return i.CLASS_NAME="AMap.Nebula.LabelsLayer",i._opts={id:Ss,type:Ss,opacity:1,visible:1,collision:!0,allowCollision:!1},i._opts=_.assign({},i._opts,t),i.Qh=t.labelzIndex||100,i.il=!1!==t.showLabel,i.tl=void 0===t.opacity?1:t.opacity,i}Rs.prototype.qk=function(t){return t=Object.keys(t),this.Uk+t.length<this.uf},Rs.prototype.getSize=function(){return[this.maxWidth,this.Uk/this.Hk*this.unit]},Rs.prototype.clear=function(){},Rs.prototype.destroy=function(){},Rs.prototype.Rk=function(t){var i=this.Vk,n=this.$k,s=t[_.dY.iconWidth],t=t[_.dY.iconHeight];return this.pY<t&&(this.pY=t),i+s<=this.maxWidth||(this.$k+=this.pY,n=this.$k,this.Vk=i=0,this.pY=t),this.Vk+=s,this.nU=[i,n],{startX:i,startY:n}};var Os=Rs;function Rs(){this.Uk=0,this.unit=32,this.Hk=128,this.maxWidth=this.unit*this.Hk,this.maxHeight=this.unit*this.Hk,this.uf=this.maxWidth/this.unit*(this.maxHeight/this.unit),this.Kv=!1,this.Vk=0,this.$k=0,this.pY=0,this.nU=[0,0],this.Es={};var t=document.createElement("canvas");t.width=this.maxWidth,t.height=this.maxHeight,this.mY=t,this.Nz=t.getContext("2d")}Ps.prototype.play=function(t){for(var i=t,n=Date.now();0<i&&this.offset!==this.mG.length;){var s=this.mG[this.offset],e=this.bY.Rk(s.info),r=s.info[_.dY.iconWidth],h=s.info[_.dY.iconHeight];0<r&&0<h&&this.bY.Nz.putImageData(function(t,i,n,s){for(var e=(t=t.createImageData(n,s)).data,r=0;r<i.length;r++)e[4*r+0]=i[r],e[4*r+1]=i[r],e[4*r+2]=i[r],e[4*r+3]=255;return t}(this.bY.Nz,s.data,s.info[_.dY.iconWidth],s.info[_.dY.iconHeight]),e.startX,e.startY),s.pos=e,delete s.data,this.result.push(s),this.offset++,i=t-(Date.now()-n)}return this.offset===this.mG.length&&(this.bY.Kv=!0),this.result},Object.defineProperty(Ps.prototype,"status",{get:function(){return this.offset>=this.mG.length?_.vY.finish:_.vY.pause},eb:!1,nb:!0});var Es=Ps;function Ps(t,i){this.bY=t,this.mG=i,this.type="SDFCombineTask",this.offset=0,this.result=[]}Bs.prototype.dynamicTextSDFInfoLoaded=function(t){var i=this.map.R_;i&&"SDFManagerBase"!==i.CLASS_NAME&&(i.Ju(t.data),this.Eo())},Bs.prototype.iconImageLoaded=function(t){for(var i=this,t=t.data,e=[],n=0,s=t;n<s.length;n++)!function(n){n.url;var s=n.data;e.push(new Promise(function(t){var i=new Image;i.src=n.data.data.data,i.onload=function(){t({img:i,name:n.data.data.hash,hv:n.data.ext.hv,width:s.width,height:s.height})}}))}(s[n]);Promise.all(e).then(function(t){i.map.so.sv(t)}),this.Eo()},Bs.prototype.updateDataVersion=function(t){this.map.UH(t.version)},Bs.prototype.destroy=function(){this.$$()},Bs.prototype.Ia=function(){this.map.gn.on("dynamicTextSDFInfoLoaded",this.dynamicTextSDFInfoLoaded.bind(this)),this.map.gn.on("iconImageLoaded",this.iconImageLoaded.bind(this)),this.map.gn.on("updateDataVersion",this.updateDataVersion.bind(this))},Bs.prototype.$$=function(){this.map.gn.clearEvents("dynamicTextSDFInfoLoaded"),this.map.gn.clearEvents("commonWordLoaded"),this.map.gn.clearEvents("iconImageLoaded"),this.map.gn.clearEvents("updateDataVersion")},Bs.prototype.Eo=function(){this.map.setNeedUpdate(!0)};var js=Bs;function Bs(t){this.map=t,this.Ia()}Fs.prototype.CS=function(){this.AS=!1},Fs.prototype.getData=function(){var t,r,e,h,i,o,a,u=this,n=this.$E;return this.AS||!n||(t=_.GeometryUtil.typePolygon(n),r={type:"Polygon",$S:new Array,polygons:new Array,BM:new Array,LS:{x:0,y:0}},t&&"Polygon"===t?(n[0][0]instanceof _.LngLat?r.LS=_.lcs.getLocalByLnglat(n[0][0].toString()):r.LS=_.lcs.getLocalByLnglat(n[0][0]),e=(i=r.LS).x,h=i.y,_.forEach(n,function(t,i){var s;0===i?_.forEach(t,function(t){t instanceof _.LngLat&&(t=t.toArray());var t=_.lcs.getLocalByLnglat(t),n=(i=u.DS(e,h,t.x,t.y))[0],i=i[1];r.$S.push(t.Sa[0]+n,t.Sa[1]+i)}):(s=[],_.forEach(t,function(t){t instanceof _.LngLat&&(t=t.toArray());var t=_.lcs.getLocalByLnglat(t),n=(i=u.DS(e,h,t.x,t.y))[0],i=i[1];s.push(t.Sa[0]+n,t.Sa[1]+i)}),r.BM.push(s))})):t&&"MultiPolygon"===t&&(r.type="MultiPolygon",n[0][0][0]instanceof _.LngLat?r.LS=_.lcs.getLocalByLnglat(n[0][0][0].toArray()):r.LS=_.lcs.getLocalByLnglat(n[0][0][0]),o=(i=r.LS).x,a=i.y,_.forEach(n,function(t){var e=[],n=[];_.forEach(t,function(t,i){var s;0===i?_.forEach(t,function(t){t instanceof _.LngLat&&(t=t.toArray());var t=_.lcs.getLocalByLnglat(t),n=(i=u.DS(o,a,t.x,t.y))[0],i=i[1];e.push(t.Sa[0]+n,t.Sa[1]+i)}):(s=[],_.forEach(t,function(t){t instanceof _.LngLat&&(t=t.toArray());var t=_.lcs.getLocalByLnglat(t),n=(i=u.DS(o,a,t.x,t.y))[0],i=i[1];s.push(t.Sa[0]+n,t.Sa[1]+i)}),n.push(s))}),r.BM.push(n),r.polygons.push(e)})),this.AS=this.zw(r),this.AS)},Fs.prototype.DS=function(t,i,n,s){return n-=t,t=s-i,[n*(s=_.lcs.getSize())[0],t*s[1]]},Fs.prototype.zw=function(t){if(t.Oc=new _._w,!t.Dc){t.Dc=new _.K_;var i=[],n=[];"Polygon"===t.type?(i=[t.$S],n=[t.BM]):"MultiPolygon"===t.type&&(i=t.polygons,n=t.BM);for(var s=0;s<i.length;s++){for(var e=i[s],r=[],h=0;h<n[s].length;h++){var o=n[s][h];r.push(e.length/2),e.push.apply(e,o)}var a=t.Dc.Nx(e,r);0<a&&t.Oc.add(99,99,a,_.zoomRange[0],_.zoomRange[1])}return t}},Fs.prototype.EE=function(t){if(!t)return null;for(var i=[],n=t.length,s=0;s<n;s++){var e=t[s],e=[(e=this.map.pixelToLngLat(e,16)).lng,e.lat];i.push(e)}return[i]};var Ws=Fs;function Fs(t,i,n){this.map=i,this.$E=t}Ns.prototype.destroy=function(){for(var t=0,i=this.MZ;t<i.length;t++){var n=i[t];"function"==typeof n.destroy&&n.destroy.call(n)}};var Gs=Ns;function Ns(t){this.MZ=t,this.dynamic=new Us}_s=_.Event,_.Ei(Ys,_s),Ys.prototype.has=function(t){return this.gV.has(t)},Ys.prototype.set=function(t,i,n){(n=void 0===n||n)?(n=this.gV.get(t),this.gV.set(t,i),n!==i&&this.emit(t,i)):this.gV.set(t,i)},Ys.prototype.get=function(t){return this.gV.get(t)},Ys.prototype.subscribe=function(t,i,n,s){var e=this;return this.on(t,i,n,s=void 0!==s&&s),function(){return e.off(t,i,n)}};var _s,Us=Ys;function Ys(){var t=null!==_s&&_s.apply(this,arguments)||this;return t.gV=new _.OZ,t}function Zs(t){var i=this,t=(this.map=t,this.gZ=function(){return i.stencil.getData()},t.getOutseaDataType()),t=_.vZ(t).boundsP16;this.stencil=new Ws(t,this.map)}Js.prototype.update=function(t){var i=this;void 0===t?this.PZ.forEach(function(t){i.jZ(t)}):(t=this.WZ(t))&&this.jZ(t)},Js.prototype.add=function(t){if(this.PZ.has(t.group)){var i=this.PZ.get(t.group);if(null==i||!i.includes(t))return null!=(i=this.PZ.get(t.group))&&i.push(t),!0}return!1},Js.prototype.remove=function(t){if(this.PZ.has(t.group)){var i=null==(i=this.PZ.get(t.group))?void 0:i.indexOf(t);if(-1!==i)return null!=(t=this.PZ.get(t.group))&&t.splice(i,1),!0}return!1},Js.prototype.BZ=function(t){var i=0;return void 0===t?this.PZ.forEach(function(t){i+=t.length}):i+=null!=(t=null==(t=this.WZ(t))?void 0:t.length)?t:0,i},Js.prototype.RZ=function(t,i,n){if(void 0===n&&(n=1),!this.WZ(t)||this.BZ(t)<=0)return!1;for(var s=0;s<n&&0<this.BZ(t);s++){var e=this.GZ(t,!0);void 0!==e&&(!i||null!=i&&i(e)?e.NZ():this.add(e))}return!0},Js.prototype.GZ=function(t,i){var n,s;return void 0===i&&(i=!1),this.WZ(t)&&(s=null==(s=this.WZ(t))?void 0:s.pop(),i)&&s&&null!=(n=s.UZ)&&n.call(s)?this.GZ(t,i):s},Js.prototype.sort=function(t,i){return i.FZ()-t.FZ()},Js.prototype.WZ=function(t){return this.PZ.get(t)},Js.prototype.jZ=function(t){for(var i,n=0;n<t.length;n++){var s=t[n];null!=(i=null==s?void 0:s.UZ)&&i.call(s)&&(t.splice(n,1),n--)}t.sort(this.sort)},Js.prototype.destroy=function(){this.PZ.clear()};var Xs=Js;function Js(t){var i=this;this.PZ=new _.OZ,this.ZZ=t,null!=(t=this.ZZ.Fz)&&t.forEach(function(t){i.PZ.set(t,[])}),this.ZZ._Z&&(this.sort=this.ZZ._Z)}var Hs={rainbow:{HY:["#96005A","#0000C8","#0019FF","#0098FF","#2CFF96","#97FF00","#FFEA00","#FF6F00","#FF0000"],JY:[0,.125,.25,.375,.5,.625,.75,.875,1]},jet:{HY:["#000083","#003CAA","#05FFFF","#FFFF00","#FA0000","#800000"],JY:[0,.125,.375,.625,.875,1]},hsv:{HY:["#ff0000","#fdff02","#f7ff02","#00fc04","#00fc0a","#01f9ff","#0200fd","#0800fd","#ff00fb","#ff00f5","#ff0006"],JY:[0,.169,.173,.337,.341,.506,.671,.675,.839,.843,1]},hot:{HY:["#000000","#e60000","#ffd200","#ffffff"],JY:[0,.3,.6,1]},greys:{HY:["#000000","#ffffff"],JY:[0,1]},greens:{HY:["#00441b","#006d2c","#238b45","#41ab5d","#74c476","#a1d99b","#c7e9c0","#e5f5e0","#f7fcf5"],JY:[0,.125,.25,.375,.5,.625,.75,.875,1]},ylgnbu:{HY:["#081d58","#253494","#225ea8","#1d91c0","#41b6c4","#7fcdbb","#c7e9b4","#edf8d9","#ffffd9"],JY:[1,.875,.75,.625,.5,.375,.25,.125,0]},ylorrd:{HY:["#800026","#bd0026","#e31a1c","#fc4e2a","#fd8d3c","#feb24c","#fed976","#ffeda0","#ffffcc"],JY:[1,.875,.75,.625,.5,.375,.25,.125,0]}},Vs=(qs.getTexture=function(t,i){var n;return this.cache[i]||(Hs[i]&&(n=function(t){t.JY,t.HY;for(var i=document.createElement("canvas"),n=(i.height=1,i.width=256,i.getContext("2d")),s=n.createLinearGradient(0,0,256,1),e=0;e<t.JY.length;e++){var r=t.JY[e],h=t.HY[e];s.addColorStop(r,h)}return n.fillStyle=s,n.fillRect(0,0,256,1),i}(Hs[i]),n=t.createTexture(n,{Zi:!0}),t=t.gl,n.bind(t.CLAMP_TO_EDGE,t.NEAREST,t.NEAREST_MIPMAP_NEAREST),this.cache[i]=n),null)},qs.cache={},_.dZ([_.pZ("ColorScale")],qs));function qs(){}Qs.oX=function(t){var i=document.createElement("canvas"),n=(i.width=256,i.height=256,i.getContext("2d"));if(n){n.beginPath();for(var s="rgba("+t[0]+","+t[1]+","+t[2]+","+t[3]/255+")",e=0;e<9;e++){n.lineWidth=1,n.strokeStyle=s;var r=256*e/8;8===e?(n.moveTo(.5,r-.5),n.lineTo(255.5,r-.5),n.moveTo(r-.5,.5),n.lineTo(r-.5,255.5)):(n.moveTo(.5,.5+r),n.lineTo(255.5,.5+r),n.moveTo(.5+r,.5),n.lineTo(.5+r,255.5))}return n.stroke(),"url("+i.toDataURL("image/png")+")"}},Qs.hX=function(t,i){var n=t.toLowerCase();if(n&&/^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/.test(n)){if(4===n.length){for(var s="#",e=1;e<4;e+=1)s+=n.slice(e,e+1).concat(n.slice(e,e+1));n=s}for(var r=[],e=1;e<7;e+=2)r.push(parseInt("0x"+n.slice(e,e+2),10));return i&&(t=parseFloat((parseInt(i,16)/255).toFixed(2)),r.push(t)),"RGB("+r.join(",")+")"}return n};var Ks=Qs;function Qs(){}new _.rW({}),te.addLayerRender=function(t,i,n){i&&(this.YZ[t]=i),n&&(this.JZ[t]=n),this.XZ(!0)},te.XZ=function(t){this.HZ=t},te.VZ=function(){return this.HZ},te.HZ=!0,te.YZ={},te.JZ={};var $s=_.dZ([_.pZ("LayerRenderManager")],te);function te(){}ie=_.Event,_.Ei(x,ie),x.prototype.TL=function(){return!window.movingDraw&&(this.gm||this.Lv||this.lt||this.Cv)},x.prototype.getContext=function(){var t;return null==(t=this.mm)?void 0:t.context},x.prototype.getGL=function(){return this.gl},x.prototype.getView=function(){return this._view},x.prototype.loadData=function(){return this.IY},x.prototype.wX=function(){return{hardwareAccEnabled:_.Support.hardwareAccEnabled}},x.prototype.getContainer=function(){return this.kv},x.prototype.getSize=function(){var t=this._view.getStatus().size;return new _.Size(t[0],t[1])},x.prototype.addLayer=function(t){var i,n,s;"d"===_.Support.baseRender&&/^(AMap\\.DistrictLayer)|(AMap\\.MapboxLayer)$/g.test(t.CLASS_NAME)?console.log("浏览器版本过低，请升级最新版本的浏览器，或使用高版本火狐、谷歌等浏览器。"):(t.map=this,i=t.getSourceConfig(),n=this.Mv.addSource(i,this._view.au(),t),t.Hh(this.Mv),t.Kh(n),s=this.Rv(t,{}),t.Do(s),this.zv.push(t),this.zv.sort(function(t,i){return t.getOptions().zIndex-i.getOptions().zIndex}),"AMap.NebulaLayer"!==t.CLASS_NAME&&"AMap.TileLayer.RoadNet"!==t.CLASS_NAME||!1===this.showLabel||"w"!==this.baseRender||this.getLayerByClass("AMap.Nebula.LabelsLayer")||(s=new Is(_.Ln(_.Ln({},this.options),{rejectMapMask:!0})),this.addLayer(s)),"AMap.Nebula.LabelsLayer"!==t.CLASS_NAME&&"AMap.MapboxLayer"!==t.CLASS_NAME||!1===this.showLabel||"w"!==this.baseRender||((s=this.getLayerByClass("AMap.Inner.LabelsLayer"))?s.oP()&&s.show():(s=new $i(_.Ln(_.Ln({},this.options),{rejectMapMask:!0})),this.addLayer(s)),s.getSource().addSource(i.id,n)),"AMap.NebulaLayer"===t.CLASS_NAME&&this.yS()&&!_.some(this.zv,function(t){return"AMap.Buildings"===t.CLASS_NAME})&&this.addLayer(new AMap.Buildings({zooms:[16.8,_.zoomRange[1]],rejectMapMask:!0,zIndex:10,visible:!0,u$:!0})),!this.c$||_.some(this.zv,function(t){return"AMap.MaskLayer"===t.CLASS_NAME})||this.d$||(this.d$=new As({zIndex:-10,visible:!0,path:this.c$}),this.addLayer(this.d$)),"3D"!==this.getView().type||_.some(this.zv,function(t){return"AMap.SkyLayer"===t.CLASS_NAME})||this.addLayer(new Ms({zIndex:-1,visible:!0,skyColor:this.$C})),t.onAdd&&t.onAdd(),this.d_(),this.setNeedUpdate(!0))},x.prototype.removeLayer=function(t){for(var i,n=0;n<this.zv.length;n++)this.zv[n]===t&&(this.zv.splice(n,1),t.v$&&(t.v$(),"d"===_.Support.baseRender)&&null!=(i=t.getRender())&&i.destroy(),t.map=null,--n);this.d_(),this.setNeedUpdate(!0)},x.prototype.setLayers=function(t){for(var i=0;i<this.zv.length;i++)"AMap.VectorLayer"!==(n=this.zv[i]).CLASS_NAME&&this.removeLayer(n);for(var n,i=0;i<t.length;i++)(n=t[i]).setMap(this)},x.prototype.getLayers=function(){return this.zv.filter(function(t){return!t._opts||!t._opts.TF})},x.prototype.DF=function(){return this.zv},x.prototype.getDefaultLayer=function(){for(var t=this.getLayers(),i=0;i<t.length;i++){var n=t[i];if(n instanceof Ji||"_defaultLayer"===n.getLayerConfig().id)return n}},x.prototype.getLayerByClass=function(t){for(var i=this.getLayers(),n=0;n<i.length;n++){var s=i[n];if(s.CLASS_NAME===t)return s}},x.prototype.isDOMRender=function(){return!_.Support.isWebGL||"d"===this.baseRender},x.prototype.isDOMMode=function(){return!_.Support.isWebGL||"d"===this.baseRender},x.prototype.getMapState=function(){return{zooming:this.lt,panning:this.Cv,rotating:this.Lv,pitching:this.gm}},x.prototype.getControlContainer=function(){return this.Tv},x.prototype.getMapsContainer=function(){return this.Iv},x.prototype.getStatus=function(){return{dragEnable:this.Dv,zoomEnable:this.Pv,doubleClickZoom:this.fi,keyboardEnable:this.jv,jogEnable:this.Ov,scrollWheel:this.Fv,zoomSpeed:this.fZ,animateEnable:this.Ev,touchZoomCenter:this.Nv,touchZoom:this.$v,pitchEnable:this.Uv,rotateEnable:this.Bv,showBuildingBlock:this.m$,isHotspot:this.Wv,mapstyleUrl:this.c_,features:this.Cw,allBubble:this.HL,pickWhenMoving:this.UB}},x.prototype.setStatus=function(t){this.Dv=void 0!==t.dragEnable?t.dragEnable:this.Dv,this.Pv=void 0!==t.zoomEnable?t.zoomEnable:this.Pv,this.fi=void 0!==t.doubleClickZoom?t.doubleClickZoom:this.fi,this.jv=void 0!==t.keyboardEnable?t.keyboardEnable:this.jv,this.Ov=void 0!==t.jogEnable?t.jogEnable:this.Ov,this.Fv=void 0!==t.scrollWheel?t.scrollWheel:this.Fv,this.Ev=void 0===t.animateEnable?this.Ev:t.animateEnable,this.Uv=void 0===t.pitchEnable?this.Uv:t.pitchEnable,this.$v=void 0===t.touchZoom?this.$v:t.touchZoom,this.Wv=void 0===t.isHotspot?this.Wv:t.isHotspot,this.Bv=void 0===t.rotateEnable?this.Bv:t.rotateEnable,this.HL=void 0===t.allBubble?this.HL:t.allBubble},x.prototype.getBuildingColor=function(){return{buildingColor:this.az,roofColor:this.rz,wallColor:this.sz}},x.prototype.getMask=function(){return this.c$},x.prototype.getOutseaState=function(){return this.YG},x.prototype.getOutseaDataType=function(){return this.QZ},x.prototype.getMapboxStyle=function(){return this.JG},x.prototype._setStyle=function(t){this.mapStyle.setStyle(t,!1,this)},x.prototype.RY=function(t){"d"!==this.baseRender&&(this.mapStyle.setStyleByPlat(t,this),this.u0(t))},x.prototype.f_=function(t){var i=this;if(!t)return!1;"d"!==this.baseRender?(this.c_=t,this.mapStyle.pn(function(){i._getUserStyle(t),i.d_(),i.setNeedUpdate(!0)})):console.log("浏览器版本过低，请升级最新版本的浏览器，或使用高版本火狐、谷歌等浏览器。")},x.prototype.getProjection=function(){return _.ProjectionManager.getProjection(this._view.au())},x.prototype.getDefaultCursor=function(){return this.Zv},x.prototype.setDefaultCursor=function(t){this.Zv=t,this.setCursor()},x.prototype.setCursor=function(t){this.kv&&(t=t||this.getDefaultCursor())!==this.qv&&(_.Support.$e||(this.kv.style.cursor=t),this.qv=t)},x.prototype.destroy=function(){this.G("beforeDestroy"),this.y$=!0,this.bZ&&(this.bZ.destroy(),delete this.bZ),this.x$&&(this.x$.destroy(),delete this.x$),this.gn&&(this.gn.destroy(),delete this.gn),this.mapStyle&&this.mapStyle.destroy&&(this.mapStyle.destroy(),delete this.mapStyle),this.b$&&this.b$.destroy&&(this.b$.destroy(),delete this.b$),this.$F&&this.$F.destroy&&(this.$F.destroy(),delete this.$F),this.wm&&delete this.wm,this.z_&&this.z_.destory&&(this.z_.destory(),delete this.z_),this._view&&delete this._view,this.I_&&delete this.I_,this.yH&&delete this.yH,this.m_&&delete this.m_,this.gl&&delete this.gl,this.canvas&&delete this.canvas,this.lcs&&(this.lcs=null),this.Vv(),this.Xv(),this.Hv(),this.G("afterDestroy")},x.prototype.getLimitBounds=function(){return this.it},x.prototype.setLimitBounds=function(t){t instanceof l?this.it=t:this.it=new l(t)},x.prototype.clearLimitBounds=function(){this.it=void 0},x.prototype.getZooms=function(){return[Math.max(this.xt[0],_.zoomRange[0]),Math.min(_.zoomRange[1],this.xt[1])]},x.prototype.setZooms=function(t){this.xt=t},x.prototype.setNeedUpdate=function(t){this.zX||(this.Jv=5,t&&!this.Kv&&(this.Kv=t,_.Util.cancelAnimFrame(this.Qv),this.Qv=0,this.Eo()),this.Kv=t,this.bZ&&this.bZ.MZ.yY.setNeedUpdate(t))},x.prototype.render=function(){this.setNeedUpdate(!0)},x.prototype.qz=function(){return!1!==this.showLabel&&(!this.Cw||-1<this.Cw.indexOf("point"))},x.prototype.Qz=function(){return!1!==this.showLabel&&(!this.Cw||-1<this.Cw.indexOf("road"))},x.prototype.yS=function(){return!!this.m$||void 0===this.m$&&(!this.Cw||-1<this.Cw.indexOf("building"))},x.prototype.getViewMode_=function(){return this._view.type},x.prototype.fS=function(){return this.b$},x.prototype.XT=function(t){this.QT=t},x.prototype.JF=function(t){return this.mapStyle.vn?((t=this.mapStyle.vn.nX("00001","1","color",t))&&(t=_.Util.Hex2Rgba(t),t=_.vector.Up(t,255)),this.$C||t||[.329,.549,.839,1]):this.$C||[.329,.549,.839,1]},x.prototype.sX=function(t){var i;return this.mapStyle.vn?((i=(i=this.mapStyle.vn.nX("00001","2","color",t))||this.mapStyle.vn.nX("00001","1","color",t))&&(i=_.Util.Hex2Rgba(i),i=_.vector.Up(i,255)),this.$C||i||[.329,.549,.839,1]):this.$C||[.329,.549,.839,1]},x.prototype.qF=function(){return this.tB},x.prototype.qY=function(t,i){var n;return t&&2===t.length?(n=t[0],t=t[1],this.mapStyle.dn(n,t,i)):null},x.prototype.ra=function(t){return{2:3,3:3,4:3,5:3,6:6,7:6,8:8,9:8,10:10,11:10,12:10,13:12,14:12,15:14,16:14,17:14,18:14,19:14,20:14,21:14,22:14}[t]},x.prototype.getCustomTypeByPos=function(t){var i=this.ym().viewState.optimalZoom,i=this.ra(i),t=[(t=t.lnglat).lng,t.lat,t.lng,t.lat];return _.Util.WY(t,i)},x.prototype.jH=function(){return this.NH},x.prototype.UH=function(t){this.Mv.UH(t)},x.prototype.setHighlight=function(t,i){var n;this.bZ&&(n=this.bZ.MZ.KY)&&n.setHighlight(t,i)},x.prototype.start=function(){this.zX=!1,this.setNeedUpdate(!0)},x.prototype.stop=function(){this.setNeedUpdate(!1),this.zX=!0},x.prototype.Zdt=function(){return this.zv.filter(function(t){return!t._opts||!t._opts.TF||"AMap.MarkLayer"===t.CLASS_NAME})},x.prototype.im=function(){return this.Mv},x.prototype.em=function(t,i,n){var s,e,r,h,o,a,u,c,f;return void 0===i&&(i=[0,0,0,0]),void 0===n&&(n=_.zoomRange[1]),t?(r=_.ProjectionManager.getProjection(this._view.au()),s=_.V[this._view.au()],e=r.project(t[0],t[1]),t=[(r=r.project(t[2],t[3]))[0]-e[0],r[1]-e[1]],f=this.getSize().toArray(),h=this._view.getStatus().pitch,c=this._view.getStatus().rotation,c*=Math.PI/180,a=(i[2]-i[3])/2,u=(i[0]-i[1])/2,o=a*Math.cos(c)+Math.sin(c)*u,a=-Math.sin(c)*a+Math.cos(c)*u,u=t[0],0!=c&&(t[0]=Math.abs(t[0]*Math.cos(c))+Math.abs(t[1]*Math.sin(c)),t[1]=Math.abs(t[1]*Math.cos(c))+Math.abs(u*Math.sin(c))),u=Math.max(10,f[0]-i[2]-i[3]),c=Math.max(10,f[1]-i[0]-i[1]),f=Math.log(156543.03392804097/t[0]*u)/Math.log(2),i=Math.log(156543.03392804097/t[1]*c)/Math.log(2),u=Math.min(f,i),0<h&&(u-=h/60),u=Math.min(u,n),t=[(e[0]+r[0])/2,(e[1]+r[1])/2],(c=s.transform(t[0],t[1],u))[0]-=o,c[1]-=a,f=s.unproject(c[0],c[1],u),_.Pt(f,[u])):[116.39708007097433,39.874529056682476,12]},x.prototype.nm=function(t){if(0<t.length){for(var i,n=void 0,s=0;s<t.length;s++)n?(i=t[s].getBounds())&&n.union(i):n=(n=t[s].getBounds())&&n.clone();return n}},x.prototype.om=function(t,i){void 0===i&&(i=!0),this._view&&this._view.setOptions(t,i)},x.prototype.Eo=function(){this.zX||(this.Qv||(this.Qv=_.Util.requestAnimFrame(this.Yf.bind(this))),this.bZ&&this.bZ.MZ.yY.to())},x.prototype.rm=function(){return this.hm||(this.hm=new ms,this.addLayer(this.hm)),this.hm},x.prototype.sm=function(){return this.$F.source},x.prototype.FY=function(t){if(_.Module.eS.BY)return this.getLayerByClass("AMap.Inner.LabelsLayer").vi(t,!0)},x.prototype._getUserStyle=function(t){t&&this._changeStyle(t)},x.prototype._changeStyle=function(t){var s=this,i=t.split("amap://styles/")[1],e=(n=AMap.getConfig()).protocol,n=n.key,r=((t=-1!==t.indexOf("?isPublic=true"))&&(i=i.split("?isPublic")[0]),null),h=!1;i.length<32?(h=!0,r=e+"://webapi.amap.com/style2?name="+i+"&key="+n):(r=e+"://webapi.amap.com/v4/map/styles2?styleid="+i+"&s=rsv3&key="+n+(t?"&ispublic=1":""),AMap.getConfig().jscode?r+="&jscode="+AMap.getConfig().jscode:AMap.getConfig().gaodeserver&&(r=AMap.getConfig().gaodeserver+"/v4/map/styles2?styleid="+i+"&s=rsv3&key="+n+(t?"&ispublic=1":""))),yi.JSONP(r,function(t,i){var n;"complete"===t&&(i=i.data)&&i.data&&i.data.content?(t=JSON.parse(i.data.content),n=JSON.parse(i.data.layer||"{}"),s.QR=t,s.mapStyle&&(s.mapStyle.setStyle(t,h,s),n)&&s.mapStyle.vn.EY(n),s.u0(i.data)):s.emit("styleChanged")})},x.prototype._getMapboxStyle=function(n){var s=this,t=AMap.getConfig(),i=t.protocol;t.key,yi.Ajax(i+"://a.amap.com/jsapi/static/json/web_v8_2.0_"+n+".json",{type:"GET",requestContentType:"application/json"},function(t,i){"complete"===t?(i=i.data,s.JG={styles:i,vectorMapForeign:n},s.gn&&s.gn.Ha({QG:s.JG}),s.Eo()):s.JG=null})},x.prototype.um=function(t){for(var i=0,n=t.length;i<n;i+=1)this.addLayer(t[i])},x.prototype.u0=function(t){var i=this;t&&t.third_layer&&_.Module.module("AMap.StyleParser",function(){setTimeout(function(){i.y$||(i.f0||(i.f0=new AMap.StyleParser(i)),i.emit("styleLoaded",t))},0)})},x.prototype.cm=function(){var n=this,t=(w.addClass(this.kv,"amap-container"),this.l0=w.watchSize(this.kv,function(t,i){n.om({size:[t,i]})},this),this.kv),i=(!1===this.options.showMapGrid&&(this.kv.style.backgroundImage="none"),this.Iv=w.create("div",null,"amap-maps"),this.do=w.create("div",this.Iv,"amap-layers"),this.fm=w.create("div",this.Iv,"amap-overlays"),t.appendChild(this.Iv),this.Tv=w.create("div",this.kv,"amap-controls"),this.Iv.tabIndex=0,{});i.p_=w.create("a",t,"amap-logo"),w.create("img",i.p_).src=_.Support.Ue?AMap.getConfig().protocol+"://"+AMap.getConfig().domain+"/theme/v2.0/logo@2x.png":AMap.getConfig().protocol+"://"+AMap.getConfig().domain+"/theme/v2.0/logo@1x.png",i.v_=w.create("div",t,"amap-copyright"),i.v_.style.display="none",350<w.getViewport(this.kv)[0]&&(i.v_.innerHTML=AMap.getConfig().v_,i.v_.mapNumber=w.create("span",i.v_,"amap-mcode")),this.m_=i},x.prototype.d_=function(){var t=this.getLayers();if(t){for(var i=-1,n="",s=0;s<t.length;s+=1){var e=t[s].get("mapNumber"),r=t[s].get("zIndex");e&&i<r&&t[s].get("visible")&&(n=e,i=r)}var h=this.c_;return(n=!this.g$||"GS(2021)6375"===n&&h&&"normal"!==h&&"amap://styles/normal"!==h?"":n)&&this.tE!==n&&this.m_&&this.m_.v_&&this.m_.v_.mapNumber&&(this.m_.v_.mapNumber.innerHTML="- "+n+"号"),this.tE=n}},x.prototype.pm=function(t){var i={size:w.getViewport(this.kv),zoom:t.zoom,center:t.center,rotation:t.rotation,projectionId:t.projection,pitch:t.pitch};return new(t.viewMode&&"3D"===t.viewMode?Gn:jn)(i,this)},x.prototype.dm=function(){},x.prototype.Hv=function(){for(w.remove(this.Iv),delete this.Iv,this.do&&(w.remove(this.do),delete this.do),this.Tv&&(w.remove(this.Tv),delete this.Tv),this.fm&&(w.remove(this.fm),delete this.fm),this.l0&&(this.l0(),delete this.l0);this.kv&&this.kv.firstChild;)this.kv.removeChild(this.kv.firstChild);this.kv&&delete this.kv,Vs.cache&&(Vs.cache={})},x.prototype.Vv=function(){this.pi&&(this.pi.destroy(),delete this.pi),this.di&&(this.di.destroy(),delete this.di),this.vm&&(this.vm.destroy(),delete this.vm)},x.prototype.Xv=function(){this.mm&&this.mm.destroy&&(this.mm.destroy(),delete this.mm);for(var t=0,i=this.getLayers();t<i.length;t++)i[t].destroy();this.so&&this.so.destroy(),this.R_&&(this.R_.destroy(),delete this.R_),this.zv=[],this.Mv&&this.Mv.destroy&&(this.Mv.destroy(),delete this.Mv)},x.prototype.ym=function(){var t=this._view.getStatus();return{debug:this.debug,layers:this.zv,uo:this.Mv,size:t.size,do:this.do,viewState:t,map:this}},x.prototype.Yf=function(){if(!this.zX&&(this.w$(),!this.y$)){if($s.VZ())for(var t=0,i=this.ym().layers;t<i.length;t++){var n,s=i[t];s.getRender()||(n=this.Rv(s,{}),s.Do(n))}this.pi&&this.pi.iy({}),this.di&&this.di.iy({});var e=this.ym();if(this.bm(e),this.tB=(new Date).getTime(),this.Mv.loadData(e.viewState,this,this.mm?this.mm.context:null),this.mm&&this.mm.renderFrame(e),this.Jv&&this.Kv)this.Qv=_.Util.requestAnimFrame(this.Yf.bind(this));else if((this.Jv<=0||!this.Kv)&&(this.Kv=!1,_.Util.cancelAnimFrame(this.Qv),this.Qv=0,this.gm||this.Lv||this.lt||this.Cv)){if(this.lt&&-1!==this.k$){if("d"===_.Support.baseRender&&0<=this.k$){if(this.KT(),!this.tD)return void(this.tD=!0);this.tD=!1}this.G("zoomend",{target:e.map})}this.Cv&&-1!==this._$&&this.G("moveend",{target:e.map}),this.Lv&&-1!==this.M$&&this.G("rotateend"),this.gm&&-1!==this.S$&&this.G("pitchend"),this.Lv=!1,this.gm=!1,this.lt=!1,this.Cv=!1,this.Qv||(this.Mv.loadData(e.viewState,this,this.mm?this.mm.context:null),this.mm&&this.mm.renderFrame(e))}this.Jv--}},x.prototype.bm=function(t){var i=t.viewState,s=(n=this.wm).center,e=n.rotation,r=n.zoom,n=n.pitch,h=i.center,o=i.zoom,a=i.rotation,u=i.pitch;if(s[0]!==h[0]||s[1]!==h[1]?(this._$=1,this.Cv||this.G("movestart",{target:t.map}),this.Cv=!0,this.G("mapmove",{target:t.map})):1<=this._$&&this._$++,r!==o?(this.lt||this.G("zoomstart",{target:t.map}),this.G("zoomchange",{target:t.map}),this.lt=!0,this.k$=1):1<=this.k$&&this.k$++,e!==a?(this.Lv||this.G("rotatestart"),this.G("rotatechange"),this.Lv=!0,this.M$=1):1<=this.M$&&this.M$++,n!==u?(this.gm||this.G("pitchstart"),this.G("pitchchange"),this.gm=!0,this.S$=1):1<=this.S$&&this.S$++,5<=this._$&&(this.Cv=!1,this._$=-1,this.G("moveend",{target:t.map})),5<=this.k$&&(this.lt=!1,this.k$=-1,this.G("zoomend",{target:t.map})),5<=this.M$&&(this.Lv=!1,this.M$=-1,this.G("rotateend")),5<=this.S$&&(this.gm=!1,this.S$=-1,this.G("pitchend")),"d"===_.Support.baseRender&&4<=this.k$){if(this.KT(),!this.tD)return void(this.tD=!0);this.tD=!1}this.Qv||this.mm&&(this.Mv.loadData(t.viewState,this,this.mm.context),this.mm.renderFrame(t)),this.wm=i},x.prototype.G=function(t,i){this.emit(t,i=void 0===i?{}:i)},x.prototype.Rm=function(){var r=this;this.on("styleChanged",function(){if(r.kv){var t=void 0,i=(t=r.options.backgroundColor||(r.mapStyle&&(i="fast"===r.bZ.MZ.drawMode?_.Util.getOptimalZoom(r.getZoom()):r.getZoom(),i=r.mapStyle.dn(30001,1,i))&&i.faceColor?((t=i.faceColor.rgba.slice(0))[3]=t[3]/255,"rgba( "+t.join(",")+")"):"#f7f7f7"),r.kv.style.backgroundColor=t,r.mapStyle.vn.nX("00001","3","visible",10)),t=r.mapStyle.vn.nX("00001","3","lineColor",10);i&&t?(t=_.Util.Hex2Rgba(t),(t=Ks.oX(t))&&(r.kv.style.backgroundImage=t,r.kv.style.backgroundSize="100px 100px")):!1===i&&(r.kv.style.backgroundImage="none");for(var n=0,s=r.zv;n<s.length;n++){var e=s[n];_.qG(e)&&e.sl()}}r.xm=!0,r.Eo()}),this.on("repaint",function(){r.Eo()})},x.prototype.w$=function(){var t=this;this.R$||("d"===this.baseRender?(this.R$=!0,_.Module.module("DomRender",function(){setTimeout(function(){t.y$||(t.mm=new _.Module.DomRender(t),t.Eo())},0)})):(this.R$=!0,_.Module.module("WebGLRender",function(){setTimeout(function(){t.y$||(AMap.Browser.isWebGL&&!t.KZ?(t.KZ=!0,t.mm=new _.Module.WebGLRender(t),t.I_=new ys(t),t.yH=new _.LH(t,t.I_,t.gn),t.Eo()):t.R$=!1)},0)})))},x.prototype.Rv=function(t,i){return this.isDOMMode()?$s.JZ[t.CLASS_NAME]?new $s.JZ[t.CLASS_NAME](this,t):void 0:$s.YZ[t.CLASS_NAME]?new $s.YZ[t.CLASS_NAME]:void 0},x.prototype.KT=function(){var e,r,h,o,a,u,c=this,t=this._view.getStatus(),f=t.zoom,l=t.centerCoord,d=f,v=0;0!=(v=(d=this.bo>f?Math.floor(f):Math.ceil(f))-f)&&(this.bo=d,e=_.V[this._view.au()],r=200*Math.abs(v)+100,h=new H(0,.6,.15,1),u=o=0,a=function(){o+=16;var t=c._view.getStatus().zoom,i=f+v*h.h(o/r),t=(r<o&&(i=d),e.nt(c.QT[0],c.QT[1],t)),s=(n=e.nt(c.QT[0],c.QT[1],i))[0]-t[0]+l[0],n=n[1]-t[1]+l[1],t=c.getProjection().unproject(s,n);c.setZoomAndCenter(i,t,!0),d<=i&&0<v||v<0&&i<=d?(c.setZoom(d,!0),_.Util.cancelAnimFrame(u)):o<r&&(u=_.Util.requestAnimFrame(a))},u=_.Util.requestAnimFrame(a))},x.prototype.iB=function(){window.onbeforeload=this.destroy,window.onunload=this.destroy,window.onbeforeunload=this.destroy},x.t_=[2,20];var ie,ne=x;function x(t,i){var n=ie.call(this)||this;n.className="AMap.Map",n.so=new as,n.lcs=_.lcs,n.debug=!1,n.complete=!1,n.Kv=!1,n.controls=[],n.langForeign="zh_cn",n.fE=!0,n.IY="normal",n.az=[.92,.92,.9,.9],n.sz=[.94,.94,.94,.9],n.rz=[.94,.94,.94,.9],n.$C=[.329,.549,.839,1],n.Ov=!0,n.Dv=!0,n.Pv=!0,n.Fv=!0,n.fZ=1,n.fi=!0,n.jv=!0,n.Ev=!0,n.Uv=!0,n.Bv=!0,n.$v=!0,n.Nv=0,n.Sm=!1,n.c_="",n.Zv="default",n.qv="",n.xt=[2,20],n.YG=!1,n.QZ="",n.zv=[],n.A$=!1,n.R$=!1,n.Qv=0,n.f0=void 0,n.xm=!1,n.lt=!1,n.Cv=!1,n.Lv=!1,n.gm=!1,n.km=0,n.Jv=5,n.y$=!1,n.Wv=!_.Support.$e,n.g$=!0,n.tB=(new Date).getTime(),n._$=-1,n.M$=-1,n.S$=-1,n.k$=-1,n.HL=!1,n.bo=10,n.tD=!1,n.QT=[0,0],n.UB=!1,n.tE="",n.KZ=!1,n.zX=!1,_.Support.hardwareAccEnabled||console&&console.log&&console.log("检测到您已关闭硬件加速模式，开启以获得更好的体验！"),n.Rm(),n.options=i,n.xX=i.cacheSize,n.g$=void 0===i.I$?n.g$:i.I$,n.az=_.Util.color2RgbaArray(i.buildingColor=i.buildingColor),n.sz=_.Util.color2RgbaArray(i.wallColor),n.rz=_.Util.color2RgbaArray(i.roofColor),n.$C=_.Util.color2RgbaArray(i.skyColor),n.Dv=void 0===i.dragEnable?n.Dv:i.dragEnable,n.Pv=void 0===i.zoomEnable?n.Pv:i.zoomEnable,n.Fv=void 0===i.scrollWheel?n.Fv:i.scrollWheel,n.fZ=void 0===i.zoomSpeed?n.fZ:i.zoomSpeed,n.Ov=void 0===i.jogEnable?n.Ov:i.jogEnable,n.fi=void 0===i.doubleClickZoom?n.fi:i.doubleClickZoom,n.jv=void 0===i.keyboardEnable?n.jv:i.keyboardEnable,n.Ev=void 0===i.animateEnable?n.Ev:i.animateEnable,n.Uv=void 0===i.pitchEnable?n.Uv:i.pitchEnable,n.$v=void 0!==i.touchZoom?i.touchZoom:n.$v,n.Nv=void 0!==i.touchZoomCenter?i.touchZoomCenter:n.Nv,n.Zv=i.defaultCursor||n.Zv,n.QZ=i.overseaDataType||n.QZ,n.IY=i.loadData||"normal",n.Wdt=i.poiIcon,i.limitBounds&&n.setLimitBounds(i.limitBounds),n.Sm=i.Lm||!1,n.xt=i.zooms||n.xt,n.bo=i.zoom||n.bo,n.baseRender=_.Support.baseRender,i.viewMode="d"===_.Support.baseRender?"2D":i.viewMode,n.Bv=!("3D"!==i.viewMode),n.Bv=void 0===i.rotateEnable?n.Bv:i.rotateEnable,n.debug=i.debug||!1,n.m$="3D"===i.viewMode&&i.showBuildingBlock,n.Wv=void 0===i.isHotspot?n.Wv:i.isHotspot,n.UB=void 0===i.pickWhenMoving?n.UB:i.pickWhenMoving,n.fE=void 0===i.asyncOverlay?n.fE:i.asyncOverlay,n.showLabel=void 0===i.showLabel||Boolean(i.showLabel),n.Cw=i.features||["bg","point","road","building"],n.c$=i.mask,n.NH=void 0!==i.labelRejectMask&&Boolean(i.labelRejectMask),n.bZ=new Gs({lY:new _.MY,gY:new Os,yY:new _.wY({check:function(){return!!n.bZ&&n.bZ.MZ.lY.xY()},render:function(){if(n.TL())return!1;n.bZ&&n.bZ.MZ.lY.exec(20)}}),drawMode:i.drawMode||"normal",tY:new Xs({Fz:["default"]}),wZ:new Zs(n),KY:new se(n)}),n.WebGLParams=void 0===i.WebGLParams?{}:i.WebGLParams,"d"!==n.baseRender?(n.bZ.dynamic.subscribe("firstPaint",function(){n.emit("firstPaint",_.Support.amapRunTime)},n,!0),n.bZ.MZ.lY.on("taskclear",function(){n.setNeedUpdate(!0)}),n.bZ.MZ.lY.register("SDFCombine",function(t){return new Es(n.bZ.MZ.gY,t)},{kY:10}),n.bZ.MZ.lY.register("LangSDF",function(t){return new Xn(n.R_.yG,t)},{kY:10}),n.mapStyle=new _n(n),n.mapStyle.pn(function(){var t=i.mapStyle;t?n._getUserStyle(t):n.emit("styleChanged")}),n.Eo(),s=n.z_=new Vn,n.gn=new rs(n),n.R_=new Zn(s,n),n.x$=new js(n)):(n.z_=new Vn,n.R_=new _.vG,n.emit("styleChanged"));(s=i.vectorMapForeign)&&n._getMapboxStyle(s),i.langForeign&&(n.langForeign=i.langForeign),n.gn&&n.gn.Ha({langForeign:n.langForeign}),t&&(t.amap&&t.amap.destroy(),t.amap=n),n.kv=t,n.isDOMMode()&&(i.zoom=i.zoom&&18<i.zoom?18:i.zoom),n._view=n.pm(i),n.b$=new ws(n),n.Mv=new Ui(n),n.c_=i.mapStyle||"normal",n.QR=null;var s=_.Support.isWebGL,t=AMap.getConfig().y_,e=i.layers||[],r=(n.cm(),s&&"d"!==n.baseRender&&(n.canvas=w.create("canvas",n.do,"amap-layer"),n.canvas.width=0,n.canvas.height=0,n.gl=_.Support.getContext(n.canvas,n.WebGLParams)),n.w$(),0===e.length?n.isDOMMode()?(n.bo=18<n.bo?18:n.bo,r=[n.xt[0],n.xt[1]],n.xt[0]=2<r[0]?r[0]:2,n.xt[1]=18<r[1]?18:r[1],n.addLayer(new v({id:"_defaultLayer",tileUrl:t})),n.Bv=!1):s&&n.addLayer(new Ji({cacheSize:n.xX})):n.um(e),n.d_(),n.$F=new is({map:n}),n.addLayer(n.$F),n._view.getStatus());return n.wm=r,n.setCursor(n.Zv),AMap.getConfig().keytype&&"1"===AMap.getConfig().keytype&&(n.isDOMMode()?n.addLayer(new v.Mark({})):n.addLayer(new AMap.Mark({zIndex:8,opacity:1,map:n}))),n}ee.prototype.setHighlight=function(t,i){this.Lp=t,this.Ap=i,this._Y.setNeedUpdate(!0)},ee.prototype.destroy=function(){this.map.off("hotspotclick",this.$Y),this.map.off("hotspotover",this.$Y),this.map.off("hotspotout",this.tX)},ee.prototype.$Y=function(t){this.iX=t.id,this.map.setNeedUpdate(!0)},ee.prototype.tX=function(t){this.iX="",this.map.setNeedUpdate(!0)};var se=ee;function ee(t){var i=this;this.map=t,this.Lp=-2,this.Ap=[],this.iX="",this.$Y=this.$Y.bind(this),this.tX=this.tX.bind(this),this.map.on("hotspotclick",this.$Y),this.map.on("hotspotover",this.$Y),this.map.on("hotspotout",this.tX),this.GY=Date.now(),this.NY=0,this.UY=!0,this._Y=new _.wY({check:function(){return-1<i.Lp},render:function(){var t=Date.now()-i.GY;i.NY=2400<t%3e3?0:.5-Math.abs(t%3e3/2400-.5),i.map.setNeedUpdate(!0)}}),this._Y.setNeedUpdate(!0)}he.prototype.setImageSize=function(t){t instanceof _.Size&&(t=t.toArray()),this._opts.imageSize=t},he.prototype.getImageSize=function(){var t=this._opts.imageSize,i=this.Om;return t||(i.length?i:[])},he.prototype.setSize=function(t){t instanceof _.Size&&(t=t.toArray()),this._opts.size=t},he.prototype.getSize=function(){return this._opts.size},he.prototype.setImageOffset=function(t){t instanceof _.Pixel&&(t=t.toArray()),this._opts.imageOffset=t},he.prototype.getImageOffset=function(){return this._opts.imageOffset||[0,0]},he.prototype.getImage=function(){return this._opts.image},he.prototype.setImage=function(t){this._opts.image=t},he.prototype.Fm=function(){return this.Om||[]},he.prototype.Em=function(t){t instanceof _.Size&&(t=t.toArray()),this.Om=t};var re=he;function he(t){this.CLASS_NAME="AMap.Icon",this._opts={size:[0,0],imageOffset:new _.Pixel(0,0),image:AMap.getConfig().protocol+"://webapi.amap.com/theme/v1.3/markers/0.png"},this.Om=[];var i=t.size,n=t.imageSize,s=t.image,t=t.imageOffset;i&&this.setSize(i),n&&this.setImageSize(n),t&&this.setImageOffset(t),s&&this.setImage(s)}var oe,ae="AMap.Overlay",Qt=(oe=_.Event,_.Ei(ue,oe),ue);function ue(){var t=null!==oe&&oe.apply(this,arguments)||this;return t.type=ae,t.className=ae,t}ce=_.Event,_.Ei(fe,ce);var ce;function fe(){var t=null!==ce&&ce.apply(this,arguments)||this;return t.type=ae,t.className=ae,t}var le,de={_dt:function(t){return!!(window&&window._AMapConfig&&window._AMapConfig.wiaBizToken)&&!!(t&&t[0]&&"string"==typeof t[0]&&-1<t[0].indexOf("WIA"))},Ydt:function(e){return _.T8t(this,void 0,void 0,function(){var i,n;return _.x8t(this,function(t){return i="http://dev-restapi.amap.com/api/v1/wia/point/get/lonlat?s=rsv3&key="+AMap.getConfig().key+"&bizToken="+window._AMapConfig.wiaBizToken,(n=AMap.getConfig()).jscode&&(i+="&jscode="+n.jscode),[2,new Promise(function(n,s){yi.Ajax(i,{requestContentType:"application/json",type:"POST",content:JSON.stringify({wiaLonLat:e})},function(t,i){i&&i.data&&(i=JSON.parse(i.data))&&i.data&&i.data.list&&i.data.list[0]?(i=i.data.list[0],i=new AMap.LngLat(i.lon,i.lat),n([i.lng,i.lat])):s("error")})})]})})}},ve="AMap.DOMOverlay",ge={top:"top",right:"right",bottom:"bottom",left:"left",Nm:"top-left",$m:"top-center",Um:"top-right",Bm:"middle-left",center:"center",Wm:"middle-right",Gm:"bottom-left",Zm:"bottom-center",qm:"bottom-right"},Me_Ym="viewchange",ke=[10,0,0,0],we={map:null,visible:!0,offset:[0,0],anchor:"top-left",rotate:0,orientation:null,scale:1,zooms:_.zoomRange,noSelect:!1,innerOverlay:!1,isCustom:!1},si=(le=fe,_.Ei(xe,le),xe.prototype.getOptions=function(){return this._options},xe.prototype.add=function(t){for(var i=this._map,n=0,s=t=void 0===t?[]:t;n<s.length;n++)s[n].add(i)},xe.prototype.remove=function(t){for(var i=0,n=t=void 0===t?[]:t;i<n.length;i++)n[i].remove()},xe.prototype.updateOverlay=function(t){if(t)for(var i=0,n=t;i<n.length;i++)n[i].updateOverlay();else{var s,e=!this.aZ&&this.viewChange,r=(this.aZ=!1,this._overlays);for(s in r)r.hasOwnProperty(s)&&r[s].updateOverlay({viewChange:e})}},xe.prototype.iy=function(t){this.updateOverlay()},xe.prototype.addToGroup=function(t){var i=this._container,n=this._overlays,s=t.hS,e=t.dom;i.appendChild(e),n[s]=t},xe.prototype.removeFromGroup=function(t){var i=this._container,n=this._overlays,s=t.hS,t=t.dom;i.removeChild(t),delete n[s]},xe.prototype.vi=function(t){return null},xe.prototype.destroy=function(){this.ey();var t,i=this._overlays;for(t in i)i.hasOwnProperty(t)&&i[t].remove();this._overlays={},this._container&&w.remove(this._container)},xe.prototype.getAllOverlays=function(){var t,i,n=this._overlays,s=[];for(t in n)n.hasOwnProperty(t)&&(i=n[t])&&s.push(i);return s},xe.prototype.ny=function(){this._map},xe.prototype.ey=function(){var t=this._map,i=Me_Ym;t.off(i,this.iy)},xe);function xe(t,i){void 0===i&&(i={});var n=le.call(this)||this,t=(n.type="AMap.DOMOverlayGroup",n.viewChange=!1,n.aZ=!1,n._options={zIndex:120},n._overlays={},(n._map=t).kv),t=(n._parent=t.querySelector(".amap-layers"),i.className);return n._className=t,n.iy=n.iy.bind(n),n.ny(),n}Ae=Qt,_.Ei(A,Ae),Object.defineProperty(A.prototype,"CLASS_NAME",{get:function(){return this.className},eb:!1,nb:!0}),A.prototype.getMap=function(){return this._map||null},A.prototype.setMap=function(t){t instanceof ur?this.add(t):null==t&&this.remove()},A.prototype.addTo=function(t){this.add(t)},A.prototype.add=function(t){t&&(this._add(t),this._parent)&&(this._parent.addToGroup(this),this.updateOverlay())},A.prototype.remove=function(){this._map&&this._parent&&(this._parent.removeFromGroup(this),this._remove())},A.prototype.show=function(){this._opts.visible=!0,this.updateOverlay()},A.prototype.hide=function(){this._opts.visible=!1,this.updateOverlay()},A.prototype.getPosition=function(){var t=this._position;return t?_.Bs(t)?t:new _.LngLat(t[0],t[1]):null},A.prototype.setPosition=function(t){this._position=t,this.updateOverlay()},A.prototype.getAnchor=function(){return this._opts.anchor||ge.Nm},A.prototype.setAnchor=function(t){t&&(this._opts.anchor=t,this.updateOverlay())},A.prototype.getOffset=function(){var t=this._opts.offset||[0,0];return new _.Pixel(t[0],t[1])},A.prototype.setOffset=function(t){t&&(t instanceof Array||void 0===t.x||void 0===t.y||(this._opts.offset=[t.x,t.y]),this.updateOverlay())},A.prototype.getAngle=function(){return this._opts.rotate||0},A.prototype.setAngle=function(t){this._opts.rotate=t,this.updateOverlay()},A.prototype.getOrientation=function(){return this._opts.orientation},A.prototype.setOrientation=function(t){"number"==typeof t?(this._opts.orientation=t,this._opts.rotate=this.dP(t)):(this._opts.orientation=void 0,this._opts.rotate=0),this.updateOverlay()},A.prototype.getSize=function(){return this._getSize()},A.prototype.setSize=function(t){this._opts.size=_.ay(t)?t.toArray():t,this.updateOverlay()},A.prototype.getzIndex=function(){return this._opts.zIndex},A.prototype.setzIndex=function(t){this._opts.zIndex=t,this.updateOverlay()},A.prototype.getOptions=function(){return this._opts},A.prototype.getContent=function(){return this._opts.content||""},A.prototype.setContent=function(t){this._opts.content=t=void 0===t?"":t,this._size=[0,0],this._removeContent(),this._createDom(this.dom,t),this.updateOverlay()},A.prototype.getBounds=function(){var t=this._position;return new l(t,t)},A.prototype.getVisible=function(){return void 0===this._opts.visible||this._opts.visible},A.prototype.updateOverlay=function(t){t=void 0!==(t=(t=void 0===t?{}:t).viewChange)&&t,this._map&&this._setStyle(t)&&this._applyStyle(t)},A.prototype.uZ=function(t){t=void 0!==(t=(t=void 0===t?{}:t).viewChange)&&t,this._map&&(this._setStyle(t),this._applyStyle(t))},A.prototype.destroy=function(){this.dom&&w.remove(this.dom)},A.prototype.getCursor=function(){if(this._map)return this._map.getDefaultCursor()},A.prototype.getContentDom=function(){return this.dom},A.prototype._add=function(t){},A.prototype._remove=function(){this._map=null,this._parent=null},A.prototype._createContainer=function(){var t=document.createElement("div");return w.addClass(t,this._className),t},A.prototype._createDefaultInnerDom=function(){return document.createElement("div")},A.prototype._setStyle=function(t){void 0===t&&(t=!1);var i=this._position,i=this._points=this._map&&i&&this._map.lngLatToContainer(i).toArray(),n=(this._map&&this._map.getRotation(),this._style),s=this._map&&this._map.getZoom(),e=this._opts.zooms||[2,20],r=void 0===this._opts.visible||this._opts.visible,s=s&&(s<e[0]||s>e[1]),e=n.visible,r=(void 0!==r&&(n.visible=r),r&&(n.visible=!s),this.ZF(i));n.visible&&(n.visible=!r);var r=(s=this._opts).zIndex,h=void 0===(h=s.anchor)?ge.Nm:h,o=void 0===(o=s.offset)?[0,0]:o,a=s.rotate,u=s.scale,c=s.noSelect,f=[0,0];return"number"==typeof(s=s.orientation)?n.rotate=this.dP(s):void 0!==a&&(n.rotate=a),e!==n.visible&&this._map&&(this._map.render(),this._parent)?!(this._parent.aZ=!0):(t?i&&(n.left=i[0]+"px",n.top=i[1]+"px",f=n.translate):(this._getContentSize(),(s=this._getStyleZIndex(r))&&(n.zIndex=s),void 0!==u&&(n.scale=u),i&&(n.left=i[0]+"px",n.top=i[1]+"px"),(h||o)&&(f=this._getOffset(h,o),n.translate=f,n.transformOrigin=-f[0]+"px "+-f[1]+"px"),n.pointerEvents=!0===c?"none":"auto"),a="translate("+f[0]+"px, "+f[1]+"px) scale("+n.scale+") rotate("+n.rotate+"deg)",_.Support.ie&&(n.msTransform=a),n.transform=a,!0)},A.prototype._getStyleZIndex=function(t){return t},A.prototype._getSize=function(){var i=(t=(t=this._opts.size||[])instanceof _.Size?t.toArray():t)[0],t=void 0===(t=t[1])?0:t,s=(n=this._size)[0],n=n[1];return[(void 0===i?0:i)||(void 0===s?0:s),t||(void 0===n?0:n)]},A.prototype._getContentSize=function(){var t=this._style,i=this._getSize(),n=0,s=0;i[0]&&i[1]?(n=i[0],s=i[1]):this.dom&&(i=this.dom,n=Math.ceil(i.offsetWidth)||0,s=Math.ceil(i.offsetHeight)||0,this._size=[n,s]),t.width=n+"px",t.height=s+"px",t.size=[n,s]},A.prototype._applyStyle=function(t){void 0===t&&(t=!1);var i,n,s=this._style,e=this.dom;for(i in s)s.hasOwnProperty(i)&&("visible"===i?(n=s[i]?"block":"none",e.style.display=n):t?"top"!==i&&"left"!==i&&"transform"!==i&&"msTransform"!==i||(e.style[i]=s[i]):"width"===i||"height"===i?"0px"!==s[i]&&(n=this._opts.size)&&"AMap.InfoWindow"!==this.type&&("width"===i&&(e.style[i]=n[0]+"px"),"height"===i)&&(e.style[i]=n[1]+"px"):"translate"!==i&&"scale"!==i&&"rotate"!==i&&(e.style[i]=s[i]))},A.prototype._getOffset=function(t,i){var n=(t=this._getAnchorOffset(t))[0],t=t[1];return[n+i[0],t+i[1]]},A.prototype._getAnchorOffset=function(t){var n=(i=this._style.size)[0],s=i[1],i=ge,e=0,r=0;if(Array.isArray(t))return t;switch(t){case i.Nm:e=0;break;case i.$m:e=-n/2;break;case i.Um:e=-n;break;case i.Bm:e=0,r=-s/2;break;case i.center:e=-n/2,r=-s/2;break;case i.Wm:e=-n,r=-s/2;break;case i.Gm:r=-s;break;case i.Zm:e=-n/2,r=-s;break;case i.qm:e=-n,r=-s}return[e,r]},A.prototype._createDom=function(t,i){return i&&("object"==typeof i&&i instanceof HTMLElement?t.appendChild(i):t.innerHTML=i),t.addEventListener("touchstart",function(t){t.cH="markerContent"}),t},A.prototype._removeContent=function(){this.dom.innerHTML=""},A.prototype._formatSize=function(t){return[t.getWidth(),t.getHeight()]},A.prototype.ZF=function(t){var i,n=this._map;return!!(n&&t&&"3D"===(n=n.getView()).type&&(n=n.Uu(),i=ke,t)&&t[1]-n-i[0]<=0)},A.prototype._getRotationByPoints=function(t,i){var n=i.y-t.y,s=i.x-t.x,e=0;return(0!=n||0!=s)&&(i.x-t.x!=0?(e=Math.atan((i.y-t.y)/(i.x-t.x)),0<=n&&s<0||n<0&&s<=0?e=Math.PI+e:n<0&&0<=s&&(e=2*Math.PI+e)):e=i.y>t.y?Math.PI/2:3*Math.PI/2,Math.round(180*e/Math.PI*10)/10)},A.prototype._getRotationByLngLats=function(t,i){var n=null==(n=this._map)?void 0:n.getProjection().project(t.KL,t.kT),i=(t=null==(t=this._map)?void 0:t.getProjection().project(i.KL,i.kT))[0]-n[0],t=t[1]-n[1],n=0;return(0!=i||0!=t)&&(0!=t?(n=Math.atan(i/t),0<=i&&0<t||(0<=i&&t<0||i<0&&t<0?n=Math.PI+n:i<0&&0<t&&(n=2*Math.PI+n))):n=0<i?Math.PI/2:3*Math.PI/2,Math.round(180*n/Math.PI*10)/10)},A.prototype.dP=function(t){var i=0,n=this._position,s=(n instanceof AMap.LngLat&&(n=[n.lng,n.lat]),this._map);return s&&n&&(t=this.pP(n,t),n=s.lngLatToContainer(n),s=s.lngLatToContainer(t),i=!1===(t=this._getRotationByPoints(n,s))?0:t+Math.PI),i+90},A.prototype.pP=function(t,i){var n=null==(n=this._map)?void 0:n.getProjection().project(t[0],t[1]);return n[0]+=Math.sin(i*Math.PI/180)*Math.pow(2,18-this._map.getZoom()),n[1]+=Math.cos(i*Math.PI/180)*Math.pow(2,18-this._map.getZoom()),null==(t=this._map)?void 0:t.getProjection().unproject(n[0],n[1])},A.prototype.vP=function(t){return 10/Math.pow(2,t-2)},A.prototype.Ydt=function(n){return _.T8t(this,void 0,void 0,function(){var i;return _.x8t(this,function(t){switch(t.label){case 0:return[4,de.Ydt(n)];case 1:return i=t.y8t(),this._position=i,this.updateOverlay(),[2]}})})};var Ae,Pi=A;function A(t,i){void 0===t&&(t={}),void 0===i&&(i={});var n=Ae.call(this)||this,s=(n.type=ve,n.className=ve,n._style={width:0,height:0,size:[0,0],position:"absolute",top:0,left:0,translate:[0,0],rotate:0,scale:1,transformOrigin:[0,0],zIndex:12,visible:!0,draggable:!1,zooms:_.zoomRange,noSelect:!1},n._size=[0,0],n._dragObjects={sy:[0,0],hy:[0,0],ly:[0,0]},n._className="amap-overlay",n._originOpts=t,n._opts=_.assign({},we,t),n._opts.angle&&(n._opts.rotate=n._opts.angle),!t.offset||t.offset instanceof Array||void 0===t.offset.x||void 0===t.offset.y||(n._opts.offset=[t.offset.x,t.offset.y]),n.hS=_.Util.stamp(n),i.className),i=i.anchor,s=(n._className=s,!t.anchor&&i&&(n._opts.anchor=i),t.content),i=n._createContainer();return n.dom=n._createDom(i,s),n._position=t.position,n.updateOverlay(),n}var ze,Ce={uy:"AMap.Marker",py:"amap-markers",vy:"amap-marker",my:"//webapi.amap.com/theme/v1.3/markers/b/mark_bs.png",yy:120,xy:12,by:2,gy:Math.pow(2,31)},Se=_.assign({},we,{title:"",clickable:!0,draggable:!1,bubble:!1,topWhenClick:!1,zIndex:Ce.xy,cursor:"pointer",extData:{}}),Te=(ze=si,_.Ei(Le,ze),Le.prototype.vi=function(t){var i,n,t=t.target;return _.isEmpty(this._overlays)||!t?null:(i=w.closest(t,"amap-marker"),t=this._overlays,n=null,i&&_.forEach(t,function(t){t.dom===i&&(n=t)}),n)},Le.prototype.setTop=function(t){var i;t&&((i=this.Kl)&&i!==t&&i.setTop(!1),this.Kl=t)},Le.prototype._createContainer=function(t){var i=document.createElement("div");return w.addClass(i,this._className),t.appendChild(i),i},Le);function Le(t){return(t=ze.call(this,t,{className:Ce.py})||this).type=Ce.uy,t.className=Ce.uy,t._container=t._createContainer(t._parent),t}Ie=Pi,_.Ei(z,Ie),z.prototype.getTitle=function(){return this._opts.title},z.prototype.setTitle=function(t){this._opts.title=t,this.dom&&this.dom.setAttribute("title",t)},z.prototype.getIcon=function(){return this._opts.icon},z.prototype.setIcon=function(t){t&&(this._opts.icon=t,this._opts.content||this._removeContent(),"AMap.Icon"===t.CLASS_NAME&&(this._opts.size=t.getSize()),this.wy(),this.updateOverlay())},z.prototype.getLabel=function(){return this._opts.label||{}},z.prototype.setLabel=function(t){var i,n=this._opts.label||{},t=(this._opts.label=_.assign(n,t),n.content),n=void 0===(n=n._needUpdate)||n;t?((i=this._y?this.ky(t,this._y):this._y=this.ky(t))&&(11<=(t=void 0,t=this.v0())||t<0)&&this.d0(),this.dom&&this.dom.appendChild(i),n&&this.updateOverlay()):this._y&&(w.remove(this._y),this._y=null)},z.prototype.getClickable=function(){var t=this._opts.clickable;return!(void 0!==t&&!t)},z.prototype.setClickable=function(t){this._opts.clickable=!!(t=void 0===t||t)},z.prototype.getDraggable=function(){var t=this._opts.draggable;return void 0!==t&&t},z.prototype.setDraggable=function(t){(this._opts.draggable=t)?this._bindEvents():this.T_()},z.prototype.getTop=function(){return this._isTop},z.prototype.setTop=function(t){this._isTop=t=void 0!==t&&t;var i=this._parent;i&&t&&i.setTop(this),this.updateOverlay()},z.prototype.getCursor=function(){var t=this._opts.cursor;return!t&&this._map?this._map.getDefaultCursor():t},z.prototype.setCursor=function(t){t&&(this._opts.cursor=t)},z.prototype.getExtData=function(){return this._opts.extData},z.prototype.setExtData=function(t){this._opts.extData=t},z.prototype.remove=function(){this.T_(),this.ZH(),Ie.prototype.remove.call(this)},z.prototype.moveTo=function(){console.log("Should implement AMap.moveAnimation plugin first.")},z.prototype.moveAlong=function(){console.log("Should implement AMap.moveAnimation plugin first.")},z.prototype.startMove=function(){console.log("Should implement AMap.moveAnimation plugin first.")},z.prototype.stopMove=function(){console.log("Should implement AMap.moveAnimation plugin first.")},z.prototype.pauseMove=function(){console.log("Should implement AMap.moveAnimation plugin first.")},z.prototype.resumeMove=function(){console.log("Should implement AMap.moveAnimation plugin first.")},z.prototype.setOptions=function(t){this._opts=_.assign({},Se,this._opts,t),t.content&&this.setContent(t.content),t.offset&&this.setOffset(t.offset),t.title&&this.setTitle(t.title),t.label&&this.setLabel(t.label),t.draggable&&this.setDraggable(!0),this.updateOverlay()},z.prototype.updateOverlay=function(t){Ie.prototype.updateOverlay.call(this,t=void 0===t?{}:t);t=this._y;this._opts.label&&t&&(!t.parentElement&&this.dom&&this.dom.appendChild(t),0<(t=void 0,t=this.v0())&&t<11&&this.My(),this.Ry())},z.prototype.emit=function(t,i){var n=this.getCursor();return this._map&&("mouseout"===t?this._map.setCursor():this._map.setCursor(n)),"click"===t?this.getClickable()&&(Ie.prototype.emit.call(this,t,i),void 0!==(n=this.getOptions().topWhenClick))&&n&&this.setTop(!0):("dragstart"!==t&&"dragging"!==t&&"dragend"!==t||(_.Support.$e||i.originEvent.buttons&&2!==i.originEvent.buttons&&i.originEvent.preventDefault(),this.getDraggable()))&&Ie.prototype.emit.call(this,t,i),this},z.prototype.toGeometry=function(){var t=this.getPosition();if(t)return{type:"Point",coordinates:t&&t.toJSON()}},z.prototype.v0=function(){var t=navigator.userAgent,i=-1<t.indexOf("compatible")&&-1<t.indexOf("MSIE"),n=-1<t.indexOf("Edge")&&!i,s=-1<t.indexOf("Trident")&&-1<t.indexOf("rv:11.0");return i?(new RegExp("MSIE (\\\\d+\\\\.\\\\d+);").test(t),7===(i=parseFloat(RegExp.$1))?7:8===i?8:9===i?9:10===i?10:6):n?"edge":s?11:-1},z.prototype.d0=function(){var t=this;new MutationObserver(function(){t._opts.label&&t.My()}).observe(this._y,{attributes:!0,characterData:!0,childList:!0,subtree:!0})},z.prototype._add=function(t){this._map=t,this._parent=t.pi,this.updateOverlay()},z.prototype._createDom=function(t,i){return this.dom=Ie.prototype._createDom.call(this,t,i),this.wy(),t},z.prototype._createDefaultInnerDom=function(){var t=document.createElement("img");return t.setAttribute("width","19px"),t.setAttribute("height","32px"),t.setAttribute("src",Ce.my),this._size=[19,32],t},z.prototype._getMarkerOffset=function(t,i){return i},z.prototype._getStyleZIndex=function(t){var i;return this._isTop?i=Ce.gy:void 0!==t&&(i=t),i},z.prototype._createIcon=function(n,s){var e=this,t=n.getImage(),i=n.getSize(),r=n.getImageSize(),h=n.getImageOffset(),o=document.createElement("div"),a=(o.className="amap-icon",o.style.overflow="hidden",document.createElement("img"));return a.onload=function(){var t=a.width,i=a.height,t=(n.Em([t,i]),e._size=r&&r.length?r:[t,i],e._getSize());e._setIconSize(o,a,t,r),s&&s()},a.onerror=function(){},o.appendChild(a),this._setIconStyle(o,a,{size:i,imageSize:r,imageOffset:h}),a.src=t,o},z.prototype._setIconStyle=function(t,i,n){var s=void 0===(s=n.size)?[0,0]:s,e=void 0===(e=n.imageSize)?[0,0]:e,n=void 0===(n=n.imageOffset)?[0,0]:n;i.style.top=n[1]+"px",i.style.left=n[0]+"px",this._setIconSize(t,i,s,e)},z.prototype._setIconSize=function(t,i,n,s){var e=n[0],n=n[1],r=s[0],s=s[1];e&&(t.style.width=e+"px"),n&&(t.style.height=n+"px"),r&&s&&(i.style.width=r+"px",i.style.height=s+"px")},z.prototype._removeContent=function(){this.dom.innerHTML="",this._opts.label&&this.setLabel(this._opts.label)},z.prototype._getD=function(){return this.dom},z.prototype.wy=function(){var t,i=this,s=(n=this._opts).content,e=n.icon,n=n.text;!s&&e?(t="string"==typeof e?new re({image:e}):e,t=this._createIcon(t,function(){i.updateOverlay(),i._opts.label&&i.My()}),this.dom.appendChild(t)):s||e||n||(t=this._createDefaultInnerDom(),this._originOpts.anchor||(this._opts.anchor="bottom-center"),this.dom.appendChild(t))},z.prototype.ky=function(t,i){return i||((i=document.createElement("div")).className="amap-marker-label"),i.innerHTML=t,i},z.prototype.My=function(){var t,i,n,s,e,r;this._y&&(r=this._style.size,i=(e=this._opts.label).offset,t=(i=_.oy(i=void 0===i?[0,0]:i)?i.toArray():i)[0],i=i[1],n=this._y.offsetWidth,s=this._y.offsetHeight,n=this.zy.size=[n,s],r=(e=[(s=this.Sy(e,r,n))[0]+t,s[1]+i])[0],this.zy.top=e[1],this.zy.left=r)},z.prototype.Sy=function(t,i,n){var t=t.direction,e=i[0],r=i[1],h=n[0],o=n[1],a=0,u=0;switch(void 0===t?"right":t){case ge.Nm:a=0,u=-o;break;case ge.top:case ge.$m:a=e/2-h/2,u=-o;break;case ge.Um:a=e,u=-o;break;case ge.right:case ge.Wm:a=e,u=r/2-o/2;break;case ge.center:a=e/2-h/2,u=r/2-o/2;break;case ge.left:case ge.Bm:a=-h,u=r/2-o/2;break;case ge.Gm:a=0,u=r;break;case ge.bottom:case ge.Zm:a=e/2-h/2,u=r;break;case ge.qm:a=e,u=r;break;default:a=e/2-h/2,u=-o}return[a,u]},z.prototype.Ry=function(){var i=(t=this.zy).top,t=t.left,n=this._y;n.style.top=i+"px",n.style.left=t+"px"},z.prototype._bindEvents=function(){this.on("dragstart",this.Cy.bind(this)),this.on("dragging",this._dragging.bind(this)),this.on("dragend",this.Ly.bind(this))},z.prototype.XH=function(){this.dom&&(this.dom.ondragstart=function(){return!1})},z.prototype.T_=function(){this.off("dragstart",this.Cy.bind(this)),this.off("dragging",this._dragging.bind(this)),this.off("dragend",this.Ly.bind(this))},z.prototype.ZH=function(){this.dom&&(this.dom.ondragstart=null)},z.prototype.Cy=function(t){this.Ay(t)},z.prototype._dragging=function(t){var n=(i=t.lnglat).lng,i=i.lat,n=new _.LngLat(n,i);this._map&&(this.setPosition(n.toJSON()),this.Ay(t))},z.prototype.Ly=function(t){},z.prototype.Ay=function(t){this._dragObjects={sy:t.pixel,hy:t.pos,ly:t.lnglat}};var Ie,De=z;function z(t){var i=Ie.call(this,t=void 0===t?{}:t,{className:Ce.vy})||this,n=(i.type=Ce.uy,i.className=Ce.uy,i._isTop=!1,i.zy={width:0,height:0,size:[0,0],top:0,left:0,translate:[0,0],zIndex:Ce.by},i._opts=_.assign({},Se,i._opts),i._opts.size),s=i._opts.icon;return!n&&s instanceof re&&(n=s.getSize(),i._opts.size=n),n instanceof _.Size&&(i._opts.size=i._formatSize(n)),t.title&&i.setTitle(t.title),t.label&&i.setLabel(t.label),t.draggable&&i.setDraggable(!0),(s=t.map)&&s instanceof ur&&i.add(s),i.XH(),i}var Oe,Re,Ee,C={getViewport:function(t){return t?[t.clientWidth,t.clientHeight]:[0,0]},getStyle:function(t,i){var n,s=t.style[i];return"auto"===(s=(s=(s=s&&"auto"!==s||!document.defaultView?s:(n=document.defaultView.getComputedStyle(t,null))?n[i]:null)&&"auto"!==s||"height"!==i?s:t.clientHeight+"px")&&"auto"!==s||"width"!==i?s:t.clientWidth+"px")?null:s},getViewportOffset:function(t){var i,n=0,s=0,e=t,r=document.body,h=document.documentElement;do{if(n+=e.offsetTop||0,s+=e.offsetLeft||0,n+=parseInt(C.getStyle(e,"borderTopWidth"),10)||0,s+=parseInt(C.getStyle(e,"borderLeftWidth"),10)||0,i=C.getStyle(e,"position"),e.offsetParent===r&&"absolute"===i)break;if("fixed"===i){n+=r.scrollTop||h.scrollTop||0,s+=r.scrollLeft||h.scrollLeft||0;break}}while(e=e.offsetParent);for(e=t;e!==r&&(n-=e.scrollTop||0,s-=e.scrollLeft||0,!C.m()&&_.Support.webkit&&(s+=e.scrollWidth-e.clientWidth),e=e.parentNode););return[s,n]},m:function(){return Oe||(Re="ltr"===C.getStyle(document.body,"direction"),Oe=!0),Re},create:function(t,i,n,s){return t=document.createElement(t),n&&(t.className=n),i&&(s&&"before"===s?(n=i.firstChild,i.insertBefore(t,n)):i.appendChild(t)),t},toggleClass:function(t,i,n){n?this.addClass(t,i):this.removeClass(t,i)},hasClass:function(t,i){if(t&&i)return 0<t.className.length&&new RegExp("(^|\\\\s)"+i+"(\\\\s|$)").test(t.className)},addClass:function(t,i){t&&i&&(t.classList&&t.classList.add?t.classList.add(i):this.hasClass(t,i)||(t.className+=(t.className?" ":"")+i))},setClass:function(t,i){t&&(t.className=i||"")},removeClass:function(t,n){t&&n&&(t.classList&&t.classList.remove?t.classList.remove(n):t.className=t.className.replace(/(\\S+)\\s*/g,function(t,i){return i===n?"":t}).replace(/(^\\s+|\\s+$)/,""))},watchSize:function(n,s,e){var i=document.createElement("iframe"),r=(i.style.cssText="width: 100%;height: 100%;position: absolute;pointEvents:none; opacity:0; margin: 0;padding: 0;border: none;",i.onload=function(){i&&(i.contentWindow.onresize=t)},n.appendChild(i),i.src="javascript:void(0)",0),h=0;function t(){e.k=n.getBoundingClientRect(),e.M=[n.clientLeft,n.clientTop];var t=n.offsetWidth,i=n.offsetHeight;t===r&&i===h||(s(t,i),r=t,h=i)}return t(),e.resize=t,window.onscroll=t,function(){var t;e.resize&&(e.resize=null),window.onscroll&&(window.onscroll=null),i.contentWindow&&(i.contentWindow.onresize=null,i.contentWindow.document.write(""),i.parentNode.removeChild(i),null!=(t=i.contentWindow))&&t.close()}},watchSize2:function(n,s,e){var r,h,o=document.createElement("_"),a=(o.className="expand",o.appendChild(document.createElement("_"))),u=(a.className="shrink",o.appendChild(document.createElement("_"))),t=(u.className="expandChild",a.appendChild(document.createElement("_")));return t.className="shrinkChild",a.style.cssText=o.style.cssText="height:100%;left:0;opacity:0;overflow:hidden;pointer-events:none;position:absolute;top:0;transition:0s;width:100%;z-index:-1",t.style.cssText=u.style.cssText="display:block;height:100%;transition:0s;width:100%",t.style.width=t.style.height="200%",n.appendChild(o),c(),function(){f(),n.removeChild(o)};function c(){f(),e.k=n.getBoundingClientRect(),e.M=[n.clientLeft,n.clientTop];var t=n.offsetWidth,i=n.offsetHeight;t===r&&i===h||(r=t,h=i,u.style.width=2*t+"px",u.style.height=2*i+"px",o.scrollLeft=o.scrollWidth,o.scrollTop=o.scrollHeight,a.scrollLeft=a.scrollWidth,a.scrollTop=a.scrollHeight,s(t,i)),a.addEventListener("scroll",c),o.addEventListener("scroll",c)}function f(){a.removeEventListener("scroll",c),o.removeEventListener("scroll",c)}},mousePos:function(t,i,n){return t&&(n.k=t.getBoundingClientRect(),n.M=[t.clientLeft,t.clientTop]),t=n.k,[(i=i.touches&&i.changedTouches?0<i.touches.length?i.touches[0]:i.changedTouches[i.changedTouches.length-1]:i).clientX-t.left-n.M[0],i.clientY-t.top-n.M[1]]},remove:function(t){t&&t.parentNode&&t.parentNode.removeChild(t)},empty:function(t){for(;t.firstChild;)t.removeChild(t.firstChild)},closest:function(t,i){return t?this.hasClass(t,i)?t:(t=t.parentElement)?C.closest(t,i):null:null},fillText:function(t,i){if(t)return void 0!==t.textContent?t.textContent=i:void 0!==t.innerText?t.innerText=i:t.innerHTML=i,t},_L:function(t){for(var i=document.documentElement.style,n=0;n<t.length;n+=1)if(t[n]in i)return t[n];return!1},rotate:function(t,i,n){var s,e=C.kL;n=n||{x:t.clientWidth/2,y:t.clientHeight/2},e?(s="",t.style[e]=s+=" rotate("+i+"deg)",t.style[C.ML[e]+"-origin"]=n.x+"px "+n.y+"px"):(s=Math.cos(i*Math.PI/180),e=Math.sin(i*Math.PI/180),t.style.filter="progid:DXImageTransform.Microsoft.Matrix()",0<t.filters.length&&((i=t.filters.item(0)).Dx=-n.x*s+n.y*e+n.x,i.Dy=-n.x*e-n.y*s+n.y,i.M11=i.M22=s,i.M12=-(i.M21=e)))},setCss:function(t,i){t=t instanceof Array?t:[t];for(var n=0;n<t.length;n+=1)for(var s in i)i.hasOwnProperty(s)&&(t[n].style[s]=i[s]);return this},setOpacity:function(t,i){t.style&&("opacity"in t.style?t.style.opacity=""+i:"filter"in t.style&&(i=Math.round(100*i),t.style.filter="",100!==i)&&(t.style.filter=" progid:DXImageTransform.Microsoft.Alpha(opacity="+i+")"))},ML:{},kL:Re=Oe=!1},Pe=(C.kL=C._L(["WebkitTransform","OTransform","MozTransform","msTransform","transform"]),C.ML={transform:"transform",WebkitTransform:"-webkit-transform",OTransform:"-o-transform",MozTransform:"-moz-transform",msTransform:"-ms-transform"},{uy:"AMap.InfoWindow",JP:"",XP:"amap-info",QP:121,KP:8,tF:8,iF:[20,20,20,20]}),je=_.assign({},we,{isCustom:!1,closeWhenClickMap:!1,anchor:"bottom-center",autoMove:!0,avoid:Pe.iF}),Be=(Ee=si,_.Ei(We,Ee),We.prototype.addToGroup=function(t){this.Iy&&this._overlays[this.Iy]&&this.Iy!==t.hS&&this._overlays[this.Iy].remove(),this.Iy=t.hS,Ee.prototype.addToGroup.call(this,t)},We.prototype.removeFromGroup=function(t){Ee.prototype.removeFromGroup.call(this,t),this.Iy=0},We.prototype.close=function(){var t=this.Iy;(t=this._overlays[t])&&(this.Iy=0,t.close())},We.prototype.vi=function(t){return t=t.target,this.Iy&&t&&C.closest(t,"amap-info")?this._overlays[this.Iy]:null},We.prototype.destroy=function(){this.Dy(),Ee.prototype.destroy.call(this)},We.prototype.Rm=function(){this._map.on("click",this.Py)},We.prototype.Dy=function(){this._map.off("click",this.Py)},We);function We(t){var n=Ee.call(this,t,{className:Pe.JP})||this;return n.type=Pe.uy,n.Py=function(t){var i=n.Iy,i=n._overlays[i];!C.closest(t.originEvent.target,"amap-info")&&i&&i.getOptions().closeWhenClickMap&&(n.Iy=0,i.close())},n._container=n._parent,n.Rm(),n}Fe=Pi,_.Ei(S,Fe),S.prototype.open=function(t,i){t&&t instanceof ur&&i?(this._opts.visible=!0,this.add(t),this.setPosition(i),this.jy(),this.emit("open"),this.GF()):t&&this._position?(this._opts.visible=!0,this.add(t),this.jy(),this.emit("open"),this.GF()):this._map&&this._position&&(this._opts.visible=!0,this.updateOverlay(),this.emit("open"),this.GF())},S.prototype.close=function(){this._parent&&(this._opts.visible=!1,this.updateOverlay(),this.emit("close"))},S.prototype.getIsOpen=function(){return!(!this._map||!this._opts.visible)},S.prototype.setSize=function(t){t instanceof _.Size&&(t=t.toArray()),this._opts.size=t,this.updateOverlay()},S.prototype.setContent=function(t){Fe.prototype.setContent.call(this,t=void 0===t?"":t),this.jy()},S.prototype.setAnchor=function(t){var i,n=this.dom&&this.dom.querySelector(".amap-info-contentContainer");t&&n&&((i=this.g_([].slice.call(n.className.split(" "))))&&C.removeClass(n,i),this._size=[0,0],C.addClass(n,t)),Fe.prototype.setAnchor.call(this,t)},S.prototype.getDraggable=function(){return!1},S.prototype.setOptions=function(t){this._opts=_.assign({},je,this._opts,t)},S.prototype.updateOverlay=function(t){void 0===t&&(t={}),this._map&&(t=t.viewChange,this._setStyle(t=void 0!==t&&t),this._applyStyle(t),t=this._getSize(),this.Fy)&&t[0]&&window.getComputedStyle(this.Fy).boxSizing},S.prototype.getBounds=function(){return null},S.prototype.getExtData=function(){return this._opts.extData||null},S.prototype.setExtData=function(t){this._opts.extData=t},S.prototype._add=function(t){this._map=t,this._parent=t.di,this.updateOverlay()},S.prototype._remove=function(){Fe.prototype._remove.call(this),this.Ey()},S.prototype._createDefaultInnerDom=function(){return document.createElement("div")},S.prototype._createDom=function(t,i){var n=this.Ny(t);return this.$y(n,i),t},S.prototype._getContentSize=function(){var t,i,n=this._style,s=this._getSize();s[0]&&s[1]&&!this._opts.isCustom?(t=s[0],i=s[1]):(s=this.dom.querySelector(".amap-info-contentContainer"))&&(t=s.clientWidth,i=s.clientHeight,this._size=[t,i]),n.width=t+"px",n.height=i+"px",n.size=[t,i]},S.prototype._getAnchorOffset=function(t){return[(t=Fe.prototype._getAnchorOffset.call(this,t))[0],t[1]]},S.prototype.Ny=function(t){var i=document.createElement("div"),n=(C.addClass(i,"amap-info-shadowContainer"),document.createElement("div"));return C.addClass(n,"amap-info-contentContainer"),n.addEventListener("touchstart",function(t){t.cH="infoWindow"}),t.style.position="absolute",i.style.position="absolute",t.appendChild(i),t.appendChild(n),n},S.prototype.$y=function(t,i){var s=(n=this._opts).isCustom,n=n.anchor;void 0!==s&&s?"object"==typeof i&&i instanceof HTMLElement?t.appendChild(i):t.innerHTML=i+"":(s=this.Fy=document.createElement("div"),C.addClass(s,"amap-info-content"),C.addClass(s,"amap-info-outer"),"object"==typeof i&&i instanceof HTMLElement?s.appendChild(i):s.innerHTML=i?i+"":"",i=document.createElement("a"),C.addClass(i,"amap-info-close"),i.innerText="×",s.appendChild(i),i=document.createElement("div"),C.addClass(i,"amap-info-sharp"),C.addClass(t,n),t.appendChild(s),t.appendChild(i))},S.prototype.jy=function(){var t=this.dom.querySelector(".amap-info-close");t&&t.addEventListener("click",this.close.bind(this))},S.prototype.Ey=function(){var t=this,i=this.dom.querySelector(".amap-info-close");i&&i.removeEventListener("click",function(){t.close()})},S.prototype.Oy=function(){if(this._position){var t=this._map;if(t&&this._opts.autoMove&&this.dom){for(var i=this._getSize(),n=new _.Size(i[0],i[1]),s=t.lngLatToContainer(this._position).toArray(),e=this._getOffset(this.getAnchor(),this.getOffset().toArray()),r=_.vector.add(s,e),h=_.vector.add(r,i),o=t.getSize(),a=[this._opts.avoid||Pe.iF],u=0,c=0,f=0;f<a.length;f+=1){var l=a[f],d=0,v=0;0!==l[3]&&0<(d=l[3]-(r[0]+u))&&(u+=d),0!==l[1]&&(d=o.getWidth()-l[1]-(h[0]+u))<0&&(u+=d),0!==l[0]&&0<(v=l[0]-(r[1]+c))&&(c+=v),0!==l[2]&&(v=o.getHeight()-l[2]-(h[1]+c))<0&&(c+=v)}r=_.vector.add(r,[u,c]),h=_.vector.add(h,[u,c]),r[e=s=0]<0||n.getWidth()>o.getWidth()?s=20-r[0]:o.getWidth()<h[0]&&(s=o.getWidth()-h[0]-25),r[1]<0||n.getHeight()>o.getHeight()?e=5-r[1]:o.getHeight()<h[1]&&(e=o.getHeight()-h[1]-15),e+=c,((s+=u)||e)&&t.panBy(s,e)}}},S.prototype.GF=function(){var t,i,n,s,e,r,h,o,a,u,c,f;this._position&&(t=this._map)&&this._opts.autoMove&&this.dom&&(i=this._position,_.Bs(i)&&(i=i.toArray()),o=(u=t.getSize()).getWidth()||0,u=u.getHeight()||0,c=this._getSize(),f=t.lngLatToContainer(i).toArray(),n=this._getOffset(this.getAnchor(),this.getOffset().toArray()),f=_.vector.add(f,n),a=_.vector.add(f,c),s=this._opts.avoid||Pe.iF,e=f[0],r=f[1],h=!1,f[1]-s[0]<0&&(r=s[0],h=!0),a[0]+s[1]>o&&(e=o-c[0]-s[1],h=!0),a[1]+s[2]>u&&(r=u-s[2]-c[1],h=!0),f[0]-s[3]<0&&(e=s[3],h=!0),h)&&(o=_.vector.Ip([e,r],n),a=t.containerToLngLat(o).toArray(),u=_.vector.Ip(a,i),c=t.getCenter().toArray(),f=_.vector.Ip(c,u),t.panTo(f))},S.prototype.g_=function(t){var i,n,s=ge;for(n in s)if(s.hasOwnProperty(n)){var e=s[n];if(-1!==t.indexOf(e)){i=e;break}}return i};var Fe,Ge=S;function S(t){(t=Fe.call(this,t=void 0===t?{}:t,{className:Pe.XP,anchor:je.anchor})||this).type=Pe.uy,t._opts=_.assign({},je,t._opts),t._originOpts.zIndex||(t._opts.zIndex=Pe.QP);var i=t._opts.size;return i instanceof _.Size&&(t._opts.size=t._formatSize(i)),t.jy(),t}var Ne,_e="AMap.ContextMenu",Je=(Ne=si,_.Ei(He,Ne),He.prototype.addToGroup=function(t){this.Iy&&this._overlays[this.Iy]&&this.Iy!==t.hS&&this._overlays[this.Iy].remove(),this.Iy=t.hS,Ne.prototype.addToGroup.call(this,t)},He.prototype.removeFromGroup=function(t){Ne.prototype.removeFromGroup.call(this,t),this.Iy=0},He.prototype.vi=function(t){return t=t.target,this.Iy&&t&&w.closest(t,"amap-menu")?this._overlays[this.Iy]:null},He.prototype.destroy=function(){this.Uy(),Ne.prototype.destroy.call(this)},He.prototype.By=function(){this._map.on("viewchange",this.Wy),this._map.on("click",this.Py)},He.prototype.Uy=function(){this._map.off("viewchange",this.Wy),this._map.off("click",this.Py)},He);function He(t){var n=Ne.call(this,t,{className:""})||this;return n.type=_e,n.className=_e,n.Wy=function(){var t;n.Iy&&(t=n._overlays[n.Iy])&&!t.getOptions().aliveWhenMapClick&&n.removeFromGroup(t)},n.Py=function(t){var i=n.Iy,i=n._overlays[i];w.closest(t.originEvent.target,"amap-info")||!i||i.getOptions().aliveWhenMapClick||(n.Iy=0,i.close())},n._container=n._parent,n.By(),n}Ve=Pi,_.Ei(Ke,Ve),Ke.prototype.open=function(t,i){t&&i?(this._opts.visible=!0,this.add(t),this.setPosition(i),this.emit("open")):this._map&&this._position&&(this._opts.visible=!0,this.updateOverlay(),this.emit("open"))},Ke.prototype.close=function(){this._parent&&(this._opts.visible=!1,this.uZ(),this.emit("close"))},Ke.prototype.addItem=function(t,i,n){this.Zy.push({content:t,fn:i,order:n}),this.qy(this.dom),this.updateOverlay()},Ke.prototype.removeItem=function(t,i){for(var n=this.Zy,s=0;s<n.length;s++){var e=n[s];e.content===t&&e.fn===i&&(n.splice(s,1),s--)}this.qy(this.dom),this.updateOverlay()},Ke.prototype.getBounds=function(){return null},Ke.prototype.getDraggable=function(){return!1},Ke.prototype._add=function(t){this._map=t,this._parent=t.vm,this.updateOverlay()},Ke.prototype._createDefaultInnerDom=function(){return document.createElement("div")},Ke.prototype._createDom=function(t,i){var n=this.dom=this.Yy();return this._opts.isCustom&&this._opts.content?Ve.prototype._createDom.call(this,n,this._opts.content):this.qy(n),n},Ke.prototype.Yy=function(){var t=document.createElement("div");return w.addClass(t,this._className),t},Ke.prototype.qy=function(t){var i=this.Vy(this.Zy),n=document.createElement("ul");w.addClass(n,"amap-menu-outer");for(var s=0,e=i;s<e.length;s++){var r=e[s],r=this.Xy(r);n.appendChild(r)}t.innerHTML="",t.appendChild(n)},Ke.prototype.Vy=function(t){return(t=void 0===t?[]:t).sort(function(t,i){return isNaN(t.order)||isNaN(i.order)?0:t.order-i.order}),t},Ke.prototype.Xy=function(i){var n=this,t=document.createElement("li");return t.innerHTML=i.content,t.addEventListener("click",function(t){i.fn(t),n._opts.aliveWhenMapClick||n.hide()}),t};var Ve,qe=Ke;function Ke(t){var i=Ve.call(this,t=void 0===t?{}:t,{className:"amap-menu"})||this;return i.type=_e,i.className=_e,i._opts={},i.Zy=[],i._opts=t,i._style.zIndex=140,i}function Qe(){this.Hy=!1,this.ex=null,this.Ky=this.nx()}Qe.prototype.open=function(t,i,n){var s,e,r,h,o,a,u,c,f,l=this;this.Hy||(s=this.Jy,e=AMap.getConfig().server+"/verify/",(_.Support.$e?(this.Ky.style.marginLeft=-Math.min(330,screen.width)/2+"px",document.body):(r=this.Qy("amap-container",document.body)[0])&&322<r.clientWidth&&346<r.clientHeight?(this.Ky.style.position="absolute",r):(o=h=0,r&&(r=w.getViewportOffset(r),h=r[0],o=r[1]),this.Ky.style.top="0%",this.Ky.style.left="0%",a=(.5-h)/5,u=(.5-o)/5,c=setInterval(function(){o+=u,.5-(h+=a)<.05&&.5-o<.05?(l.Ky.style.top="50%",l.Ky.style.left="50%",clearInterval(c)):(l.Ky.style.top=100*o+"%",l.Ky.style.left=100*h+"%")},25),document.body)).appendChild(this.Ky),f=!0,s.onload=function(){f?f=!1:l.Hy&&(l.Ky.parentNode&&l.Ky.parentNode.removeChild(l.Ky),l.Hy=!1,l.tx())},s.src=e+"jsapi.html?channel=JSAPI-"+t+"&from="+encodeURIComponent(e+"success.html")+"&th="+i+"&restUrl="+encodeURIComponent(n),this.Hy=!0)},Qe.prototype.ix=function(t){this.ex=t},Qe.prototype.tx=function(){this.ex&&this.ex()},Qe.prototype.Qy=function(t,i){if(window.getElementsByClassName)return window.getElementsByClassName(t,i);for(var n=(i||document).getElementsByTagName("*"),s=[],e=0;e<n.length;e+=1)for(var r=n[e],h=r.className.split(" "),o=0;o<h.length;o+=1)if(h[o]===t){s.push(r);break}return s},Qe.prototype.nx=function(){var t=document.createElement("div"),i=(t.className="amap-popup",t.style.zIndex="2147483647",document.createElement("iframe"));return i.className="amap-popup-content",t.appendChild(i),i.style.width=Math.min(330,screen.width)+"px",this.Jy=i,t};var $e={"restapi.amap.com/v3/place/text":"KEYWORD","restapi.amap.com/v3/place/polygon":"POLYGON","restapi.amap.com/v3/place/around":"NEARBY","restapi.amap.com/v3/place/detail":"ID","restapi.amap.com/v3/geocode/regeo":"REGEO"},tr=new Qe,ir=(tr.ix(function(){ir.ox=!1;for(var t=ir.ax,i=0,n=t.length;i<n;i+=1){var s=t[i];10<n-i?t[2]({status:"error",info:"TIME_OUT_A"}):ir.get(s[0],s[1],s[2])}ir.ax=[]}),nr.get=function(n,s,e,t){if(void 0===t&&(t={}),nr.ox)nr.ax.push([n,s,e]);else{var i,r=n.split("://")[1],h=$e[r],o=void 0!==h,u=(a=AMap.getConfig()).key,c=a.version,f=a.appname,l=a.jscode,a=a.gaodeserver,d=n+"?platform=JS&s=rsv3&logversion=2.0&key="+u+"&sdkversion="+c+"&appname="+f+"&csid="+_.Util.uuid();for(i in l?d+="&jscode="+l:a&&r&&"restapi.amap.com"===r.split("/")[0]&&(d=r.replace(r.split("/")[0],a)+"?platform=JS&s=rsv3&logversion=2.0&key="+u+"&sdkversion="+c+"&appname="+f+"&csid="+_.Util.uuid()),s)s.hasOwnProperty(i)&&(d+="&"+i+"="+s[i]);yi.JSONP(d,function(t,i){"complete"===t&&(i=i.data,o)&&3e4===i.errcode&&i.data?(nr.ox=!0,nr.ax.push([n,s,e]),tr.open(h,i.data.host,d)):e(t,i)},t)}},nr.post=function(t,i,n){var e=(s=AMap.getConfig()).key,r=s.version,h=s.appname,o=s.jscode,s=s.gaodeserver,a=t.split("://")[1],t=t+"?platform=JS&s=rsv3&logversion=2.0&key="+e+"&sdkversion="+r+"&appname="+h+"&csid="+_.Util.uuid();o?t+="&jscode="+o:s&&a&&"restapi.amap.com"===a.split("/")[0]&&(t=a.replace(a.split("/")[0],s)+"?platform=JS&s=rsv3&logversion=2.0&key="+e+"&sdkversion="+r+"&appname="+h+"&csid="+_.Util.uuid()),yi.Ajax(t,{type:"POST",content:JSON.stringify(i),requestContentType:"text/plain"},function(t,i){"complete"===t?(i=i.data,n(t,JSON.parse(i))):n(t,i)})},nr.ox=!1,nr.ax=[],nr);function nr(){}function sr(t,i,r){var n=AMap.getConfig(),s=n.server+"/v3/assistant/coordinate/convert",e=AMap.Util.parseLngLatData(t),h=[];if(e instanceof Array){for(var o=0,a=e.length;o<a;o+=1)h.push(e[o]+"");h=h.join(";")}else h=e+"";t={key:n.key,s:"rsv3",locations:h,coordsys:i||"gps"},AMap.WebService.get(s,t,function(t,i){if("complete"===t&&i.status&&"1"===i.status){for(var n=i.locations.split(";"),s=0;s<n.length;s+=1){var e=n[s].split(",");n[s]=new AMap.LngLat(e[0],e[1])}r&&"function"==typeof r&&r("complete",{info:"ok",locations:n})}else r&&"function"==typeof r&&r("error",i.info);"error"===t&&r("error",i.info)})}hr.prototype.setCenter=function(t){t instanceof _.LngLat?this.cB=t.toArray():this.cB=t,this.dB=(t=this.map.getProjection()).project.apply(t,this.cB)},hr.prototype.getCenter=function(){return this.cB},hr.prototype.lngLatToCoord=function(t){var i=this.map.getProjection().project;return t instanceof _.LngLat&&(t=t.toArray()),this.cB||this.setCenter(t),this.pB(i(t[0],t[1]),this.dB)},hr.prototype.lngLatsToCoords=function(t){if(_.Util.isArray(t)){var i=this.map.getProjection().project,n=[];if(_.Util.vB(t[0]))this.cB||this.setCenter(t),n[0]=this.pB(i(t[0],t[1]),this.dB);else for(var s=0,e=t.length;s<e;s++){var r=t[s];if(_.Util.vB(r[0]))this.cB||this.setCenter(r),n[s]=this.pB(i(r[0],r[1]),this.dB);else{for(var h=[],o=0,a=r.length;o<a;o++){var u=r[o];if(_.Util.vB(u[0]))this.cB||this.setCenter(u),h[o]=this.pB(i(u[0],u[1]),this.dB);else{for(var c=[],f=0,l=r.length;f<l;f++){var d=u[f];_.Util.vB(d[0])&&(this.cB||this.setCenter(d),c[f]=this.pB(i(d[0],d[1]),this.dB))}h[o]=c}}n[s]=h}}return 0<n.length?n:t}return t},hr.prototype.getCameraParams=function(){this.mB();var t,i,n,s,e,r,h,o=this.map.getView(),a=o.pz(),u=this.pB(this.dB,this.Us);return"3D"===o.type?(t=(e=a.lB()).fov,n=e.near,s=e.far,h=e.position,i=e.target,e=e.up,{fov:t/Math.PI*180,near:n,far:s,position:_.Pt(this.pB(h,u),[h[2]]),lookAt:_.Pt(this.pB(i,u),[i[2]]),up:e}):"2D"===o.type?(i=(t=a.lB()).rotation,n=t.near,s=t.far,e=t.top,o=t.bottom,a=t.left,r=t.right,h=t.position,{rotation:i,near:n,far:s,top:e,bottom:o,left:a,right:r,position:_.Pt(this.pB(h,u),[h[2]])}):void 0},hr.prototype.getMVPMatrix=function(){this.mB();var t=this.map.getView().pz(),i=this.pB(this.dB,this.Us),n=_.Il();return this.Xl=t.Vl(),n.set([1,0,0,0,0,1,0,0,0,0,1,0,i[0],i[1],0,1]),_.multiply(this.Xl,this.Xl,n),this.Xl},hr.prototype.mB=function(){var i=(t=this.map.getView().getStatus()).optimalZoom,t=t.centerCoord;i>=_.Ra?(i=_.lcs.getLocalByCoord([t[0],t[1]]),this.Us=i.center):this.Us=[0,0]},hr.prototype.pB=function(t,i){var n=[0,0];return n[0]=t[0]-i[0],n[1]=t[1]-i[1],n};var er,rr=hr;function hr(t){this.Us=[0,0],t||console.error("需要传入 map 实例对象。new AMap.CustomCoords(map);"),this.map=t,this.mB()}var or=[116.397128,39.916527],ar=ne;_.Ei(T,ar),T.prototype.setCenter=function(t,i,n){void 0===i&&(i=!1),t instanceof _.LngLat&&(t=t.toJSON()),!i&&this.Ev?this.viewChange({lng:t[0],lat:t[1]},n):this.om({center:t})},T.prototype.getStyleByUserId=function(t,i){return this.qY(t,i)},T.prototype.getCustomTypeByContainerPos=function(t){var i,n,s,e=this.getCustomTypeByPos(t);return e&&e[0]?(i={},s=e[0][0],e={x:e[0][1],y:e[0][2],z:s},n=(t=t.lnglat).lng,t=t.lat,s=_.ZY(s,s,n,t,e),i.tileInnerCoord=s,i.tileCoord=e,i):null},T.prototype.getScreenShot=function(t,i){for(var n=this.getSize(),s=document.createElement("canvas"),e=s.getContext("2d"),r=(t=t||n.width,i=i||n.height,s.width=t,s.height=i,n.width,n.height,this.do.childNodes),h=[],o=0;o<r.length;o+=1)h.push(r[o]);for(o=0;o<h.length;o+=1){var a=h[o];"CANVAS"===a.tagName&&e.drawImage(a,0,0,t,i)}return s.toDataURL()},T.prototype.updateView=function(t,i){this.om(t,i=void 0===i||i)},T.prototype.destroy=function(){delete this.hx,ar.prototype.destroy.call(this)},T.prototype.setZoomAndCenter=function(t,i,n,s){void 0===n&&(n=!1),this.Pv||(t=this.getZoom()),i instanceof _.LngLat&&(i=i.toJSON()),!n&&this.Ev?this.viewChange({lng:i[0],lat:i[1],zoom:t},s):this.om({center:i,zoom:t})},T.prototype.getBounds=function(){return new l(this._view.getStatus().bounds)},T.prototype.getCenter=function(){var i=(t=this._view.getOptions().center)[0],t=t[1];return new _.LngLat(+i.toFixed(6),+t.toFixed(6))},T.prototype.getGraphicInfo=function(){return this.wX()},T.prototype.setZoom=function(t,i,n){void 0===i&&(i=!1),this.Pv&&(!i&&this.Ev?this.viewChange({zoom:t},n):this.om({zoom:t}))},T.prototype.getZoom=function(t){return void 0===t&&(t=2),+this._view.getOptions().zoom.toFixed(t)},T.prototype.zoomIn=function(){this.setZoom(this.getZoom()+1)},T.prototype.zoomOut=function(){this.setZoom(this.getZoom()-1)},T.prototype.getPitch=function(){return this._view.getOptions().pitch},T.prototype.setPitch=function(t,i,n){!(i=void 0!==i&&i)&&this.Ev?this.viewChange({pitch:t},n):this.om({pitch:t})},T.prototype.getRotation=function(){return this._view.getOptions().rotation},T.prototype.setRotation=function(t,i,n){void 0===t&&(t=0),!(i=void 0!==i&&i)&&this.Ev?this.viewChange({rotation:t},n):this.om({rotation:t})},T.prototype.setBounds=function(t,i,n){void 0===i&&(i=!1),n=(void 0===n?[0,0,0,0]:n)||[0,0,0,0],t instanceof l&&(t=t.toJSON()),t=this.em(t,n),this.setZoomAndCenter(t[2],[t[0],t[1]],i)},T.prototype.panTo=function(t,i){t instanceof _.LngLat&&(t=t.toJSON()),this.viewChange({lng:t[0],lat:t[1]},i)},T.prototype.getBindHandler=function(){return this.hx},T.prototype.panBy=function(t,i,n){var s,e,r,h,o,a,u,c,l=(f=this.getSize()).width/2-t,f=f.height/2-i,d=this.getCenter();this.lx&&this.ux&&(s=Math.sqrt(t*t+i*i),u=this.getProjection(),e=(void 0===this.ux.lng?d:this.ux).lng,d=(void 0===this.ux.lat?d:this.ux).lat,r=void 0===this.ux.zoom?this.getZoom():this.ux.zoom,h=void 0===this.ux.rotation?this.getRotation():this.ux.rotation,o=void 0===this.ux.pitch?this.getPitch():this.ux.pitch,a=u.getResolution(r),u=u.project(e,d),c=h/180*Math.PI,t=Math.atan(t/i)-c,i<0&&(t+=Math.PI),c=s*Math.sin(t),i=s*Math.cos(t),u[0]-=a*c,u[1]+=a*i,this.setCenter([e,d],!0),this.setZoom(r,!0),this.setRotation(h,!0),this.setPitch(o,!0)),this.panTo(this.containerToLngLat([l,f]),n)},T.prototype.viewChange=function(t,i){var n,s,e,r,h,o,a,u=new H(.4,0,.15,1),c=(new H(.67,0,1,.42),new H(.95,.25,.79,1)),f=new H(.18,.66,.55,.86),l=this.getZoom(),d=this.getPitch(),v=this.getRotation(),p=this.getCenter().toJSON(),m=0,y=0,b=0,g=0;this.lx?(_.Util.cancelAnimFrame(this.lx),this.ux=_.assign(this.ux,t)):this.ux=t;var M=(t=this.ux).zoom,k=t.pitch,w=t.rotation,x=t.lng,A=t.lat,z=(void 0!==M&&(n=M-l,m=u.h(Math.abs(n/10)),m=1e3*Math.max(Math.min(1,m),.1)),void 0!==k&&(s=k-d,y=Math.abs(16.7*s)),void 0!==w&&(e=w-v,b=Math.abs(16.7*e)),void 0!==x&&void 0!==A&&(t=[],a=this._view.getStatus().centerCoord,r=x-p[0],h=A-p[1],o=this.getProjection().project(x,A),t[0]=Math.abs(o[0]-a[0])/this.getResolution(),t[1]=Math.abs(o[1]-a[1])/this.getResolution(),0,o=u.h(Math.min(t[0]/this.getSize().width,1)),a=u.h(Math.min(t[1]/this.getSize().height,1)),g=1e3*Math.max(Math.min(1,a,o),.05,o,a)),Math.max(m,y,b,g)),C=0;function S(){var t,i={};z<=C?(void 0!==M&&(i.zoom=M),void 0!==k&&(i.pitch=k),void 0!==w&&(i.rotation=w),void 0!==x&&void 0!==A&&(i.center=[x,A]),this.om(i),_.Util.cancelAnimFrame(this.lx),this.lx=!1,this.ux={}):(C+=16.7,t=Math.min(1,u.p(C/z)),void 0!==k&&(i.pitch=s*t+d),void 0!==w&&(i.rotation=e*t+v),void 0!==x&&void 0!==A&&(n&&.5<n?t=f.h(C/z):n&&n<-.5&&(t=c.h(C/z)),i.center=[r*t+p[0],h*t+p[1]]),void 0!==M&&(t=(n<0?f:c).h(C/z),i.zoom=n*t+l),this.om(i),this.lx=_.Util.requestAnimFrame(S.bind(this)))}void 0!==i&&(z=i),this.Ev||(z=-1),S.call(this)},T.prototype.getContainer=function(){return this.kv},T.prototype.add=function(t){for(var i=[],n=[],s=[],e=[],r=0,h=t=Array.isArray(t)?t:[t];r<h.length;r++){var o=h[r];if(_.px(o))this.addLayer(o);else if(_.er(o))_.RF(o)?(this.add(o.getOverlays()),o.setMap(this)):this.am(o);else switch(o.type){case"AMap.Marker":case"AMap.ElasticMarker":case"AMap.Text":i.push(o);break;case"AMap.InfoWindow":n.push(o);break;case"AMap.ContextMenu":s.push(o);break;case"AMap.LabelMarker":e.push(o)}}this.pi.add(i),this.di.add(n),this.vm.add(s),e.length&&this.rm().add(e),this.setNeedUpdate(!0)},T.prototype.remove=function(t){for(var i=[],n=[],s=[],e=[],r=0,h=t=Array.isArray(t)?t:[t];r<h.length;r++){var o=h[r];if(_.er(o))_.RF(o)?(this.remove(o.getOverlays()),o.setMap(null)):this.$F.remove(o);else if(_.px(o))this.removeLayer(o);else switch(o.type){case"AMap.Marker":case"AMap.ElasticMarker":case"AMap.Text":i.push(o);break;case"AMap.InfoWindow":n.push(o);break;case"AMap.ContextMenu":s.push(o);break;case"AMap.LabelMarker":e.push(o)}}e.length&&this.rm().remove(e),this.pi&&this.pi.remove(i),this.di&&this.di.remove(n),this.vm&&this.vm.remove(s),this.setNeedUpdate(!0)},T.prototype.lngLatToCoords=function(t){var i;return _.Bs(t)&&(t=[t.lng,t.lat]),(i=this.getProjection()).project.apply(i,t)},T.prototype.coordsToLngLat=function(t){var i=(i=this.getProjection()).unproject.apply(i,t);return new AMap.LngLat(i[0],i[1])},T.prototype.lngLatToContainer=function(t){var i=(t=_.Bs(t)?[t.lng,t.lat]:t)[0],n=t[1],t=void 0===(t=t[2])?0:t,s=this._view,e=s.getOptions().zoom||this.xt[1],i=(s=s.lnglatToContainer(+i,+n,t,e))[0],n=s[1];return new _.Pixel(i,n)},T.prototype.lnglatToContainer=function(){console.log&&console.log("请使用 lngLatToContainer 方法替代。")},T.prototype.containerTolnglat=function(){console.log&&console.log("请使用 containerToLngLat 方法替代。")},T.prototype.containerToLngLat=function(t){var t=t instanceof Array?(i=t[0],t[1]):(i=t.x,t.y),t=(i=this._view.containerTolnglat(i,t))[0],i=i[1];return new _.LngLat(t,i)},T.prototype.coordToContainer=function(t){var i;return(i=this._view)._u.apply(i,t)},T.prototype.containerToCoord=function(t){return t instanceof _.Pixel&&(t=t.toArray()),this._view.ku(t[0],t[1])},T.prototype.pixelToLngLat=function(t,i){void 0===i&&(i=this.getZoom()),t=t instanceof Array?(n=t[0],t[1]):(n=t.x,t.y);var n=_.V[this._view.au()].unproject(n,t,i),t=n[0],i=n[1];return new _.LngLat(t,i)},T.prototype.pixelTolnglat=function(){console.log&&console.log("请使用 pixelToLngLat 方法替代。")},T.prototype.unproject=function(){console.log&&console.log("请使用 pixelToLngLat 方法替代。")},T.prototype.lngLatToPixel=function(t,i){var n=(t=t instanceof _.LngLat?t.toJSON():t)[0],t=t[1];void 0===i&&(i=this.getZoom());t=(n=_.V[this._view.au()].project(n,t,i))[0],i=n[1];return new _.Pixel(t,i)},T.prototype.project=function(t,i){return console.log&&console.log("请使用 lngLatToPixel 方法替代。"),this.lngLatToPixel(t,i)},T.prototype.lnglatToPixel=function(t,i){return console.log&&console.log("请使用 lngLatToPixel 方法替代。"),this.lngLatToPixel(t,i)},T.prototype.lnglatToPixelArray=function(t,i){var n=(t=t instanceof _.LngLat?t.toJSON():t)[0],t=t[1];return void 0===i&&(i=this.getZoom()),_.V[this.getView().au()].project(n,t,i)},T.prototype.getTileCoordByLngLat=function(t,i,n){var s=(t=t instanceof _.LngLat?t.toJSON():t)[0],t=t[1],s=_.V[this.getView().au()].project(s,t,n),t=Math.floor(s[0]/256),s=Math.floor(s[1]/256);return new _.ca(n,t,s)},T.prototype.addOverlay=function(t){this.am(t),this.setNeedUpdate(!0)},T.prototype.removeOverlay=function(t){this.ar(t),this.setNeedUpdate(!0)},T.prototype.getResolution=function(t){return t=(t||this.getCenter()).kT,this.getProjection().getResolution(this.getZoom())*Math.cos(t*Math.PI/180)},T.prototype.getScale=function(t){return this.getResolution()*(t||96)/.0254},T.prototype.getCity=function(n,t){ir.get(AMap.getConfig().server+"/v3/geocode/regeo",{extensions:"",output:"json",location:t||this.getCenter().toJSON()},function(t,i){"complete"===t&&i.status+""=="1"?(t=i.regeocode.addressComponent,n({province:t.province,city:t.city instanceof Array?"":t.city,citycode:t.citycode instanceof Array?"":t.citycode,district:t.district instanceof Array?"":t.district})):n({})})},T.prototype.setCity=function(r,h){var o=this;ir.get(AMap.getConfig().server+"/v3/config/district",{output:"json",subdistrict:"0",extensions:"all",keywords:r},function(t,i){if("complete"===t&&i.status+""=="1"){if((t=i.districts)&&t.length){i=t[0],/[^\\w]+/.test(r)&&(t=_.find(t,function(t){return t.name===r}))&&t!==i&&(i=t);try{var n=i.center.split(","),s=i.level,e=void 0;switch(s){case"city":e=10;break;case"province":e=7;break;case"district":e=12;break;case"country":e=4;break;default:e=12}-1!==i.name.indexOf("市")&&(e=10),o.setZoomAndCenter(e,n),h&&h.call(o,n,e)}catch(t){}}}else h(null,null)})},T.prototype.setFitView=function(t,i,n,s){if(void 0===i&&(i=!1),void 0===n&&(n=[60,60,60,60]),void 0===s&&(s=Math.min(17.5,ne.t_[1])),!((t=_.FF(t)?t.getAllOverlays():t)instanceof Array&&0===t.length)){n=Boolean(n)?n:[60,60,60,60],(t=!(t=t||[])||t instanceof Array?t:[t])&&0!==t.length||(t=this.getAllOverlays());var e,r,t=this.nm(t);if(t&&(!window._AMapConfig||t.check()))return e=t.toJSON(),e=this.em(e,n,s),"d"===_.Support.baseRender&&(e[2]=Math.floor(e[2])),this.viewChange({lng:e[0],lat:e[1],zoom:e[2]},r=i?0:r),t}},T.prototype.getFitZoomAndCenterByOverlays=function(t,i,n){if(void 0===i&&(i=[0,0,0,0]),void 0===n&&(n=_.zoomRange[1]),t=this.nm(t))return t=t.toJSON(),[(t=this.em(t,i,n))[2],new _.LngLat(t[0],t[1])]},T.prototype.getFitZoomAndCenterByBounds=function(t,i,n){return void 0===i&&(i=[0,0,0,0]),void 0===n&&(n=_.zoomRange[1]),t instanceof l&&(t=t.toJSON()),[(t=this.em(t,i,n))[2],new _.LngLat(t[0],t[1])]},T.prototype.addControl=function(t){t.addTo(this),this.controls.push(t)},T.prototype.removeControl=function(t){t.remove?t.remove():t.removeFrom&&t.removeFrom(this,this.controls);for(var i=0;i<this.controls.length;i++)if(this.controls[i]===t)return void this.controls.splice(i-1,1)},T.prototype.L$=function(){},T.prototype.D$=function(){return"zh_cn"},T.prototype.set=function(t,i){switch(t){case"layers":this.setLayers(i);break;case"projection":break;case"pitch":this.setPitch(i);break;case"debug":this.debug=i;break;case"showLabel":this.showLabel=i;break;case"zoom":this.setZoom(i);break;case"center":this.setCenter(i);break;case"rotation":this.setRotation(i);break;case"dragEnable":this.setStatus({dragEnable:i});break;case"zoomEnable":this.setStatus({zoomEnable:i});break;case"scrollWheel":this.setStatus({scrollWheel:i});break;case"jogEnable":this.setStatus({jogEnable:i});break;case"doubleClickZoom":this.setStatus({doubleClickZoom:i});break;case"keyboardEnable":this.setStatus({keyboardEnable:i});break;case"animateEnable":this.setStatus({animateEnable:i});break;case"pitchEnable":this.setStatus({pitchEnable:i});break;case"touchZoom":this.setStatus({touchZoom:i});break;case"isHotspot":this.setStatus({isHotspot:i});break;case"style":this.setStyleByPlat(i)}},T.prototype.setMapStyle=function(t){this.f_(t),this.setStatus({mapStyle:t}),this.indoorMap&&this.indoorMap.hide()},T.prototype.getMapStyle=function(){var t,i=this.getStatus();return i&&i.mapstyleUrl?(t=i.mapstyleUrl,"normal"===i.mapstyleUrl?"amap://styles/normal":t):""},T.prototype.getAllOverlays=function(i){var t=this.$F.getAllOverlays(),n=_.Pt(t),t=this.pi.getAllOverlays(),s=this.di.getAllOverlays();_.vx(t,function(t){n.push(t)}),s&&s.length&&_.Util.Ig(n,s);for(var e=0,r=this.zv;e<r.length;e++){var h=r[e];h instanceof ms&&_.Util.Ig(n,h.getAllOverlays())}return n=n.filter(function(t){return!(t._opts&&t._opts.innerOverlay||i&&!(-1<t.className.toLocaleLowerCase().indexOf(i)))})},T.prototype.clearMap=function(){for(var t=this.getAllOverlays(),i=0;i<t.length;i++){var n=t[i];n&&n.remove&&n.remove()}},T.prototype.clearInfoWindow=function(){this.di&&this.di.close()},T.prototype.addImage=function(t,i){this.I_&&this.I_.addImage(t,i)},T.prototype.getImage=function(t){if(this.I_)return this.I_.getImage(t)},T.prototype.getFeatures=function(){return this.Cw},T.prototype.setFeatures=function(t){this.Cw=t;for(var i=this.yS(),n=this.getLayers(),s=0;s<n.length;s++){var e=n[s];"AMap.Buildings"===e.CLASS_NAME&&e.getState().u$&&(i?e.show():e.hide())}this.setNeedUpdate(!0)},T.prototype.hasLayer=function(i){var t=this.getLayers();return-1<_.findIndex(t,function(t){return t===i})},T.prototype.getMapApprovalNumber=function(){var t=this.c_,i={satellite:"GS(2021)6342",district:"GS(2021)6375"};return t&&("normal"===t||"amap://styles/normal"===t)||(i.base="GS(2021)6375"),i},T.prototype.setMask=function(t){t&&(this.c$=t,this.d$||(this.d$=new As({zIndex:-10,visible:!0,path:this.c$}),this.addLayer(this.d$)),null!=(t=this.d$))&&t.setMask(this.c$)},T.prototype.cancelMapAnimate=function(){this.lx&&(_.Util.cancelAnimFrame(this.lx),this.lx=-1,this.ux={})},T.prototype.setLabelRejectMask=function(t){void 0!==t&&(this.NH=t,this.setNeedUpdate(!0))},T.prototype.queryOverlayByPosition=function(t){return this.FY(t)},T.prototype.am=function(t){this.$F.add(t)},T.prototype.ar=function(t){this.sm().remove(t)},T.prototype.setStyle=function(t){this.RY(t)},T.prototype.setStyleByPlat=function(t){this.RY(t)};var ar,cr,ur=T;function T(t,i){void 0===i&&(i={zoom:9,center:[116.397128,39.916527],rotation:0,pitch:0,viewMode:"2D"});var n=this,s=null;if(null===(s=t instanceof HTMLDivElement||null!==(t=document.getElementById(t))?t:s))throw Error("Map container div not exist");_.Support.amapRunTime&&!_.Support.amapRunTime["map-init"]&&(_.Support.amapRunTime["map-init"]=(new Date).getTime()),i.zooms=i.zooms||ne.t_,t=!1,void 0===i.zoom&&(t=!0,i.zoom=Math.max(Math.min(i.zooms[1],12),i.zooms[0])),i.center=i.center?_.Bs(i.center)?i.center.toJSON():i.center:or,i.rotation=i.rotation||0,i.layers=i.layers||[],i.baseRender=_.Support.isWebGL?"w":"d",i.showIndoorMap=i.showIndoorMap||!1,i.vectorMapForeign=i.vectorMapForeign||!1,i.overseaDataType=i.overseaDataType||"",i.vdataProxy=i.vdataProxy||"",i.poiIcon=i.poiIcon||void 0,i.vdataProxy&&(AMap.getConfig().vdataProxy=i.vdataProxy),n=ar.call(this,s,i)||this,t&&(s=n.em(er)[2],n.setZoom(s,!0)),n.pi=new Te(n),n.di=new Be(n),n.vm=new Je(n),n.hx=new ot(n),n.hx.Xt(),n.plugin=AMap.plugin;for(var e=0;e<i.layers.length;e++){var r=i.layers[e];r&&"AMap.IndoorMap"===r.CLASS_NAME&&r.setMap(n)}return!i.showIndoorMap||"normal"!==n.c_&&"amap://styles/normal"!==n.c_||n.isDOMMode()||n.addLayer(n.indoorMap=new AMap.IndoorMap({zIndex:8,opacity:1,map:n})),n.YG=i.vectorMapForeign,n.QZ=i.overseaDataType,n.jdt=performance&&performance.now(),i.vectorMapForeign&&n.addLayer(new AMap.Mapbox({zIndex:8,opacity:1,visible:!0,map:n})),n.lcs.setMap(n),n.customCoords=new rr(n),n.getOutseaState()&&n.bZ.MZ.tY.add({NZ:function(){n.bZ.MZ.wZ.gZ()},group:"default",UZ:function(){return n.bZ.MZ.wZ.stencil.AS},FZ:function(){return 0}}),n}function fr(t){var i=cr.call(this,t)||this;return i.CLASS_NAME="AMap.ImageLayer",i._tileUrl=t.url||t.tileUrl,i.ir=t.bounds,i.Qh=t.zIndex||6,i.tl=void 0===t.opacity?1:t.opacity,i.il=void 0===t.visible||t.visible,i.xt=void 0===t.zooms?_.zoomRange:t.zooms,i.canvas=t.canvas,i}cr=s,_.Ei(fr,cr),fr.prototype.getSourceConfig=function(){return{id:this._id,type:"image",tileUrl:this._tileUrl,bounds:this.ir,canvas:this.canvas,zooms:this.xt}},fr.prototype.co=function(){return this._id},fr.prototype.getState=function(){return{visible:this.il,opacity:this.tl,layer:this,rejectMapMask:this._rejectMapMask,depthTest:this.AF,ce:this.IF}};var lr,dr={tileUrl:"",url:"",bounds:[0,0,0,0],opacity:1,visible:!0,zIndex:4,zooms:_.zoomRange},vr=(lr=pi=fr,_.Ei(pr,lr),pr.prototype.getImageUrl=function(){return this._tileUrl},pr.prototype.setImageUrl=function(t){var i;t&&(this._tileUrl=t,this.getSourceConfig(),(i=this.getSource())&&i._tileUrl&&i.reLoadImgage&&(i._tileUrl=t,i.reLoadImgage(t)),this._opts.url=t,this.uo.getSource(this._id).Fo(!1),this.map)&&this.map.setNeedUpdate(!0)},pr.prototype.getBounds=function(){return this.ir},pr.prototype.setBounds=function(t){t&&(this.ir=t,this.map.setNeedUpdate(!0))},pr);function pr(t){var i=this;if((t=void 0===t?dr:t).tileUrl||t.url)return t.bounds=t.bounds||dr.bounds,t.opacity=(void 0===t.opacity?dr:t).opacity,t.visible=(void 0===t.visible?dr:t).visible,t.zIndex=(void 0===t.zIndex?dr:t).zIndex,t.canvas=void 0,(i=lr.call(this,t)||this).onCreated(),i;throw new Error("ImageLayer need an Url")}var mr,yr,br={url:"",tileUrl:"",bounds:[0,0,0,0],opacity:1,visible:!0,zooms:_.zoomRange,zIndex:6},gr=(mr=pi,_.Ei(Mr,mr),Mr.prototype.setCanvas=function(t){this.canvas=t,this.reFresh()},Mr.prototype.getElement=function(){return this.canvas},Mr.prototype.getBounds=function(){return this.ir},Mr.prototype.setBounds=function(t){t&&(this.ir=t,this.map.setNeedUpdate(!0))},Mr.prototype.reFresh=function(){this.map&&this.map.setNeedUpdate(!0)},Mr.prototype.destroy=function(){var t=this.getSource();t&&t.destroy&&t.destroy()},Mr);function Mr(t){var i=this;return(t=void 0===t?br:t).bounds=t.bounds||br.bounds,t.opacity=(void 0===t.opacity?br:t).opacity,t.visible=(void 0===t.visible?br:t).visible,t.tileUrl="",(i=mr.call(this,t)||this).onCreated(),i.CLASS_NAME="AMap.CanvasLayer",i}function kr(t,i){var n=yr.call(this,i)||this;return n.CLASS_NAME="AMap.CustomLayer",n.eP=!1,n.UF=!1,n.render=i.render||function(){},n.canvas=t,n.Qh=i.zIndex||11,n.tl=void 0===i.opacity?1:i.opacity,n.il=void 0===i.visible||i.visible,n.UF=void 0!==i.alwaysRender&&i.alwaysRender,n.xt=i.zooms||_.zoomRange,n.canvas.style.opacity=""+n.tl,n.canvas.style.display=n.il?"block":"none",n.map&&n.gx(n.canvas),n}yr=s,_.Ei(kr,yr),kr.prototype.getState=function(){return!this.eP&&this.map&&this.gx(this.canvas),{visible:this.il,opacity:this.tl,zIndex:this.Qh,layer:this,rejectMapMask:this._rejectMapMask,depthTest:this.AF,ce:this.IF,kv:this._container,alwaysRender:this.UF}},kr.prototype.getSourceConfig=function(){return{id:this._id,type:"custom",zooms:this.xt}},kr.prototype.co=function(){return this._id},kr.prototype.setOpacity=function(t){yr.prototype.setOpacity.call(this,t),this.canvas.style.opacity=""+this.tl},kr.prototype.setMap=function(t){t||this.destroy(),yr.prototype.setMap.call(this,t),t&&this.gx(this.canvas)},kr.prototype.setzIndex=function(t){this.Qh=t,this._container&&(this._container.style.zIndex=this.Qh+"")},kr.prototype.destroy=function(){var t;this._container&&(this.map?this.map.do.removeChild(this._container):(t=document.querySelector(".amap-layers"))&&t.removeChild(this._container),this._container=null)},kr.prototype.gx=function(t){this._container||(this._container=document.createElement("div"),this._container.style.zIndex=this.Qh+"",this._container.className="amap-layer amap-e",this._container.appendChild(t),this.map.do.appendChild(this._container),this.eP=!0)},wr=kr,_.Ei(Ar,wr);var wr,xr=Ar;function Ar(t,i){return(t=wr.call(this,t,i)||this).onCreated(),t}var zr,Cr={zIndex:120,opacity:1,zooms:_.zoomRange,cursor:"pointer",alwaysRender:!0},Sr=(zr=_.Event,_.Ei(L,zr),L.prototype.setMap=function(t){t?(this._map=t).add(this.a$):this._map&&(this.clear(),this._map.remove(this.a$))},L.prototype.getMap=function(){return this._map||null},L.prototype.getData=function(){return this.VL},L.prototype.setData=function(t){var i=this;t&&(this.VL=t,this.XD(),AMap.Util.requestAnimFrame(function(){i.emit("complete")}))},L.prototype.getStyle=function(){return 1===this.Ze.length?this.Ze[0]:this.Ze},L.prototype.setStyle=function(t){if(t){Array.isArray(t)||(t=[t]);var i=this.Ze,n=[];if(i&&i.length)for(var s=0;s<t.length;s++){var e=t[s],r=i[s]||i[0];n.push(AMap.extend({},r,e))}else n=t;this.Ze=n,this.XD()}},L.prototype.getOpacity=function(){return this._opts.opacity},L.prototype.setOpacity=function(t){this._opts.opacity=t,this.a$&&this.a$.setOpacity(t)},L.prototype.getzIndex=function(){return this._opts.zIndex},L.prototype.setzIndex=function(t){this._opts.zIndex=t,this.a$&&this.a$.setzIndex(t)},L.prototype.getZooms=function(){return this._opts.zooms||[2,30]},L.prototype.setZooms=function(t){this._opts.zooms=t,this.a$&&this.a$.setZooms(t)},L.prototype.getCursor=function(){return this._opts.cursor||"default"},L.prototype.show=function(){this.a$.show()},L.prototype.hide=function(){this.a$.hide()},L.prototype.clear=function(){this.a$.clear(),this.VL=[]},L.prototype.XD=function(){var t=this.VL,i=this.Ze,n=[],s=this.getCursor();if(t&&i){for(var e=0,r=t;e<r.length;e++){var h,o,a,u,c,f=r[e],l=f.lnglat,d=void 0===(d=f.style)?0:d;l&&(h=(a=i[d]||i[0]).url,c=void 0===(c=a.anchor)?new AMap.Pixel(0,0):c,u=a.size,o=a.rotation,d=void 0===(a=a.zIndex)?d:a,a=u.width?u.toArray():u,u=c.x?c.toArray():c,(c=new AMap.LabelMarker({position:l,zIndex:d,cursor:s,rotation:o,icon:{image:h,size:a,anchor:u}})).qD=f,this.Rm(c),n.push(c))}this.jT=n,this.a$.clear(),this.a$.add(n)}},L.prototype.Rm=function(t){var r=this;t.on(["click","dblclick","mouseover","mousemove","mouseout","mouseup","mousedown","touchstart","touchend"],function(t){var i,n=t.type,s=r._map,e=r.getCursor();"default"!==e&&s&&(i=s.getDefaultCursor(),"mouseover"===n?s.setCursor(e):"mouseout"===n&&s.setCursor(i)),r.QD(t)})},L.prototype.QD=function(t){var i=t.type,t=this.KD(t);this.emit(i,t)},L.prototype.KD=function(t){var i=t.target;return t.target=this,{target:t.target,type:t.type,data:i.qD||{}}},L);function L(t,i){var n=zr.call(this)||this;n.CLASS_NAME="AMap.MassMarks",n._opts=AMap.extend({},Cr,i);var s=(i=n._opts).zIndex,e=i.opacity,r=i.zooms,i=i.style;return n.a$=new AMap.LabelsLayer({zIndex:s,opacity:e,zooms:r,collision:!1,allowCollision:!1,VT:!0}),n.setData(t),n.setStyle(i),n.XD(),n}var Tr,Lr="AMap.Text",Ir="amap-overlay-text-container",Dr=(Tr=De,_.Ei(Or,Tr),Or.prototype.getText=function(){return this._opts.text},Or.prototype.getOptions=function(){return this._opts},Or.prototype.setText=function(t){var i=this.wx(t);this._opts.text=t,this.setContent(i)},Or.prototype.setStyle=function(t){t&&(this._x=t,this._opts.style=t,this._size=[0,0],this.updateOverlay())},Or.prototype.updateOverlay=function(t){void 0===t&&(t={}),this.dom&&!_.isEmpty(this._x)&&this.kx(this._x),Tr.prototype.updateOverlay.call(this,t)},Or.prototype.wx=function(t){var i=document.createElement("div");return w.addClass(i,Ir),i.innerHTML=t||"",i},Or.prototype.kx=function(t){void 0===t&&(t={});var i=this.dom.querySelector("."+Ir);if(i)for(var n in t)t.hasOwnProperty(n)&&(i.style[n]=t[n])},Or);function Or(t){var i=Tr.call(this,t=void 0===t?{}:t)||this;return i.className=Lr,i.type=Lr,i._x={},i._size=[0,0],t.style&&(i._x=t.style),t.text&&i.setText(t.text),i}var Rr,Er={zooms:_.zoomRange,opacity:1,rank:1,bubble:!1,visible:!0,zIndex:1,cursor:"pointer",noSelect:!1,icon:{clipOrigin:[0,0],anchor:[0,0],retina:!0},innerOverlay:!1,rotation:0,text:{content:"",direction:"right",offset:[0,0],zooms:_.zoomRange,style:{fontSize:12,fontFamily:"sans-serif",fontWeight:"normal",fillColor:"#000",strokeWidth:0,padding:"3",fold:!1}}},Pr={uy:"AMap.LabelMarker",gy:Math.pow(2,31)},jr={constructor:{time:0,highResTime:0},setIcon:{time:0,highResTime:0},setText:{time:0,highResTime:0}},Br=(Rr=Qt,_.Ei(I,Rr),I.prototype.nY=function(t){var i,n=_.yn(t);for(i in Er)Er.hasOwnProperty(i)&&void 0===n[i]&&(n[i]=_.clone(Er[i]));return n},I.prototype.getName=function(){return this._opts.name},I.prototype.setName=function(t){this._opts.name=t},I.prototype.getBounds=function(){var t=this._position;return new l(t,t)},I.prototype.getPosition=function(){return new _.LngLat(this._position[0],this._position[1])},I.prototype.setPosition=function(t){t&&("string"==typeof t?t=_.map(t.split(","),function(t){return parseFloat(t)}):_.Bs(t)&&(t=t.toJSON()),this._position=t,this.to())},I.prototype.getZooms=function(){return this._opts.zooms},I.prototype.setZooms=function(t){void 0===t&&(t=_.zoomRange),this._opts.zooms=t,this.to()},I.prototype.getOpacity=function(){return this._opts.opacity},I.prototype.setOpacity=function(t){void 0!==t&&(this._opts.opacity=t,this.to())},I.prototype.setRotation=function(t){void 0!==t&&(this._opts.rotation=t,this.to())},I.prototype.getRotation=function(){return void 0===this._opts.rotation?0:this._opts.rotation},I.prototype.getzIndex=function(){return this._opts.zIndex},I.prototype.setzIndex=function(t){this._opts.zIndex=t,this.to()},I.prototype.getRank=function(){return this._opts.rank},I.prototype.setRank=function(t){this._opts.rank=t,this.to()},I.prototype.getText=function(){return this._originOpts.text&&this._opts.text||null},I.prototype.setText=function(t){t&&(_.assign(this._opts.text,t),this.to())},I.prototype.getIcon=function(){return this._originOpts.icon&&this._opts.icon||null},I.prototype.setIcon=function(t){t&&(_.assign(this._opts.icon,t),this.to())},I.prototype.getOptions=function(){return this._opts},I.prototype.getDraggable=function(){return!1},I.prototype.getExtData=function(){return this._opts.extData||null},I.prototype.setExtData=function(t){this._opts.extData=t},I.prototype.setTop=function(t){void 0===t&&(t=!0),this._parent&&this._parent.setTop(this,t),t?(this.vL=this._opts.zIndex||1,this.setzIndex(Pr.gy)):(t=this.vL||this._opts.zIndex||1,this.setzIndex(t))},I.prototype.setCursor=function(t){t&&(this._opts.cursor=t)},I.prototype.getCursor=function(){return this._opts.cursor||"default"},I.prototype.setVisible=function(t){void 0!==t&&(this._opts.visible=t,this.to())},I.prototype.getVisible=function(){return this._opts.visible||!0},I.prototype.getCollision=function(){var t,i=this.getVisible(),n=!1;return this._parent&&i&&(t=this.hS,n=this._parent.IL(t)),i&&n},I.prototype.show=function(){this._opts.visible=!0,this.to()},I.prototype.hide=function(){this._opts.visible=!1,this.to()},I.prototype.emit=function(t,i){var n=this._opts||{},s=n.icon,e=n.text,r=e&&e.content,h=this.getCursor(),h=(this._map&&("mouseout"===t?this._map.setCursor():this._map.setCursor(h)),{data:{name:r,txt:r,position:this._position,extData:{},rank:n.rank,zooms:n.zooms},opts:{visible:n.visible,opacity:n.opacity,zooms:n.zooms,zIndex:n.zIndex,icon:s,text:e}});return i.data=h,Rr.prototype.emit.call(this,t,i),this},I.prototype.remove=function(){this._parent&&this._parent.remove(this)},I.prototype.to=function(){var n=this;this._parent&&this._parent.to({vv:!0},function(){var t=(new Date).getTime(),i=0;"performance"in window&&"function"==typeof performance.now&&(i=performance.now()),n.Ndt.setIcon={time:t,highResTime:i},n.Ndt.setText={time:t,highResTime:i}})},I.prototype.getStatus=function(){return this.Ndt},I.prototype.Cs=function(t){(this._parent=t)&&t.map?this._map=t.map:this._map=null},I.prototype.Ydt=function(n){return _.T8t(this,void 0,void 0,function(){var i;return _.x8t(this,function(t){switch(t.label){case 0:return[4,de.Ydt(n)];case 1:return i=t.y8t(),this.setPosition(i),[2]}})})},I);function I(t){var i=Rr.call(this)||this,t=(i.type=Pr.uy,i.className=Pr.uy,i.hS=_.Util.stamp(i),i._originOpts=t,i._opts=i.nY(t),t.position&&i.setPosition(t.position),i.Ndt=jr,(new Date).getTime()),n=0;return"performance"in window&&"function"==typeof performance.now&&(n=performance.now()),i.Ndt.constructor={time:t,highResTime:n},i}Wr=_.Event,_.Ei(Gr,Wr),Gr.prototype.addTo=function(t){this.map=t,this.map.controls.push(this),t.getControlContainer().appendChild(this._container),t.on("beforeDestroy",this.remove.bind(this))},Gr.prototype.removeFrom=function(t){t?(t.off("beforeDestroy",this.remove.bind(this)),t.getControlContainer().removeChild(this._container),delete this.map):this.map&&(this.map.off("beforeDestroy",this.remove.bind(this)),this.map.getControlContainer().removeChild(this._container),delete this.map)},Gr.prototype.remove=function(){this.map&&(this.map.off("beforeDestroy",this.remove.bind(this)),this.map.getControlContainer().removeChild(this._container),delete this.map)},Gr.prototype.show=function(){this._container.style.display="block",this.emit("show"),this.il=!0},Gr.prototype.hide=function(){this._container.style.display="none",this.emit("hide"),this.il=!1},Gr.prototype.initContainer=function(){this._className?(this._container=w.create("div",null,"amap-control amap-"+this._className),void 0===this._config.visible||this._config.visible||(this._container.style.display="none")):this._container=w.create("div",null,"amap-control"),this.Pb()},Gr.prototype.Pb=function(){var t=0,i=0,n=0,s=0;switch(this._config.offset&&0<this._config.offset.length&&(t=this._config.offset[0]+t,i=this._config.offset[1]+i,n=this._config.offset[0]+n,s=this._config.offset[1]+s),t+="px",i+="px",n+="px",s+="px",this._config.position){case"LT":this._container.style.top=i,this._container.style.left=t,this._container.style.bottom="",this._container.style.right="";break;case"RT":this._container.style.top=i,this._container.style.right=n,this._container.style.bottom="",this._container.style.left="";break;case"LB":this._container.style.bottom=s,this._container.style.left=t,this._container.style.top="",this._container.style.right="";break;case"RB":this._container.style.bottom=s,this._container.style.right=n,this._container.style.top="",this._container.style.left="";break;default:this._container.style.top=this._config.position.top||"",this._container.style.left=this._config.position.left||"",this._container.style.right=this._config.position.right||"",this._container.style.bottom=this._config.position.bottom||""}};var Wr,Fr=Gr;function Gr(t){var i=Wr.call(this)||this;return i.il=!0,i._config=t,i.il=void 0===t.visible||t.visible,i}var Nr,_r={ua:(xi=window.navigator).userAgent,mobile:_.Support.$e,plat:_.Support.plat,mac:_.Support.mac,windows:_.Support.windows,ios:_.Support.ios,iPad:_.Support.iPad,iPhone:_.Support.iPhone,android:_.Support.android,android23:_.Support.android23,chrome:_.Support.chrome,firefox:_.Support.firefox,safari:_.Support.safari,wechat:_.Support.wechat,uc:_.Support.SL,qq:_.Support.qq,ie:_.Support.ie,ie6:_.Support.ie6,ie7:_.Support.ie7,ie8:_.Support.ielt9&&!_.Support.ie7&&!_.Support.ie6,ie9:_.Support.ie9,ie10:_.Support.ie10,ie11:_.Support.ie11,edge:_.Support.edge,ielt9:_.Support.ielt9,baidu:_.Support.baidu,isLocalStorage:_.Support.RL,isGeolocation:!!xi.geolocation,mobileWebkit:_.Support.mobileWebkit,mobileWebkit3d:_.Support.mobileWebkit3d,mobileOpera:!!_.Support.mobileOpera,retina:_.Support.Ue,touch:!!_.Support.touch,msPointer:!!_.Support.msPointer,pointer:!!_.Support.pointer,baseRender:_.Support.baseRender,wasm:_.Support.wasm,webkit:_.Support.webkit,ie3d:_.Support.ie3d,webkit3d:_.Support.webkit3d,gecko3d:_.Support.gecko3d,opera3d:_.Support.opera3d,any3d:_.Support.any3d,isCanvas:_.Support.isCanvas,isSvg:_.Support.isSvg,isVML:_.Support.ie,isWorker:!!window.Worker,isWebsocket:!!window.WebSocket,isWebGL:_.Support.isWebGL,checkWebGL:function(){return _.Support.isWebGL=_.Support.sY(),_.Support.isWebGL}},ct=(Nr=s,_.Ei(Ur,Nr),Ur.prototype.getState=function(){return{zooms:this.xt,heightFactor:this.Q_,visible:this.il,zIndex:this.Qh,opacity:this.tl,wallColor:[],roofColor:[],layer:this,rejectMapMask:this._rejectMapMask,depthTest:this.AF,ce:this.IF}},Ur.prototype.getLayerConfig=function(){return Nr.prototype.getLayerConfig.call(this)},Ur.prototype.getSourceConfig=function(){return{id:this._id,type:"building",tileUrl:AMap.getConfig().protocol+(_.Support.wasm?"://{vdata,vdata01,vdata02,vdata03,vdata04}.amap.com/nebula/v3":"://{vdata,vdata01,vdata02,vdata03,vdata04}.amap.com/nebula/v2"),tileSize:0,zooms:_.zoomRange}},Ur.prototype.co=function(){return this._id},Ur.prototype.destroy=function(){this.Jh&&this.Jh.destroy&&(this.Jh.destroy(),delete this.Jh)},Ur);function Ur(){var t=Nr.call(this)||this;return t.CLASS_NAME="AMap.Buildings",t.Q_=1,t._id="building",t}var Yr,Zr={zooms:[14.8,_.zoomRange[1]],opacity:1,heightFactor:1,visible:!0,zIndex:11,wallColor:[.94,.94,.94,.9],roofColor:[.89,.89,.86,.9],u$:!1},Xr=(Yr=ct,_.Ei(Jr,Yr),Jr.prototype.setStyle=function(t){this.fL=t,this.uL()},Jr.prototype.getState=function(){return{zooms:this.xt,heightFactor:this.Q_,visible:this.il,zIndex:this.Qh,opacity:this.tl,wallColor:this.sz,roofColor:this.rz,vS:this.fL,layer:this,u$:this.cL,rejectMapMask:this._rejectMapMask,depthTest:this.AF,ce:this.IF}},Jr.prototype.uL=function(){this.map&&(this.getSource().reload(),this.map.setNeedUpdate(!0))},Jr);function Jr(t){void 0===t&&(t=Zr);var i=Yr.call(this)||this;return i.cL=!1,i.xt=(void 0===t.zooms?Zr:t).zooms,i.xt[0]=Math.max(i.xt[0],14.8),i.tl=(void 0===t.opacity?Zr:t).opacity,i.Q_=(void 0===t.heightFactor?Zr:t).heightFactor,i.il=(void 0===t.visible?Zr:t).visible,i.Qh=(void 0===t.zIndex?Zr:t).zIndex,i.sz=void 0!==t.wallColor&&_.Util.color2RgbaArray(t.wallColor),i.rz=void 0!==t.roofColor&&_.Util.color2RgbaArray(t.roofColor),i.AF=void 0===t.depthTest||Boolean(t.depthTest),i.cL=t.u$,i.cL&&(i._id="nebula"),i.onCreated(),i}Vr.add=function(){};var Hr=Vr;function Vr(){}function qr(t){return _.Support.isWebGL?new Ji(t):new v(_.Ln({id:"_defaultLayer_"+_.Util.uuid(),tileUrl:AMap.getConfig().y_},t))}var Kr,Qr="gl_custom";function $r(t){var i=Kr.call(this,t)||this;return i.CLASS_NAME="AMap.GLCustomLayer",i.init=t.init||function(t){},i.render=t.render||function(t,i,n){},i.Qh=t.zIndex||120,i.tl=void 0===t.opacity?1:t.opacity,i.il=void 0===t.visible||t.visible,i.xt=t.zooms||_.zoomRange,i}Kr=s,_.Ei($r,Kr),$r.prototype.getState=function(){return{visible:this.il,opacity:this.tl,zIndex:this.Qh,layer:this,rejectMapMask:this._rejectMapMask,depthTest:this.AF,ce:this.IF}},$r.prototype.getSourceConfig=function(){return{id:Qr,type:Qr,zooms:this.xt}},$r.prototype.co=function(){return Qr},$r.prototype.setMap=function(t){Kr.prototype.setMap.call(this,t)},$r.prototype.setzIndex=function(t){this.Qh=t},th=$r,_.Ei(nh,th);var th,ih=nh;function nh(t){return(t=th.call(this,t)||this).onCreated(),t}sh=_.Event,_.Ei(rh,sh),rh.prototype.setMap=function(t){var i=this;return t&&t!==this._map&&(this._map=t,_.forEach(this.zv,function(t){i._map&&!i._map.hasLayer(t)&&t.setMap(i._map)})),this},rh.prototype.hasLayer=function(i){return!!_.find(this.zv,function(t){return t===i})},rh.prototype.setOptions=function(e){var r=this.zv;return _.vx(e,function(t,i){for(var n=0;n<r.length;n++){var s=r[n];if("AMap.Layer"===s.el)switch(i){case"visible":t?s.show():s.hide();break;case"opacity":s.setOpacity&&s.setOpacity(t);break;case"zIndex":s.setzIndex&&s.setzIndex(t);break;case"zooms":s.setZooms&&s.setZooms(t)}else s.setOptions&&s.setOptions(e)}}),this},rh.prototype.eachLayer=function(t){if(_.isFunction(t))for(var i=0;i<this.zv.length;i++)t(this.zv[i],i,this.zv)},rh.prototype.addLayer=function(t){this.hasLayer(t)||(this.zv.push(t),t.setMap(this._map))},rh.prototype.addLayers=function(t){if(0<t.length)for(var i=0;i<t.length;i++){var n=t[i];this.addLayer(n)}},rh.prototype.removeLayer=function(t){for(var i=0;i<this.zv.length;i++)t===this.zv[i]&&this.zv.splice(i,1);return t.setMap(null),t},rh.prototype.removeLayers=function(t){if(t&&0<t.length)for(var i=0;i<t.length;i++){var n=t[i];this.removeLayer(n)}},rh.prototype.getLayers=function(){return this.zv},rh.prototype.clearLayers=function(){for(var t=0;t<this.zv.length;t++){var i=this.zv[t];this.removeLayer(i)}},rh.prototype.hide=function(){for(var t=0;t<this.zv.length;t++)this.zv[t].hide();return this},rh.prototype.show=function(){for(var t=0;t<this.zv.length;t++)this.zv[t].show();return this},rh.prototype.on=function(t,i){for(var n=0;n<this.zv.length;n++){var s=this.zv[n];s.on instanceof Function&&i instanceof Function&&s.on(t,i)}return this},rh.prototype.reload=function(){for(var t=0;t<this.zv.length;t++){var i=this.zv[t];i.reload&&i.reload()}return this};var sh,oh,eh=rh;function rh(t){var i=sh.call(this)||this;if(i.zv=[],i._map=null,t&&0<t.length)for(var n=0;n<t.length;n++){var s=t[n];i.addLayer(s)}return i}function hh(){console.log("jsapi2.0 AMap.Heatmap is renamed, please use AMap.HeatMap"),console.log("jsapi2.0  AMap.Heatmap 已重命名, 请使用 AMap.HeatMap")}function ah(t){var i=oh.call(this)||this;return i.CLASS_NAME="AMap.MapboxLayer",i._id="mapbox",i._tileUrl=AMap.getConfig().protocol+"://fmap0{1234}.amap.com/v3/vectormap?version=v8&key="+AMap.getConfig().key+"&s=rsv3&x=[x]&y=[y]&zoom=[z]",AMap.getConfig().jscode?i._tileUrl+="&jscode="+AMap.getConfig().jscode:AMap.getConfig().gaodeserver&&(i._tileUrl=AMap.getConfig().gaodeserver+"/v3/vectormap?version=v8&key="+AMap.getConfig().key+"&s=rsv3&x=[x]&y=[y]&zoom=[z]"),i.Xa=t.tileSize||256,i.Qs=[2,22],i.Qh=2,i.xt=[9.8,_.zoomRange[1]],i}oh=s,_.Ei(ah,oh),ah.prototype.getState=function(){return{zooms:[17,23],visible:this.il,zIndex:2,opacity:this.tl,layer:this,depthTest:this.AF,ce:this.IF,tileUrl:this._tileUrl}},ah.prototype.getSourceConfig=function(){return{id:this._id,tileUrl:this._tileUrl||"",type:"mapbox",tileSize:this.Xa||256,zooms:this.xt,dataZooms:this.Qs,projection:"EPS3857"}},ah.prototype.co=function(){return this._id},uh=ah,_.Ei(fh,uh);var uh,ch=fh;function fh(t){return uh.call(this,t)||this}Object.defineProperty(vh.prototype,"CLASS_NAME",{get:function(){return this.className},eb:!1,nb:!0}),vh.prototype.addOverlay=function(t){this._overlays.indexOf(t)<0&&(this._overlays.push(t),this._map)&&this._map.add(t)},vh.prototype.addOverlays=function(t){for(var i=0,n=t;i<n.length;i++){var s=n[i];this.addOverlay(s)}},vh.prototype.getOverlays=function(){return this._overlays},vh.prototype.hasOverlay=function(t){return-1<this._overlays.indexOf(t)},vh.prototype.removeOverlay=function(t){this.hasOverlay(t)&&(_.Util.deleteItemFromArray(this._overlays,t),this._map)&&this._map.remove(t)},vh.prototype.removeOverlays=function(t){for(var i=0,n=t;i<n.length;i++){var s=n[i];this.removeOverlay(s)}},vh.prototype.clearOverlays=function(){this._map&&this._map.remove(this._overlays),this._overlays=[]},vh.prototype.eachOverlay=function(t){_.forEach(this._overlays,t)},vh.prototype.setMap=function(t){this._map=t},vh.prototype.show=function(){for(var t=0,i=this._overlays;t<i.length;t++)i[t].show()},vh.prototype.hide=function(){for(var t=0,i=this._overlays;t<i.length;t++)i[t].hide()},vh.prototype.setOptions=function(t){for(var i=0,n=this._overlays;i<n.length;i++)n[i].setOptions(t)},vh.prototype.on=function(i,n,s,e){this.eachOverlay(function(t){t.on(i,n,s,e)})},vh.prototype.off=function(i,n,s,t){this.eachOverlay(function(t){t.off(i,n,s)})};var lh,dh=vh;function vh(t){void 0===t&&(t=[]),this.className="Overlay.OverlayGroup",this._overlays=[],this.addOverlays(t)}function ph(){var t=null!==lh&&lh.apply(this,arguments)||this;return t.P$=!1,t._dragObjects={sy:{x:0,y:0},hy:[0,0],ly:{lng:0,lat:0}},t}lh=Qt,_.Ei(ph,lh),ph.prototype.Cy=function(t){this.P$=!0,_.Support.$e||t.originEvent.preventDefault(),this.Ay(t)},ph.prototype.Ly=function(t){this.P$=!1,_.Support.$e||t.originEvent.preventDefault()},ph.prototype.Ay=function(t){this._dragObjects={sy:t.pixel,hy:t.pos,ly:t.lnglat}},ph.prototype.Mx=function(){this.on("dragstart",this.Cy.bind(this)),this.on("dragging",this._dragging.bind(this)),this.on("dragend",this.Ly.bind(this))},ph.prototype.Rx=function(){this.off("dragstart",this.Cy.bind(this)),this.off("dragging",this._dragging.bind(this)),this.off("dragend",this.Ly.bind(this))},mh=ph,_.Ei(D,mh),Object.defineProperty(D.prototype,"CLASS_NAME",{get:function(){return this.className},eb:!1,nb:!0}),D.prototype.Zx=function(t){this._map=t,this._opts&&(this._opts.map=t)},D.prototype.setMap=function(t){this._map!==t&&(this._map&&this._map.remove(this),t)&&t.add(this)},D.prototype.getMap=function(){return this._map||null},D.prototype.destroy=function(){this.Rx(),this._beforeRemoveMap&&this._beforeRemoveMap(),this._map=null,this.F$&&delete this.F$,this._bindEvents&&delete this._bindEvents,this._afterSetMap&&delete this._afterSetMap},D.prototype.remove=function(){this.setMap(null)},D.prototype.hide=function(){this.visible&&(this.visible=!1,this._map&&this._map.setNeedUpdate(!0),this.emit("hide",{target:this}))},D.prototype.show=function(){this.visible||(this.visible=!0,this._map&&this._map.setNeedUpdate(!0),this.emit("show",{target:this}))},D.prototype.setDraggable=function(t){return this._opts.draggable=t},D.prototype.getOptions=function(){return _.extend({},this._opts)},D.prototype.to=function(){var t=this;this._map&&(AMap.Util.requestAnimFrame(function(){t.emit("complete")}),this._map.setNeedUpdate(!0))},D.prototype.getExtData=function(){var t=this._opts;if(t&&t.extData)return t.extData},D.prototype.setExtData=function(t){this.setOptions({extData:t})},D.prototype.getCursor=function(){var t=this._opts.cursor;return!t&&this._map?this._map.getDefaultCursor():t},D.prototype.emit=function(t,i){var n=this.getCursor();return this._map&&("mouseout"===t?this._map.setCursor():this._map.setCursor(n)),("dragstart"!==t&&"dragging"!==t&&"dragend"!==t||this.getDraggable())&&mh.prototype.emit.call(this,t,i),this},D.prototype.getDraggable=function(){var t=this._opts.draggable;return void 0!==t&&t},D.prototype.BB=function(){this.b_([0,0])},D.prototype.getDeltaCoord=function(){return this.zx},D.prototype.b_=function(t){this.zx=t},D.prototype.rY=function(t){var i=this.Sx;return _.Util.hp(i,t)},D.prototype._beforeRemoveMap=function(){var t;this.F$&&(null!=(t=this.F$.parentNode)&&t.removeChild(this.F$),delete this.F$)},D.prototype.nY=function(t){var i,n=this._opts;for(i in t)t.hasOwnProperty(i)&&(n[i]=t[i]);return n},D.prototype._dragging=function(t){var i,n,s,e,r;this.getDraggable()&&(n=this._dragObjects.hy,i=t.pos[0]-n[0],n=t.pos[1]-n[1],r=this._dragObjects.sy,this.F$&&"d"===this._map.baseRender?(e=t.pixel.x-r.x,r=t.pixel.y-r.y,s=this.B$,this.B$=[e+s[0],r+s[1]],e=" translate("+this.B$[0]+"px, "+this.B$[1]+"px)",this.F$.style.transform=e,this.F$.style.webkitTransform=e,this.F$.style.MozTransform=e,this.F$.style.msTransform=e):this.to(),r=this.getDeltaCoord(),this.b_([i+r[0],n+r[1]]),this.Ay(t))},D.prototype.Ly=function(t){mh.prototype.Ly.call(this,t),this.Ay(t),this.F$&&"d"===this._map.baseRender?this.moveWithPixel(this.B$[0],-1*this.B$[1]):this.moveWithPos(this.zx[0],this.zx[1]),this.BB(),this.B$=[0,0],this.F$&&(this.F$.style.transform="",this.F$.style.webkitTransform="",this.F$.style.MozTransform="",this.F$.style.msTransform=""),this.to()},D.prototype.moveWithPixel=function(){console.log("please implement movePixel")},D.prototype.moveWithPos=function(){console.log("please implement moveWithPos")},D.prototype._checkMap=function(){this._opts&&this._opts.map!==this._map&&this.setMap(this._opts.map)},D.prototype.cE=function(){this._needUpdate=!0,!this._map||this._map.fE&&!this._map.isDOMMode()||this.ZB()};var mh,Bt=D;function D(){var t=mh.call(this)||this;return t._needUpdate=!1,t.className="Overlay",t.gdt=!1,t.visible=!0,t.P$=!1,t.zx=[0,0],t.B$=[0,0],t.Ax=[0,0],t.hS=_.Util.stamp(t),t.Mx(),t}function yh(t){if(t=_.jsonLngLatData(t),_.ys(t))t=[[t]];else if(_.Ox(t))t=[t];else if(!_.tL(t))return;return t}function bh(t,i,n){return _.hL.ss(t,i,n)}function gh(t,i){if(!bh(t,i[0]))return!1;for(var n=1,s=i.length;n<s;n++)if(bh(t,i[n],!0))return!1;return!0}function Mh(t,i){for(var n=0,s=i.length;n<s;n++)if(gh(t,i[n]))return!0;return!1}function kh(t,i,n){for(var s=[],e=0,r=t;e<r.length;e++){var h=r[e];s.push(n.moveWithPos(h,i))}return s}function wh(t,i,n){for(var s=[],e=0,r=t;e<r.length;e++){var h=kh(r[e],i,n);s.push(h)}return s}function xh(t,i,n,s){for(var e=[],r=0,h=t;r<h.length;r++){var o=h[r];e.push(s.moveWithPixel(o,i,n))}return e}function Ah(t,i,n,s){for(var e=[],r=0,h=t;r<h.length;r++){var o=xh(h[r],i,n,s);e.push(o)}return e}function zh(t){return _.GeometryUtil.ringArea(t)}function Ch(t){for(var i=zh(t[0]),n=1;n<t.length;n++)i-=zh(t[n]);return i}function Sh(t){for(var i=0,n=0,s=t;n<s.length;n++)i+=Ch(s[n]);return i}function Th(t){return t=_.jsonLngLatData(t),_.ys(t)?[t]:t}function Lh(t){return _.GeometryUtil.distanceOfLine(t)}function Ih(t){if(t.length<2)return t;var i=[];i.push(t[0]);for(var n=1,s=t.length;n<s;n++){var e=t[n-1],r=t[n];Array.prototype.push.apply(i,function(t,i){var n=Math.round(Math.abs(t.KL-i.KL));if(!n||Math.abs(t.KL-i.KL)<.001)return[];for(var e,r,h,o,a=[],u=Math.PI,c=Math.asin,f=Math.sqrt,l=Math.sin,d=Math.pow,v=Math.cos,p=Math.atan2,m=t.kT*Dh,y=t.KL*Dh,b=i.kT*Dh,g=i.KL*Dh,M=2*c(f(d(l((m-b)/2),2)+v(m)*v(b)*d(l((y-g)/2),2))),s=1;s<n;s+=1)o=l((1-(h=1/n*s))*M)/l(M),h=l(h*M)/l(M),e=o*v(m)*v(y)+h*v(b)*v(g),r=o*v(m)*l(y)+h*v(b)*l(g),h=p(o=o*l(m)+h*l(b),f(d(e,2)+d(r,2))),o=p(r,e),y<g?(o<y&&(o+=2*u),g<o&&(o-=2*u)):(y<o&&(o-=2*u),o<g&&(o+=2*u)),a.push([o*Oh,h*Oh]);return a}(_.LngLat.from(e),_.LngLat.from(r))),i.push(r)}return i}var Dh=Math.PI/180,Oh=180/Math.PI;function Rh(t,i){var n=[],t=_.parseLngLatData(t),s=_.ProjectionManager.getProjection("EPSG:3857");if(t)for(var e=s.project(t.KL,t.kT),r=e[0],h=e[1],o=6*Math.PI/180,a=Math.cos(t.kT*Math.PI/180),u=0;u<=60;u++){var c=u*o,f=i*Math.cos(c)/a,c=i*Math.sin(c)/a,f=s.unproject(r+f,h+c);n.push(f)}return n}function Eh(t,i,n){var s=[],t=_.parseLngLatData(t),e=_.ProjectionManager.getProjection("EPSG:3857");if(t)for(var h=(r=e.project(t.KL,t.kT))[0],o=r[1],r=n?89:359,a=(n?4:1)*Math.PI/180,u=i[0],c=i[1],f=Math.cos(t.kT*Math.PI/180),l=0,d=r;l<=d;l++){var v=l*a,p=u*Math.cos(v)/f,v=c*Math.sin(v)/f,p=e.unproject(h+p,o+v);s.push(p)}return s}function Ph(t){var i=t.getSouthWest(),t=t.getNorthEast();return[new _.LngLat(i.KL,i.kT,!0),new _.LngLat(t.KL,i.kT,!0),new _.LngLat(t.KL,t.kT,!0),new _.LngLat(i.KL,t.kT,!0)]}Bh.prototype.init=function(t,i){var n,s,e=t.length;this.tdt=new Array(e);for(var r=0;r<e;r+=1)if(n=t[r],s=new Uh(n),this.tdt[r]=s,!i)if(0===r){if(0===n.length)return;s.isClockwise(n)||n.reverse()}else 0!==n.length&&s.isClockwise(n)&&n.reverse()},Bh.prototype.getBounds=function(){if(0===this.tdt.length)return Pt.createEmpty();if(!this.ndt){for(var t=this.tdt[0].getBounds(),i=1;i<this.tdt.length;i+=1){var n=this.tdt[i].getBounds();Pt.rs(t,n)||Pt.extend(t,n)}this.ndt=t}return this.ndt},Bh.prototype.sdt=function(){return this.tdt},Bh.prototype.edt=function(){for(var t=0;t<this.tdt.length;t+=1)this.tdt[t].xh},Bh.prototype.getType=function(){return Fh.rdt.POLYGON},Bh.prototype.ss=function(t){for(var i,n=this.tdt,s=0,e=n.length;s<e&&(i=n[s].ss(t),i=0<s?!i:i);s+=1);return i},Bh.prototype.odt=function(t){for(var i=this.tdt,n=[],s=0,e=i.length;s<e;s+=1)_.hL.isClockwise(i[s].xh)?n.length&&n[n.length-1].push(s):n.push([s]);for(s=0,e=n.length;s<e;s+=1){for(var a=!1,r=0,h=n[s].length;r<h;r+=1){var o=n[s][r],a=Uh.prototype.ss.call(i[o],t);if(!(a=0<r?!a:a))break}if(a)return!0}};var jh=Bh;function Bh(){}(li=ea=ea||{}).POINT="point",li.LINESTRING="linestring",li.LINEARRING="linearring",li.POLYGON="polygon",li.MULTIPOINT="multipoint",li.MULTILINESTRING="multilinestring",li.MULTIPOLYGON="multipolygon",li.GEOMETRYCOLLECTION="geometrycollection",Gh.prototype.hdt=function(){var t=this.getBounds();return t.center||(t.center=Pt.getCenter(t)),t.center},Gh.prototype.clone=function(){var t=new this.constructor;return t.init(this.XK()),t},Gh.prototype.XK=function(){return this.xh},Gh.prototype.got=function(t){if(this.adt=this.getBounds(),this.ndt=null,this instanceof jh)for(var i=t.length,n=void(this.tdt=new Array(i)),s=void 0,e=0;e<i;e+=1)if(n=t[e],s=new Uh(n),this.tdt[e]=s,0===e){if(0===n.length)return;s.isClockwise(n)||n.reverse()}else 0!==n.length&&s.isClockwise(n)&&n.reverse();else this.xh=t},Gh.rdt=ea;var Wh,Fh=Gh;function Gh(t){var i=this;this.setCoords=function(t){i.got(t)},this.init(t)}function Nh(){return null!==Wh&&Wh.apply(this,arguments)||this}Wh=Fh,_.Ei(Nh,Wh),Nh.prototype.init=function(t){this.xh=t},Nh.prototype.getBounds=function(){if(!this.ndt){for(var t=Pt.createEmpty(),i=0,n=this.xh.length;i<n;i+=1)Pt.extendCoordinate(t,this.xh[i]);this.ndt=t}return this.ndt},Nh.prototype.XK=function(){return this.xh},Nh.prototype.getType=function(){return Fh.rdt.LINESTRING},Nh.prototype.getCount=function(){return this.XK().length},Nh.prototype.udt=function(t){return _.hL.lr(t,this.XK())},_h=Nh,_.Ei(Yh,_h),Yh.prototype.getType=function(){return Fh.rdt.LINEARRING},Yh.prototype.ss=function(t){return _.hL.ss(t,this.xh)};var _h,Uh=Yh;function Yh(){var t=null!==_h&&_h.apply(this,arguments)||this;return t.isClockwise=_.hL.isClockwise,t}Zh=Bt,_.Ei(Xh,Zh),Xh.prototype.Tx=function(t){t&&(t=_.Bs(t)?_.ProjectionManager.getProjection("EPSG:3857").project(t.KL,t.kT):_.ProjectionManager.getProjection("EPSG:3857").project(t[0],t[1]),this.Sx=_.lcs.getLocalByCoord(t))},Xh.prototype.toGeometry=function(){var t;if(this._opts.path)return t=this._opts.path.slice(0),_.ys(t)?{type:"Polygon",coordinates:[t]}:_.Ox(t)?{type:"Polygon",coordinates:t}:{type:"MultiPolygon",coordinates:t}},Xh.prototype.toString=function(){var t=this._opts.path;return _.ys(t)?""+t.join(";"):_.Ox(t)?""+_.map(t,function(t){return""+t.join(";")}).join("|"):_.tL(t)?_.map(t,function(t){return _.map(t,function(t){return""+t.join(";")}).join("|")}).join("^"):""},Xh.prototype.reset=function(){this.Dx&&this.Dx.reset(),this.Px&&this.Px.reset(),this.XB&&this.XB.reset(),this.qB&&this.qB.reset(),this.p0&&this.p0.reset(),this.m0&&this.m0.reset()},Xh.prototype.destroy=function(){this.Dx&&(this.Dx.destroy(),delete this.Dx),this.Px&&(this.Px.destroy(),delete this.Px),this.XB&&this.XB.destroy&&(this.XB.destroy(),delete this.XB),this.qB&&this.qB.destroy&&(this.qB.destroy(),delete this.qB),this.p0&&(this.p0.destroy(),delete this.p0),this.p0&&this.Px.destroy&&(this.p0.destroy(),delete this.p0),this.q$&&delete this.X$,this.$x&&(this.$x=[]),Zh.prototype.destroy.call(this)},Xh.prototype.pdt=function(t,i,n){var s=0;if(i&&this._opts.extrusionHeight){for(var e=[],r=0;r<i.length;r++)e.push(i[r][0],i[r][1]);s=this.p0.tz(e,this._opts.extrusionHeight,n)}return n={bz:"",length:1,mainkey:this.hS,maxzoom:26,minzoom:2,offset:0,subkey:1},s&&0<s&&this.m0.add(n.mainkey,n.subkey,s,n.minzoom,n.maxzoom,n.bz),this.p0.upload(t),s},Xh.prototype.X$=function(t){for(var i=[],n=0,s=t;n<s.length;n++){for(var e=s[n],r=[],h=[],o=0,a=e[0];o<a.length;o++){var u=a[o],c=_.ProjectionManager.getProjection("EPSG:3857").project(u[0],u[1]);h.push([c[0],c[1]])}h.length&&(h.push(h[0].slice()),r.push(h));for(var f=1,l=e.length;f<l;f++){var d=e[f],v=[];if(d&&d.length){for(var p=0,m=d;p<m.length;p++)u=m[p],c=_.ProjectionManager.getProjection("EPSG:3857").project(u[0],u[1]),v.push([c[0],c[1]]);v.push(v[0].slice()),r.push(v)}}i.push(r)}this.q$=i},Xh.prototype.Q$=function(t,i){this.BB(),this.JL(),this.reset();var n=this.Dx,s=this.Px,e=this.XB,r=this.qB;this.Tx(t[0][0][0]);for(var h=0,o=t;h<o.length;h++){for(var a=o[h],u=this.Sx.center,c=[],f=[],l=[],d=[],v=[],p=0,m=a[0];p<m.length;p++){var y=m[p],b=_.ProjectionManager.getProjection("EPSG:3857").project(y[0],y[1]);c.push(b[0]-u[0],b[1]-u[1]),f.push(y)}for(var g=1,M=a.length;g<M;g++){for(var k=[],w=[],x=0,A=a[g];x<A.length;x++)y=A[x],_.Bs(y)?(k.push(y.pos[0]-u[0],y.pos[1]-u[1]),w.push(y.toJSON())):(b=_.ProjectionManager.getProjection("EPSG:3857").project(y[0],y[1]),k.push(b[0]-u[0],b[1]-u[1]),w.push(y));l.push(k),d.push(w)}for(var z=[],g=0,M=c.length;g<M;g+=2)z.push(_.xd(c[g],c[g+1]));_.equals(z[0],z[z.length-1])||z.push(_.Ex(z[0]));for(var C=c.length,g=0;g<l.length;g++)v.push(C/2),C+=l[g].length,_.Util.Ig(c,l[g]);var S=n.Nx(c,v);if(i&&c&&0<this._opts.extrusionHeight){for(var T=z,L=[],g=0;g<l.length;g++)for(var I=l[g],D=0;D<I.length;D+=2)L.push([I[D],I[D+1]]);L&&0<L.length&&(new Uh(L).isClockwise(L)||L.reverse()),new Uh(z).isClockwise(z)&&z.reverse(),_.Util.Ig(T,L),this.pdt(i,T,v)}e.add(S);var O=s.Nx(z,{lineJoin:"miter"}).Iw;for(r.add(O),g=0;g<l.length;g++){for(var R=[],E=0,M=(k=l[g]).length;E<M;E+=2)R.push(_.xd(k[E],k[E+1]));R.push(_.xd(k[0],k[1])),O=s.Nx(R,{lineJoin:"miter"}).Iw,r.add(O)}}i&&(this.Dx.upload(i),this.Px.upload(i))},Xh.prototype.JL=function(){this.Dx||(this.Dx=new _.K_),this.Px||(this.Px=new _.J_),this.XB||(this.XB=new _.oE),this.qB||(this.qB=new _.oE),this.p0||(this.p0=new _.iz),this.m0||(this.m0=new _._w)};var Zh,Ti=Xh;function Xh(){return null!==Zh&&Zh.apply(this,arguments)||this}var Jh,Kh,Hh={map:void 0,fillColor:"#00D3FC",fillOpacity:.5,strokeColor:"#00B2D5",strokeWeight:2,strokeOpacity:.9,strokeStyle:"solid",draggable:!1,extrusionHeight:0,bubble:!1,strokeDasharray:[10,5],zIndex:50,extData:{},noSelect:!1,innerOverlay:!1,zooms:_.zoomRange,async:!1},Vh={constructor:{time:0,highResTime:0},setPath:{time:0,highResTime:0}},qh=(Jh=Ti,_.Ei(O,Jh),O.prototype.getOptions=function(){return _.extend({},this._opts)},O.prototype.setOptions=function(t){var t=this.nY(t),i=!_.isEqual(this._opts.path,t.path);this._opts=t,this._checkMap(),i&&this.setPath(this._opts.path),this.to()},O.prototype.init=function(t){this.reset(),t=t||this._opts,this._opts=this.nY(t),this.setPath(this._opts.path),this._map&&(0<this._opts.extrusionHeight&&(this.zdt=this.Cdt.bind(this),this.Sdt=this.Ldt.bind(this),this.tv()),this._map.setNeedUpdate(!0))},O.prototype.destroy=function(){0<this._opts.extrusionHeight&&(this.Tdt(),this.zdt=null,this.Sdt=null),this.gdt&&delete this.gdt,this._opts,Jh.prototype.destroy.call(this)},O.prototype.getPath=function(){if(this._opts&&this._opts.path)return _.parseLngLatData(_.yn(this._opts.path))},O.prototype.getStatus=function(){return this.Ndt},O.prototype.setExtrusionHeight=function(t){this._opts&&(this._opts.extrusionHeight=t,this.reset(),this.Ix(this._opts.path)),this.to()},O.prototype.getExtrusionHeight=function(){return this._opts&&this._opts.extrusionHeight?this._opts.extrusionHeight:0},O.prototype.getBounds=function(){var t;if(this.ir)t=this.ir;else{var i=this._opts.path;if(!i)return;if(!(i=yh(i)))return;(i=l.ms(i))&&(t=this.ir=i)}if(t)return this._map&&this.zx&&(0!==this.zx[0]||0!==this.zx[1])?(i=t.getSouthWest(),t=t.getNorthEast(),i=this._map.getView().ru().moveWithPos([i.KL,i.kT],this.zx),t=this._map.getView().ru().moveWithPos([t.KL,t.kT],this.zx),new l(i,t)):this.ir},O.prototype.getArea=function(){var t;return this._opts&&this._opts.path?(t=_.jsonLngLatData(this._opts.path),_.ys(t)?+_.GeometryUtil.ringArea(t).toFixed(2):_.Ox(t)?+Ch(t).toFixed(2):+Sh(t).toFixed(2)):0},O.prototype.contains=function(t,i){var n,s,e;return!!this.jx()&&(n=this._opts.path,s=_.parseLngLatData(t),!!(e=null==(e=this._map)?void 0:e.lngLatToContainer(s)))&&(0<this._opts.extrusionHeight&&(this._opts.bubble&&i&&i.Adt&&"click"===i.Adt&&(this.gdt=!1),!this.gdt)&&(0<(i=this.queryPolyhedronFeature([e.x,e.y]))&&i===this.hS)||!(this.ir&&!this.ir.contains(t))&&(_.ys(n)?bh:_.Ox(n)?gh:Mh)([s.lng,s.lat],n))},O.prototype.setPath=function(t){var i;t&&(this.reset(),this.Ix(t),t=(new Date).getTime(),i=0,"performance"in window&&"function"==typeof performance.now&&(i=performance.now()),this.Ndt&&(this.Ndt.setPath={time:t,highResTime:i}),this.to())},O.prototype.iE=function(t){if(this.jx()&&(!this.ir||this.ir.contains(t))){var i=this._opts.path,t=_.parseLngLatData(t);if(_.ys(i))return 0;if(_.Ox(i))return 0;for(var n=[t.lng,t.lat],s=i,e=0,r=s.length;e<r;e++)if(gh(n,s[e]))return e}return-1},O.prototype.ZB=function(t){var i,n=this;this._map&&(this._needUpdate=!1,this._opts.path)&&(i=yh(this._opts.path))&&(this._opts.async?this._map.gn.QB({data:i,type:"polygon"},function(t,i){t?console.log(t):(n.Dx=i.Dc,n.Px=i.$c,n.Sx=i.Sx,n.XB=i.Oc,n.qB=i.Uc)}):this.Q$(i,t))},O.prototype.queryPolyhedronFeature=function(t){if(this._map&&this.bdt()){for(var i,s=(n=this._map).getView().getStatus(),s={layers:n.getLayers(),uo:n.Mv,size:s.size,do:n.do,viewState:s,map:n},e=0,r=n.getLayers();e<r.length;e++){var h=r[e];"AMap.VectorLayer"===h.CLASS_NAME&&(i=h)}var o=i.getRender();if(o){var a=o.pu||0,n=n.getGL(),u=t[0]*a,t=n.drawingBufferHeight-t[1]*a,a=new Uint8Array(4);if(o.vdt&&(s=o.pickRender(s,this),n.bindFramebuffer(n.FRAMEBUFFER,s),n.readPixels(u,t,1,1,n.RGBA,n.UNSIGNED_BYTE,a),n.bindFramebuffer(n.FRAMEBUFFER,null)),u=(s=o.ydt)&&s.GV([a[0],a[1],a[2]]))return u}}},O.prototype.Cdt=function(){this.gdt=!0},O.prototype.Ldt=function(){this.gdt=!1},O.prototype.tv=function(){this._map&&(this._map.on("mousedown",this.zdt),this._map.on("mouseup",this.Sdt))},O.prototype.Tdt=function(){this._map&&(this._map.off("mousedown",this.zdt),this._map.off("mouseup",this.Sdt))},O.prototype._dragging=function(t){var i,n,s;this.getDraggable()&&(n=this._dragObjects.hy,i=t.pos[0]-n[0],n=t.pos[1]-n[1],this._dragObjects.sy,s=this.getDeltaCoord(),this.b_([i+s[0],n+s[1]]),this.Ay(t),this.F$&&"d"===this._map.baseRender?this.moveWithPixel(this.B$[0],-1*this.B$[1]):this.moveWithPos(this.zx[0],this.zx[1]),this.BB(),this.B$=[0,0],this.F$&&(this.F$.style.transform="",this.F$.style.webkitTransform=""),this.to())},O.prototype.jx=function(){return Boolean(this._opts&&this._opts.path&&0<this._opts.path.length)},O.prototype.moveWithPixel=function(t,i){var n,s,e;this._map&&(n=this._map,s=_.ProjectionManager.getProjection(n.getView().au()),e=this._opts.path,e=(_.ys(e)?xh:_.Ox(e)?Ah:function(t,i,n,s){for(var e=[],r=0,h=t;r<h.length;r++){var o=Ah(h[r],i,n,s);e.push(o)}return e})(e,[t,i],n.getZoom(),s),this.setPath(e))},O.prototype.moveWithPos=function(t,i){var n,s;this._map&&(n=this._map,n=_.ProjectionManager.getProjection(n.getView().au()),s=this._opts.path.slice(0),s=(_.ys(s)?kh:_.Ox(s)?wh:function(t,i,n){for(var s=[],e=0,r=t;e<r.length;e++){var h=wh(r[e],i,n);s.push(h)}return s})(s,[t,i],n),this.setPath(s))},O.prototype.bdt=function(){var t;return!(this._opts.fillOpacity<=0||null!=(t=this._map)&&t.TL()||(t=this._map.getZoom())<this._opts.zooms[0]||t>this._opts.zooms[1])},O);function O(t){void 0===t&&(t={});var n=Jh.call(this)||this,i=(n.Ix=function(t){var i;n._opts.path=_.jsonLngLatData(t),(t=yh(t))&&(n.ir=l.ms(t),i=n._map)&&("d"===i.baseRender?n.X$(t):n.cE())},t.path),i=(_.iL(i)?(s=i[0],n.Tx(s)):_.eL(i)?(s=i[0][0],n.Tx(s)):_.yL(i)&&(s=i[0][0][0],n.Tx(s)),n.className="Overlay.Polygon",n._opts={fillColor:"#00D3FC",fillOpacity:.5,strokeColor:"#00B2D5",strokeWeight:2,strokeOpacity:.9,strokeStyle:"solid",draggable:!1,extrusionHeight:0,wallColor:"#00D3FC",roofColor:"#00B2D5",bubble:!1,strokeDasharray:[10,5],zIndex:50,extData:{},noSelect:!1,innerOverlay:!1,zooms:_.zoomRange,async:!1},n._opts=n.nY(t),n._checkMap(),n.Ndt=Vh,(new Date).getTime()),s=0;return"performance"in window&&"function"==typeof performance.now&&(s=performance.now()),n.Ndt.constructor={time:i,highResTime:s},n}function Qh(){var n=null!==Kh&&Kh.apply(this,arguments)||this;return n.contains=function(t){var i;return!(!n.aE||n.ir&&!n.ir.contains(t))&&(i=n.aE,t=_.parseLngLatData(t),(_.ys(i)?bh:_.Ox(i)?gh:Mh)([t.lng,t.lat],i))},n}Kh=Ti,_.Ei(Qh,Kh),Qh.prototype.getOptions=function(){return _.extend({},this._opts)},Qh.prototype.getArea=function(){var t=this.aE;return t?+Sh(t).toFixed(2):0},$h=Oi=Qh,_.Ei(io,$h),io.prototype.init=function(t){t=t||this._opts,this._opts=this.nY(t),this.setBounds(t.bounds)},io.prototype.setBounds=function(t){t&&(_.xs(t)||(t=new l(t)),this._opts.bounds=t,this.ir=t.clone(),this.cE(),this.to())},io.prototype.ZB=function(t){var i,n,s;this._map&&(this._needUpdate=!1,i=this._opts.bounds)&&(n=this._map,(s=yh(Ph(i)))&&(this.ir=i.clone(),this.aE=s,"d"===n.baseRender?this.X$(s):this.Q$(s,t)),this.to())},io.prototype.moveWithPixel=function(t,i){var n,s,e;this._map&&(n=this._map,s=(e=this._opts.bounds).southWest.toJSON(),e=e.northEast.toJSON(),s=this._map.getView().ru().moveWithPixel(s,[t,i],n.getZoom()),e=this._map.getView().ru().moveWithPixel(e,[t,i],n.getZoom()),t=new l(s,e),this.setBounds(t))},io.prototype.moveWithPos=function(t,i){var n,s;this._map&&(n=(s=this._opts.bounds).southWest.toJSON(),s=s.northEast.toJSON(),n=this._map.getView().ru().moveWithPos(n,[t,i]),s=this._map.getView().ru().moveWithPos(s,[t,i]),t=new l(n,s),this.setBounds(t))},io.prototype.setOptions=function(t){var t=this.nY(t),i=!_.isEqual(this._opts.bounds,t.bounds);this._opts=t,this._checkMap(),i&&this.setBounds(t.bounds),this.to()},io.prototype.getPath=function(){var t,i,n;if(!this.ir){var s=this._opts.bounds;if(!s)return;this.ir=s.clone()}if(s=this.ir)return this.P$&&(i=s.getSouthWest(),n=s.getNorthEast(),i=this._map.getView().ru().moveWithPos([i.KL,i.kT],this.zx),n=this._map.getView().ru().moveWithPos([n.KL,n.kT],this.zx),s=new l(i,n)),s?Ph(s):t},io.prototype.getBounds=function(){var t;if(!this.ir){var i=this._opts.bounds;if(!i)return;this.ir=i.clone()}if(i=this.ir)return this.P$?(t=i.getSouthWest(),i=i.getNorthEast(),t=this._map.getView().ru().moveWithPos([t.KL,t.kT],this.zx),i=this._map.getView().ru().moveWithPos([i.KL,i.kT],this.zx),new l(t,i)):this.ir},io.prototype.getCenter=function(){if(this._opts.bounds)return this._opts.bounds.getCenter()};var $h,to=io;function io(t){void 0===t&&(t={});var n=$h.call(this)||this;return n.className="Overlay.Rectangle",n.contains=function(t){var i=n.getBounds();return!!i&&i.contains(t)},n._opts={fillColor:"#00D3FC",fillOpacity:.5,strokeColor:"#00B2D5",strokeWeight:2,strokeOpacity:.9,strokeStyle:"solid",draggable:!1,bubble:!1,strokeDasharray:[10,5],zIndex:50,extData:{},noSelect:!1,innerOverlay:!1,zooms:_.zoomRange,async:!1},n._opts=n.nY(t),n._checkMap(),n}no=Oi,_.Ei(eo,no),eo.prototype.init=function(t){t=t||this._opts,this._opts=this.nY(t),this.setCenterAndRadius(this._opts.center,this._opts.radius)},eo.prototype.setCenter=function(t){this.setCenterAndRadius(t,this._opts.radius)},eo.prototype.setRadius=function(t){this.setCenterAndRadius(this._opts.center,t)},eo.prototype.getCenter=function(){var t=_.parseLngLatData(this._opts.center),t=this._map.getView().ru().moveWithPos([t.KL,t.kT],this.zx);return new _.LngLat(t[0],t[1])},eo.prototype.getRadius=function(){return this._opts.radius},eo.prototype.getPath=function(){var t;return this._opts.center&&this._opts.radius&&(t=Eh(this._opts.center,this._opts.radius,_.Support.$e))&&0<t.length?_.parseLngLatData(_.yn(t)):[]},eo.prototype.setCenterAndRadius=function(t,i){this._opts.center=t,this._opts.radius=i,this.cE(),this.to()},eo.prototype.ZB=function(t){var i,n,s;this._map&&(this._needUpdate=!1,s=this._opts.center,i=this._opts.radius,s)&&i&&(s=_.jsonLngLatData(s),n=this._map,(s=yh(Eh(s,i,_.Support.$e)))&&(this.ir=l.ms(s),this.aE=s,"d"===n.baseRender?this.X$(s):this.Q$(s,t)),this.BB(),this._map.setNeedUpdate(!0))},eo.prototype.moveWithPixel=function(t,i){var n,s;this._map&&(n=this._map,s=_.parseLngLatData(this._opts.center),s=this._map.getView().ru().moveWithPixel([s.KL,s.kT],[t,i],n.getZoom()),this.setCenter(s))},eo.prototype.moveWithPos=function(t,i){var n;this._map&&(n=_.parseLngLatData(this._opts.center),n=this._map.getView().ru().moveWithPos([n.KL,n.kT],[t,i]),this.setCenter(n))},eo.prototype.getBounds=function(){if(!this.ir){var t=this._opts.center,i=this._opts.radius;if(!t||!i)return;var i=Math.max(i[0],i[1]),n=(t=_.parseLngLatData(t)).offset(-i,-i),t=t.offset(i,i);this.ir=new l(n,t)}if(i=this.ir,this.ir)return this.P$?(n=i.getSouthWest(),t=i.getNorthEast(),n=this._map.getView().ru().moveWithPos([n.KL,n.kT],this.zx),t=this._map.getView().ru().moveWithPos([t.KL,t.kT],this.zx),new l(n,t)):this.ir},eo.prototype.setOptions=function(t){var t=this.nY(t),i=!_.isEqual(this._opts.center,t.center)||!_.isEqual(this._opts.radius,t.radius);this._opts=t,this._checkMap(),i&&this.setCenterAndRadius(this._opts.center,this._opts.radius),this.to()};var no,so=eo;function eo(t){void 0===t&&(t={});var i=no.call(this)||this;return i.className="Overlay.Ellipse",i.Cx=_.assign({center:void 0,radius:void 0},Hh),i._opts={fillColor:"#00D3FC",fillOpacity:.5,strokeColor:"#00B2D5",strokeWeight:2,strokeOpacity:.9,strokeStyle:"solid",draggable:!1,bubble:!1,strokeDasharray:[10,5],zIndex:50,extData:{},noSelect:!1,innerOverlay:!1,zooms:_.zoomRange,async:!1},i._opts=i.nY(t),i._checkMap(),i}ro=Oi,_.Ei(ao,ro),ao.prototype.init=function(t){t=t||this._opts,this._opts=this.nY(t),this.setCenterAndRadius(this._opts.center,this._opts.radius)},ao.prototype.setCenter=function(t){this.setCenterAndRadius(t,this._opts.radius)},ao.prototype.setRadius=function(t){this.setCenterAndRadius(this._opts.center,t)},ao.prototype.getCenter=function(){var t,i=_.parseLngLatData(this._opts.center);return this.P$?(t=this._map.getView().ru().moveWithPos([i.KL,i.kT],this.zx),new _.LngLat(t[0],t[1])):i},ao.prototype.getPath=function(){var t;return this._opts.center&&this._opts.radius&&(t=Rh(this._opts.center,this._opts.radius))&&0<t.length?_.parseLngLatData(_.yn(t)):[]},ao.prototype.getRadius=function(){return parseFloat(this._opts.radius)},ao.prototype.setCenterAndRadius=function(t,i){this._opts.center=t,_.vB(i)&&0<=i&&(this._opts.radius=i),this.cE(),this.to()},ao.prototype.ZB=function(t){var i,n,s;this._map&&(this._needUpdate=!1,s=this._opts.center,i=this._opts.radius,s)&&_.vB(i)&&(n=this._map,(s=yh(Rh(s,i)))&&(this.ir=l.ms(s),this.aE=s,"d"===n.baseRender?this.X$(s):this.Q$(s,t)),this.BB(),this._map.setNeedUpdate(!0))},ao.prototype.moveWithPixel=function(t,i){var n,s;this._map&&(n=this._map,s=_.parseLngLatData(this._opts.center),s=this._map.getView().ru().moveWithPixel([s.KL,s.kT],[t,i],n.getZoom()),this.setCenter(s))},ao.prototype.moveWithPos=function(t,i){var n;this._map&&(n=_.parseLngLatData(this._opts.center),n=this._map.getView().ru().moveWithPos([n.KL,n.kT],[t,i]),this.setCenter(n))},ao.prototype.setOptions=function(t){var t=this.nY(t),i=!_.isEqual(this._opts.center,t.center)||!_.isEqual(this._opts.radius,t.radius);this._opts=t,this._checkMap(),i&&this.setCenterAndRadius(this._opts.center,this._opts.radius),this.to()},ao.prototype.O$=function(t,i,n){},ao.prototype.getBounds=function(){if(!this.ir){var t=this._opts.center,i=this._opts.radius;if(!t)return;if(!_.vB(i))return;var n=(t=_.parseLngLatData(t)).offset(-i,-i),t=t.offset(i,i);this.ir=new l(n,t)}if(i=this.ir,this.ir)return this.P$?(n=i.getSouthWest(),t=i.getNorthEast(),n=this._map.getView().ru().moveWithPos([n.KL,n.kT],this.zx),t=this._map.getView().ru().moveWithPos([t.KL,t.kT],this.zx),new l(n,t)):this.ir},ao.prototype.ab=function(t){return delete(t=_.extend({},t)).center,delete t.radius,delete t.map,delete t.path,t};var ro,ho,oo=ao;function ao(t){void 0===t&&(t={});var i=ro.call(this)||this;return i.className="Overlay.Circle",i._opts={fillColor:"#00D3FC",fillOpacity:.5,strokeColor:"#00B2D5",strokeWeight:2,strokeOpacity:.9,strokeStyle:"solid",draggable:!1,bubble:!1,strokeDasharray:[10,5],zIndex:50,extData:{},noSelect:!1,innerOverlay:!1,zooms:_.zoomRange,async:!1},i._opts=i.nY(t),i}function uo(t){var i=ho.call(this)||this;return i.className="Overlay.Circle",i.Tx(t),i}ho=Bt,_.Ei(uo,ho),uo.prototype.Tx=function(t){t&&(t=_.Bs(t)?_.ProjectionManager.getProjection("EPSG:3857").project(t.KL,t.kT):_.ProjectionManager.getProjection("EPSG:3857").project(t[0],t[1]),this.Sx=_.lcs.getLocalByCoord(t))},uo.prototype.setCenter=function(t){t&&(this._opts.center=_.parseLngLatData(t),this.ir=new l(this._opts.center,this._opts.center),this.cE(),this.to())},uo.prototype.destroy=function(){this.KB&&delete this.KB,this.Sb&&(this.Sb.destroy(),delete this.Sb),ho.prototype.destroy.call(this)},uo.prototype.reset=function(){this.KB&&delete this.KB,this.Sb&&this.Sb.reset()},uo.prototype.toGeometry=function(){var t;if(this._opts.center)return{type:"Point",coordinates:(t=_.parseLngLatData(this._opts.center))&&t.toJSON()}},uo.prototype.Ydt=function(n){return _.T8t(this,void 0,void 0,function(){var i;return _.x8t(this,function(t){switch(t.label){case 0:return[4,de.Ydt(n)];case 1:return i=t.y8t(),this.setCenter(i),[2]}})})},uo.prototype.XL=function(t){var i=_.parseLngLatData(t),t=(this.reset(),this.Tx(t),this.Sx.center),i=this._map.getView().ru().project(i.KL,i.kT);this.KB=[i[0]-t[0],i[1]-t[1]],_.Support.safari&&(this.Sb||(this.Sb=new _.e0),this.Sb.wb([i[0]-t[0],i[1]-t[1]]))},co=uo,_.Ei(lo,co),lo.prototype.init=function(t){t=t||this._opts,this._opts=this.nY(t),this.setCenter(this._opts.center)},lo.prototype.setRadius=function(t){this._opts.radius=t,this.to()},lo.prototype.ZB=function(){var t;this._map&&(this._needUpdate=!1,t=this._opts.center)&&this._map&&"d"!==this._map.baseRender&&(this.XL(t),this.BB())},lo.prototype.getCenter=function(){var t,i=_.parseLngLatData(this._opts.center);return this._map?(t=this._map.getView().ru().moveWithPos([i.KL,i.kT],this.zx),new _.LngLat(t[0],t[1])):i},lo.prototype.getRadius=function(){return this._opts.radius},lo.prototype.moveWithPixel=function(t,i){var n,s;this._map&&(n=this._map,s=_.parseLngLatData(this._opts.center),s=this._map.getView().ru().moveWithPixel([s.KL,s.kT],[t,i],n.getZoom()),this.setCenter(s))},lo.prototype.moveWithPos=function(t,i){var n;this._map&&(n=_.parseLngLatData(this._opts.center),n=this._map.getView().ru().moveWithPos([n.KL,n.kT],[t,i]),this.setCenter(n))},lo.prototype.setOptions=function(t){var t=this.nY(t),i=!_.isEqual(this._opts.center,t.center);this._opts=t,this._checkMap(),i&&this.setCenter(t.center),this.to()},lo.prototype.getOptions=function(){return _.extend({},this._opts)},lo.prototype.getBounds=function(){var t;if(!this.ir){var i=this._opts.center;if(!i)return;this.ir=new l(i,i)}if(i=this.ir)return this.P$?(t=i.getSouthWest(),i=i.getNorthEast(),t=this._map.getView().ru().moveWithPos([t.KL,t.kT],this.zx),i=this._map.getView().ru().moveWithPos([i.KL,i.kT],this.zx),new l(t,i)):this.ir},lo.prototype.Ib=function(){var t=(t=this._opts).radius+(t.strokeWeight||0);return Math.min(t,64)};var co,vo,fo=lo;function lo(t){var e=co.call(this,(t=void 0===t?{}:t).center||void 0)||this;return e.contains=function(t){return!!e._map&&(t=e._map.lngLatToContainer(t),e.containsWithPixel(t))},e.containsWithPixel=function(t){var i,n,s;return!!e._map&&!(!e._opts.center||(i=e.Ib(),n=_.parseLngLatData(e._opts.center),n=e._map.getView().ru().moveWithPos([n.KL,n.kT],e.zx),n=e._map.lngLatToContainer(n),Math.abs(n.x-t.x)>i)||Math.abs(n.y-t.y)>i)&&(t=t.toJSON(),n=n.toJSON(),s=Math.abs(t[0]-n[0]),t=Math.abs(t[1]-n[1]),s=Math.sqrt(s*s+t*t),t=e._map.getView().Pu||0,s/Math.cos(t)<i)},e.className="Overlay.CircleMarker",e._opts={radius:20,fillColor:"#00D3FC",fillOpacity:.5,strokeColor:"#00B2D5",strokeWeight:2,strokeOpacity:.9,strokeStyle:"solid",draggable:!1,bubble:!1,strokeDasharray:[10,5],zIndex:50,extData:{},noSelect:!1,innerOverlay:!1,zooms:_.zoomRange,async:!1},e._opts=e.nY(t),t&&t.center&&de._dt(t.center)&&e.Ydt(t.center),e._checkMap(),e}function po(){var u=null!==vo&&vo.apply(this,arguments)||this;return u.sC=0,u.W_=function(){if(_r.isWebGL&&u._map&&u.q$&&!u._opts.geodesic&&!u._needUpdate){var t=u._map,i=Math.min(_.Util.getOptimalZoom(t.getZoom()),20);if(u.EI!==i)if(i<18){u.EI=i;for(var n=_.ProjectionManager.getProjection("EPSG:3857").getResolution(Math.min(_.Util.getOptimalZoom(t.getZoom()),18)),s=[],e=0,r=u.q$;e<r.length;e++){for(var h=r[e],o=[],a=0;a<h.length;a+=1)h[a][2]>n*n*1&&o.push([h[a][0],h[a][1]]);s.push(o)}u.D_(s)}else u.EI=i,u.D_(u.q$)}},u}vo=Bt,_.Ei(po,vo),po.prototype.Tx=function(t){t&&(t=_.Bs(t)?_.ProjectionManager.getProjection("EPSG:3857").project(t.KL,t.kT):_.ProjectionManager.getProjection("EPSG:3857").project(t[0],t[1]),this.Sx=_.lcs.getLocalByCoord(t))},po.prototype.destroy=function(){this.Px&&(this.Px.destroy(),delete this.Px),vo.prototype.destroy.call(this)},po.prototype.toGeometry=function(){var t=this._opts.path;if(t)return _.ys(t)?{type:"LineString",coordinates:t}:_.Ox(t)?{type:"MultiLineString",coordinates:t}:void 0},po.prototype.U_=function(t){this.F_&&!this.E_&&(this.E_=t.createTexture(this.F_,{Zi:!0}),this.E_.bind(t.gl.CLAMP_TO_EDGE,t.gl.LINEAR,t.gl.LINEAR))},po.prototype.aC=function(t,i){this.rC||(i=function(t){for(var i=document.createElement("canvas"),n=(i.height=1,i.width=4096,i.getContext("2d")),s=n.createImageData(4096,1),e=0,r=0;r<4096;r++){for(var h=void 0;e<t.length;e++){if(e===t.length-1){h=t[e][1];break}if(!(4096*t[e+1][0]<r)){h=t[e][1];break}}var h=t[e][1],a=_.Util.color2RgbaArray(h);s.data[4*r]=255*a[0],s.data[4*r+1]=255*a[1],s.data[4*r+2]=255*a[2],s.data[4*r+3]=255*a[3]}return n.putImageData(s,0,0),i}(i.values),this.rC=t.createTexture(i,{Zi:!0}),i=t.gl,this.rC.bind(i.CLAMP_TO_EDGE,i.NEAREST,i.NEAREST_MIPMAP_NEAREST))},po.prototype.X$=function(t){for(var i=[],n=[],s=0,e=t;s<e.length;s++){for(var r=[],h=[],o=0,a=e[s];o<a.length;o++){var u=a[o],c=_.ProjectionManager.getProjection("EPSG:3857").project(u[0],u[1]);r.push([c[0],c[1]]),h.push(u)}i.push(r),n.push(h)}this.$x=n,this.q$=i},po.prototype.Q$=function(t){for(var i=[],n=[],s=0,e=t;s<e.length;s++){for(var r=[],h=[],o=0,a=e[s];o<a.length;o++){var u=a[o],c=_.ProjectionManager.getProjection("EPSG:3857").project(u[0],u[1]);r.push([c[0],c[1],0]),h.push(u)}this.P_(r),i.push(r),n.push(h)}this.$x=n,this.q$=i,this.cE()},po.prototype.D_=function(t,i){if(0!==t.length){this.Px?this.Px.reset():this.Px=new _.J_;for(var n=this.Sx.center,s=0,e=_.ProjectionManager.getProjection("EPSG:3857"),r=this.EI,h=e.getResolution(r),o=0,a=t;o<a.length;o++){for(var u=a[o],c=[],f=0,l=u.length;f<l;f+=1)c.push(u[f][0]-n[0],u[f][1]-n[1]);var d=this._opts;10<=this.EI&&(this._opts.showDir||"dashed"===this._opts.strokeStyle)?s+=this.Px.eD(c,{X_:1,lineJoin:d.lineJoin,lineCap:d.lineCap},Math.floor(2048*h)).distance:s+=this.Px.hb(c,{X_:1,lineJoin:d.lineJoin,lineCap:d.lineCap}).distance}this.sC=s,i&&this.Px.upload(i)}},po.prototype.P_=function(t){t[0][2]=1/0,t[t.length-1][2]=1/0;var i=_.ProjectionManager.getProjection("EPSG:3857").getResolution(16);!function t(i,n,s,e){for(var r=e,h=s-n>>1,o=s-n,a=s,u=i[n][0],c=i[n][1],f=i[s][0],l=i[s][1],d=n+1;d<s;d+=1){var v=function(t,i,n,s,e,r){var h,o=e-n,a=r-s;return 0==o&&0==a||(1<(h=((t-n)*o+(i-s)*a)/(o*o+a*a))?(n=e,s=r):0<h&&(n+=o*h,s+=a*h)),(o=t-n)*o+(a=i-s)*a}(i[d][0],i[d][1],u,c,f,l);r<v?(a=d,r=v):v===r&&(v=Math.abs(d-h))<o&&(a=d,o=v)}e<r&&(1<a-n&&t(i,n,a,e),i[a][2]=r,1<s-a)&&t(i,a,s,e)}(t,0,t.length-1,i*i)};var mo,yo={constructor:{time:0,highResTime:0},setPath:{time:0,highResTime:0}},bo=(mo=Xt=po,_.Ei(R,mo),R.prototype.getOptions=function(){return _.extend({},this._opts)},R.prototype.getPath=function(){if(this._opts&&this._opts.path)return _.parseLngLatData(_.yn(this._opts.path))},R.prototype.getStatus=function(){return this.Ndt},R.prototype.destroy=function(){this.E_&&(this.E_.destroy(),delete this.E_),mo.prototype.destroy.call(this)},R.prototype.getBounds=function(){var t;if(this.ir)t=this.ir;else{var i=this._opts.path;if(!i)return;if(!(i=Th(i)))return;(i=l.bS(i))&&(t=this.ir=i)}if(t)return this._map&&this.zx&&(0!==this.zx[0]||0!==this.zx[1])?(i=t.getSouthWest(),t=t.getNorthEast(),i=this._map.getView().ru().moveWithPos([i.KL,i.kT],this.zx),t=this._map.getView().ru().moveWithPos([t.KL,t.kT],this.zx),new l(i,t)):this.ir},R.prototype.setPath=function(t){var i;t&&(this.Ix(t),t=(new Date).getTime(),i=0,"performance"in window&&"function"==typeof performance.now&&(i=performance.now()),this.Ndt&&(this.Ndt.setPath={time:t,highResTime:i}),this.to())},R.prototype.moveWithPixel=function(t,i){if(this._map){for(var n=this._map,s=_.ProjectionManager.getProjection(n.getView().au()),e=[],r=0,h=this.$x;r<h.length;r++){for(var o=[],a=0,u=h[r];a<u.length;a++){var c=u[a];o.push(s.moveWithPixel(c,[t,i],n.getZoom()))}e.push(o)}this.setPath(e)}},R.prototype.moveWithPos=function(t,i){if(this._map){for(var n=this._map,s=_.ProjectionManager.getProjection(n.getView().au()),e=[],r=0,h=this.$x;r<h.length;r++){for(var o=[],a=0,u=h[r];a<u.length;a++){var c=u[a];o.push(s.moveWithPos(c,[t,i]))}e.push(o)}this.setPath(_.parseLngLatData(e))}},R.prototype.getLength=function(){var t=this._opts&&this._opts.path;return _.ys(t)?+Lh(t).toFixed(2):_.Ox(t)?+function(t){for(var i=0,n=0,s=t;n<s.length;n++)i+=Lh(s[n]);return i}(t).toFixed(2):0},R.prototype.rL=function(){return this.sC},R.prototype.ZB=function(t){this._map&&(this._needUpdate=!1,this.D_(this.q$,t))},R.prototype.setOptions=function(t){var t=this.nY(t),i=function(t,i,n){for(var s=0,e=n.length;s<e;s+=1){var r=n[s];if(t[r]!==i[r])return!0}return!1}(this._opts,t,["path","lineCap","lineJoin","geodesic"]);t.lineGradient!==this._opts.lineGradient&&this.rC&&(this.rC.destroy(),delete this.rC),this._opts=t,this._checkMap(),i&&this.setPath(this._opts.path),this.to()},R.prototype.init=function(t){var i,n=this,t=t||this._opts,t=this.nY(t);this._opts=t,this._opts.dirImg&&(this._opts.dirImg instanceof HTMLCanvasElement?this.F_=this._opts.dirImg:(i=this._opts.dirImg,this._map.z_.loadImage(this._opts.dirImg,{type:"dirImg",cb:function(t){t?n.F_=t.img:console.error("load dirImg error",i)}}))),this.setPath(this._opts.path),this._map&&(this.W_(),this._map.setNeedUpdate(!0))},R.prototype.contains=function(t){if(this.jx()&&(!this.ir||this.ir.southWest.lat===this.ir.northEast.lat||this.ir.southWest.lng===this.ir.northEast.lng||this.ir.contains(t)))for(var i=this._map.getView(),n=i.getStatus().pitch*Math.PI/180,t=_.parseLngLatData(t),s=i.ru().project(t.lng,t.lat),e=i.ru().getResolution(this._map.getZoom()),r=0,h=this.q$;r<h.length;r++){var o=h[r];if(_.hL.lr(s,o)*Math.cos(n)<this._opts.strokeWeight*e)return!0}return!1},R.prototype.jx=function(){return Boolean(this._opts&&this._opts.path&&0<this._opts.path.length)},R.prototype.Ix=function(t){var i=_.jsonLngLatData(t);this._opts.path=i,i=Th(t),_.Ox(i)?(this._opts.geodesic&&(i=_.map(i,Ih)),this.Tx(i[0][0]),this.ir=l.bS(i),this._map&&("d"===this._map.baseRender?this.X$(i):(this.Q$(i),this.BB()))):console.error("error Polyline path")},R.prototype.rD=function(t){var i=_.jsonLngLatData(t);this._opts.path=i,i=Th(t),_.Ox(i)?(this._opts.geodesic&&(i=_.map(i,Ih)),this.Tx(i[0][0]),this.ir=l.bS(i)):console.error("error Polyline path")},R);function R(t){void 0===t&&(t={});var i=mo.call(this)||this,t=(i.className="Overlay.Polyline",i._opts={cursor:"",strokeColor:"#00B2D5",strokeWeight:2,strokeOpacity:.5,strokeStyle:"solid",draggable:!1,bubble:!1,strokeDasharray:[10,5],isOutline:!1,geodesic:!1,showDir:!1,outlineColor:"#00B2D5",borderWeight:1,lineJoin:"miter",lineCap:"butt",extData:{},zIndex:50,dirColor:"white",dirImg:"",lineGradient:void 0,noSelect:!1,innerOverlay:!1,zooms:_.zoomRange,animate:!1,speed:100,dirImgGap:1},i.EI=-1,i._opts=i.nY(t),i._opts.path&&i.rD(i._opts.path),i._checkMap(),i.Ndt=yo,(new Date).getTime()),n=0;return"performance"in window&&"function"==typeof performance.now&&(n=performance.now()),i.Ndt.constructor={time:t,highResTime:n},i}go=Xt,_.Ei(Mo,go),Mo.prototype.getOptions=function(){return _.extend({},this._opts)};var go,hi=Mo;function Mo(){return null!==go&&go.apply(this,arguments)||this}wo=_.LngLat,_.Ei(Ao,wo),Ao.prototype.lL=function(){for(var t=[],i=0,n=this.controlPoints;i<n.length;i++){var s=n[i];t.push(s.toJSON())}return t.push(this.toJSON()),t},Ao.prototype.moveWithPos=function(t,i,n){for(var s=t.moveWithPos(this.toJSON(),[i,n]),e=[],r=0,h=this.controlPoints.length;r<h;r++){var o=this.controlPoints[r];e.push(t.moveWithPos(o.toJSON(),[i,n]))}return e.push(s),new Ao(e)},Ao.prototype.moveWithPixel=function(t,i,n,s){for(var e=t.moveWithPixel(this.toJSON(),[i,n],s),r=[],h=0,o=this.controlPoints.length;h<o;h++){var a=this.controlPoints[h];r.push(t.moveWithPixel(a.toJSON(),[i,n],s))}return r.push(e),new Ao(r)};var wo,xo=Ao;function Ao(t){var i=this;if(_.ys(t))for(var n=t.length,i=wo.call(this,t[n-1][0],t[n-1][1])||this,s=[],e=0,r=n-1;e<r;e+=1){var h=t[e][0],o=t[e][1];s.push(new _.LngLat(h,o))}else for(n=t.length,i=wo.call(this,t[n-2],t[n-1])||this,s=[],e=0,r=n-2;e<r;e+=2)h=t[e],o=t[e+1],s.push(new _.LngLat(h,o));return i.controlPoints=s,i}zo=hi,_.Ei(So,zo),So.prototype.init=function(t){var i,n=this,t=t||this._opts;this._opts=this.nY(t),this._opts.dirImg&&(this._opts.dirImg instanceof HTMLCanvasElement?this.F_=this._opts.dirImg:(i=this._opts.dirImg,this._map.z_.loadImage(this._opts.dirImg,{type:"dirImg",cb:function(t){t?n.F_=t.img:console.error("load dirImg error",i)}}))),this.setPath(this._opts.path),this._map&&(this.W_(),this._map.setNeedUpdate(!0))},So.prototype.setOptions=function(t){var t=this.nY(t),i=!_.isEqual(this._opts.path,t.path);this._opts=t,this._checkMap(),i&&this.Ix(this._opts.path),this.BB(),this.to()},So.prototype.ZB=function(t){this._map&&(this._needUpdate=!1,this.D_(this.q$,t))},So.prototype.getPath=function(){if(this._opts)return this._opts.path},So.prototype.setPath=function(t){t&&(this._opts.path=t,this.Ix(t))},So.prototype.getBounds=function(){var t;if(this.ir)t=this.ir;else{var i=this.$x;if(!i)return;if(!(i=Th(i)))return;(i=l.bS(i))&&(t=this.ir=i)}if(t)return this._map&&this.zx&&(0!==this.zx[0]||0!==this.zx[1])?(i=t.getSouthWest(),t=t.getNorthEast(),i=this._map.getView().ru().moveWithPos([i.KL,i.kT],this.zx),t=this._map.getView().ru().moveWithPos([t.KL,t.kT],this.zx),new l(i,t)):this.ir},So.prototype.moveWithPos=function(t,i){if(this._map){var n=this._map,s=_.ProjectionManager.getProjection(n.getView().au());if(n=this.getPath()){for(var e=[],r=0,h=n;r<h.length;r++){var o=h[r],o=(o=new xo(o)).moveWithPos(s,t,i);e.push(o.lL())}this.setPath(e)}}},So.prototype.moveWithPixel=function(t,i){if(this._map){var n=this._map,s=_.ProjectionManager.getProjection(n.getView().au()),e=this.getPath();if(e){for(var r=[],h=n.getZoom(),o=0,a=e;o<a.length;o++){var u=a[o],u=(u=new xo(u)).moveWithPixel(s,t,i,h);r.push(u.lL())}this.setPath(r)}}},So.prototype.contains=function(t){if(this.jx()&&(!this.ir||this.ir.contains(t)))for(var i=this._map.getView(),n=i.getStatus().pitch*Math.PI/180,t=_.parseLngLatData(t),s=i.ru().project(t.lng,t.lat),e=i.ru().getResolution(this._map.getZoom()),r=0,h=this.q$;r<h.length;r++){var o=h[r];if(_.hL.lr(s,o)*Math.cos(n)<this._opts.strokeWeight*e)return!0}return!1},So.prototype.Ix=function(t){var i=[];if(t)for(var n=0,s=t;n<s.length;n++){var e=s[n];i.push(new xo(e))}t=Th(this.yb(i)),this.Tx(t[0][0]),this.ir=l.bS(t),this._map&&("d"===this._map.baseRender?this.X$(t):(this.Q$(t),this.BB()))},So.prototype.jx=function(){return Boolean(this._opts&&this._opts.path&&0<this._opts.path.length)},So.prototype.yb=function(t){var i;return this._map?(i=_.ProjectionManager.getProjection("EPSG:3857").getResolution(this._map.getZoom()),_.bb.xb(t,i)):[]};var zo,Co=So;function So(t){void 0===t&&(t={});var i=zo.call(this)||this;return i.className="Overlay.BezierCurve",i.bo=3,i.W_=function(){},i._opts={cursor:"",strokeColor:"#00D3FC",strokeWeight:2,strokeOpacity:.5,strokeStyle:"solid",draggable:!1,bubble:!1,strokeDasharray:[10,5],isOutline:!1,geodesic:!1,showDir:!1,outlineColor:"#00B2D5",borderWeight:1,lineJoin:"miter",lineCap:"butt",extData:{},zIndex:50,dirColor:"white",dirImg:"",lineGradient:void 0,noSelect:!1,innerOverlay:!1,zooms:_.zoomRange},i.EI=-1,i._opts=i.nY(t),i._checkMap(),i}var To,Ro={high:{fillColor:"rgb(252, 249, 242)",strokeColor:"rgb(230,142,0)"},unHigh:{fillColor:"rgb(252, 249, 242)",strokeColor:"rgb(171,171,171)"}},Eo=(To=s,_.Ei(E,To),E.prototype.Do=function(t){return t&&(this.Jh=t).HF(this),t},E.prototype.onAdd=function(){var t;this.$F=new is({zIndex:this.Qh,visible:this.il,TF:!0}),null!=(t=this.map)&&t.addLayer(this.$F)},E.prototype.v$=function(){var t;null!=(t=this.map)&&t.removeLayer(this.$F)},E.prototype.destroy=function(){To.prototype.destroy.call(this),this.$F.destroy(),this.$F&&this.$F.destroy&&(this.$F.destroy(),delete this.$F)},E.prototype.yD=function(){return{show:this.xD}},E.prototype.mD=function(t){this.xD=t},E.prototype.cD=function(){var n=this;if(this.dD)return!1;this.dD=!0,this._map.on("moveend",function(){var t=n._map.getZoom(),i=n.VR;n.VR.showId,i&&i.centerId&&i.indoor&&(!n.ZT(i.indoor)||t<n.xt[0]?(n.e$&&(n.e$.hide(),n.xD=!1),n.nD()):n.e$&&n.VR.visible&&(n.mL||n.e$.show(),n.xD=!0))})},E.prototype.uD=function(){for(var t=this.VR,i=t.indoor,n=t.centerId,s=Object.keys(i),e=Ro,r=0;r<s.length;r++){var h=s[r];if(i[h]&&i[h].outline)for(var o=i[h].outline,a=0;a<o.length;a++){var u=o[a],c=u.getOptions();c.strokeColor=(h===n?e.high:e.unHigh).strokeColor,u.setOptions(c)}}},E.prototype.oZ=function(){for(var t=this.VR,i=t.indoor,n=(t.centerId,Object.keys(i)),s=Ro,e=0;e<n.length;e++){var r=n[e];if(i[r]&&i[r].outline)for(var h=i[r].outline,o=0;o<h.length;o++){var a=h[o],u=a.getOptions();u.strokeColor=s.unHigh.strokeColor,a.setOptions(u)}}},E.prototype.BT=function(){var t=this;setTimeout(function(){t._map&&t._map.emit("indoor_create")},500)},E.prototype.bL=function(t){this.VR.opacity=t,this.gL()},E.prototype.wL=function(t){this.VR.zIndex=t,this.gL()},E.prototype.ZI=function(){return this.VR},E.prototype.KI=function(t){this.VR=t},E.prototype.getState=function(){return{zooms:[17,_.zoomRange[1]],visible:this.il,opacity:this.tl,layer:this,rejectMapMask:this._rejectMapMask,depthTest:this.AF,ce:this.IF}},E.prototype.getSourceConfig=function(){return{id:this._id,type:"indoor",zooms:[17,_.zoomRange[1]],url:""}},E.prototype.co=function(){return this._id},E.prototype.getMap=function(){return this._map},E.prototype.n$=function(t,i){this.VR.floorInfo||(this.VR.floorInfo={}),this.VR.floorInfo[t]=i},E.prototype.emit=function(t,i){return To.prototype.emit.call(this,t,i),this},E.prototype.showId=function(t){this.VR.showId=t},E.prototype.setBar=function(t){this.e$=t},E.prototype.setBarOpt=function(t){this.VR.defaultBarFloor=t},E.prototype._hideLayer=function(t){this.VR.visible=t,this.DT(t),this._hideBar(!t),t?this.$F.show():this.$F.hide(),this.gL()},E.prototype._hideBar=function(t){this.mL=t,this.VR.hideFloorBar=t,this.e$&&t?this.e$.hide():this.e$&&this.e$.show()},E.prototype._showLabels=function(t){this.VR.showLabels=t;var i=this._map&&this._map.showLabel;this.VR.labelsLayer&&t&&i?this.VR.labelsLayer.show():this.VR.labelsLayer&&this.VR.labelsLayer.hide()},E.prototype.setShowId=function(t){this.VR.hasId=t},E.prototype.update=function(){this.gL()},E.prototype._getSelectedBuildingId=function(){return this.VR.centerId},E.prototype._getSelectedBuilding=function(){return this.VR.building},E.prototype.setRenderData=function(t){this.VR=_.assign(this.VR,t)},E.prototype.getIntersectPoly=function(t){var t=t.getBounds(),n=this._map&&this._map.getBounds();return!(!t||!n)&&n.intersects(t)},E.prototype.getIntersect=function(t){if(!t)return!1;for(var i=!1,n=this._map&&this._map.getBounds(),s=0;s<t.length;s++){var e=t[s],e=new AMap.LngLat(e[0],e[1]);if(i=n.contains(e))return!0}return i},E.prototype.getRingInRing=function(t){var i;return!!t&&(i=this._map&&this._map.getBounds(),t=new AMap.Polygon({path:t}),_.GeometryUtil.isRingInRing(i,t))},E.prototype.YR=function(t,s){var i,e=this;try{this._map&&this._map.gn&&((i=new XMLHttpRequest).onreadystatechange=function(){4===i.readyState&&200===i.status&&e._map.gn.JB(i.response,function(t,i){var n;t?console.log(t):(n=(t=Object.keys(i))[0]?i[t[0]].building:void 0)&&n.properties&&n.properties.outside_outline&&(n=i[t[0]].building.properties.outside_outline,i=AMap.Bounds.xS(n))&&e._map.setBounds(i),s&&s()})},i.open("GET",t,!0),i.responseType="arraybuffer",i.send())}catch(t){}},E.prototype.DT=function(t){for(var i=this.VR.indoor,n=Object.keys(i),s=0;s<n.length;s++){var e=i[n[s]];if(e.polygons)for(var r=0;r<e.polygons.length;r++){var h=e.polygons[r];t?h.show():h.hide()}if(e.markers)for(var o=0;o<e.markers.length;o++){var a=e.markers[o];t?a.show():a.hide()}}},E.prototype.ZT=function(t){for(var i=Object.keys(t),n=0;n<i.length;n++){var s=i[n];if(this._map&&t[s].outline&&(s=t[s].outline,s=this.getIntersectPoly(s[0])))return s}return!1},E.prototype.gL=function(){},E.prototype.nD=function(){for(var t=this.VR.indoor,i=Object.keys(t),n=0;n<i.length;n++){var s=i[n],e=t[s];e.polygons&&this.$F.remove(e.polygons),e&&e.markers&&0<e.markers.length&&this.VR.labelsLayer&&this.VR.labelsLayer.remove(e.markers),delete t[s]}},E);function E(t){var i=To.call(this)||this;return i.CLASS_NAME="AMap.IndoorLayer",t=t||{},i._id="indoor",i.il=!0,i.Qh=t.zIndex||5,i.tl=t.opacity||1,i.mL=t.hideFloorBar||!1,i.xL=t.cursor||"auto",i.xt=[17,_.zoomRange[1]],i.xD=!1,i.dD=!1,0===t.opacity&&(i.tl=0),i.VR={opacity:i.tl,zIndex:i.Qh,visible:i.il,cursor:i.xL,centerId:null,centerFloor:null,indoor:{},hideFloorBar:i.mL,showLabels:!0,reRender:!1,floorInfo:{},indoorState:{},centerBuilding:{}},t&&t.map&&(i._map=t.map,i.cD()),i._config=AMap.getConfig(),i.BT(),i}Po=Eo,_.Ei(Bo,Po),Bo.prototype.showIndoorMap=function(t,i,n){var s,e,i=i||1;t&&(this.pL=t,Po.prototype.showId.call(this,t),Po.prototype.n$.call(this,t,i),this.pL=t,e=this._config.server+"/v3/indoor/indoormaps?",(s=[]).push("poiid="+t),s.push("floor="+i),s.push("version=0"),s.push("s=rsv3"),s.push("from=indoorH5Map"),s.push("servicetype=unify"),s.push("key="+this._config.key),this._config.jscode?s.push("jscode="+this._config.jscode):this._config.gaodeserver&&(e=this._config.gaodeserver+"/v3/indoor/indoormaps?"),t=e+s.join("&"),Po.prototype.YR.call(this,t))},Bo.prototype.showFloor=function(t,i){this.pL&&this.showIndoorMap(this.pL,t)},Bo.prototype.show=function(){this._hideLayer(!0)},Bo.prototype.hide=function(){this._hideLayer(!1)},Bo.prototype.getMap=function(){return this._map},Bo.prototype.setMap=function(t){var i=(this._map=t).getStatus().animateEnable;Po.prototype.setRenderData.call(this,{animateState:i}),t.setStatus({animateEnable:!1}),Po.prototype.setMap.call(this,t),Po.prototype.cD.call(this)},Bo.prototype.setzIndex=function(t){Po.prototype.wL.call(this,t)},Bo.prototype.showFloorBar=function(){this._hideBar(!1)},Bo.prototype.hideFloorBar=function(){this._hideBar(!0)},Bo.prototype.setOpacity=function(t){Po.prototype.bL.call(this,t)},Bo.prototype.getOpacity=function(){return Po.prototype.getOpacity.call(this)},Bo.prototype.showLabels=function(){this._showLabels(!0)},Bo.prototype.hideLabels=function(){this._showLabels(!1)},Bo.prototype.getSelectedBuildingId=function(){return Po.prototype._getSelectedBuildingId.call(this)},Bo.prototype.getSelectedBuilding=function(){return Po.prototype._getSelectedBuilding.call(this)};var Po,jo=Bo;function Bo(t){var i=Po.call(this,t)||this;return i.CLASS_NAME="AMap.IndoorMap",i._config=AMap.getConfig(),i.pL="",t&&t.map&&(i._map=t.map,t=t.map.getStatus().animateEnable,Po.prototype.setRenderData.call(i,{animateState:t})),i}function Fo(t,i,n){this.x=i,this.y=n,this.z=t,this.key=t+","+i+","+n}var Wo;function Go(){var t=null!==Wo&&Wo.apply(this,arguments)||this;return t.CLASS_NAME="AMap.DistrictLayer",t._E=AMap.getConfig().protocol+"://mvt.amap.com/getDistrictInfo",t}Wo=v,_.Ei(Go,Wo),Go.prototype.getLayerConfig=function(){var t=Wo.prototype.getLayerConfig.call(this);return t.mapNumber="GS(2019)756",t},Go.prototype.getSourceConfig=function(){return{id:this._id,tileUrl:this._tileUrl||"",type:"districtVectorTile",tileSize:this.Xa||256,zooms:this.xt,dataZooms:this.Qs||[3,16],projection:this.hl||"EPS3857",SOC:this.SOC}},Go.prototype.getLayerOptions=function(){return{zIndex:this.Qh,visible:this.il,zooms:this.xt,opacity:this.tl,adcode:this._adcode,styles:this.Ze,layer:this,rejectMapMask:this._rejectMapMask,depthTest:this.AF}},Go.prototype.getState=function(){return _.Ln({},this.getLayerOptions())},Go.prototype.getDistrictByContainerPos=function(t){if(i=this.map){var n,t=i.containerToLngLat(t),s=i.getProjection().project(t.lng,t.lat),e=i.getView().getStatus().optimalZoom,i=i.getTileCoordByLngLat(t,this.Xa||256,e-1);if(!(e=(t=this.getSource().getTileCache()).getTile(i))&&i.z<12&&(n=Math.pow(2,i.z)/((this.Xa||256)/256),e=t.getTile(new Fo(i.z,i.x+n,i.y))||t.getTile(new Fo(i.z,i.x-n,i.y))),e&&e.localCoord&&e.data){var r=[s[0]-e.localCoord.center[0],s[1]-e.localCoord.center[1]],h=e.data;if(h.polygons)for(var o=0,a=h.polygons.length;o<a;o+=1){var u=h.polygons[o];if(3<u.path.length&&3===u.properties.feature_type_){for(var c=[],f=0,l=u.path.length;f<l;f+=2)c.push([u.path[f],u.path[f+1]]);if(AMap.GeometryUtil.pointInRing(r,[[c]]))return u.properties}}}}},Go.prototype.co=function(){return this._id},Go.prototype.destroy=function(){this.Jh&&this.Jh.destroy&&(this.Jh.destroy(),delete this.Jh)},Go.prototype.reload=function(){var t;this.map&&((t=this.getSource()).setTileUrl(this._tileUrl),t.reload(),this.map.setNeedUpdate(!0))},Go.prototype.yE=function(){var n=this;AMap.xE||AMap.bE||(AMap.bE="loading",AMap.Http.Ajax(this._E,{},function(t,i){i&&i.data&&(i=JSON.parse(i.data),AMap.xE||(AMap.xE=i,n.wE&&(i=n.wE,n.setFitViewByAdcode(i.CE,i.zE,i.avoid))))}))},No=Go,_.Ei(Uo,No),Uo.prototype.setSOC=function(t){this.SOC=t,this._tileUrl=this.Ml.replace("[SOC]",this.SOC),this.reload()},Uo.prototype.setDistricts=function(t){this.setAdcode(t)},Uo.prototype.getDistricts=function(){return this._adcode},Uo.prototype.setStyles=function(t){this.Ze=_.Util.baseAssign(_.Util.baseAssign({},this.tP.styles),t),this.map&&((t=this.getRender())&&t.clearStyleCache(),this.map.setNeedUpdate(!0))},Uo.prototype.getStyle=function(){return this.Ze},Uo.prototype.setAdcode=function(t){t instanceof Array||(t=[t]);for(var i,n={},s=0;s<t.length;s+=1)n[t[s]]=1;this._adcode=t=n,null!=(i=this.map)&&i.setNeedUpdate(!0)},Uo.prototype.setFitViewByAdcode=function(t,i,n){var s,e;if(void 0===i&&(i=!1),t instanceof Array||(t=[t]),this.RE||(this.RE=window.AE),AMap.xE){this.RE=AMap.xE;for(var r=0;r<t.length;r+=1){var h=this.RE[t[r]],h=new l(_.Pt(h[0],h[1]));e?e.union(h):e=h}this.map&&null!=(s=this.map)&&s.setBounds(e,i,n)}else this.wE={CE:t,zE:i,avoid:n}},Uo.prototype.on=function(s,t,i,n){var e=this,r=(void 0===n&&(n=!1),this.getEvents()),h=!!r[s];return No.prototype.on.call(this,s,t,i,n),this.map?h||("click"!==s&&"mousemove"!==s||null!=(h=this.map)&&h.on(s,function(t){if(!r[s])return e;t.type=s,t.target=e;var i=t.pixel,i=e.getDistrictByContainerPos(i),i={preProps:e.IE,props:i,origin:t};e.emit(s,i)}),/(mouseenter|mouseleave|mouseover|mouseout)/.test(s)&&(null!=(h=this.map)&&h.on("mouseleave",function(t){if("mouseleave"===s||"mouseout"===s){if(!r[s])return e;t.type=s,t={preProps:(t.target=e).IE,props:void 0,origin:t},e.emit(s,t),e.IE=void 0}}),null!=(h=this.map))&&h.on("mousemove",function(t){if(!r[s])return e;var i,n=t.pixel;(n=e.getDistrictByContainerPos(n))?e.IE&&e.IE.adcode===n.adcode&&e.IE.SOC===n.SOC||(t.type=s,i={preProps:(t.target=e).IE,props:n,origin:t},e.emit("mouseleave",i),e.emit("mouseout",i),e.emit("mouseenter",i),e.emit("mouseover",i),e.IE=n):!e.IE||"mouseout"!==s&&"mouseleave"!==s||(t.type=s,i={preProps:(t.target=e).IE,props:n,origin:t},e.emit("mouseleave",i),e.emit("mouseout",i),e.IE=n)})):(h={fn:t,context:i,once:n},this.LE[s]?this.LE[s].push(h):this.LE[s]=[h]),this},Uo.prototype.onAdd=function(){if(No.prototype.onAdd.call(this),this.LE)for(var t in this.LE)if(this.LE.hasOwnProperty(t))for(var i=this.LE[t],n=0;n<i.length;n++)this.on(t,i[n].fn,i[n].context)};var No,_o=Uo;function Uo(t){var i=No.call(this,t)||this;return i.LE={},i.CX="2"===t.dataVersion?"2":"",i.tP={id:"DistrictLayer_"+_.Util.uuid(),tileUrl:AMap.getConfig().protocol+"://mvt.amap.com/district/[SOC]/[z]/[x]/[y]/4096?\\nkey="+AMap.getConfig().key+"&version="+i.CX,zooms:_.zoomRange,dataZooms:[1,18],opacity:1,visible:!0,depth:0,zIndex:80,styles:{"stroke-width":.5,"nation-stroke":[.35,.35,.35,1],"coastline-stroke":[.18,.63,.94,1],"province-stroke":[.5,.5,.5,1],"city-stroke":[.7,.7,.7,1],"county-stroke":[.85,.85,.85,1],fill:[1,1,1,1],dash:void 0,zIndex:0},SOC:"CHN"},i.SOC=t.SOC||i.tP.SOC,i._id=i.tP.id,t.adcode&&i.setAdcode(t.adcode),i._depth=t.depth||i.tP.depth,i.Ze=_.Util.baseAssign(_.Util.baseAssign({},i.tP.styles),t.styles||{}),i.Ml=i.tP.tileUrl,i._tileUrl=i.tP.tileUrl.replace("[SOC]",i.SOC),i.xt=t.zooms||i.tP.zooms,i.tl=(void 0===t.opacity?i.tP:t).opacity,i.il=(void 0===t.visible?i.tP:t).visible,i.Qh=(void 0===t.zIndex?i.tP:t).zIndex,i.Qs=i.tP.dataZooms,i.CLASS_NAME="AMap.DistrictLayer",i}Yo=_o,_.Ei(Zo,Yo);var Yo,Ut=Zo;function Zo(t){var i=this,n={id:"WorldLayer_"+_.Util.uuid(),zIndex:81,SOC:"WLD"};return(i=Yo.call(this,t)||this)._id=n.id,i.SOC=t.SOC||n.SOC,i.Qh=(void 0===t.zIndex?n:t).zIndex,i._tileUrl=i.Ml.replace("[SOC]",i.SOC),i.CLASS_NAME="AMap.DistrictLayer.World",i}Xo=_o,_.Ei(Jo,Xo);var Xo,Vt=Jo;function Jo(t){var i=this,n={id:"CountryLayer_"+_.Util.uuid(),depth:1,zIndex:82,SOC:"CHN"};return 0===(t=t||n).depth&&(t.styles||(t.styles={}),t.styles["stroke-width"]=0),(i=Xo.call(this,t)||this)._id=n.id,i._depth=void 0===t.depth?n.depth:+t.depth,i.SOC=t.SOC||n.SOC,i.Qh=(void 0===t.zIndex?n:t).zIndex,"CHN"===i.SOC&&1<i._depth&&(i.SOC="CHN2"),i._tileUrl=i.Ml.replace("[SOC]",i.SOC),i.CLASS_NAME="AMap.DistrictLayer.Country",i}Ho=_o,_.Ei(Vo,Ho);var Ho,Gt=Vo;function Vo(t){var i=this,n={id:"ProvinceLayer_"+_.Util.uuid(),depth:1,zIndex:83,SOC:"CHN5"};return(i=Ho.call(this,t)||this)._id=n.id,i._depth=void 0===t.depth?n.depth:+t.depth,i.SOC=t.SOC||n.SOC,i.Qh=(void 0===t.zIndex?n:t).zIndex,0===i._depth&&(i.SOC="CHN4"),1===i._depth&&(i.SOC="CHN5"),2===i._depth&&(i.SOC="CHN3"),i._tileUrl=i.Ml.replace("[SOC]",i.SOC),i.CLASS_NAME="AMap.DistrictLayer.Province",i.onCreated(),i}_o.World=Ut,_o.Country=Vt,_o.Province=Gt,qo=ui,_.Ei(Qo,qo),Qo.prototype._l=function(){this.kl.TileMatrixSet=this.kl.TileMatrixSet||"EPSG:3857",this.kl.Request="GetTile",this.kl.Service="WMTS",this.kl.Format=this.kl.Format||"image/png",this._tileUrl=this.Ml+"?"+_.Util.join(this.kl,"&"),this.map&&this.map.setNeedUpdate(!0)},Qo.prototype.getSourceConfig=function(){return{id:this._id||"tile",tileUrl:this._tileUrl||"",type:"markLayer",tileSize:this.Xa||256,zooms:this.xt,dataZooms:this.Qs||[7,17],projection:this.hl||"EPS3857"}};var qo,ia,na,sa,Ko=Qo;function Qo(){var o=this,t={id:"mark_"+_.Util.uuid(),cacheSize:1,opacity:1,tileUrl:"",visible:!0,zIndex:1e3,detectRetina:!1,dataZooms:[2,30],TF:!0};return(o=qo.call(this,t)||this)._opts=t,o.CLASS_NAME="AMap.MarkLayer",o.bl=function(t,i,n,s,e){console.log("_createTile");var r,h=document.createElement("img");"w"===(null==(r=o.map)?void 0:r.baseRender)&&(h.crossOrigin="anonymous"),h.onload=function(){s(h)},h.onerror=function(){e(h)},h.src=o._tileUrl+"&TileMatrix="+n+"&TileRow="+i+"&TileCol="+t},o}function $o(t,i){var s=W(t=Array.isArray(t)?t:[t]);0===s.length?i():(j.add(s,i),F(ia+"/mapsplugin?v="+na+"&cls="+s.join()+"&key="+sa,function(){for(var t=0,i=s;t<i.length;t++){var n=i[t];j.finish(n)}}))}function ta(){return ra}ti=config,ia=(ti=void 0===ti?[]:ti)[16]+"://"+ti[17]||"",na=ti[4],sa=ti[0],ti[18]||console.log("地图 JS API 将于2023年1月1日起，禁止非Web端key的调用权限。请您提前确保已正确使用 Web 端 key 进行服务访问，避免对您的服务产生不必要的影响。"),_.Module.module=function(t,i){var s=W(t=Array.isArray(t)?t:[t]);0===s.length?i&&i():(j.add(s,i),F(ia+"/mapsplugin?v="+na+"&cls="+s.join()+"&key="+sa,function(){for(var t=0,i=s;t<i.length;t++){var n=i[t];j.finish(n)}}))},N(\'.amap-custom{top:0;left:0;position:absolute}.amap-container img{max-width:none!important;max-height:none!important}.amap-container{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAACC2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS40LjAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyI+CiAgICAgICAgIDx0aWZmOlJlc29sdXRpb25Vbml0PjI8L3RpZmY6UmVzb2x1dGlvblVuaXQ+CiAgICAgICAgIDx0aWZmOkNvbXByZXNzaW9uPjE8L3RpZmY6Q29tcHJlc3Npb24+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlBob3RvbWV0cmljSW50ZXJwcmV0YXRpb24+MjwvdGlmZjpQaG90b21ldHJpY0ludGVycHJldGF0aW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KD0UqkwAAAf1JREFUeAHtmtGpAkEQBE9TMAi/zMb8MzCGU/97Ye8QunDrfQ7qNFUMS8Pbtom/fd8fEx/b/FymdIDL85p/wmmLgEJa5Ad7FTIA0xorpEV+sFchAzCtsUJa5Ad7FTIA0xorpEV+sPcyW1oG33f8WwL3qZ+blebnMs4DXGzqGWFv6hvSYx83KyRi6Q0V0mMfNyskYukNFdJjHzcrJGLpDRXSYx8329QjltrQpp7QH2jWv/5fA5t6EtKc+YY06YfdCglQmiOFNOmH3QoJUJojhTTph90KCVCaI4U06YfdNvUApTiyqSf4NvVEZdGZbwhMvEIUAiMAi+OFKARGABbHC1EIjAAsjk2dJcSmnnzY1BOVRWc+6jDxClEIjAAsjheiEBgBWBwvRCEwArA4/9LUbx+uLxjbM3Fs6omaTT1RWXTmow4TrxCFwAjA4nghCoERgMXxQhQCIwCL8y9NHYb1dBybekJnU09UFp35qMPEK0QhMAKwOF6IQmAEYHG8EIXACMDi2NRZQmzqyYdNPVFZdOajDhOvEIXACMDieCEKgRGAxfFCFAIjAItjU2cJsaknHzb1RGXRmY86TLxCFAIjAIvjhSgERgAWxwtRCIwALI5NnSXEpp582NQTlUVnPuow8QpRCIwALI4XohAYAVgcL0QhMAKwON+m/oRlWjrOG2SeYNIaKe7fAAAAAElFTkSuQmCC);background-color:#f1f1f1;touch-action:none;position:relative;overflow:hidden;-ms-touch-action:none}.amap-drags,.amap-layers{width:100%;height:100%;position:absolute;overflow:hidden;transform:translateZ(0)}.amap-layers canvas{-webkit-touch-callout:none;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.amap-layers .amap-layer-tile{transform:translateZ(0)}.amap-layers .amap-layer-tile,.amap-layers .amap-layer-tile img{position:absolute;top:0;left:0;user-select:none;-webkit-user-select:none}.amap-layers .amap-layer-image{position:absolute;top:0;left:0;transform:translateZ(0)}.amap-layers .amap-layer-image img{position:absolute;top:0;left:0}.amap-layer img{pointer-events:none;display:block}.amap-layers .amap-layer-overlay{position:absolute;top:0;left:0;transform:translateZ(0)}.amap-e,.amap-maps{width:100%;height:100%;outline:none}.amap-maps{z-index:0}.amap-e,.amap-layers,.amap-maps,.amap-tile-container{position:absolute;left:0;top:0;overflow:hidden}.amap-context,.amap-marker,.amap-markers,.amap-overlays{position:absolute;left:0;top:0}.amap-layers{z-index:0}.amap-overlays{z-index:110;cursor:default}.amap-markers{z-index:120}.amap-controls{z-index:150}.amap-copyright{display:block!important;left:85px;height:16px;bottom:1.8px;line-height:1.5;padding-bottom:2px;font-size:11px;font-family:Arial,sans-serif}.amap-copyright,.amap-logo{position:absolute;z-index:160;user-select:none;-webkit-user-select:none}.amap-logo{bottom:1.5px;left:4px;height:20px}.amap-logo img{width:73px!important;height:20px!important;border:none;vertical-align:baseline!important;user-select:none;-webkit-user-select:none}.amap-icon{position:relative;z-index:1}.amap-icon img{position:absolute;z-index:-1}.amap-marker-label{position:absolute;z-index:2;border:1px solid #00f;background-color:#fff;white-space:nowrap;cursor:default;padding:3px;font-size:12px;line-height:14px}.amap-info{left:0;width:fit-content;width:-webkit-fit-content;width:-moz-max-content}.amap-info,.amap-menu{position:absolute;z-index:140}.amap-info-close{position:absolute;right:5px;top:5px;color:#c3c3c3;text-decoration:none;font:700 16px/14px Tahoma,Verdana,sans-serif;width:14px;height:14px;cursor:pointer}.amap-info-outer,.amap-menu-outer{box-shadow:0 1px 2px rgba(0,0,0,.1);background:none repeat scroll 0 0 #fff;border-radius:2px;padding:1px;text-align:left}.amap-info-contentContainer:hover .amap-info-outer,.amap-menu-outer:hover{box-shadow:0 1px 2px rgba(0,0,0,.3)}.amap-info-content{position:relative;background:#fff;padding:10px 18px 10px 10px;line-height:1.4;overflow:auto}.amap-marker-content{position:relative}.amap-info-sharp-old{overflow:hidden;position:absolute;background-image:url(https://webapi.amap.com/images/arrows.png)}.bottom-center .amap-info-sharp-old{height:12px;width:20px;background-position:center 12px;top:100%;left:50%;margin:-9px auto 0 -10px}.bottom-left .amap-info-sharp-old{height:12px;width:13px;background-position:-16px -46px;top:100%;margin-top:-9px}.bottom-right .amap-info-sharp-old{height:12px;width:13px;top:-1px;background-position:-56px -46px;left:100%;margin-left:-13px;top:100%;margin-top:-9px}.middle-left .amap-info-sharp-old{height:20px;width:12px;background-position:0;top:50%;margin-top:-10px;margin-left:-11px}.center .amap-info-sharp-old{display:none}.middle-right .amap-info-sharp-old{height:20px;margin-right:0;width:12px;background-position:100%;left:100%;margin-left:-9px;top:50%;margin-top:-10px}.top-center .amap-info-sharp-old{height:12px;width:20px;background-position:top;top:0;left:50%;margin:-3px auto 0 -10px}.top-left .amap-info-sharp-old{height:12px;width:13px;background-position:-16px -3px;top:0;margin-top:-3px}.top-right .amap-info-sharp-old{height:12px;width:13px;background-position:-56px -3px;left:100%;margin-left:-13px;top:0;margin-top:-3px}.amap-info-sharp{position:absolute}.bottom-center .amap-info-sharp{bottom:0;left:50%;border-top:8px solid #fff}.bottom-center .amap-info-sharp,.bottom-center .amap-info-sharp:after{margin-left:-8px;border-left:8px solid transparent;border-right:8px solid transparent}.bottom-center .amap-info-sharp:after{position:absolute;content:"";margin-top:-7px;border-top:8px solid rgba(0,0,0,.3);filter:blur(2px);z-index:-1}.amap-info-contentContainer:hover.bottom-center .amap-info-sharp:after{border-top:8px solid rgba(0,0,0,.5)}.bottom-left .amap-info-sharp{border-color:transparent #fff;border-style:solid;border-width:0 0 10px 10px}.bottom-left .amap-info-sharp:after{position:absolute;content:"";margin-left:-10px;border-color:transparent rgba(0,0,0,.3);border-style:solid;border-width:0 0 10px 10px;filter:blur(1px);z-index:-1}.amap-info-contentContainer:hover.bottom-left .amap-info-sharp:after{border-color:transparent rgba(0,0,0,.5)}.bottom-left .amap-info-content{border-radius:2px 2px 2px 0}.bottom-right .amap-info-sharp{right:0;border-top:10px solid #fff;border-left:10px solid transparent}.bottom-right .amap-info-sharp:after{position:absolute;margin-top:-9px;margin-left:-10px;content:"";border-top:10px solid rgba(0,0,0,.3);border-left:10px solid transparent;filter:blur(1px);z-index:-1}.amap-info-contentContainer:hover.bottom-right .amap-info-sharp:after{border-top:10px solid rgba(0,0,0,.5)}.bottom-right .amap-info-content{border-radius:2px 2px 0 2px}.top-center .amap-info-sharp{top:0;left:50%;border-bottom:8px solid #fff}.top-center .amap-info-sharp,.top-center .amap-info-sharp:after{margin-left:-8px;border-left:8px solid transparent;border-right:8px solid transparent}.top-center .amap-info-sharp:after{position:absolute;content:"";margin-top:0;border-bottom:8px solid rgba(0,0,0,.3);filter:blur(1px);z-index:-1}.top-left .amap-info-sharp{left:0;top:0;border-bottom:10px solid #fff;border-right:10px solid transparent}.top-left .amap-info-sharp:after{position:absolute;content:"";margin-top:0;margin-left:0;border-bottom:10px solid rgba(0,0,0,.3);border-right:10px solid transparent;filter:blur(1px);z-index:-1}.top-right .amap-info-sharp{right:0;top:0;border-bottom:10px solid #fff;border-left:10px solid transparent}.top-right .amap-info-sharp:after{position:absolute;content:"";margin-top:0;margin-left:-10px;border-bottom:10px solid rgba(0,0,0,.3);border-left:10px solid transparent;filter:blur(1px);z-index:-1}.middle-right .amap-info-sharp{right:0;top:50%;border-left:8px solid #fff}.middle-right .amap-info-sharp,.middle-right .amap-info-sharp:after{margin-top:-8px;border-top:8px solid transparent;border-bottom:8px solid transparent}.middle-right .amap-info-sharp:after{position:absolute;content:"";margin-left:-8px;border-left:8px solid rgba(0,0,0,.3);filter:blur(1px);z-index:-1}.amap-info-contentContainer:hover.middle-right .amap-info-sharp:after{border-left:8px solid rgba(0,0,0,.5)}.middle-left .amap-info-sharp{left:0;top:50%;border-right:8px solid #fff}.middle-left .amap-info-sharp,.middle-left .amap-info-sharp:after{margin-top:-8px;border-top:8px solid transparent;border-bottom:8px solid transparent}.middle-left .amap-info-sharp:after{position:absolute;content:"";margin-left:0;border-right:8px solid rgba(0,0,0,.3);filter:blur(1px);z-index:-1}.amap-info-contentContainer:hover.middle-left .amap-info-sharp:after{border-right:8px solid rgba(0,0,0,.5)}.amap-info-contentContainer.top-center,.amap-info-contentContainer.top-left,.amap-info-contentContainer.top-right{padding-top:8px}.amap-info-contentContainer.bottom-center,.amap-info-contentContainer.bottom-left,.amap-info-contentContainer.bottom-right{padding-bottom:8px}.amap-info-contentContainer.middle-right{padding-right:8px}.amap-info-contentContainer.middle-left{padding-left:8px}.amap-menu-outer{margin:0;padding:0;list-style-type:none}ul.amap-menu-outer li{height:35px;line-height:35px;word-break:break-all;padding:0 10px;font-size:12px;white-space:nowrap}ul.amap-menu-outer li a{text-decoration:none;font-size:13px;margin:0 5px;color:#000;padding:5px}ul.amap-menu-outer li:hover{background-color:#f3f3ee}.amap-overlay-text-container{display:block;width:auto;word-break:keep-all;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;background:#fff;padding:2px 3px;border:1px solid #ccc;border-radius:3px}.amap-overlay-text-container.amap-overlay-text-empty{display:none}.amap-info-content-ie8{border:1px solid #9c9c9c}.amap-control{position:absolute;-webkit-tap-highlight-color:transparent}.amap-toolbar{background-color:#fff;border-radius:4px;box-shadow:0 0 3px rgba(0,0,0,.5)}.amap-toolbar span{display:block;width:30px;height:30px;line-height:30px;text-align:center;border-radius:0 0 4px 4px;-webkit-user-select:none;-moz-user-select:none;user-select:none;font-size:20px}.amap-toolbar span:first-child{border-bottom:1px solid #eee;border-radius:4px 4px 0 0}.amap-toolbar span:hover{font-weight:bolder;background-color:#f0f0f0}.amap-scalecontrol{pointer-events:none;background-color:hsla(0,0%,100%,.5);border-radius:2px;user-select:none}.amap-scalecontrol .amap-scale-text{font-size:10px;text-align:center;transition:width .3s;user-select:none}.amap-scalecontrol .amap-scale-line{position:relative;height:8px;left:2px;user-select:none}.amap-scalecontrol .amap-scale-edgeleft,.amap-scalecontrol .amap-scale-edgeright,.amap-scalecontrol .amap-scale-middle{position:absolute;background-color:#333;overflow:hidden;box-sizing:content-box!important}.amap-scalecontrol .amap-scale-edgeright{width:1px;height:6px;border:1px solid #fff;transition:left .3s}.amap-scalecontrol .amap-scale-middle{height:2px;left:2px;top:2px;border-top:1px solid #fff;border-bottom:1px solid #fff;transition:width .3s}.amap-scalecontrol .amap-scale-edgeleft{width:1px;height:6px;border:1px solid #fff}.amap-controlbar,.amap-controlbar *{user-select:none}.amap-controlbar .amap-luopan{width:92px;height:92px;background:url(https://webapi.amap.com/theme/v1.3/controlbar/ctb.png) -22px -30px no-repeat;background-size:348px 270px;user-select:none}.amap-luopan .amap-compass{top:46px;left:50%;position:absolute;margin:-24px;width:48px;height:48px;z-index:10;background:url(https://webapi.amap.com/theme/v1.3/controlbar/ctb.png) -231px -26px no-repeat;background-size:348px 270px}.amap-luopan .amap-compass.amap-compass-black{background:url(https://webapi.amap.com/theme/v1.3/controlbar/ctb.png) no-repeat -231px -79px;background-size:348px 270px}.amap-luopan .amap-compass .amap-pointers{position:absolute;width:30px;height:48px;top:0;left:9px;border:none;z-index:2;background:url(https://webapi.amap.com/theme/v1.3/controlbar/ctb.png) -281px -26px no-repeat;background-size:348px 270px}.amap-pitchDown,.amap-pitchUp{width:30px;height:25.5px;position:absolute;top:3.5px;margin-left:-15px;left:50%;z-index:1;background:url(https://webapi.amap.com/theme/v1.3/controlbar/ctb.png) -302.5px -49px no-repeat;background-size:348px 270px}.amap-pitchDown:hover,.amap-pitchUp:hover{background:url(https://webapi.amap.com/theme/v1.3/controlbar/ctb.png) no-repeat -302.5px -23.5px;background-size:348px 270px}.amap-pitchDown{top:66px;transform:rotate(180deg);-ms-transform:rotate(180deg);-webkit-transform:rotate(180deg);-o-transform:rotate(180deg);-moz-transform:rotate(180deg)}.amap-rotateLeft,.amap-rotateRight{width:21px;height:52px;top:19px;position:absolute;z-index:2;background:url(https://webapi.amap.com/theme/v1.3/controlbar/ctb.png) -301.5px -77px no-repeat;background-size:348px 270px}.amap-rotateLeft:hover,.amap-rotateRight:hover{background:url(https://webapi.amap.com/theme/v1.3/controlbar/ctb.png) no-repeat -278.5px -76.5px;background-size:348px 270px}.amap-rotateLeft{left:5px}.amap-rotateRight{right:5px;transform:rotateY(180deg);-ms-transform:rotateY(180deg);-webkit-transform:rotateY(180deg);-o-transform:rotateY(180deg);-moz-transform:rotateY(180deg)}.amap-ctrl-icon-layer{width:30px;height:30px}.amap-ctrl-icon-layer,.amap-ctrl-list-layer{background-color:#fff;border-radius:3px;box-shadow:0 0 4px 1px rgba(0,0,0,.2)}.amap-ctrl-list-layer{position:absolute;top:0;right:0;overflow:hidden;z-index:1}.amap-ctrl-list-layer ul{overflow:hidden;list-style:none;margin:0;padding:5px 8px}.amap-ctrl-list-layer ul li{float:left;width:100%}.amap-ctrl-list-layer ul p{white-space:nowrap;font-size:12px;height:20px;line-height:20px;padding-left:5px;margin:0 10px}.amap-ctrl-list-layer input{float:left;height:20px;width:12px;margin:0 5px}.amap-ctrl-base-layer{border-bottom:1px solid #eee}.amap-ranging-label{_width:10px;font-size:12px;line-height:14px;background:#fff;border:1px solid #ccc;padding:3px 7px 3px 2px;white-space:nowrap}.amap-ranging-label span{height:12px;vertical-align:center;display:inline-block;white-space:nowrap;margin-left:5px}.amap-popup{text-align:center;position:fixed;top:50%;left:50%;margin-left:-165px;margin-top:-170px}.amap-popup-content{vertical-align:middle;line-height:200px;overflow:hidden;background-color:#fff;border:solid;border-width:3px 1px;border-radius:5px;border-color:#ddf;margin:0 auto;text-align:center;height:340px}.amap-labellayers{position:absolute;top:0;left:0;transform-origin:0 0}.amap-indoormap-floorbar-control{position:absolute;width:40px;text-align:center;line-height:1.3em;border-radius:20px;box-shadow:0 0 3px 3px rgba(0,0,0,.1);background-color:#fff;margin-top:-100px}.amap-indoormap-floorbar-control .floor-list-box{max-height:160px;overflow:scroll;-ms-overflow-style:none;overflow:-moz-scrollbars-none;-webkit-user-select:none;-moz-user-select:none}.floor-list-box::-webkit-scrollbar{width:0!important;height:0!important}.amap-indoormap-floorbar-control ul{list-style:none;margin:0;padding:0 4px;width:40px;box-sizing:border-box}.amap-indoormap-floorbar-control ul li{height:32px;width:32px;border-radius:16px}.amap-indoormap-floorbar-control ul li:hover{background-color:#efefef}.amap-indoormap-floorbar-control ul li div{height:32px;text-align:center;line-height:32px;font-size:12px}.amap-indoormap-floorbar-control ul li.selected{color:#fff;background-color:#4196ff}.amap-indoormap-floorbar-control .floor-minus,.amap-indoormap-floorbar-control .floor-plus{height:32px;width:32px;margin:0 auto;border-radius:16px;position:relative}.amap-indoormap-floorbar-control .floor-minus:after,.amap-indoormap-floorbar-control .floor-plus:after{content:"";position:absolute;margin:auto;bottom:4px;left:0;right:0;width:0;height:0;border:7px solid transparent;border-top-color:#777}.amap-indoormap-floorbar-control .floor-plus:after{border-bottom-color:#777;border-top-color:transparent;bottom:11px}.amap-indoormap-floorbar-control .floor-plus:hover:after{border-bottom-color:#222}.amap-indoormap-floorbar-control .floor-minus:hover:after{border-top-color:#222}.amap-indoormap-floorbar-control .floor-plus.disabled:after{border-bottom-color:#ddd}.amap-indoormap-floorbar-control .floor-minus.disabled:after{border-top-color:#ddd}.amap-indoormap-floorbar-control .floor-list-item.selected:after{right:0;left:auto;border-left-color:transparent;border-right-color:#4196ff}.amap-indoormap-floorbar-control .floor-btn.disabled,.amap-indoormap-floorbar-control .floor-btn.disabled *,.amap-indoormap-floorbar-control.with-indrm-loader *{-webkit-pointer-events:none!important;pointer-events:none!important}.amap-indoormap-floorbar-control .with-indrm-loader .floor-nonas{opacity:.5}\'),-1!==(si=0!==(si=window.location.href).indexOf("http")&&window.parent&&window.parent!==window?window.parent.location.href:si).indexOf("?")&&(si=si.substr(0,si.indexOf("?"))),si=encodeURIComponent(si);var pi=(Pi=config[16]||config[2].split(":")[0])+"://restapi.amap.com",ct=(xi=Pi+"://"+config[2].split("://")[1])+"/theme/v1.3/markers/"+(_.Support.Ue?"b":"n"),Qt=Pi+"://webrd0{1,2,3,4}.is.autonavi.com/appmaptile?lang=zh_cn&size=1&scale=1&style=8&x=[x]&y=[y]&z=[z]",li=Pi+"://wprd0{1,2,3,4}.is.autonavi.com/appmaptile?lang=zh_cn&size=1&style=7&x=[x]&y=[y]&z=[z]",ea="",Ti="",ra=(window._AMapSecurityConfig&&(window._AMapSecurityConfig.securityJsCode?ea=window._AMapSecurityConfig.securityJsCode||"":window._AMapSecurityConfig.serviceHost&&(Oi="",Bt=(Oi="https"===(Ti=window._AMapSecurityConfig.serviceHost||"").split(":")[0]?Ti.replace(/https:\\/\\/\\S+?\\//g,""):Ti.replace(/http:\\/\\/\\S+?\\//g,""))&&Oi.split("/")[0],Xt=window.location.hostname,"_AMapService"!==Bt)&&("127.0.0.1"===Xt||"localhost"===Xt?window.alert("使用 JSAPI 安全模式，代理服务请以_AMapService 作为一级路由"):"undefined"!=typeof console&&console.log("<AMap JSAPI> 使用 JSAPI 安全模式，代理服务请以_AMapService 作为一级路由"))),{key:config[0],host:config[2],domain:config[17],server:pi,protocol:Pi,version:config[4],adcode:config[6],callback:config[5],appname:si,client:xi,markers:ct,pc:"http://gaode.com",mo:"http://m.amap.com",workerUrl:"",YT:Qt,qT:li,y_:_.Support.$e?li:Qt,v_:"\\x3c!--v2.0--\\x3e &copy "+(new Date).getFullYear()+" AutoNavi ",db:config[14]||"",JH:config[15]||"",jscode:ea,gaodeserver:Ti,vdataProxy:"",keytype:config[19]});return hi=(new Date).getTime(),Ut=ra.server+"/v3/log/init?",(s=["platform=JS&s=rsv3&logversion=2.0&product=JsInit&key="+ra.key,"t="+hi]).push("sdkversion=2.0"),s.push("appname="+si),s.push("csid="+_.Util.uuid()),s.push("resolution="+window.screen.width+"*"+window.screen.height),s.push("mob="+(_.Support.$e?1:0)),s.push("vt="+(_.Support.isWebGL?1:0)),s.push("dpr="+window.devicePixelRatio),s.push("scale="+(_.Support.Ue?2:1)),s.push("detect="+_.Support.Ue),ra.jscode?s.push("jscode="+ra.jscode):ra.gaodeserver&&(Ut=ra.gaodeserver+"/v3/log/init?"),Ut+=s.join("&"),yi.JSONP(Ut),function(t){return t[1]&&(or=t[1].slice(-2),er=t[1].slice(0,4)),{Map:ur,ImageLayer:vr,createDefaultLayer:qr,TileLayer:v,NebulaLayer:Ji,Buildings:Xr,Indoor:Eo,SkyLayer:Ms,DistrictLayer:_o,CanvasLayer:gr,CustomLayer:xr,GLCustomLayer:ih,LabelsLayer:ms,MassMarks:Sr,Event:_.Event,version:"2.0",plugin:$o,LngLat:_.LngLat,Pixel:_.Pixel,Size:_.Size,Icon:re,Bounds:l,extent:Pt,Marker:De,Text:Dr,InfoWindow:Ge,ContextMenu:qe,LabelMarker:Br,Polygon:qh,Rectangle:to,Ellipse:so,Circle:oo,CircleMarker:fo,Polyline:bo,BezierCurve:Co,OverlayGroup:dh,VectorLayer:is,LayerGroup:eh,Control:Fr,DomUtil:w,Util:_.Util,GeometryUtil:_.GeometryUtil,Browser:_r,UA:{ie:_r.ie,ie9:_r.ie9,ie11:_r.ie11,mobile:_r.mobile,android:_r.android,ios:_r.ios},PlaneGeometryUtil:_.PlaneGeometryUtil,getConfig:ta,WebService:ir,extend:_.extend,Http:yi,addCss:N,BuryPoint:Hr,lcs:_.lcs,convertFrom:sr,Heatmap:hh,IndoorMap:jo,Mapbox:ch,BuildingLayer:Xr,Mark:Ko}}});var __AMap_callback=AMap.getConfig().callback,tryGetCallback,tryCallback;return __AMap_callback&&(tryGetCallback=function(){var c=__AMap_callback.split("."),context=window;do{if(!(context=context[c.shift()]))return null}while(c.length);return context||null},tryCallback=function(isFinalTry){var func=tryGetCallback();if(func){if("function"!=typeof func)throw new Error(__AMap_callback+" is not a function!");setTimeout(func,1)}else if(isFinalTry)throw new Error("Can not find callback: "+__AMap_callback+", try define it before load JsApi!")},document.body&&tryGetCallback()?tryCallback():setTimeout(function(){tryCallback(!0)},1)),AMap});\r\n(typeof _cssload_=="function")&&_cssload_("logo",".amap-logo{display:block!important;pointer-events:none;}",true)})(["74f03d0dfdac3925b83e85d25133a1bd",[108.183723,21.588354,109.870977,22.681402,108.624175,21.967127],"https://webapi.amap.com",1,"2.0.5.21",null,"450700","",true,false,false,true,"20230103011500-20201123-1",false,"A","3_23_10_10_00","https","webapi.amap.com",1,"0"])')();
  /**
   * @license
   * Copyright 2010-2022 Three.js Authors
   * SPDX-License-Identifier: MIT
   */
  const e = "142"
    , i = 0
    , n = 1
    , r = 2
    , o = 1
    , s = 2
    , a = 3
    , l = 0
    , h = 1
    , c = 2
    , u = 0
    , p = 1
    , d = 2
    , f = 3
    , g = 4
    , m = 5
    , y = 100
    , v = 101
    , A = 102
    , b = 103
    , x = 104
    , I = 200
    , C = 201
    , w = 202
    , _ = 203
    , S = 204
    , M = 205
    , T = 206
    , E = 207
    , k = 208
    , R = 209
    , L = 210
    , P = 0
    , z = 1
    , O = 2
    , D = 3
    , U = 4
    , N = 5
    , F = 6
    , B = 7
    , j = 0
    , V = 1
    , G = 2
    , W = 0
    , J = 1
    , H = 2
    , Z = 3
    , Q = 4
    , K = 5
    , Y = 300
    , q = 301
    , X = 302
    , $ = 303
    , tt = 304
    , et = 306
    , it = 1e3
    , nt = 1001
    , rt = 1002
    , ot = 1003
    , st = 1004
    , at = 1005
    , lt = 1006
    , ht = 1007
    , ct = 1008
    , ut = 1009
    , pt = 1010
    , dt = 1011
    , ft = 1012
    , gt = 1013
    , mt = 1014
    , yt = 1015
    , vt = 1016
    , At = 1017
    , bt = 1018
    , xt = 1020
    , It = 1021
    , Ct = 1022
    , wt = 1023
    , _t = 1024
    , St = 1025
    , Mt = 1026
    , Tt = 1027
    , Et = 1028
    , kt = 1029
    , Rt = 1030
    , Lt = 1031
    , Pt = 1033
    , zt = 33776
    , Ot = 33777
    , Dt = 33778
    , Ut = 33779
    , Nt = 35840
    , Ft = 35841
    , Bt = 35842
    , jt = 35843
    , Vt = 36196
    , Gt = 37492
    , Wt = 37496
    , Jt = 37808
    , Ht = 37809
    , Zt = 37810
    , Qt = 37811
    , Kt = 37812
    , Yt = 37813
    , qt = 37814
    , Xt = 37815
    , $t = 37816
    , te = 37817
    , ee = 37818
    , ie = 37819
    , ne = 37820
    , re = 37821
    , oe = 36492
    , se = 2300
    , ae = 2301
    , le = 2302
    , he = 2400
    , ce = 2401
    , ue = 2402
    , pe = 2500
    , de = 2501
    , fe = 3e3
    , ge = 3001
    , me = 3201
    , ye = 0
    , ve = 1
    , Ae = "srgb"
    , be = "srgb-linear"
    , xe = 7680
    , Ie = 35044
    , Ce = 35048
    , we = "300 es"
    , _e = 1035;
  class Se {
    addEventListener(t, e) {
      void 0 === this._listeners && (this._listeners = {});
      const i = this._listeners;
      void 0 === i[t] && (i[t] = []),
        -1 === i[t].indexOf(e) && i[t].push(e)
    }
    hasEventListener(t, e) {
      if (void 0 === this._listeners)
        return !1;
      const i = this._listeners;
      return void 0 !== i[t] && -1 !== i[t].indexOf(e)
    }
    removeEventListener(t, e) {
      if (void 0 === this._listeners)
        return;
      const i = this._listeners[t];
      if (void 0 !== i) {
        const t = i.indexOf(e);
        -1 !== t && i.splice(t, 1)
      }
    }
    dispatchEvent(t) {
      if (void 0 === this._listeners)
        return;
      const e = this._listeners[t.type];
      if (void 0 !== e) {
        t.target = this;
        const i = e.slice(0);
        for (let e = 0, n = i.length; e < n; e++)
          i[e].call(this, t);
        t.target = null
      }
    }
  }
  const Me = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
  let Te = 1234567;
  const Ee = Math.PI / 180
    , ke = 180 / Math.PI;
  function Re() {
    const t = 4294967295 * Math.random() | 0
      , e = 4294967295 * Math.random() | 0
      , i = 4294967295 * Math.random() | 0
      , n = 4294967295 * Math.random() | 0;
    return (Me[255 & t] + Me[t >> 8 & 255] + Me[t >> 16 & 255] + Me[t >> 24 & 255] + "-" + Me[255 & e] + Me[e >> 8 & 255] + "-" + Me[e >> 16 & 15 | 64] + Me[e >> 24 & 255] + "-" + Me[63 & i | 128] + Me[i >> 8 & 255] + "-" + Me[i >> 16 & 255] + Me[i >> 24 & 255] + Me[255 & n] + Me[n >> 8 & 255] + Me[n >> 16 & 255] + Me[n >> 24 & 255]).toLowerCase()
  }
  function Le(t, e, i) {
    return Math.max(e, Math.min(i, t))
  }
  function Pe(t, e) {
    return (t % e + e) % e
  }
  function ze(t, e, i) {
    return (1 - i) * t + i * e
  }
  function Oe(t) {
    return 0 == (t & t - 1) && 0 !== t
  }
  function De(t) {
    return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
  }
  function Ue(t) {
    return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
  }
  var Ne = Object.freeze({
    __proto__: null,
    DEG2RAD: Ee,
    RAD2DEG: ke,
    generateUUID: Re,
    clamp: Le,
    euclideanModulo: Pe,
    mapLinear: function (t, e, i, n, r) {
      return n + (t - e) * (r - n) / (i - e)
    },
    inverseLerp: function (t, e, i) {
      return t !== e ? (i - t) / (e - t) : 0
    },
    lerp: ze,
    damp: function (t, e, i, n) {
      return ze(t, e, 1 - Math.exp(-i * n))
    },
    pingpong: function (t, e = 1) {
      return e - Math.abs(Pe(t, 2 * e) - e)
    },
    smoothstep: function (t, e, i) {
      return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e)) * t * (3 - 2 * t)
    },
    smootherstep: function (t, e, i) {
      return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e)) * t * t * (t * (6 * t - 15) + 10)
    },
    randInt: function (t, e) {
      return t + Math.floor(Math.random() * (e - t + 1))
    },
    randFloat: function (t, e) {
      return t + Math.random() * (e - t)
    },
    randFloatSpread: function (t) {
      return t * (.5 - Math.random())
    },
    seededRandom: function (t) {
      void 0 !== t && (Te = t);
      let e = Te += 1831565813;
      return e = Math.imul(e ^ e >>> 15, 1 | e),
        e ^= e + Math.imul(e ^ e >>> 7, 61 | e),
        ((e ^ e >>> 14) >>> 0) / 4294967296
    },
    degToRad: function (t) {
      return t * Ee
    },
    radToDeg: function (t) {
      return t * ke
    },
    isPowerOfTwo: Oe,
    ceilPowerOfTwo: De,
    floorPowerOfTwo: Ue,
    setQuaternionFromProperEuler: function (t, e, i, n, r) {
      const o = Math.cos
        , s = Math.sin
        , a = o(i / 2)
        , l = s(i / 2)
        , h = o((e + n) / 2)
        , c = s((e + n) / 2)
        , u = o((e - n) / 2)
        , p = s((e - n) / 2)
        , d = o((n - e) / 2)
        , f = s((n - e) / 2);
      switch (r) {
        case "XYX":
          t.set(a * c, l * u, l * p, a * h);
          break;
        case "YZY":
          t.set(l * p, a * c, l * u, a * h);
          break;
        case "ZXZ":
          t.set(l * u, l * p, a * c, a * h);
          break;
        case "XZX":
          t.set(a * c, l * f, l * d, a * h);
          break;
        case "YXY":
          t.set(l * d, a * c, l * f, a * h);
          break;
        case "ZYZ":
          t.set(l * f, l * d, a * c, a * h);
          break;
        default:
          console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
      }
    },
    normalize: function (t, e) {
      switch (e.constructor) {
        case Float32Array:
          return t;
        case Uint16Array:
          return Math.round(65535 * t);
        case Uint8Array:
          return Math.round(255 * t);
        case Int16Array:
          return Math.round(32767 * t);
        case Int8Array:
          return Math.round(127 * t);
        default:
          throw new Error("Invalid component type.")
      }
    },
    denormalize: function (t, e) {
      switch (e.constructor) {
        case Float32Array:
          return t;
        case Uint16Array:
          return t / 65535;
        case Uint8Array:
          return t / 255;
        case Int16Array:
          return Math.max(t / 32767, -1);
        case Int8Array:
          return Math.max(t / 127, -1);
        default:
          throw new Error("Invalid component type.")
      }
    }
  });
  class Fe {
    constructor(t = 0, e = 0) {
      Fe.prototype.isVector2 = !0,
        this.x = t,
        this.y = e
    }
    get width() {
      return this.x
    }
    set width(t) {
      this.x = t
    }
    get height() {
      return this.y
    }
    set height(t) {
      this.y = t
    }
    set(t, e) {
      return this.x = t,
        this.y = e,
        this
    }
    setScalar(t) {
      return this.x = t,
        this.y = t,
        this
    }
    setX(t) {
      return this.x = t,
        this
    }
    setY(t) {
      return this.y = t,
        this
    }
    setComponent(t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;
        case 1:
          this.y = e;
          break;
        default:
          throw new Error("index is out of range: " + t)
      }
      return this
    }
    getComponent(t) {
      switch (t) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        default:
          throw new Error("index is out of range: " + t)
      }
    }
    clone() {
      return new this.constructor(this.x, this.y)
    }
    copy(t) {
      return this.x = t.x,
        this.y = t.y,
        this
    }
    add(t, e) {
      return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
        this.addVectors(t, e)) : (this.x += t.x,
          this.y += t.y,
          this)
    }
    addScalar(t) {
      return this.x += t,
        this.y += t,
        this
    }
    addVectors(t, e) {
      return this.x = t.x + e.x,
        this.y = t.y + e.y,
        this
    }
    addScaledVector(t, e) {
      return this.x += t.x * e,
        this.y += t.y * e,
        this
    }
    sub(t, e) {
      return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
        this.subVectors(t, e)) : (this.x -= t.x,
          this.y -= t.y,
          this)
    }
    subScalar(t) {
      return this.x -= t,
        this.y -= t,
        this
    }
    subVectors(t, e) {
      return this.x = t.x - e.x,
        this.y = t.y - e.y,
        this
    }
    multiply(t) {
      return this.x *= t.x,
        this.y *= t.y,
        this
    }
    multiplyScalar(t) {
      return this.x *= t,
        this.y *= t,
        this
    }
    divide(t) {
      return this.x /= t.x,
        this.y /= t.y,
        this
    }
    divideScalar(t) {
      return this.multiplyScalar(1 / t)
    }
    applyMatrix3(t) {
      const e = this.x
        , i = this.y
        , n = t.elements;
      return this.x = n[0] * e + n[3] * i + n[6],
        this.y = n[1] * e + n[4] * i + n[7],
        this
    }
    min(t) {
      return this.x = Math.min(this.x, t.x),
        this.y = Math.min(this.y, t.y),
        this
    }
    max(t) {
      return this.x = Math.max(this.x, t.x),
        this.y = Math.max(this.y, t.y),
        this
    }
    clamp(t, e) {
      return this.x = Math.max(t.x, Math.min(e.x, this.x)),
        this.y = Math.max(t.y, Math.min(e.y, this.y)),
        this
    }
    clampScalar(t, e) {
      return this.x = Math.max(t, Math.min(e, this.x)),
        this.y = Math.max(t, Math.min(e, this.y)),
        this
    }
    clampLength(t, e) {
      const i = this.length();
      return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
    }
    floor() {
      return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this
    }
    ceil() {
      return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this
    }
    round() {
      return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this
    }
    roundToZero() {
      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
        this
    }
    negate() {
      return this.x = -this.x,
        this.y = -this.y,
        this
    }
    dot(t) {
      return this.x * t.x + this.y * t.y
    }
    cross(t) {
      return this.x * t.y - this.y * t.x
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y)
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y)
    }
    normalize() {
      return this.divideScalar(this.length() || 1)
    }
    angle() {
      return Math.atan2(-this.y, -this.x) + Math.PI
    }
    distanceTo(t) {
      return Math.sqrt(this.distanceToSquared(t))
    }
    distanceToSquared(t) {
      const e = this.x - t.x
        , i = this.y - t.y;
      return e * e + i * i
    }
    manhattanDistanceTo(t) {
      return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
    }
    setLength(t) {
      return this.normalize().multiplyScalar(t)
    }
    lerp(t, e) {
      return this.x += (t.x - this.x) * e,
        this.y += (t.y - this.y) * e,
        this
    }
    lerpVectors(t, e, i) {
      return this.x = t.x + (e.x - t.x) * i,
        this.y = t.y + (e.y - t.y) * i,
        this
    }
    equals(t) {
      return t.x === this.x && t.y === this.y
    }
    fromArray(t, e = 0) {
      return this.x = t[e],
        this.y = t[e + 1],
        this
    }
    toArray(t = [], e = 0) {
      return t[e] = this.x,
        t[e + 1] = this.y,
        t
    }
    fromBufferAttribute(t, e, i) {
      return void 0 !== i && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),
        this.x = t.getX(e),
        this.y = t.getY(e),
        this
    }
    rotateAround(t, e) {
      const i = Math.cos(e)
        , n = Math.sin(e)
        , r = this.x - t.x
        , o = this.y - t.y;
      return this.x = r * i - o * n + t.x,
        this.y = r * n + o * i + t.y,
        this
    }
    random() {
      return this.x = Math.random(),
        this.y = Math.random(),
        this
    }
    *[Symbol.iterator]() {
      yield this.x,
        yield this.y
    }
  }
  class Be {
    constructor() {
      Be.prototype.isMatrix3 = !0,
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
    }
    set(t, e, i, n, r, o, s, a, l) {
      const h = this.elements;
      return h[0] = t,
        h[1] = n,
        h[2] = s,
        h[3] = e,
        h[4] = r,
        h[5] = a,
        h[6] = i,
        h[7] = o,
        h[8] = l,
        this
    }
    identity() {
      return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
        this
    }
    copy(t) {
      const e = this.elements
        , i = t.elements;
      return e[0] = i[0],
        e[1] = i[1],
        e[2] = i[2],
        e[3] = i[3],
        e[4] = i[4],
        e[5] = i[5],
        e[6] = i[6],
        e[7] = i[7],
        e[8] = i[8],
        this
    }
    extractBasis(t, e, i) {
      return t.setFromMatrix3Column(this, 0),
        e.setFromMatrix3Column(this, 1),
        i.setFromMatrix3Column(this, 2),
        this
    }
    setFromMatrix4(t) {
      const e = t.elements;
      return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]),
        this
    }
    multiply(t) {
      return this.multiplyMatrices(this, t)
    }
    premultiply(t) {
      return this.multiplyMatrices(t, this)
    }
    multiplyMatrices(t, e) {
      const i = t.elements
        , n = e.elements
        , r = this.elements
        , o = i[0]
        , s = i[3]
        , a = i[6]
        , l = i[1]
        , h = i[4]
        , c = i[7]
        , u = i[2]
        , p = i[5]
        , d = i[8]
        , f = n[0]
        , g = n[3]
        , m = n[6]
        , y = n[1]
        , v = n[4]
        , A = n[7]
        , b = n[2]
        , x = n[5]
        , I = n[8];
      return r[0] = o * f + s * y + a * b,
        r[3] = o * g + s * v + a * x,
        r[6] = o * m + s * A + a * I,
        r[1] = l * f + h * y + c * b,
        r[4] = l * g + h * v + c * x,
        r[7] = l * m + h * A + c * I,
        r[2] = u * f + p * y + d * b,
        r[5] = u * g + p * v + d * x,
        r[8] = u * m + p * A + d * I,
        this
    }
    multiplyScalar(t) {
      const e = this.elements;
      return e[0] *= t,
        e[3] *= t,
        e[6] *= t,
        e[1] *= t,
        e[4] *= t,
        e[7] *= t,
        e[2] *= t,
        e[5] *= t,
        e[8] *= t,
        this
    }
    determinant() {
      const t = this.elements
        , e = t[0]
        , i = t[1]
        , n = t[2]
        , r = t[3]
        , o = t[4]
        , s = t[5]
        , a = t[6]
        , l = t[7]
        , h = t[8];
      return e * o * h - e * s * l - i * r * h + i * s * a + n * r * l - n * o * a
    }
    invert() {
      const t = this.elements
        , e = t[0]
        , i = t[1]
        , n = t[2]
        , r = t[3]
        , o = t[4]
        , s = t[5]
        , a = t[6]
        , l = t[7]
        , h = t[8]
        , c = h * o - s * l
        , u = s * a - h * r
        , p = l * r - o * a
        , d = e * c + i * u + n * p;
      if (0 === d)
        return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
      const f = 1 / d;
      return t[0] = c * f,
        t[1] = (n * l - h * i) * f,
        t[2] = (s * i - n * o) * f,
        t[3] = u * f,
        t[4] = (h * e - n * a) * f,
        t[5] = (n * r - s * e) * f,
        t[6] = p * f,
        t[7] = (i * a - l * e) * f,
        t[8] = (o * e - i * r) * f,
        this
    }
    transpose() {
      let t;
      const e = this.elements;
      return t = e[1],
        e[1] = e[3],
        e[3] = t,
        t = e[2],
        e[2] = e[6],
        e[6] = t,
        t = e[5],
        e[5] = e[7],
        e[7] = t,
        this
    }
    getNormalMatrix(t) {
      return this.setFromMatrix4(t).invert().transpose()
    }
    transposeIntoArray(t) {
      const e = this.elements;
      return t[0] = e[0],
        t[1] = e[3],
        t[2] = e[6],
        t[3] = e[1],
        t[4] = e[4],
        t[5] = e[7],
        t[6] = e[2],
        t[7] = e[5],
        t[8] = e[8],
        this
    }
    setUvTransform(t, e, i, n, r, o, s) {
      const a = Math.cos(r)
        , l = Math.sin(r);
      return this.set(i * a, i * l, -i * (a * o + l * s) + o + t, -n * l, n * a, -n * (-l * o + a * s) + s + e, 0, 0, 1),
        this
    }
    scale(t, e) {
      const i = this.elements;
      return i[0] *= t,
        i[3] *= t,
        i[6] *= t,
        i[1] *= e,
        i[4] *= e,
        i[7] *= e,
        this
    }
    rotate(t) {
      const e = Math.cos(t)
        , i = Math.sin(t)
        , n = this.elements
        , r = n[0]
        , o = n[3]
        , s = n[6]
        , a = n[1]
        , l = n[4]
        , h = n[7];
      return n[0] = e * r + i * a,
        n[3] = e * o + i * l,
        n[6] = e * s + i * h,
        n[1] = -i * r + e * a,
        n[4] = -i * o + e * l,
        n[7] = -i * s + e * h,
        this
    }
    translate(t, e) {
      const i = this.elements;
      return i[0] += t * i[2],
        i[3] += t * i[5],
        i[6] += t * i[8],
        i[1] += e * i[2],
        i[4] += e * i[5],
        i[7] += e * i[8],
        this
    }
    equals(t) {
      const e = this.elements
        , i = t.elements;
      for (let t = 0; t < 9; t++)
        if (e[t] !== i[t])
          return !1;
      return !0
    }
    fromArray(t, e = 0) {
      for (let i = 0; i < 9; i++)
        this.elements[i] = t[i + e];
      return this
    }
    toArray(t = [], e = 0) {
      const i = this.elements;
      return t[e] = i[0],
        t[e + 1] = i[1],
        t[e + 2] = i[2],
        t[e + 3] = i[3],
        t[e + 4] = i[4],
        t[e + 5] = i[5],
        t[e + 6] = i[6],
        t[e + 7] = i[7],
        t[e + 8] = i[8],
        t
    }
    clone() {
      return (new this.constructor).fromArray(this.elements)
    }
  }
  function je(t) {
    for (let e = t.length - 1; e >= 0; --e)
      if (t[e] > 65535)
        return !0;
    return !1
  }
  const Ve = {
    Int8Array: Int8Array,
    Uint8Array: Uint8Array,
    Uint8ClampedArray: Uint8ClampedArray,
    Int16Array: Int16Array,
    Uint16Array: Uint16Array,
    Int32Array: Int32Array,
    Uint32Array: Uint32Array,
    Float32Array: Float32Array,
    Float64Array: Float64Array
  };
  function Ge(t, e) {
    return new Ve[t](e)
  }
  function We(t) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", t)
  }
  function Je(t) {
    return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
  }
  function He(t) {
    return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
  }
  const Ze = {
    [Ae]: {
      [be]: Je
    },
    [be]: {
      [Ae]: He
    }
  }
    , Qe = {
      legacyMode: !0,
      get workingColorSpace() {
        return be
      },
      set workingColorSpace(t) {
        console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")
      },
      convert: function (t, e, i) {
        if (this.legacyMode || e === i || !e || !i)
          return t;
        if (Ze[e] && void 0 !== Ze[e][i]) {
          const n = Ze[e][i];
          return t.r = n(t.r),
            t.g = n(t.g),
            t.b = n(t.b),
            t
        }
        throw new Error("Unsupported color space conversion.")
      },
      fromWorkingColorSpace: function (t, e) {
        return this.convert(t, this.workingColorSpace, e)
      },
      toWorkingColorSpace: function (t, e) {
        return this.convert(t, e, this.workingColorSpace)
      }
    }
    , Ke = {
      aliceblue: 15792383,
      antiquewhite: 16444375,
      aqua: 65535,
      aquamarine: 8388564,
      azure: 15794175,
      beige: 16119260,
      bisque: 16770244,
      black: 0,
      blanchedalmond: 16772045,
      blue: 255,
      blueviolet: 9055202,
      brown: 10824234,
      burlywood: 14596231,
      cadetblue: 6266528,
      chartreuse: 8388352,
      chocolate: 13789470,
      coral: 16744272,
      cornflowerblue: 6591981,
      cornsilk: 16775388,
      crimson: 14423100,
      cyan: 65535,
      darkblue: 139,
      darkcyan: 35723,
      darkgoldenrod: 12092939,
      darkgray: 11119017,
      darkgreen: 25600,
      darkgrey: 11119017,
      darkkhaki: 12433259,
      darkmagenta: 9109643,
      darkolivegreen: 5597999,
      darkorange: 16747520,
      darkorchid: 10040012,
      darkred: 9109504,
      darksalmon: 15308410,
      darkseagreen: 9419919,
      darkslateblue: 4734347,
      darkslategray: 3100495,
      darkslategrey: 3100495,
      darkturquoise: 52945,
      darkviolet: 9699539,
      deeppink: 16716947,
      deepskyblue: 49151,
      dimgray: 6908265,
      dimgrey: 6908265,
      dodgerblue: 2003199,
      firebrick: 11674146,
      floralwhite: 16775920,
      forestgreen: 2263842,
      fuchsia: 16711935,
      gainsboro: 14474460,
      ghostwhite: 16316671,
      gold: 16766720,
      goldenrod: 14329120,
      gray: 8421504,
      green: 32768,
      greenyellow: 11403055,
      grey: 8421504,
      honeydew: 15794160,
      hotpink: 16738740,
      indianred: 13458524,
      indigo: 4915330,
      ivory: 16777200,
      khaki: 15787660,
      lavender: 15132410,
      lavenderblush: 16773365,
      lawngreen: 8190976,
      lemonchiffon: 16775885,
      lightblue: 11393254,
      lightcoral: 15761536,
      lightcyan: 14745599,
      lightgoldenrodyellow: 16448210,
      lightgray: 13882323,
      lightgreen: 9498256,
      lightgrey: 13882323,
      lightpink: 16758465,
      lightsalmon: 16752762,
      lightseagreen: 2142890,
      lightskyblue: 8900346,
      lightslategray: 7833753,
      lightslategrey: 7833753,
      lightsteelblue: 11584734,
      lightyellow: 16777184,
      lime: 65280,
      limegreen: 3329330,
      linen: 16445670,
      magenta: 16711935,
      maroon: 8388608,
      mediumaquamarine: 6737322,
      mediumblue: 205,
      mediumorchid: 12211667,
      mediumpurple: 9662683,
      mediumseagreen: 3978097,
      mediumslateblue: 8087790,
      mediumspringgreen: 64154,
      mediumturquoise: 4772300,
      mediumvioletred: 13047173,
      midnightblue: 1644912,
      mintcream: 16121850,
      mistyrose: 16770273,
      moccasin: 16770229,
      navajowhite: 16768685,
      navy: 128,
      oldlace: 16643558,
      olive: 8421376,
      olivedrab: 7048739,
      orange: 16753920,
      orangered: 16729344,
      orchid: 14315734,
      palegoldenrod: 15657130,
      palegreen: 10025880,
      paleturquoise: 11529966,
      palevioletred: 14381203,
      papayawhip: 16773077,
      peachpuff: 16767673,
      peru: 13468991,
      pink: 16761035,
      plum: 14524637,
      powderblue: 11591910,
      purple: 8388736,
      rebeccapurple: 6697881,
      red: 16711680,
      rosybrown: 12357519,
      royalblue: 4286945,
      saddlebrown: 9127187,
      salmon: 16416882,
      sandybrown: 16032864,
      seagreen: 3050327,
      seashell: 16774638,
      sienna: 10506797,
      silver: 12632256,
      skyblue: 8900331,
      slateblue: 6970061,
      slategray: 7372944,
      slategrey: 7372944,
      snow: 16775930,
      springgreen: 65407,
      steelblue: 4620980,
      tan: 13808780,
      teal: 32896,
      thistle: 14204888,
      tomato: 16737095,
      turquoise: 4251856,
      violet: 15631086,
      wheat: 16113331,
      white: 16777215,
      whitesmoke: 16119285,
      yellow: 16776960,
      yellowgreen: 10145074
    }
    , Ye = {
      r: 0,
      g: 0,
      b: 0
    }
    , qe = {
      h: 0,
      s: 0,
      l: 0
    }
    , Xe = {
      h: 0,
      s: 0,
      l: 0
    };
  function $e(t, e, i) {
    return i < 0 && (i += 1),
      i > 1 && (i -= 1),
      i < 1 / 6 ? t + 6 * (e - t) * i : i < .5 ? e : i < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - i) : t
  }
  function ti(t, e) {
    return e.r = t.r,
      e.g = t.g,
      e.b = t.b,
      e
  }
  class ei {
    constructor(t, e, i) {
      return this.isColor = !0,
        this.r = 1,
        this.g = 1,
        this.b = 1,
        void 0 === e && void 0 === i ? this.set(t) : this.setRGB(t, e, i)
    }
    set(t) {
      return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t),
        this
    }
    setScalar(t) {
      return this.r = t,
        this.g = t,
        this.b = t,
        this
    }
    setHex(t, e = Ae) {
      return t = Math.floor(t),
        this.r = (t >> 16 & 255) / 255,
        this.g = (t >> 8 & 255) / 255,
        this.b = (255 & t) / 255,
        Qe.toWorkingColorSpace(this, e),
        this
    }
    setRGB(t, e, i, n = be) {
      return this.r = t,
        this.g = e,
        this.b = i,
        Qe.toWorkingColorSpace(this, n),
        this
    }
    setHSL(t, e, i, n = be) {
      if (t = Pe(t, 1),
        e = Le(e, 0, 1),
        i = Le(i, 0, 1),
        0 === e)
        this.r = this.g = this.b = i;
      else {
        const n = i <= .5 ? i * (1 + e) : i + e - i * e
          , r = 2 * i - n;
        this.r = $e(r, n, t + 1 / 3),
          this.g = $e(r, n, t),
          this.b = $e(r, n, t - 1 / 3)
      }
      return Qe.toWorkingColorSpace(this, n),
        this
    }
    setStyle(t, e = Ae) {
      function i(e) {
        void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
      }
      let n;
      if (n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)) {
        let t;
        const r = n[1]
          , o = n[2];
        switch (r) {
          case "rgb":
          case "rgba":
            if (t = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
              return this.r = Math.min(255, parseInt(t[1], 10)) / 255,
                this.g = Math.min(255, parseInt(t[2], 10)) / 255,
                this.b = Math.min(255, parseInt(t[3], 10)) / 255,
                Qe.toWorkingColorSpace(this, e),
                i(t[4]),
                this;
            if (t = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
              return this.r = Math.min(100, parseInt(t[1], 10)) / 100,
                this.g = Math.min(100, parseInt(t[2], 10)) / 100,
                this.b = Math.min(100, parseInt(t[3], 10)) / 100,
                Qe.toWorkingColorSpace(this, e),
                i(t[4]),
                this;
            break;
          case "hsl":
          case "hsla":
            if (t = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) {
              const n = parseFloat(t[1]) / 360
                , r = parseInt(t[2], 10) / 100
                , o = parseInt(t[3], 10) / 100;
              return i(t[4]),
                this.setHSL(n, r, o, e)
            }
        }
      } else if (n = /^\#([A-Fa-f\d]+)$/.exec(t)) {
        const t = n[1]
          , i = t.length;
        if (3 === i)
          return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255,
            this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255,
            this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255,
            Qe.toWorkingColorSpace(this, e),
            this;
        if (6 === i)
          return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255,
            this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255,
            this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255,
            Qe.toWorkingColorSpace(this, e),
            this
      }
      return t && t.length > 0 ? this.setColorName(t, e) : this
    }
    setColorName(t, e = Ae) {
      const i = Ke[t.toLowerCase()];
      return void 0 !== i ? this.setHex(i, e) : console.warn("THREE.Color: Unknown color " + t),
        this
    }
    clone() {
      return new this.constructor(this.r, this.g, this.b)
    }
    copy(t) {
      return this.r = t.r,
        this.g = t.g,
        this.b = t.b,
        this
    }
    copySRGBToLinear(t) {
      return this.r = Je(t.r),
        this.g = Je(t.g),
        this.b = Je(t.b),
        this
    }
    copyLinearToSRGB(t) {
      return this.r = He(t.r),
        this.g = He(t.g),
        this.b = He(t.b),
        this
    }
    convertSRGBToLinear() {
      return this.copySRGBToLinear(this),
        this
    }
    convertLinearToSRGB() {
      return this.copyLinearToSRGB(this),
        this
    }
    getHex(t = Ae) {
      return Qe.fromWorkingColorSpace(ti(this, Ye), t),
        Le(255 * Ye.r, 0, 255) << 16 ^ Le(255 * Ye.g, 0, 255) << 8 ^ Le(255 * Ye.b, 0, 255) << 0
    }
    getHexString(t = Ae) {
      return ("000000" + this.getHex(t).toString(16)).slice(-6)
    }
    getHSL(t, e = be) {
      Qe.fromWorkingColorSpace(ti(this, Ye), e);
      const i = Ye.r
        , n = Ye.g
        , r = Ye.b
        , o = Math.max(i, n, r)
        , s = Math.min(i, n, r);
      let a, l;
      const h = (s + o) / 2;
      if (s === o)
        a = 0,
          l = 0;
      else {
        const t = o - s;
        switch (l = h <= .5 ? t / (o + s) : t / (2 - o - s),
        o) {
          case i:
            a = (n - r) / t + (n < r ? 6 : 0);
            break;
          case n:
            a = (r - i) / t + 2;
            break;
          case r:
            a = (i - n) / t + 4
        }
        a /= 6
      }
      return t.h = a,
        t.s = l,
        t.l = h,
        t
    }
    getRGB(t, e = be) {
      return Qe.fromWorkingColorSpace(ti(this, Ye), e),
        t.r = Ye.r,
        t.g = Ye.g,
        t.b = Ye.b,
        t
    }
    getStyle(t = Ae) {
      return Qe.fromWorkingColorSpace(ti(this, Ye), t),
        t !== Ae ? `color(${t} ${Ye.r} ${Ye.g} ${Ye.b})` : `rgb(${255 * Ye.r | 0},${255 * Ye.g | 0},${255 * Ye.b | 0})`
    }
    offsetHSL(t, e, i) {
      return this.getHSL(qe),
        qe.h += t,
        qe.s += e,
        qe.l += i,
        this.setHSL(qe.h, qe.s, qe.l),
        this
    }
    add(t) {
      return this.r += t.r,
        this.g += t.g,
        this.b += t.b,
        this
    }
    addColors(t, e) {
      return this.r = t.r + e.r,
        this.g = t.g + e.g,
        this.b = t.b + e.b,
        this
    }
    addScalar(t) {
      return this.r += t,
        this.g += t,
        this.b += t,
        this
    }
    sub(t) {
      return this.r = Math.max(0, this.r - t.r),
        this.g = Math.max(0, this.g - t.g),
        this.b = Math.max(0, this.b - t.b),
        this
    }
    multiply(t) {
      return this.r *= t.r,
        this.g *= t.g,
        this.b *= t.b,
        this
    }
    multiplyScalar(t) {
      return this.r *= t,
        this.g *= t,
        this.b *= t,
        this
    }
    lerp(t, e) {
      return this.r += (t.r - this.r) * e,
        this.g += (t.g - this.g) * e,
        this.b += (t.b - this.b) * e,
        this
    }
    lerpColors(t, e, i) {
      return this.r = t.r + (e.r - t.r) * i,
        this.g = t.g + (e.g - t.g) * i,
        this.b = t.b + (e.b - t.b) * i,
        this
    }
    lerpHSL(t, e) {
      this.getHSL(qe),
        t.getHSL(Xe);
      const i = ze(qe.h, Xe.h, e)
        , n = ze(qe.s, Xe.s, e)
        , r = ze(qe.l, Xe.l, e);
      return this.setHSL(i, n, r),
        this
    }
    equals(t) {
      return t.r === this.r && t.g === this.g && t.b === this.b
    }
    fromArray(t, e = 0) {
      return this.r = t[e],
        this.g = t[e + 1],
        this.b = t[e + 2],
        this
    }
    toArray(t = [], e = 0) {
      return t[e] = this.r,
        t[e + 1] = this.g,
        t[e + 2] = this.b,
        t
    }
    fromBufferAttribute(t, e) {
      return this.r = t.getX(e),
        this.g = t.getY(e),
        this.b = t.getZ(e),
        !0 === t.normalized && (this.r /= 255,
          this.g /= 255,
          this.b /= 255),
        this
    }
    toJSON() {
      return this.getHex()
    }
    *[Symbol.iterator]() {
      yield this.r,
        yield this.g,
        yield this.b
    }
  }
  let ii;
  ei.NAMES = Ke;
  class ni {
    static getDataURL(t) {
      if (/^data:/i.test(t.src))
        return t.src;
      if ("undefined" == typeof HTMLCanvasElement)
        return t.src;
      let e;
      if (t instanceof HTMLCanvasElement)
        e = t;
      else {
        void 0 === ii && (ii = We("canvas")),
          ii.width = t.width,
          ii.height = t.height;
        const i = ii.getContext("2d");
        t instanceof ImageData ? i.putImageData(t, 0, 0) : i.drawImage(t, 0, 0, t.width, t.height),
          e = ii
      }
      return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t),
        e.toDataURL("image/jpeg", .6)) : e.toDataURL("image/png")
    }
    static sRGBToLinear(t) {
      if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
        const e = We("canvas");
        e.width = t.width,
          e.height = t.height;
        const i = e.getContext("2d");
        i.drawImage(t, 0, 0, t.width, t.height);
        const n = i.getImageData(0, 0, t.width, t.height)
          , r = n.data;
        for (let t = 0; t < r.length; t++)
          r[t] = 255 * Je(r[t] / 255);
        return i.putImageData(n, 0, 0),
          e
      }
      if (t.data) {
        const e = t.data.slice(0);
        for (let t = 0; t < e.length; t++)
          e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[t] = Math.floor(255 * Je(e[t] / 255)) : e[t] = Je(e[t]);
        return {
          data: e,
          width: t.width,
          height: t.height
        }
      }
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
        t
    }
  }
  class ri {
    constructor(t = null) {
      this.isSource = !0,
        this.uuid = Re(),
        this.data = t,
        this.version = 0
    }
    set needsUpdate(t) {
      !0 === t && this.version++
    }
    toJSON(t) {
      const e = void 0 === t || "string" == typeof t;
      if (!e && void 0 !== t.images[this.uuid])
        return t.images[this.uuid];
      const i = {
        uuid: this.uuid,
        url: ""
      }
        , n = this.data;
      if (null !== n) {
        let t;
        if (Array.isArray(n)) {
          t = [];
          for (let e = 0, i = n.length; e < i; e++)
            n[e].isDataTexture ? t.push(oi(n[e].image)) : t.push(oi(n[e]))
        } else
          t = oi(n);
        i.url = t
      }
      return e || (t.images[this.uuid] = i),
        i
    }
  }
  function oi(t) {
    return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? ni.getDataURL(t) : t.data ? {
      data: Array.from(t.data),
      width: t.width,
      height: t.height,
      type: t.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."),
      {})
  }
  let si = 0;
  class ai extends Se {
    constructor(t = ai.DEFAULT_IMAGE, e = ai.DEFAULT_MAPPING, i = nt, n = nt, r = lt, o = ct, s = wt, a = ut, l = 1, h = fe) {
      super(),
        this.isTexture = !0,
        Object.defineProperty(this, "id", {
          value: si++
        }),
        this.uuid = Re(),
        this.name = "",
        this.source = new ri(t),
        this.mipmaps = [],
        this.mapping = e,
        this.wrapS = i,
        this.wrapT = n,
        this.magFilter = r,
        this.minFilter = o,
        this.anisotropy = l,
        this.format = s,
        this.internalFormat = null,
        this.type = a,
        this.offset = new Fe(0, 0),
        this.repeat = new Fe(1, 1),
        this.center = new Fe(0, 0),
        this.rotation = 0,
        this.matrixAutoUpdate = !0,
        this.matrix = new Be,
        this.generateMipmaps = !0,
        this.premultiplyAlpha = !1,
        this.flipY = !0,
        this.unpackAlignment = 4,
        this.encoding = h,
        this.userData = {},
        this.version = 0,
        this.onUpdate = null,
        this.isRenderTargetTexture = !1,
        this.needsPMREMUpdate = !1
    }
    get image() {
      return this.source.data
    }
    set image(t) {
      this.source.data = t
    }
    updateMatrix() {
      this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
    }
    clone() {
      return (new this.constructor).copy(this)
    }
    copy(t) {
      return this.name = t.name,
        this.source = t.source,
        this.mipmaps = t.mipmaps.slice(0),
        this.mapping = t.mapping,
        this.wrapS = t.wrapS,
        this.wrapT = t.wrapT,
        this.magFilter = t.magFilter,
        this.minFilter = t.minFilter,
        this.anisotropy = t.anisotropy,
        this.format = t.format,
        this.internalFormat = t.internalFormat,
        this.type = t.type,
        this.offset.copy(t.offset),
        this.repeat.copy(t.repeat),
        this.center.copy(t.center),
        this.rotation = t.rotation,
        this.matrixAutoUpdate = t.matrixAutoUpdate,
        this.matrix.copy(t.matrix),
        this.generateMipmaps = t.generateMipmaps,
        this.premultiplyAlpha = t.premultiplyAlpha,
        this.flipY = t.flipY,
        this.unpackAlignment = t.unpackAlignment,
        this.encoding = t.encoding,
        this.userData = JSON.parse(JSON.stringify(t.userData)),
        this.needsUpdate = !0,
        this
    }
    toJSON(t) {
      const e = void 0 === t || "string" == typeof t;
      if (!e && void 0 !== t.textures[this.uuid])
        return t.textures[this.uuid];
      const i = {
        metadata: {
          version: 4.5,
          type: "Texture",
          generator: "Texture.toJSON"
        },
        uuid: this.uuid,
        name: this.name,
        image: this.source.toJSON(t).uuid,
        mapping: this.mapping,
        repeat: [this.repeat.x, this.repeat.y],
        offset: [this.offset.x, this.offset.y],
        center: [this.center.x, this.center.y],
        rotation: this.rotation,
        wrap: [this.wrapS, this.wrapT],
        format: this.format,
        type: this.type,
        encoding: this.encoding,
        minFilter: this.minFilter,
        magFilter: this.magFilter,
        anisotropy: this.anisotropy,
        flipY: this.flipY,
        premultiplyAlpha: this.premultiplyAlpha,
        unpackAlignment: this.unpackAlignment
      };
      return "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData),
        e || (t.textures[this.uuid] = i),
        i
    }
    dispose() {
      this.dispatchEvent({
        type: "dispose"
      })
    }
    transformUv(t) {
      if (this.mapping !== Y)
        return t;
      if (t.applyMatrix3(this.matrix),
        t.x < 0 || t.x > 1)
        switch (this.wrapS) {
          case it:
            t.x = t.x - Math.floor(t.x);
            break;
          case nt:
            t.x = t.x < 0 ? 0 : 1;
            break;
          case rt:
            1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
        }
      if (t.y < 0 || t.y > 1)
        switch (this.wrapT) {
          case it:
            t.y = t.y - Math.floor(t.y);
            break;
          case nt:
            t.y = t.y < 0 ? 0 : 1;
            break;
          case rt:
            1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
        }
      return this.flipY && (t.y = 1 - t.y),
        t
    }
    set needsUpdate(t) {
      !0 === t && (this.version++,
        this.source.needsUpdate = !0)
    }
  }
  ai.DEFAULT_IMAGE = null,
    ai.DEFAULT_MAPPING = Y;
  class li {
    constructor(t = 0, e = 0, i = 0, n = 1) {
      li.prototype.isVector4 = !0,
        this.x = t,
        this.y = e,
        this.z = i,
        this.w = n
    }
    get width() {
      return this.z
    }
    set width(t) {
      this.z = t
    }
    get height() {
      return this.w
    }
    set height(t) {
      this.w = t
    }
    set(t, e, i, n) {
      return this.x = t,
        this.y = e,
        this.z = i,
        this.w = n,
        this
    }
    setScalar(t) {
      return this.x = t,
        this.y = t,
        this.z = t,
        this.w = t,
        this
    }
    setX(t) {
      return this.x = t,
        this
    }
    setY(t) {
      return this.y = t,
        this
    }
    setZ(t) {
      return this.z = t,
        this
    }
    setW(t) {
      return this.w = t,
        this
    }
    setComponent(t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;
        case 1:
          this.y = e;
          break;
        case 2:
          this.z = e;
          break;
        case 3:
          this.w = e;
          break;
        default:
          throw new Error("index is out of range: " + t)
      }
      return this
    }
    getComponent(t) {
      switch (t) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        case 3:
          return this.w;
        default:
          throw new Error("index is out of range: " + t)
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z, this.w)
    }
    copy(t) {
      return this.x = t.x,
        this.y = t.y,
        this.z = t.z,
        this.w = void 0 !== t.w ? t.w : 1,
        this
    }
    add(t, e) {
      return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
        this.addVectors(t, e)) : (this.x += t.x,
          this.y += t.y,
          this.z += t.z,
          this.w += t.w,
          this)
    }
    addScalar(t) {
      return this.x += t,
        this.y += t,
        this.z += t,
        this.w += t,
        this
    }
    addVectors(t, e) {
      return this.x = t.x + e.x,
        this.y = t.y + e.y,
        this.z = t.z + e.z,
        this.w = t.w + e.w,
        this
    }
    addScaledVector(t, e) {
      return this.x += t.x * e,
        this.y += t.y * e,
        this.z += t.z * e,
        this.w += t.w * e,
        this
    }
    sub(t, e) {
      return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
        this.subVectors(t, e)) : (this.x -= t.x,
          this.y -= t.y,
          this.z -= t.z,
          this.w -= t.w,
          this)
    }
    subScalar(t) {
      return this.x -= t,
        this.y -= t,
        this.z -= t,
        this.w -= t,
        this
    }
    subVectors(t, e) {
      return this.x = t.x - e.x,
        this.y = t.y - e.y,
        this.z = t.z - e.z,
        this.w = t.w - e.w,
        this
    }
    multiply(t) {
      return this.x *= t.x,
        this.y *= t.y,
        this.z *= t.z,
        this.w *= t.w,
        this
    }
    multiplyScalar(t) {
      return this.x *= t,
        this.y *= t,
        this.z *= t,
        this.w *= t,
        this
    }
    applyMatrix4(t) {
      const e = this.x
        , i = this.y
        , n = this.z
        , r = this.w
        , o = t.elements;
      return this.x = o[0] * e + o[4] * i + o[8] * n + o[12] * r,
        this.y = o[1] * e + o[5] * i + o[9] * n + o[13] * r,
        this.z = o[2] * e + o[6] * i + o[10] * n + o[14] * r,
        this.w = o[3] * e + o[7] * i + o[11] * n + o[15] * r,
        this
    }
    divideScalar(t) {
      return this.multiplyScalar(1 / t)
    }
    setAxisAngleFromQuaternion(t) {
      this.w = 2 * Math.acos(t.w);
      const e = Math.sqrt(1 - t.w * t.w);
      return e < 1e-4 ? (this.x = 1,
        this.y = 0,
        this.z = 0) : (this.x = t.x / e,
          this.y = t.y / e,
          this.z = t.z / e),
        this
    }
    setAxisAngleFromRotationMatrix(t) {
      let e, i, n, r;
      const o = .01
        , s = .1
        , a = t.elements
        , l = a[0]
        , h = a[4]
        , c = a[8]
        , u = a[1]
        , p = a[5]
        , d = a[9]
        , f = a[2]
        , g = a[6]
        , m = a[10];
      if (Math.abs(h - u) < o && Math.abs(c - f) < o && Math.abs(d - g) < o) {
        if (Math.abs(h + u) < s && Math.abs(c + f) < s && Math.abs(d + g) < s && Math.abs(l + p + m - 3) < s)
          return this.set(1, 0, 0, 0),
            this;
        e = Math.PI;
        const t = (l + 1) / 2
          , a = (p + 1) / 2
          , y = (m + 1) / 2
          , v = (h + u) / 4
          , A = (c + f) / 4
          , b = (d + g) / 4;
        return t > a && t > y ? t < o ? (i = 0,
          n = .707106781,
          r = .707106781) : (i = Math.sqrt(t),
            n = v / i,
            r = A / i) : a > y ? a < o ? (i = .707106781,
              n = 0,
              r = .707106781) : (n = Math.sqrt(a),
                i = v / n,
                r = b / n) : y < o ? (i = .707106781,
                  n = .707106781,
                  r = 0) : (r = Math.sqrt(y),
                    i = A / r,
                    n = b / r),
          this.set(i, n, r, e),
          this
      }
      let y = Math.sqrt((g - d) * (g - d) + (c - f) * (c - f) + (u - h) * (u - h));
      return Math.abs(y) < .001 && (y = 1),
        this.x = (g - d) / y,
        this.y = (c - f) / y,
        this.z = (u - h) / y,
        this.w = Math.acos((l + p + m - 1) / 2),
        this
    }
    min(t) {
      return this.x = Math.min(this.x, t.x),
        this.y = Math.min(this.y, t.y),
        this.z = Math.min(this.z, t.z),
        this.w = Math.min(this.w, t.w),
        this
    }
    max(t) {
      return this.x = Math.max(this.x, t.x),
        this.y = Math.max(this.y, t.y),
        this.z = Math.max(this.z, t.z),
        this.w = Math.max(this.w, t.w),
        this
    }
    clamp(t, e) {
      return this.x = Math.max(t.x, Math.min(e.x, this.x)),
        this.y = Math.max(t.y, Math.min(e.y, this.y)),
        this.z = Math.max(t.z, Math.min(e.z, this.z)),
        this.w = Math.max(t.w, Math.min(e.w, this.w)),
        this
    }
    clampScalar(t, e) {
      return this.x = Math.max(t, Math.min(e, this.x)),
        this.y = Math.max(t, Math.min(e, this.y)),
        this.z = Math.max(t, Math.min(e, this.z)),
        this.w = Math.max(t, Math.min(e, this.w)),
        this
    }
    clampLength(t, e) {
      const i = this.length();
      return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
    }
    floor() {
      return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this.w = Math.floor(this.w),
        this
    }
    ceil() {
      return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this.w = Math.ceil(this.w),
        this
    }
    round() {
      return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this.w = Math.round(this.w),
        this
    }
    roundToZero() {
      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
        this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w),
        this
    }
    negate() {
      return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this.w = -this.w,
        this
    }
    dot(t) {
      return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    }
    normalize() {
      return this.divideScalar(this.length() || 1)
    }
    setLength(t) {
      return this.normalize().multiplyScalar(t)
    }
    lerp(t, e) {
      return this.x += (t.x - this.x) * e,
        this.y += (t.y - this.y) * e,
        this.z += (t.z - this.z) * e,
        this.w += (t.w - this.w) * e,
        this
    }
    lerpVectors(t, e, i) {
      return this.x = t.x + (e.x - t.x) * i,
        this.y = t.y + (e.y - t.y) * i,
        this.z = t.z + (e.z - t.z) * i,
        this.w = t.w + (e.w - t.w) * i,
        this
    }
    equals(t) {
      return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
    }
    fromArray(t, e = 0) {
      return this.x = t[e],
        this.y = t[e + 1],
        this.z = t[e + 2],
        this.w = t[e + 3],
        this
    }
    toArray(t = [], e = 0) {
      return t[e] = this.x,
        t[e + 1] = this.y,
        t[e + 2] = this.z,
        t[e + 3] = this.w,
        t
    }
    fromBufferAttribute(t, e, i) {
      return void 0 !== i && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),
        this.x = t.getX(e),
        this.y = t.getY(e),
        this.z = t.getZ(e),
        this.w = t.getW(e),
        this
    }
    random() {
      return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this.w = Math.random(),
        this
    }
    *[Symbol.iterator]() {
      yield this.x,
        yield this.y,
        yield this.z,
        yield this.w
    }
  }
  class hi extends Se {
    constructor(t, e, i = {}) {
      super(),
        this.isWebGLRenderTarget = !0,
        this.width = t,
        this.height = e,
        this.depth = 1,
        this.scissor = new li(0, 0, t, e),
        this.scissorTest = !1,
        this.viewport = new li(0, 0, t, e);
      const n = {
        width: t,
        height: e,
        depth: 1
      };
      this.texture = new ai(n, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.encoding),
        this.texture.isRenderTargetTexture = !0,
        this.texture.flipY = !1,
        this.texture.generateMipmaps = void 0 !== i.generateMipmaps && i.generateMipmaps,
        this.texture.internalFormat = void 0 !== i.internalFormat ? i.internalFormat : null,
        this.texture.minFilter = void 0 !== i.minFilter ? i.minFilter : lt,
        this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer,
        this.stencilBuffer = void 0 !== i.stencilBuffer && i.stencilBuffer,
        this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null,
        this.samples = void 0 !== i.samples ? i.samples : 0
    }
    setSize(t, e, i = 1) {
      this.width === t && this.height === e && this.depth === i || (this.width = t,
        this.height = e,
        this.depth = i,
        this.texture.image.width = t,
        this.texture.image.height = e,
        this.texture.image.depth = i,
        this.dispose()),
        this.viewport.set(0, 0, t, e),
        this.scissor.set(0, 0, t, e)
    }
    clone() {
      return (new this.constructor).copy(this)
    }
    copy(t) {
      this.width = t.width,
        this.height = t.height,
        this.depth = t.depth,
        this.viewport.copy(t.viewport),
        this.texture = t.texture.clone(),
        this.texture.isRenderTargetTexture = !0;
      const e = Object.assign({}, t.texture.image);
      return this.texture.source = new ri(e),
        this.depthBuffer = t.depthBuffer,
        this.stencilBuffer = t.stencilBuffer,
        null !== t.depthTexture && (this.depthTexture = t.depthTexture.clone()),
        this.samples = t.samples,
        this
    }
    dispose() {
      this.dispatchEvent({
        type: "dispose"
      })
    }
  }
  class ci extends ai {
    constructor(t = null, e = 1, i = 1, n = 1) {
      super(null),
        this.isDataArrayTexture = !0,
        this.image = {
          data: t,
          width: e,
          height: i,
          depth: n
        },
        this.magFilter = ot,
        this.minFilter = ot,
        this.wrapR = nt,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
  }
  class ui extends ai {
    constructor(t = null, e = 1, i = 1, n = 1) {
      super(null),
        this.isData3DTexture = !0,
        this.image = {
          data: t,
          width: e,
          height: i,
          depth: n
        },
        this.magFilter = ot,
        this.minFilter = ot,
        this.wrapR = nt,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
  }
  class pi {
    constructor(t = 0, e = 0, i = 0, n = 1) {
      this.isQuaternion = !0,
        this._x = t,
        this._y = e,
        this._z = i,
        this._w = n
    }
    static slerp(t, e, i, n) {
      return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),
        i.slerpQuaternions(t, e, n)
    }
    static slerpFlat(t, e, i, n, r, o, s) {
      let a = i[n + 0]
        , l = i[n + 1]
        , h = i[n + 2]
        , c = i[n + 3];
      const u = r[o + 0]
        , p = r[o + 1]
        , d = r[o + 2]
        , f = r[o + 3];
      if (0 === s)
        return t[e + 0] = a,
          t[e + 1] = l,
          t[e + 2] = h,
          void (t[e + 3] = c);
      if (1 === s)
        return t[e + 0] = u,
          t[e + 1] = p,
          t[e + 2] = d,
          void (t[e + 3] = f);
      if (c !== f || a !== u || l !== p || h !== d) {
        let t = 1 - s;
        const e = a * u + l * p + h * d + c * f
          , i = e >= 0 ? 1 : -1
          , n = 1 - e * e;
        if (n > Number.EPSILON) {
          const r = Math.sqrt(n)
            , o = Math.atan2(r, e * i);
          t = Math.sin(t * o) / r,
            s = Math.sin(s * o) / r
        }
        const r = s * i;
        if (a = a * t + u * r,
          l = l * t + p * r,
          h = h * t + d * r,
          c = c * t + f * r,
          t === 1 - s) {
          const t = 1 / Math.sqrt(a * a + l * l + h * h + c * c);
          a *= t,
            l *= t,
            h *= t,
            c *= t
        }
      }
      t[e] = a,
        t[e + 1] = l,
        t[e + 2] = h,
        t[e + 3] = c
    }
    static multiplyQuaternionsFlat(t, e, i, n, r, o) {
      const s = i[n]
        , a = i[n + 1]
        , l = i[n + 2]
        , h = i[n + 3]
        , c = r[o]
        , u = r[o + 1]
        , p = r[o + 2]
        , d = r[o + 3];
      return t[e] = s * d + h * c + a * p - l * u,
        t[e + 1] = a * d + h * u + l * c - s * p,
        t[e + 2] = l * d + h * p + s * u - a * c,
        t[e + 3] = h * d - s * c - a * u - l * p,
        t
    }
    get x() {
      return this._x
    }
    set x(t) {
      this._x = t,
        this._onChangeCallback()
    }
    get y() {
      return this._y
    }
    set y(t) {
      this._y = t,
        this._onChangeCallback()
    }
    get z() {
      return this._z
    }
    set z(t) {
      this._z = t,
        this._onChangeCallback()
    }
    get w() {
      return this._w
    }
    set w(t) {
      this._w = t,
        this._onChangeCallback()
    }
    set(t, e, i, n) {
      return this._x = t,
        this._y = e,
        this._z = i,
        this._w = n,
        this._onChangeCallback(),
        this
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._w)
    }
    copy(t) {
      return this._x = t.x,
        this._y = t.y,
        this._z = t.z,
        this._w = t.w,
        this._onChangeCallback(),
        this
    }
    setFromEuler(t, e) {
      if (!t || !t.isEuler)
        throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
      const i = t._x
        , n = t._y
        , r = t._z
        , o = t._order
        , s = Math.cos
        , a = Math.sin
        , l = s(i / 2)
        , h = s(n / 2)
        , c = s(r / 2)
        , u = a(i / 2)
        , p = a(n / 2)
        , d = a(r / 2);
      switch (o) {
        case "XYZ":
          this._x = u * h * c + l * p * d,
            this._y = l * p * c - u * h * d,
            this._z = l * h * d + u * p * c,
            this._w = l * h * c - u * p * d;
          break;
        case "YXZ":
          this._x = u * h * c + l * p * d,
            this._y = l * p * c - u * h * d,
            this._z = l * h * d - u * p * c,
            this._w = l * h * c + u * p * d;
          break;
        case "ZXY":
          this._x = u * h * c - l * p * d,
            this._y = l * p * c + u * h * d,
            this._z = l * h * d + u * p * c,
            this._w = l * h * c - u * p * d;
          break;
        case "ZYX":
          this._x = u * h * c - l * p * d,
            this._y = l * p * c + u * h * d,
            this._z = l * h * d - u * p * c,
            this._w = l * h * c + u * p * d;
          break;
        case "YZX":
          this._x = u * h * c + l * p * d,
            this._y = l * p * c + u * h * d,
            this._z = l * h * d - u * p * c,
            this._w = l * h * c - u * p * d;
          break;
        case "XZY":
          this._x = u * h * c - l * p * d,
            this._y = l * p * c - u * h * d,
            this._z = l * h * d + u * p * c,
            this._w = l * h * c + u * p * d;
          break;
        default:
          console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o)
      }
      return !1 !== e && this._onChangeCallback(),
        this
    }
    setFromAxisAngle(t, e) {
      const i = e / 2
        , n = Math.sin(i);
      return this._x = t.x * n,
        this._y = t.y * n,
        this._z = t.z * n,
        this._w = Math.cos(i),
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(t) {
      const e = t.elements
        , i = e[0]
        , n = e[4]
        , r = e[8]
        , o = e[1]
        , s = e[5]
        , a = e[9]
        , l = e[2]
        , h = e[6]
        , c = e[10]
        , u = i + s + c;
      if (u > 0) {
        const t = .5 / Math.sqrt(u + 1);
        this._w = .25 / t,
          this._x = (h - a) * t,
          this._y = (r - l) * t,
          this._z = (o - n) * t
      } else if (i > s && i > c) {
        const t = 2 * Math.sqrt(1 + i - s - c);
        this._w = (h - a) / t,
          this._x = .25 * t,
          this._y = (n + o) / t,
          this._z = (r + l) / t
      } else if (s > c) {
        const t = 2 * Math.sqrt(1 + s - i - c);
        this._w = (r - l) / t,
          this._x = (n + o) / t,
          this._y = .25 * t,
          this._z = (a + h) / t
      } else {
        const t = 2 * Math.sqrt(1 + c - i - s);
        this._w = (o - n) / t,
          this._x = (r + l) / t,
          this._y = (a + h) / t,
          this._z = .25 * t
      }
      return this._onChangeCallback(),
        this
    }
    setFromUnitVectors(t, e) {
      let i = t.dot(e) + 1;
      return i < Number.EPSILON ? (i = 0,
        Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y,
          this._y = t.x,
          this._z = 0,
          this._w = i) : (this._x = 0,
            this._y = -t.z,
            this._z = t.y,
            this._w = i)) : (this._x = t.y * e.z - t.z * e.y,
              this._y = t.z * e.x - t.x * e.z,
              this._z = t.x * e.y - t.y * e.x,
              this._w = i),
        this.normalize()
    }
    angleTo(t) {
      return 2 * Math.acos(Math.abs(Le(this.dot(t), -1, 1)))
    }
    rotateTowards(t, e) {
      const i = this.angleTo(t);
      if (0 === i)
        return this;
      const n = Math.min(1, e / i);
      return this.slerp(t, n),
        this
    }
    identity() {
      return this.set(0, 0, 0, 1)
    }
    invert() {
      return this.conjugate()
    }
    conjugate() {
      return this._x *= -1,
        this._y *= -1,
        this._z *= -1,
        this._onChangeCallback(),
        this
    }
    dot(t) {
      return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
    }
    lengthSq() {
      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    }
    length() {
      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    }
    normalize() {
      let t = this.length();
      return 0 === t ? (this._x = 0,
        this._y = 0,
        this._z = 0,
        this._w = 1) : (t = 1 / t,
          this._x = this._x * t,
          this._y = this._y * t,
          this._z = this._z * t,
          this._w = this._w * t),
        this._onChangeCallback(),
        this
    }
    multiply(t, e) {
      return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),
        this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
    }
    premultiply(t) {
      return this.multiplyQuaternions(t, this)
    }
    multiplyQuaternions(t, e) {
      const i = t._x
        , n = t._y
        , r = t._z
        , o = t._w
        , s = e._x
        , a = e._y
        , l = e._z
        , h = e._w;
      return this._x = i * h + o * s + n * l - r * a,
        this._y = n * h + o * a + r * s - i * l,
        this._z = r * h + o * l + i * a - n * s,
        this._w = o * h - i * s - n * a - r * l,
        this._onChangeCallback(),
        this
    }
    slerp(t, e) {
      if (0 === e)
        return this;
      if (1 === e)
        return this.copy(t);
      const i = this._x
        , n = this._y
        , r = this._z
        , o = this._w;
      let s = o * t._w + i * t._x + n * t._y + r * t._z;
      if (s < 0 ? (this._w = -t._w,
        this._x = -t._x,
        this._y = -t._y,
        this._z = -t._z,
        s = -s) : this.copy(t),
        s >= 1)
        return this._w = o,
          this._x = i,
          this._y = n,
          this._z = r,
          this;
      const a = 1 - s * s;
      if (a <= Number.EPSILON) {
        const t = 1 - e;
        return this._w = t * o + e * this._w,
          this._x = t * i + e * this._x,
          this._y = t * n + e * this._y,
          this._z = t * r + e * this._z,
          this.normalize(),
          this._onChangeCallback(),
          this
      }
      const l = Math.sqrt(a)
        , h = Math.atan2(l, s)
        , c = Math.sin((1 - e) * h) / l
        , u = Math.sin(e * h) / l;
      return this._w = o * c + this._w * u,
        this._x = i * c + this._x * u,
        this._y = n * c + this._y * u,
        this._z = r * c + this._z * u,
        this._onChangeCallback(),
        this
    }
    slerpQuaternions(t, e, i) {
      return this.copy(t).slerp(e, i)
    }
    random() {
      const t = Math.random()
        , e = Math.sqrt(1 - t)
        , i = Math.sqrt(t)
        , n = 2 * Math.PI * Math.random()
        , r = 2 * Math.PI * Math.random();
      return this.set(e * Math.cos(n), i * Math.sin(r), i * Math.cos(r), e * Math.sin(n))
    }
    equals(t) {
      return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
    }
    fromArray(t, e = 0) {
      return this._x = t[e],
        this._y = t[e + 1],
        this._z = t[e + 2],
        this._w = t[e + 3],
        this._onChangeCallback(),
        this
    }
    toArray(t = [], e = 0) {
      return t[e] = this._x,
        t[e + 1] = this._y,
        t[e + 2] = this._z,
        t[e + 3] = this._w,
        t
    }
    fromBufferAttribute(t, e) {
      return this._x = t.getX(e),
        this._y = t.getY(e),
        this._z = t.getZ(e),
        this._w = t.getW(e),
        this
    }
    _onChange(t) {
      return this._onChangeCallback = t,
        this
    }
    _onChangeCallback() { }
    *[Symbol.iterator]() {
      yield this._x,
        yield this._y,
        yield this._z,
        yield this._w
    }
  }
  class di {
    constructor(t = 0, e = 0, i = 0) {
      di.prototype.isVector3 = !0,
        this.x = t,
        this.y = e,
        this.z = i
    }
    set(t, e, i) {
      return void 0 === i && (i = this.z),
        this.x = t,
        this.y = e,
        this.z = i,
        this
    }
    setScalar(t) {
      return this.x = t,
        this.y = t,
        this.z = t,
        this
    }
    setX(t) {
      return this.x = t,
        this
    }
    setY(t) {
      return this.y = t,
        this
    }
    setZ(t) {
      return this.z = t,
        this
    }
    setComponent(t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;
        case 1:
          this.y = e;
          break;
        case 2:
          this.z = e;
          break;
        default:
          throw new Error("index is out of range: " + t)
      }
      return this
    }
    getComponent(t) {
      switch (t) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        default:
          throw new Error("index is out of range: " + t)
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z)
    }
    copy(t) {
      return this.x = t.x,
        this.y = t.y,
        this.z = t.z,
        this
    }
    add(t, e) {
      return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
        this.addVectors(t, e)) : (this.x += t.x,
          this.y += t.y,
          this.z += t.z,
          this)
    }
    addScalar(t) {
      return this.x += t,
        this.y += t,
        this.z += t,
        this
    }
    addVectors(t, e) {
      return this.x = t.x + e.x,
        this.y = t.y + e.y,
        this.z = t.z + e.z,
        this
    }
    addScaledVector(t, e) {
      return this.x += t.x * e,
        this.y += t.y * e,
        this.z += t.z * e,
        this
    }
    sub(t, e) {
      return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
        this.subVectors(t, e)) : (this.x -= t.x,
          this.y -= t.y,
          this.z -= t.z,
          this)
    }
    subScalar(t) {
      return this.x -= t,
        this.y -= t,
        this.z -= t,
        this
    }
    subVectors(t, e) {
      return this.x = t.x - e.x,
        this.y = t.y - e.y,
        this.z = t.z - e.z,
        this
    }
    multiply(t, e) {
      return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),
        this.multiplyVectors(t, e)) : (this.x *= t.x,
          this.y *= t.y,
          this.z *= t.z,
          this)
    }
    multiplyScalar(t) {
      return this.x *= t,
        this.y *= t,
        this.z *= t,
        this
    }
    multiplyVectors(t, e) {
      return this.x = t.x * e.x,
        this.y = t.y * e.y,
        this.z = t.z * e.z,
        this
    }
    applyEuler(t) {
      return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),
        this.applyQuaternion(gi.setFromEuler(t))
    }
    applyAxisAngle(t, e) {
      return this.applyQuaternion(gi.setFromAxisAngle(t, e))
    }
    applyMatrix3(t) {
      const e = this.x
        , i = this.y
        , n = this.z
        , r = t.elements;
      return this.x = r[0] * e + r[3] * i + r[6] * n,
        this.y = r[1] * e + r[4] * i + r[7] * n,
        this.z = r[2] * e + r[5] * i + r[8] * n,
        this
    }
    applyNormalMatrix(t) {
      return this.applyMatrix3(t).normalize()
    }
    applyMatrix4(t) {
      const e = this.x
        , i = this.y
        , n = this.z
        , r = t.elements
        , o = 1 / (r[3] * e + r[7] * i + r[11] * n + r[15]);
      return this.x = (r[0] * e + r[4] * i + r[8] * n + r[12]) * o,
        this.y = (r[1] * e + r[5] * i + r[9] * n + r[13]) * o,
        this.z = (r[2] * e + r[6] * i + r[10] * n + r[14]) * o,
        this
    }
    applyQuaternion(t) {
      const e = this.x
        , i = this.y
        , n = this.z
        , r = t.x
        , o = t.y
        , s = t.z
        , a = t.w
        , l = a * e + o * n - s * i
        , h = a * i + s * e - r * n
        , c = a * n + r * i - o * e
        , u = -r * e - o * i - s * n;
      return this.x = l * a + u * -r + h * -s - c * -o,
        this.y = h * a + u * -o + c * -r - l * -s,
        this.z = c * a + u * -s + l * -o - h * -r,
        this
    }
    project(t) {
      return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
    }
    unproject(t) {
      return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
    }
    transformDirection(t) {
      const e = this.x
        , i = this.y
        , n = this.z
        , r = t.elements;
      return this.x = r[0] * e + r[4] * i + r[8] * n,
        this.y = r[1] * e + r[5] * i + r[9] * n,
        this.z = r[2] * e + r[6] * i + r[10] * n,
        this.normalize()
    }
    divide(t) {
      return this.x /= t.x,
        this.y /= t.y,
        this.z /= t.z,
        this
    }
    divideScalar(t) {
      return this.multiplyScalar(1 / t)
    }
    min(t) {
      return this.x = Math.min(this.x, t.x),
        this.y = Math.min(this.y, t.y),
        this.z = Math.min(this.z, t.z),
        this
    }
    max(t) {
      return this.x = Math.max(this.x, t.x),
        this.y = Math.max(this.y, t.y),
        this.z = Math.max(this.z, t.z),
        this
    }
    clamp(t, e) {
      return this.x = Math.max(t.x, Math.min(e.x, this.x)),
        this.y = Math.max(t.y, Math.min(e.y, this.y)),
        this.z = Math.max(t.z, Math.min(e.z, this.z)),
        this
    }
    clampScalar(t, e) {
      return this.x = Math.max(t, Math.min(e, this.x)),
        this.y = Math.max(t, Math.min(e, this.y)),
        this.z = Math.max(t, Math.min(e, this.z)),
        this
    }
    clampLength(t, e) {
      const i = this.length();
      return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
    }
    floor() {
      return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this
    }
    ceil() {
      return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this
    }
    round() {
      return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this
    }
    roundToZero() {
      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
        this
    }
    negate() {
      return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this
    }
    dot(t) {
      return this.x * t.x + this.y * t.y + this.z * t.z
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    }
    normalize() {
      return this.divideScalar(this.length() || 1)
    }
    setLength(t) {
      return this.normalize().multiplyScalar(t)
    }
    lerp(t, e) {
      return this.x += (t.x - this.x) * e,
        this.y += (t.y - this.y) * e,
        this.z += (t.z - this.z) * e,
        this
    }
    lerpVectors(t, e, i) {
      return this.x = t.x + (e.x - t.x) * i,
        this.y = t.y + (e.y - t.y) * i,
        this.z = t.z + (e.z - t.z) * i,
        this
    }
    cross(t, e) {
      return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),
        this.crossVectors(t, e)) : this.crossVectors(this, t)
    }
    crossVectors(t, e) {
      const i = t.x
        , n = t.y
        , r = t.z
        , o = e.x
        , s = e.y
        , a = e.z;
      return this.x = n * a - r * s,
        this.y = r * o - i * a,
        this.z = i * s - n * o,
        this
    }
    projectOnVector(t) {
      const e = t.lengthSq();
      if (0 === e)
        return this.set(0, 0, 0);
      const i = t.dot(this) / e;
      return this.copy(t).multiplyScalar(i)
    }
    projectOnPlane(t) {
      return fi.copy(this).projectOnVector(t),
        this.sub(fi)
    }
    reflect(t) {
      return this.sub(fi.copy(t).multiplyScalar(2 * this.dot(t)))
    }
    angleTo(t) {
      const e = Math.sqrt(this.lengthSq() * t.lengthSq());
      if (0 === e)
        return Math.PI / 2;
      const i = this.dot(t) / e;
      return Math.acos(Le(i, -1, 1))
    }
    distanceTo(t) {
      return Math.sqrt(this.distanceToSquared(t))
    }
    distanceToSquared(t) {
      const e = this.x - t.x
        , i = this.y - t.y
        , n = this.z - t.z;
      return e * e + i * i + n * n
    }
    manhattanDistanceTo(t) {
      return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
    }
    setFromSpherical(t) {
      return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
    }
    setFromSphericalCoords(t, e, i) {
      const n = Math.sin(e) * t;
      return this.x = n * Math.sin(i),
        this.y = Math.cos(e) * t,
        this.z = n * Math.cos(i),
        this
    }
    setFromCylindrical(t) {
      return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
    }
    setFromCylindricalCoords(t, e, i) {
      return this.x = t * Math.sin(e),
        this.y = i,
        this.z = t * Math.cos(e),
        this
    }
    setFromMatrixPosition(t) {
      const e = t.elements;
      return this.x = e[12],
        this.y = e[13],
        this.z = e[14],
        this
    }
    setFromMatrixScale(t) {
      const e = this.setFromMatrixColumn(t, 0).length()
        , i = this.setFromMatrixColumn(t, 1).length()
        , n = this.setFromMatrixColumn(t, 2).length();
      return this.x = e,
        this.y = i,
        this.z = n,
        this
    }
    setFromMatrixColumn(t, e) {
      return this.fromArray(t.elements, 4 * e)
    }
    setFromMatrix3Column(t, e) {
      return this.fromArray(t.elements, 3 * e)
    }
    setFromEuler(t) {
      return this.x = t._x,
        this.y = t._y,
        this.z = t._z,
        this
    }
    equals(t) {
      return t.x === this.x && t.y === this.y && t.z === this.z
    }
    fromArray(t, e = 0) {
      return this.x = t[e],
        this.y = t[e + 1],
        this.z = t[e + 2],
        this
    }
    toArray(t = [], e = 0) {
      return t[e] = this.x,
        t[e + 1] = this.y,
        t[e + 2] = this.z,
        t
    }
    fromBufferAttribute(t, e, i) {
      return void 0 !== i && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),
        this.x = t.getX(e),
        this.y = t.getY(e),
        this.z = t.getZ(e),
        this
    }
    random() {
      return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this
    }
    randomDirection() {
      const t = 2 * (Math.random() - .5)
        , e = Math.random() * Math.PI * 2
        , i = Math.sqrt(1 - t ** 2);
      return this.x = i * Math.cos(e),
        this.y = i * Math.sin(e),
        this.z = t,
        this
    }
    *[Symbol.iterator]() {
      yield this.x,
        yield this.y,
        yield this.z
    }
  }
  const fi = new di
    , gi = new pi;
  class mi {
    constructor(t = new di(1 / 0, 1 / 0, 1 / 0), e = new di(-1 / 0, -1 / 0, -1 / 0)) {
      this.isBox3 = !0,
        this.min = t,
        this.max = e
    }
    set(t, e) {
      return this.min.copy(t),
        this.max.copy(e),
        this
    }
    setFromArray(t) {
      let e = 1 / 0
        , i = 1 / 0
        , n = 1 / 0
        , r = -1 / 0
        , o = -1 / 0
        , s = -1 / 0;
      for (let a = 0, l = t.length; a < l; a += 3) {
        const l = t[a]
          , h = t[a + 1]
          , c = t[a + 2];
        l < e && (e = l),
          h < i && (i = h),
          c < n && (n = c),
          l > r && (r = l),
          h > o && (o = h),
          c > s && (s = c)
      }
      return this.min.set(e, i, n),
        this.max.set(r, o, s),
        this
    }
    setFromBufferAttribute(t) {
      let e = 1 / 0
        , i = 1 / 0
        , n = 1 / 0
        , r = -1 / 0
        , o = -1 / 0
        , s = -1 / 0;
      for (let a = 0, l = t.count; a < l; a++) {
        const l = t.getX(a)
          , h = t.getY(a)
          , c = t.getZ(a);
        l < e && (e = l),
          h < i && (i = h),
          c < n && (n = c),
          l > r && (r = l),
          h > o && (o = h),
          c > s && (s = c)
      }
      return this.min.set(e, i, n),
        this.max.set(r, o, s),
        this
    }
    setFromPoints(t) {
      this.makeEmpty();
      for (let e = 0, i = t.length; e < i; e++)
        this.expandByPoint(t[e]);
      return this
    }
    setFromCenterAndSize(t, e) {
      const i = vi.copy(e).multiplyScalar(.5);
      return this.min.copy(t).sub(i),
        this.max.copy(t).add(i),
        this
    }
    setFromObject(t, e = !1) {
      return this.makeEmpty(),
        this.expandByObject(t, e)
    }
    clone() {
      return (new this.constructor).copy(this)
    }
    copy(t) {
      return this.min.copy(t.min),
        this.max.copy(t.max),
        this
    }
    makeEmpty() {
      return this.min.x = this.min.y = this.min.z = 1 / 0,
        this.max.x = this.max.y = this.max.z = -1 / 0,
        this
    }
    isEmpty() {
      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    }
    getCenter(t) {
      return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(t) {
      return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
    }
    expandByPoint(t) {
      return this.min.min(t),
        this.max.max(t),
        this
    }
    expandByVector(t) {
      return this.min.sub(t),
        this.max.add(t),
        this
    }
    expandByScalar(t) {
      return this.min.addScalar(-t),
        this.max.addScalar(t),
        this
    }
    expandByObject(t, e = !1) {
      t.updateWorldMatrix(!1, !1);
      const i = t.geometry;
      if (void 0 !== i)
        if (e && null != i.attributes && void 0 !== i.attributes.position) {
          const e = i.attributes.position;
          for (let i = 0, n = e.count; i < n; i++)
            vi.fromBufferAttribute(e, i).applyMatrix4(t.matrixWorld),
              this.expandByPoint(vi)
        } else
          null === i.boundingBox && i.computeBoundingBox(),
            Ai.copy(i.boundingBox),
            Ai.applyMatrix4(t.matrixWorld),
            this.union(Ai);
      const n = t.children;
      for (let t = 0, i = n.length; t < i; t++)
        this.expandByObject(n[t], e);
      return this
    }
    containsPoint(t) {
      return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
    }
    containsBox(t) {
      return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
    }
    getParameter(t, e) {
      return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
    }
    intersectsBox(t) {
      return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
    }
    intersectsSphere(t) {
      return this.clampPoint(t.center, vi),
        vi.distanceToSquared(t.center) <= t.radius * t.radius
    }
    intersectsPlane(t) {
      let e, i;
      return t.normal.x > 0 ? (e = t.normal.x * this.min.x,
        i = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x,
          i = t.normal.x * this.min.x),
        t.normal.y > 0 ? (e += t.normal.y * this.min.y,
          i += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y,
            i += t.normal.y * this.min.y),
        t.normal.z > 0 ? (e += t.normal.z * this.min.z,
          i += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z,
            i += t.normal.z * this.min.z),
        e <= -t.constant && i >= -t.constant
    }
    intersectsTriangle(t) {
      if (this.isEmpty())
        return !1;
      this.getCenter(Si),
        Mi.subVectors(this.max, Si),
        bi.subVectors(t.a, Si),
        xi.subVectors(t.b, Si),
        Ii.subVectors(t.c, Si),
        Ci.subVectors(xi, bi),
        wi.subVectors(Ii, xi),
        _i.subVectors(bi, Ii);
      let e = [0, -Ci.z, Ci.y, 0, -wi.z, wi.y, 0, -_i.z, _i.y, Ci.z, 0, -Ci.x, wi.z, 0, -wi.x, _i.z, 0, -_i.x, -Ci.y, Ci.x, 0, -wi.y, wi.x, 0, -_i.y, _i.x, 0];
      return !!ki(e, bi, xi, Ii, Mi) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        !!ki(e, bi, xi, Ii, Mi) && (Ti.crossVectors(Ci, wi),
          e = [Ti.x, Ti.y, Ti.z],
          ki(e, bi, xi, Ii, Mi)))
    }
    clampPoint(t, e) {
      return e.copy(t).clamp(this.min, this.max)
    }
    distanceToPoint(t) {
      return vi.copy(t).clamp(this.min, this.max).sub(t).length()
    }
    getBoundingSphere(t) {
      return this.getCenter(t.center),
        t.radius = .5 * this.getSize(vi).length(),
        t
    }
    intersect(t) {
      return this.min.max(t.min),
        this.max.min(t.max),
        this.isEmpty() && this.makeEmpty(),
        this
    }
    union(t) {
      return this.min.min(t.min),
        this.max.max(t.max),
        this
    }
    applyMatrix4(t) {
      return this.isEmpty() || (yi[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
        yi[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
        yi[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
        yi[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
        yi[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
        yi[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
        yi[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
        yi[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
        this.setFromPoints(yi)),
        this
    }
    translate(t) {
      return this.min.add(t),
        this.max.add(t),
        this
    }
    equals(t) {
      return t.min.equals(this.min) && t.max.equals(this.max)
    }
  }
  const yi = [new di, new di, new di, new di, new di, new di, new di, new di]
    , vi = new di
    , Ai = new mi
    , bi = new di
    , xi = new di
    , Ii = new di
    , Ci = new di
    , wi = new di
    , _i = new di
    , Si = new di
    , Mi = new di
    , Ti = new di
    , Ei = new di;
  function ki(t, e, i, n, r) {
    for (let o = 0, s = t.length - 3; o <= s; o += 3) {
      Ei.fromArray(t, o);
      const s = r.x * Math.abs(Ei.x) + r.y * Math.abs(Ei.y) + r.z * Math.abs(Ei.z)
        , a = e.dot(Ei)
        , l = i.dot(Ei)
        , h = n.dot(Ei);
      if (Math.max(-Math.max(a, l, h), Math.min(a, l, h)) > s)
        return !1
    }
    return !0
  }
  const Ri = new mi
    , Li = new di
    , Pi = new di
    , zi = new di;
  class Oi {
    constructor(t = new di, e = -1) {
      this.center = t,
        this.radius = e
    }
    set(t, e) {
      return this.center.copy(t),
        this.radius = e,
        this
    }
    setFromPoints(t, e) {
      const i = this.center;
      void 0 !== e ? i.copy(e) : Ri.setFromPoints(t).getCenter(i);
      let n = 0;
      for (let e = 0, r = t.length; e < r; e++)
        n = Math.max(n, i.distanceToSquared(t[e]));
      return this.radius = Math.sqrt(n),
        this
    }
    copy(t) {
      return this.center.copy(t.center),
        this.radius = t.radius,
        this
    }
    isEmpty() {
      return this.radius < 0
    }
    makeEmpty() {
      return this.center.set(0, 0, 0),
        this.radius = -1,
        this
    }
    containsPoint(t) {
      return t.distanceToSquared(this.center) <= this.radius * this.radius
    }
    distanceToPoint(t) {
      return t.distanceTo(this.center) - this.radius
    }
    intersectsSphere(t) {
      const e = this.radius + t.radius;
      return t.center.distanceToSquared(this.center) <= e * e
    }
    intersectsBox(t) {
      return t.intersectsSphere(this)
    }
    intersectsPlane(t) {
      return Math.abs(t.distanceToPoint(this.center)) <= this.radius
    }
    clampPoint(t, e) {
      const i = this.center.distanceToSquared(t);
      return e.copy(t),
        i > this.radius * this.radius && (e.sub(this.center).normalize(),
          e.multiplyScalar(this.radius).add(this.center)),
        e
    }
    getBoundingBox(t) {
      return this.isEmpty() ? (t.makeEmpty(),
        t) : (t.set(this.center, this.center),
          t.expandByScalar(this.radius),
          t)
    }
    applyMatrix4(t) {
      return this.center.applyMatrix4(t),
        this.radius = this.radius * t.getMaxScaleOnAxis(),
        this
    }
    translate(t) {
      return this.center.add(t),
        this
    }
    expandByPoint(t) {
      zi.subVectors(t, this.center);
      const e = zi.lengthSq();
      if (e > this.radius * this.radius) {
        const t = Math.sqrt(e)
          , i = .5 * (t - this.radius);
        this.center.add(zi.multiplyScalar(i / t)),
          this.radius += i
      }
      return this
    }
    union(t) {
      return !0 === this.center.equals(t.center) ? Pi.set(0, 0, 1).multiplyScalar(t.radius) : Pi.subVectors(t.center, this.center).normalize().multiplyScalar(t.radius),
        this.expandByPoint(Li.copy(t.center).add(Pi)),
        this.expandByPoint(Li.copy(t.center).sub(Pi)),
        this
    }
    equals(t) {
      return t.center.equals(this.center) && t.radius === this.radius
    }
    clone() {
      return (new this.constructor).copy(this)
    }
  }
  const Di = new di
    , Ui = new di
    , Ni = new di
    , Fi = new di
    , Bi = new di
    , ji = new di
    , Vi = new di;
  class Gi {
    constructor(t = new di, e = new di(0, 0, -1)) {
      this.origin = t,
        this.direction = e
    }
    set(t, e) {
      return this.origin.copy(t),
        this.direction.copy(e),
        this
    }
    copy(t) {
      return this.origin.copy(t.origin),
        this.direction.copy(t.direction),
        this
    }
    at(t, e) {
      return e.copy(this.direction).multiplyScalar(t).add(this.origin)
    }
    lookAt(t) {
      return this.direction.copy(t).sub(this.origin).normalize(),
        this
    }
    recast(t) {
      return this.origin.copy(this.at(t, Di)),
        this
    }
    closestPointToPoint(t, e) {
      e.subVectors(t, this.origin);
      const i = e.dot(this.direction);
      return i < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(i).add(this.origin)
    }
    distanceToPoint(t) {
      return Math.sqrt(this.distanceSqToPoint(t))
    }
    distanceSqToPoint(t) {
      const e = Di.subVectors(t, this.origin).dot(this.direction);
      return e < 0 ? this.origin.distanceToSquared(t) : (Di.copy(this.direction).multiplyScalar(e).add(this.origin),
        Di.distanceToSquared(t))
    }
    distanceSqToSegment(t, e, i, n) {
      Ui.copy(t).add(e).multiplyScalar(.5),
        Ni.copy(e).sub(t).normalize(),
        Fi.copy(this.origin).sub(Ui);
      const r = .5 * t.distanceTo(e)
        , o = -this.direction.dot(Ni)
        , s = Fi.dot(this.direction)
        , a = -Fi.dot(Ni)
        , l = Fi.lengthSq()
        , h = Math.abs(1 - o * o);
      let c, u, p, d;
      if (h > 0)
        if (c = o * a - s,
          u = o * s - a,
          d = r * h,
          c >= 0)
          if (u >= -d)
            if (u <= d) {
              const t = 1 / h;
              c *= t,
                u *= t,
                p = c * (c + o * u + 2 * s) + u * (o * c + u + 2 * a) + l
            } else
              u = r,
                c = Math.max(0, -(o * u + s)),
                p = -c * c + u * (u + 2 * a) + l;
          else
            u = -r,
              c = Math.max(0, -(o * u + s)),
              p = -c * c + u * (u + 2 * a) + l;
        else
          u <= -d ? (c = Math.max(0, -(-o * r + s)),
            u = c > 0 ? -r : Math.min(Math.max(-r, -a), r),
            p = -c * c + u * (u + 2 * a) + l) : u <= d ? (c = 0,
              u = Math.min(Math.max(-r, -a), r),
              p = u * (u + 2 * a) + l) : (c = Math.max(0, -(o * r + s)),
                u = c > 0 ? r : Math.min(Math.max(-r, -a), r),
                p = -c * c + u * (u + 2 * a) + l);
      else
        u = o > 0 ? -r : r,
          c = Math.max(0, -(o * u + s)),
          p = -c * c + u * (u + 2 * a) + l;
      return i && i.copy(this.direction).multiplyScalar(c).add(this.origin),
        n && n.copy(Ni).multiplyScalar(u).add(Ui),
        p
    }
    intersectSphere(t, e) {
      Di.subVectors(t.center, this.origin);
      const i = Di.dot(this.direction)
        , n = Di.dot(Di) - i * i
        , r = t.radius * t.radius;
      if (n > r)
        return null;
      const o = Math.sqrt(r - n)
        , s = i - o
        , a = i + o;
      return s < 0 && a < 0 ? null : s < 0 ? this.at(a, e) : this.at(s, e)
    }
    intersectsSphere(t) {
      return this.distanceSqToPoint(t.center) <= t.radius * t.radius
    }
    distanceToPlane(t) {
      const e = t.normal.dot(this.direction);
      if (0 === e)
        return 0 === t.distanceToPoint(this.origin) ? 0 : null;
      const i = -(this.origin.dot(t.normal) + t.constant) / e;
      return i >= 0 ? i : null
    }
    intersectPlane(t, e) {
      const i = this.distanceToPlane(t);
      return null === i ? null : this.at(i, e)
    }
    intersectsPlane(t) {
      const e = t.distanceToPoint(this.origin);
      if (0 === e)
        return !0;
      return t.normal.dot(this.direction) * e < 0
    }
    intersectBox(t, e) {
      let i, n, r, o, s, a;
      const l = 1 / this.direction.x
        , h = 1 / this.direction.y
        , c = 1 / this.direction.z
        , u = this.origin;
      return l >= 0 ? (i = (t.min.x - u.x) * l,
        n = (t.max.x - u.x) * l) : (i = (t.max.x - u.x) * l,
          n = (t.min.x - u.x) * l),
        h >= 0 ? (r = (t.min.y - u.y) * h,
          o = (t.max.y - u.y) * h) : (r = (t.max.y - u.y) * h,
            o = (t.min.y - u.y) * h),
        i > o || r > n ? null : ((r > i || i != i) && (i = r),
          (o < n || n != n) && (n = o),
          c >= 0 ? (s = (t.min.z - u.z) * c,
            a = (t.max.z - u.z) * c) : (s = (t.max.z - u.z) * c,
              a = (t.min.z - u.z) * c),
          i > a || s > n ? null : ((s > i || i != i) && (i = s),
            (a < n || n != n) && (n = a),
            n < 0 ? null : this.at(i >= 0 ? i : n, e)))
    }
    intersectsBox(t) {
      return null !== this.intersectBox(t, Di)
    }
    intersectTriangle(t, e, i, n, r) {
      Bi.subVectors(e, t),
        ji.subVectors(i, t),
        Vi.crossVectors(Bi, ji);
      let o, s = this.direction.dot(Vi);
      if (s > 0) {
        if (n)
          return null;
        o = 1
      } else {
        if (!(s < 0))
          return null;
        o = -1,
          s = -s
      }
      Fi.subVectors(this.origin, t);
      const a = o * this.direction.dot(ji.crossVectors(Fi, ji));
      if (a < 0)
        return null;
      const l = o * this.direction.dot(Bi.cross(Fi));
      if (l < 0)
        return null;
      if (a + l > s)
        return null;
      const h = -o * Fi.dot(Vi);
      return h < 0 ? null : this.at(h / s, r)
    }
    applyMatrix4(t) {
      return this.origin.applyMatrix4(t),
        this.direction.transformDirection(t),
        this
    }
    equals(t) {
      return t.origin.equals(this.origin) && t.direction.equals(this.direction)
    }
    clone() {
      return (new this.constructor).copy(this)
    }
  }
  class Wi {
    constructor() {
      Wi.prototype.isMatrix4 = !0,
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
    }
    set(t, e, i, n, r, o, s, a, l, h, c, u, p, d, f, g) {
      const m = this.elements;
      return m[0] = t,
        m[4] = e,
        m[8] = i,
        m[12] = n,
        m[1] = r,
        m[5] = o,
        m[9] = s,
        m[13] = a,
        m[2] = l,
        m[6] = h,
        m[10] = c,
        m[14] = u,
        m[3] = p,
        m[7] = d,
        m[11] = f,
        m[15] = g,
        this
    }
    identity() {
      return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    clone() {
      return (new Wi).fromArray(this.elements)
    }
    copy(t) {
      const e = this.elements
        , i = t.elements;
      return e[0] = i[0],
        e[1] = i[1],
        e[2] = i[2],
        e[3] = i[3],
        e[4] = i[4],
        e[5] = i[5],
        e[6] = i[6],
        e[7] = i[7],
        e[8] = i[8],
        e[9] = i[9],
        e[10] = i[10],
        e[11] = i[11],
        e[12] = i[12],
        e[13] = i[13],
        e[14] = i[14],
        e[15] = i[15],
        this
    }
    copyPosition(t) {
      const e = this.elements
        , i = t.elements;
      return e[12] = i[12],
        e[13] = i[13],
        e[14] = i[14],
        this
    }
    setFromMatrix3(t) {
      const e = t.elements;
      return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1),
        this
    }
    extractBasis(t, e, i) {
      return t.setFromMatrixColumn(this, 0),
        e.setFromMatrixColumn(this, 1),
        i.setFromMatrixColumn(this, 2),
        this
    }
    makeBasis(t, e, i) {
      return this.set(t.x, e.x, i.x, 0, t.y, e.y, i.y, 0, t.z, e.z, i.z, 0, 0, 0, 0, 1),
        this
    }
    extractRotation(t) {
      const e = this.elements
        , i = t.elements
        , n = 1 / Ji.setFromMatrixColumn(t, 0).length()
        , r = 1 / Ji.setFromMatrixColumn(t, 1).length()
        , o = 1 / Ji.setFromMatrixColumn(t, 2).length();
      return e[0] = i[0] * n,
        e[1] = i[1] * n,
        e[2] = i[2] * n,
        e[3] = 0,
        e[4] = i[4] * r,
        e[5] = i[5] * r,
        e[6] = i[6] * r,
        e[7] = 0,
        e[8] = i[8] * o,
        e[9] = i[9] * o,
        e[10] = i[10] * o,
        e[11] = 0,
        e[12] = 0,
        e[13] = 0,
        e[14] = 0,
        e[15] = 1,
        this
    }
    makeRotationFromEuler(t) {
      t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
      const e = this.elements
        , i = t.x
        , n = t.y
        , r = t.z
        , o = Math.cos(i)
        , s = Math.sin(i)
        , a = Math.cos(n)
        , l = Math.sin(n)
        , h = Math.cos(r)
        , c = Math.sin(r);
      if ("XYZ" === t.order) {
        const t = o * h
          , i = o * c
          , n = s * h
          , r = s * c;
        e[0] = a * h,
          e[4] = -a * c,
          e[8] = l,
          e[1] = i + n * l,
          e[5] = t - r * l,
          e[9] = -s * a,
          e[2] = r - t * l,
          e[6] = n + i * l,
          e[10] = o * a
      } else if ("YXZ" === t.order) {
        const t = a * h
          , i = a * c
          , n = l * h
          , r = l * c;
        e[0] = t + r * s,
          e[4] = n * s - i,
          e[8] = o * l,
          e[1] = o * c,
          e[5] = o * h,
          e[9] = -s,
          e[2] = i * s - n,
          e[6] = r + t * s,
          e[10] = o * a
      } else if ("ZXY" === t.order) {
        const t = a * h
          , i = a * c
          , n = l * h
          , r = l * c;
        e[0] = t - r * s,
          e[4] = -o * c,
          e[8] = n + i * s,
          e[1] = i + n * s,
          e[5] = o * h,
          e[9] = r - t * s,
          e[2] = -o * l,
          e[6] = s,
          e[10] = o * a
      } else if ("ZYX" === t.order) {
        const t = o * h
          , i = o * c
          , n = s * h
          , r = s * c;
        e[0] = a * h,
          e[4] = n * l - i,
          e[8] = t * l + r,
          e[1] = a * c,
          e[5] = r * l + t,
          e[9] = i * l - n,
          e[2] = -l,
          e[6] = s * a,
          e[10] = o * a
      } else if ("YZX" === t.order) {
        const t = o * a
          , i = o * l
          , n = s * a
          , r = s * l;
        e[0] = a * h,
          e[4] = r - t * c,
          e[8] = n * c + i,
          e[1] = c,
          e[5] = o * h,
          e[9] = -s * h,
          e[2] = -l * h,
          e[6] = i * c + n,
          e[10] = t - r * c
      } else if ("XZY" === t.order) {
        const t = o * a
          , i = o * l
          , n = s * a
          , r = s * l;
        e[0] = a * h,
          e[4] = -c,
          e[8] = l * h,
          e[1] = t * c + r,
          e[5] = o * h,
          e[9] = i * c - n,
          e[2] = n * c - i,
          e[6] = s * h,
          e[10] = r * c + t
      }
      return e[3] = 0,
        e[7] = 0,
        e[11] = 0,
        e[12] = 0,
        e[13] = 0,
        e[14] = 0,
        e[15] = 1,
        this
    }
    makeRotationFromQuaternion(t) {
      return this.compose(Zi, t, Qi)
    }
    lookAt(t, e, i) {
      const n = this.elements;
      return qi.subVectors(t, e),
        0 === qi.lengthSq() && (qi.z = 1),
        qi.normalize(),
        Ki.crossVectors(i, qi),
        0 === Ki.lengthSq() && (1 === Math.abs(i.z) ? qi.x += 1e-4 : qi.z += 1e-4,
          qi.normalize(),
          Ki.crossVectors(i, qi)),
        Ki.normalize(),
        Yi.crossVectors(qi, Ki),
        n[0] = Ki.x,
        n[4] = Yi.x,
        n[8] = qi.x,
        n[1] = Ki.y,
        n[5] = Yi.y,
        n[9] = qi.y,
        n[2] = Ki.z,
        n[6] = Yi.z,
        n[10] = qi.z,
        this
    }
    multiply(t, e) {
      return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),
        this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
    }
    premultiply(t) {
      return this.multiplyMatrices(t, this)
    }
    multiplyMatrices(t, e) {
      const i = t.elements
        , n = e.elements
        , r = this.elements
        , o = i[0]
        , s = i[4]
        , a = i[8]
        , l = i[12]
        , h = i[1]
        , c = i[5]
        , u = i[9]
        , p = i[13]
        , d = i[2]
        , f = i[6]
        , g = i[10]
        , m = i[14]
        , y = i[3]
        , v = i[7]
        , A = i[11]
        , b = i[15]
        , x = n[0]
        , I = n[4]
        , C = n[8]
        , w = n[12]
        , _ = n[1]
        , S = n[5]
        , M = n[9]
        , T = n[13]
        , E = n[2]
        , k = n[6]
        , R = n[10]
        , L = n[14]
        , P = n[3]
        , z = n[7]
        , O = n[11]
        , D = n[15];
      return r[0] = o * x + s * _ + a * E + l * P,
        r[4] = o * I + s * S + a * k + l * z,
        r[8] = o * C + s * M + a * R + l * O,
        r[12] = o * w + s * T + a * L + l * D,
        r[1] = h * x + c * _ + u * E + p * P,
        r[5] = h * I + c * S + u * k + p * z,
        r[9] = h * C + c * M + u * R + p * O,
        r[13] = h * w + c * T + u * L + p * D,
        r[2] = d * x + f * _ + g * E + m * P,
        r[6] = d * I + f * S + g * k + m * z,
        r[10] = d * C + f * M + g * R + m * O,
        r[14] = d * w + f * T + g * L + m * D,
        r[3] = y * x + v * _ + A * E + b * P,
        r[7] = y * I + v * S + A * k + b * z,
        r[11] = y * C + v * M + A * R + b * O,
        r[15] = y * w + v * T + A * L + b * D,
        this
    }
    multiplyScalar(t) {
      const e = this.elements;
      return e[0] *= t,
        e[4] *= t,
        e[8] *= t,
        e[12] *= t,
        e[1] *= t,
        e[5] *= t,
        e[9] *= t,
        e[13] *= t,
        e[2] *= t,
        e[6] *= t,
        e[10] *= t,
        e[14] *= t,
        e[3] *= t,
        e[7] *= t,
        e[11] *= t,
        e[15] *= t,
        this
    }
    determinant() {
      const t = this.elements
        , e = t[0]
        , i = t[4]
        , n = t[8]
        , r = t[12]
        , o = t[1]
        , s = t[5]
        , a = t[9]
        , l = t[13]
        , h = t[2]
        , c = t[6]
        , u = t[10]
        , p = t[14];
      return t[3] * (+r * a * c - n * l * c - r * s * u + i * l * u + n * s * p - i * a * p) + t[7] * (+e * a * p - e * l * u + r * o * u - n * o * p + n * l * h - r * a * h) + t[11] * (+e * l * c - e * s * p - r * o * c + i * o * p + r * s * h - i * l * h) + t[15] * (-n * s * h - e * a * c + e * s * u + n * o * c - i * o * u + i * a * h)
    }
    transpose() {
      const t = this.elements;
      let e;
      return e = t[1],
        t[1] = t[4],
        t[4] = e,
        e = t[2],
        t[2] = t[8],
        t[8] = e,
        e = t[6],
        t[6] = t[9],
        t[9] = e,
        e = t[3],
        t[3] = t[12],
        t[12] = e,
        e = t[7],
        t[7] = t[13],
        t[13] = e,
        e = t[11],
        t[11] = t[14],
        t[14] = e,
        this
    }
    setPosition(t, e, i) {
      const n = this.elements;
      return t.isVector3 ? (n[12] = t.x,
        n[13] = t.y,
        n[14] = t.z) : (n[12] = t,
          n[13] = e,
          n[14] = i),
        this
    }
    invert() {
      const t = this.elements
        , e = t[0]
        , i = t[1]
        , n = t[2]
        , r = t[3]
        , o = t[4]
        , s = t[5]
        , a = t[6]
        , l = t[7]
        , h = t[8]
        , c = t[9]
        , u = t[10]
        , p = t[11]
        , d = t[12]
        , f = t[13]
        , g = t[14]
        , m = t[15]
        , y = c * g * l - f * u * l + f * a * p - s * g * p - c * a * m + s * u * m
        , v = d * u * l - h * g * l - d * a * p + o * g * p + h * a * m - o * u * m
        , A = h * f * l - d * c * l + d * s * p - o * f * p - h * s * m + o * c * m
        , b = d * c * a - h * f * a - d * s * u + o * f * u + h * s * g - o * c * g
        , x = e * y + i * v + n * A + r * b;
      if (0 === x)
        return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      const I = 1 / x;
      return t[0] = y * I,
        t[1] = (f * u * r - c * g * r - f * n * p + i * g * p + c * n * m - i * u * m) * I,
        t[2] = (s * g * r - f * a * r + f * n * l - i * g * l - s * n * m + i * a * m) * I,
        t[3] = (c * a * r - s * u * r - c * n * l + i * u * l + s * n * p - i * a * p) * I,
        t[4] = v * I,
        t[5] = (h * g * r - d * u * r + d * n * p - e * g * p - h * n * m + e * u * m) * I,
        t[6] = (d * a * r - o * g * r - d * n * l + e * g * l + o * n * m - e * a * m) * I,
        t[7] = (o * u * r - h * a * r + h * n * l - e * u * l - o * n * p + e * a * p) * I,
        t[8] = A * I,
        t[9] = (d * c * r - h * f * r - d * i * p + e * f * p + h * i * m - e * c * m) * I,
        t[10] = (o * f * r - d * s * r + d * i * l - e * f * l - o * i * m + e * s * m) * I,
        t[11] = (h * s * r - o * c * r - h * i * l + e * c * l + o * i * p - e * s * p) * I,
        t[12] = b * I,
        t[13] = (h * f * n - d * c * n + d * i * u - e * f * u - h * i * g + e * c * g) * I,
        t[14] = (d * s * n - o * f * n - d * i * a + e * f * a + o * i * g - e * s * g) * I,
        t[15] = (o * c * n - h * s * n + h * i * a - e * c * a - o * i * u + e * s * u) * I,
        this
    }
    scale(t) {
      const e = this.elements
        , i = t.x
        , n = t.y
        , r = t.z;
      return e[0] *= i,
        e[4] *= n,
        e[8] *= r,
        e[1] *= i,
        e[5] *= n,
        e[9] *= r,
        e[2] *= i,
        e[6] *= n,
        e[10] *= r,
        e[3] *= i,
        e[7] *= n,
        e[11] *= r,
        this
    }
    getMaxScaleOnAxis() {
      const t = this.elements
        , e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2]
        , i = t[4] * t[4] + t[5] * t[5] + t[6] * t[6]
        , n = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
      return Math.sqrt(Math.max(e, i, n))
    }
    makeTranslation(t, e, i) {
      return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1),
        this
    }
    makeRotationX(t) {
      const e = Math.cos(t)
        , i = Math.sin(t);
      return this.set(1, 0, 0, 0, 0, e, -i, 0, 0, i, e, 0, 0, 0, 0, 1),
        this
    }
    makeRotationY(t) {
      const e = Math.cos(t)
        , i = Math.sin(t);
      return this.set(e, 0, i, 0, 0, 1, 0, 0, -i, 0, e, 0, 0, 0, 0, 1),
        this
    }
    makeRotationZ(t) {
      const e = Math.cos(t)
        , i = Math.sin(t);
      return this.set(e, -i, 0, 0, i, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    makeRotationAxis(t, e) {
      const i = Math.cos(e)
        , n = Math.sin(e)
        , r = 1 - i
        , o = t.x
        , s = t.y
        , a = t.z
        , l = r * o
        , h = r * s;
      return this.set(l * o + i, l * s - n * a, l * a + n * s, 0, l * s + n * a, h * s + i, h * a - n * o, 0, l * a - n * s, h * a + n * o, r * a * a + i, 0, 0, 0, 0, 1),
        this
    }
    makeScale(t, e, i) {
      return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1),
        this
    }
    makeShear(t, e, i, n, r, o) {
      return this.set(1, i, r, 0, t, 1, o, 0, e, n, 1, 0, 0, 0, 0, 1),
        this
    }
    compose(t, e, i) {
      const n = this.elements
        , r = e._x
        , o = e._y
        , s = e._z
        , a = e._w
        , l = r + r
        , h = o + o
        , c = s + s
        , u = r * l
        , p = r * h
        , d = r * c
        , f = o * h
        , g = o * c
        , m = s * c
        , y = a * l
        , v = a * h
        , A = a * c
        , b = i.x
        , x = i.y
        , I = i.z;
      return n[0] = (1 - (f + m)) * b,
        n[1] = (p + A) * b,
        n[2] = (d - v) * b,
        n[3] = 0,
        n[4] = (p - A) * x,
        n[5] = (1 - (u + m)) * x,
        n[6] = (g + y) * x,
        n[7] = 0,
        n[8] = (d + v) * I,
        n[9] = (g - y) * I,
        n[10] = (1 - (u + f)) * I,
        n[11] = 0,
        n[12] = t.x,
        n[13] = t.y,
        n[14] = t.z,
        n[15] = 1,
        this
    }
    decompose(t, e, i) {
      const n = this.elements;
      let r = Ji.set(n[0], n[1], n[2]).length();
      const o = Ji.set(n[4], n[5], n[6]).length()
        , s = Ji.set(n[8], n[9], n[10]).length();
      this.determinant() < 0 && (r = -r),
        t.x = n[12],
        t.y = n[13],
        t.z = n[14],
        Hi.copy(this);
      const a = 1 / r
        , l = 1 / o
        , h = 1 / s;
      return Hi.elements[0] *= a,
        Hi.elements[1] *= a,
        Hi.elements[2] *= a,
        Hi.elements[4] *= l,
        Hi.elements[5] *= l,
        Hi.elements[6] *= l,
        Hi.elements[8] *= h,
        Hi.elements[9] *= h,
        Hi.elements[10] *= h,
        e.setFromRotationMatrix(Hi),
        i.x = r,
        i.y = o,
        i.z = s,
        this
    }
    makePerspective(t, e, i, n, r, o) {
      void 0 === o && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
      const s = this.elements
        , a = 2 * r / (e - t)
        , l = 2 * r / (i - n)
        , h = (e + t) / (e - t)
        , c = (i + n) / (i - n)
        , u = -(o + r) / (o - r)
        , p = -2 * o * r / (o - r);
      return s[0] = a,
        s[4] = 0,
        s[8] = h,
        s[12] = 0,
        s[1] = 0,
        s[5] = l,
        s[9] = c,
        s[13] = 0,
        s[2] = 0,
        s[6] = 0,
        s[10] = u,
        s[14] = p,
        s[3] = 0,
        s[7] = 0,
        s[11] = -1,
        s[15] = 0,
        this
    }
    makeOrthographic(t, e, i, n, r, o) {
      const s = this.elements
        , a = 1 / (e - t)
        , l = 1 / (i - n)
        , h = 1 / (o - r)
        , c = (e + t) * a
        , u = (i + n) * l
        , p = (o + r) * h;
      return s[0] = 2 * a,
        s[4] = 0,
        s[8] = 0,
        s[12] = -c,
        s[1] = 0,
        s[5] = 2 * l,
        s[9] = 0,
        s[13] = -u,
        s[2] = 0,
        s[6] = 0,
        s[10] = -2 * h,
        s[14] = -p,
        s[3] = 0,
        s[7] = 0,
        s[11] = 0,
        s[15] = 1,
        this
    }
    equals(t) {
      const e = this.elements
        , i = t.elements;
      for (let t = 0; t < 16; t++)
        if (e[t] !== i[t])
          return !1;
      return !0
    }
    fromArray(t, e = 0) {
      for (let i = 0; i < 16; i++)
        this.elements[i] = t[i + e];
      return this
    }
    toArray(t = [], e = 0) {
      const i = this.elements;
      return t[e] = i[0],
        t[e + 1] = i[1],
        t[e + 2] = i[2],
        t[e + 3] = i[3],
        t[e + 4] = i[4],
        t[e + 5] = i[5],
        t[e + 6] = i[6],
        t[e + 7] = i[7],
        t[e + 8] = i[8],
        t[e + 9] = i[9],
        t[e + 10] = i[10],
        t[e + 11] = i[11],
        t[e + 12] = i[12],
        t[e + 13] = i[13],
        t[e + 14] = i[14],
        t[e + 15] = i[15],
        t
    }
  }
  const Ji = new di
    , Hi = new Wi
    , Zi = new di(0, 0, 0)
    , Qi = new di(1, 1, 1)
    , Ki = new di
    , Yi = new di
    , qi = new di
    , Xi = new Wi
    , $i = new pi;
  class tn {
    constructor(t = 0, e = 0, i = 0, n = tn.DefaultOrder) {
      this.isEuler = !0,
        this._x = t,
        this._y = e,
        this._z = i,
        this._order = n
    }
    get x() {
      return this._x
    }
    set x(t) {
      this._x = t,
        this._onChangeCallback()
    }
    get y() {
      return this._y
    }
    set y(t) {
      this._y = t,
        this._onChangeCallback()
    }
    get z() {
      return this._z
    }
    set z(t) {
      this._z = t,
        this._onChangeCallback()
    }
    get order() {
      return this._order
    }
    set order(t) {
      this._order = t,
        this._onChangeCallback()
    }
    set(t, e, i, n = this._order) {
      return this._x = t,
        this._y = e,
        this._z = i,
        this._order = n,
        this._onChangeCallback(),
        this
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._order)
    }
    copy(t) {
      return this._x = t._x,
        this._y = t._y,
        this._z = t._z,
        this._order = t._order,
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(t, e = this._order, i = !0) {
      const n = t.elements
        , r = n[0]
        , o = n[4]
        , s = n[8]
        , a = n[1]
        , l = n[5]
        , h = n[9]
        , c = n[2]
        , u = n[6]
        , p = n[10];
      switch (e) {
        case "XYZ":
          this._y = Math.asin(Le(s, -1, 1)),
            Math.abs(s) < .9999999 ? (this._x = Math.atan2(-h, p),
              this._z = Math.atan2(-o, r)) : (this._x = Math.atan2(u, l),
                this._z = 0);
          break;
        case "YXZ":
          this._x = Math.asin(-Le(h, -1, 1)),
            Math.abs(h) < .9999999 ? (this._y = Math.atan2(s, p),
              this._z = Math.atan2(a, l)) : (this._y = Math.atan2(-c, r),
                this._z = 0);
          break;
        case "ZXY":
          this._x = Math.asin(Le(u, -1, 1)),
            Math.abs(u) < .9999999 ? (this._y = Math.atan2(-c, p),
              this._z = Math.atan2(-o, l)) : (this._y = 0,
                this._z = Math.atan2(a, r));
          break;
        case "ZYX":
          this._y = Math.asin(-Le(c, -1, 1)),
            Math.abs(c) < .9999999 ? (this._x = Math.atan2(u, p),
              this._z = Math.atan2(a, r)) : (this._x = 0,
                this._z = Math.atan2(-o, l));
          break;
        case "YZX":
          this._z = Math.asin(Le(a, -1, 1)),
            Math.abs(a) < .9999999 ? (this._x = Math.atan2(-h, l),
              this._y = Math.atan2(-c, r)) : (this._x = 0,
                this._y = Math.atan2(s, p));
          break;
        case "XZY":
          this._z = Math.asin(-Le(o, -1, 1)),
            Math.abs(o) < .9999999 ? (this._x = Math.atan2(u, l),
              this._y = Math.atan2(s, r)) : (this._x = Math.atan2(-h, p),
                this._y = 0);
          break;
        default:
          console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
      }
      return this._order = e,
        !0 === i && this._onChangeCallback(),
        this
    }
    setFromQuaternion(t, e, i) {
      return Xi.makeRotationFromQuaternion(t),
        this.setFromRotationMatrix(Xi, e, i)
    }
    setFromVector3(t, e = this._order) {
      return this.set(t.x, t.y, t.z, e)
    }
    reorder(t) {
      return $i.setFromEuler(this),
        this.setFromQuaternion($i, t)
    }
    equals(t) {
      return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
    }
    fromArray(t) {
      return this._x = t[0],
        this._y = t[1],
        this._z = t[2],
        void 0 !== t[3] && (this._order = t[3]),
        this._onChangeCallback(),
        this
    }
    toArray(t = [], e = 0) {
      return t[e] = this._x,
        t[e + 1] = this._y,
        t[e + 2] = this._z,
        t[e + 3] = this._order,
        t
    }
    _onChange(t) {
      return this._onChangeCallback = t,
        this
    }
    _onChangeCallback() { }
    *[Symbol.iterator]() {
      yield this._x,
        yield this._y,
        yield this._z,
        yield this._order
    }
    toVector3() {
      console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead")
    }
  }
  tn.DefaultOrder = "XYZ",
    tn.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
  class en {
    constructor() {
      this.mask = 1
    }
    set(t) {
      this.mask = (1 << t | 0) >>> 0
    }
    enable(t) {
      this.mask |= 1 << t | 0
    }
    enableAll() {
      this.mask = -1
    }
    toggle(t) {
      this.mask ^= 1 << t | 0
    }
    disable(t) {
      this.mask &= ~(1 << t | 0)
    }
    disableAll() {
      this.mask = 0
    }
    test(t) {
      return 0 != (this.mask & t.mask)
    }
    isEnabled(t) {
      return 0 != (this.mask & (1 << t | 0))
    }
  }
  let nn = 0;
  const rn = new di
    , on = new pi
    , sn = new Wi
    , an = new di
    , ln = new di
    , hn = new di
    , cn = new pi
    , un = new di(1, 0, 0)
    , pn = new di(0, 1, 0)
    , dn = new di(0, 0, 1)
    , fn = {
      type: "added"
    }
    , gn = {
      type: "removed"
    };
  class mn extends Se {
    constructor() {
      super(),
        this.isObject3D = !0,
        Object.defineProperty(this, "id", {
          value: nn++
        }),
        this.uuid = Re(),
        this.name = "",
        this.type = "Object3D",
        this.parent = null,
        this.children = [],
        this.up = mn.DefaultUp.clone();
      const t = new di
        , e = new tn
        , i = new pi
        , n = new di(1, 1, 1);
      e._onChange((function () {
        i.setFromEuler(e, !1)
      }
      )),
        i._onChange((function () {
          e.setFromQuaternion(i, void 0, !1)
        }
        )),
        Object.defineProperties(this, {
          position: {
            configurable: !0,
            enumerable: !0,
            value: t
          },
          rotation: {
            configurable: !0,
            enumerable: !0,
            value: e
          },
          quaternion: {
            configurable: !0,
            enumerable: !0,
            value: i
          },
          scale: {
            configurable: !0,
            enumerable: !0,
            value: n
          },
          modelViewMatrix: {
            value: new Wi
          },
          normalMatrix: {
            value: new Be
          }
        }),
        this.matrix = new Wi,
        this.matrixWorld = new Wi,
        this.matrixAutoUpdate = mn.DefaultMatrixAutoUpdate,
        this.matrixWorldNeedsUpdate = !1,
        this.layers = new en,
        this.visible = !0,
        this.castShadow = !1,
        this.receiveShadow = !1,
        this.frustumCulled = !0,
        this.renderOrder = 0,
        this.animations = [],
        this.userData = {}
    }
    onBeforeRender() { }
    onAfterRender() { }
    applyMatrix4(t) {
      this.matrixAutoUpdate && this.updateMatrix(),
        this.matrix.premultiply(t),
        this.matrix.decompose(this.position, this.quaternion, this.scale)
    }
    applyQuaternion(t) {
      return this.quaternion.premultiply(t),
        this
    }
    setRotationFromAxisAngle(t, e) {
      this.quaternion.setFromAxisAngle(t, e)
    }
    setRotationFromEuler(t) {
      this.quaternion.setFromEuler(t, !0)
    }
    setRotationFromMatrix(t) {
      this.quaternion.setFromRotationMatrix(t)
    }
    setRotationFromQuaternion(t) {
      this.quaternion.copy(t)
    }
    rotateOnAxis(t, e) {
      return on.setFromAxisAngle(t, e),
        this.quaternion.multiply(on),
        this
    }
    rotateOnWorldAxis(t, e) {
      return on.setFromAxisAngle(t, e),
        this.quaternion.premultiply(on),
        this
    }
    rotateX(t) {
      return this.rotateOnAxis(un, t)
    }
    rotateY(t) {
      return this.rotateOnAxis(pn, t)
    }
    rotateZ(t) {
      return this.rotateOnAxis(dn, t)
    }
    translateOnAxis(t, e) {
      return rn.copy(t).applyQuaternion(this.quaternion),
        this.position.add(rn.multiplyScalar(e)),
        this
    }
    translateX(t) {
      return this.translateOnAxis(un, t)
    }
    translateY(t) {
      return this.translateOnAxis(pn, t)
    }
    translateZ(t) {
      return this.translateOnAxis(dn, t)
    }
    localToWorld(t) {
      return t.applyMatrix4(this.matrixWorld)
    }
    worldToLocal(t) {
      return t.applyMatrix4(sn.copy(this.matrixWorld).invert())
    }
    lookAt(t, e, i) {
      t.isVector3 ? an.copy(t) : an.set(t, e, i);
      const n = this.parent;
      this.updateWorldMatrix(!0, !1),
        ln.setFromMatrixPosition(this.matrixWorld),
        this.isCamera || this.isLight ? sn.lookAt(ln, an, this.up) : sn.lookAt(an, ln, this.up),
        this.quaternion.setFromRotationMatrix(sn),
        n && (sn.extractRotation(n.matrixWorld),
          on.setFromRotationMatrix(sn),
          this.quaternion.premultiply(on.invert()))
    }
    add(t) {
      if (arguments.length > 1) {
        for (let t = 0; t < arguments.length; t++)
          this.add(arguments[t]);
        return this
      }
      return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t),
        this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t),
          t.parent = this,
          this.children.push(t),
          t.dispatchEvent(fn)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t),
          this)
    }
    remove(t) {
      if (arguments.length > 1) {
        for (let t = 0; t < arguments.length; t++)
          this.remove(arguments[t]);
        return this
      }
      const e = this.children.indexOf(t);
      return -1 !== e && (t.parent = null,
        this.children.splice(e, 1),
        t.dispatchEvent(gn)),
        this
    }
    removeFromParent() {
      const t = this.parent;
      return null !== t && t.remove(this),
        this
    }
    clear() {
      for (let t = 0; t < this.children.length; t++) {
        const e = this.children[t];
        e.parent = null,
          e.dispatchEvent(gn)
      }
      return this.children.length = 0,
        this
    }
    attach(t) {
      return this.updateWorldMatrix(!0, !1),
        sn.copy(this.matrixWorld).invert(),
        null !== t.parent && (t.parent.updateWorldMatrix(!0, !1),
          sn.multiply(t.parent.matrixWorld)),
        t.applyMatrix4(sn),
        this.add(t),
        t.updateWorldMatrix(!1, !0),
        this
    }
    getObjectById(t) {
      return this.getObjectByProperty("id", t)
    }
    getObjectByName(t) {
      return this.getObjectByProperty("name", t)
    }
    getObjectByProperty(t, e) {
      if (this[t] === e)
        return this;
      for (let i = 0, n = this.children.length; i < n; i++) {
        const n = this.children[i].getObjectByProperty(t, e);
        if (void 0 !== n)
          return n
      }
    }
    getWorldPosition(t) {
      return this.updateWorldMatrix(!0, !1),
        t.setFromMatrixPosition(this.matrixWorld)
    }
    getWorldQuaternion(t) {
      return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(ln, t, hn),
        t
    }
    getWorldScale(t) {
      return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(ln, cn, t),
        t
    }
    getWorldDirection(t) {
      this.updateWorldMatrix(!0, !1);
      const e = this.matrixWorld.elements;
      return t.set(e[8], e[9], e[10]).normalize()
    }
    raycast() { }
    traverse(t) {
      t(this);
      const e = this.children;
      for (let i = 0, n = e.length; i < n; i++)
        e[i].traverse(t)
    }
    traverseVisible(t) {
      if (!1 === this.visible)
        return;
      t(this);
      const e = this.children;
      for (let i = 0, n = e.length; i < n; i++)
        e[i].traverseVisible(t)
    }
    traverseAncestors(t) {
      const e = this.parent;
      null !== e && (t(e),
        e.traverseAncestors(t))
    }
    updateMatrix() {
      this.matrix.compose(this.position, this.quaternion, this.scale),
        this.matrixWorldNeedsUpdate = !0
    }
    updateMatrixWorld(t) {
      this.matrixAutoUpdate && this.updateMatrix(),
        (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
          this.matrixWorldNeedsUpdate = !1,
          t = !0);
      const e = this.children;
      for (let i = 0, n = e.length; i < n; i++)
        e[i].updateMatrixWorld(t)
    }
    updateWorldMatrix(t, e) {
      const i = this.parent;
      if (!0 === t && null !== i && i.updateWorldMatrix(!0, !1),
        this.matrixAutoUpdate && this.updateMatrix(),
        null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
        !0 === e) {
        const t = this.children;
        for (let e = 0, i = t.length; e < i; e++)
          t[e].updateWorldMatrix(!1, !0)
      }
    }
    toJSON(t) {
      const e = void 0 === t || "string" == typeof t
        , i = {};
      e && (t = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {}
      },
        i.metadata = {
          version: 4.5,
          type: "Object",
          generator: "Object3D.toJSON"
        });
      const n = {};
      function r(e, i) {
        return void 0 === e[i.uuid] && (e[i.uuid] = i.toJSON(t)),
          i.uuid
      }
      if (n.uuid = this.uuid,
        n.type = this.type,
        "" !== this.name && (n.name = this.name),
        !0 === this.castShadow && (n.castShadow = !0),
        !0 === this.receiveShadow && (n.receiveShadow = !0),
        !1 === this.visible && (n.visible = !1),
        !1 === this.frustumCulled && (n.frustumCulled = !1),
        0 !== this.renderOrder && (n.renderOrder = this.renderOrder),
        "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData),
        n.layers = this.layers.mask,
        n.matrix = this.matrix.toArray(),
        !1 === this.matrixAutoUpdate && (n.matrixAutoUpdate = !1),
        this.isInstancedMesh && (n.type = "InstancedMesh",
          n.count = this.count,
          n.instanceMatrix = this.instanceMatrix.toJSON(),
          null !== this.instanceColor && (n.instanceColor = this.instanceColor.toJSON())),
        this.isScene)
        this.background && (this.background.isColor ? n.background = this.background.toJSON() : this.background.isTexture && (n.background = this.background.toJSON(t).uuid)),
          this.environment && this.environment.isTexture && (n.environment = this.environment.toJSON(t).uuid);
      else if (this.isMesh || this.isLine || this.isPoints) {
        n.geometry = r(t.geometries, this.geometry);
        const e = this.geometry.parameters;
        if (void 0 !== e && void 0 !== e.shapes) {
          const i = e.shapes;
          if (Array.isArray(i))
            for (let e = 0, n = i.length; e < n; e++) {
              const n = i[e];
              r(t.shapes, n)
            }
          else
            r(t.shapes, i)
        }
      }
      if (this.isSkinnedMesh && (n.bindMode = this.bindMode,
        n.bindMatrix = this.bindMatrix.toArray(),
        void 0 !== this.skeleton && (r(t.skeletons, this.skeleton),
          n.skeleton = this.skeleton.uuid)),
        void 0 !== this.material)
        if (Array.isArray(this.material)) {
          const e = [];
          for (let i = 0, n = this.material.length; i < n; i++)
            e.push(r(t.materials, this.material[i]));
          n.material = e
        } else
          n.material = r(t.materials, this.material);
      if (this.children.length > 0) {
        n.children = [];
        for (let e = 0; e < this.children.length; e++)
          n.children.push(this.children[e].toJSON(t).object)
      }
      if (this.animations.length > 0) {
        n.animations = [];
        for (let e = 0; e < this.animations.length; e++) {
          const i = this.animations[e];
          n.animations.push(r(t.animations, i))
        }
      }
      if (e) {
        const e = o(t.geometries)
          , n = o(t.materials)
          , r = o(t.textures)
          , s = o(t.images)
          , a = o(t.shapes)
          , l = o(t.skeletons)
          , h = o(t.animations)
          , c = o(t.nodes);
        e.length > 0 && (i.geometries = e),
          n.length > 0 && (i.materials = n),
          r.length > 0 && (i.textures = r),
          s.length > 0 && (i.images = s),
          a.length > 0 && (i.shapes = a),
          l.length > 0 && (i.skeletons = l),
          h.length > 0 && (i.animations = h),
          c.length > 0 && (i.nodes = c)
      }
      return i.object = n,
        i;
      function o(t) {
        const e = [];
        for (const i in t) {
          const n = t[i];
          delete n.metadata,
            e.push(n)
        }
        return e
      }
    }
    clone(t) {
      return (new this.constructor).copy(this, t)
    }
    copy(t, e = !0) {
      if (this.name = t.name,
        this.up.copy(t.up),
        this.position.copy(t.position),
        this.rotation.order = t.rotation.order,
        this.quaternion.copy(t.quaternion),
        this.scale.copy(t.scale),
        this.matrix.copy(t.matrix),
        this.matrixWorld.copy(t.matrixWorld),
        this.matrixAutoUpdate = t.matrixAutoUpdate,
        this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate,
        this.layers.mask = t.layers.mask,
        this.visible = t.visible,
        this.castShadow = t.castShadow,
        this.receiveShadow = t.receiveShadow,
        this.frustumCulled = t.frustumCulled,
        this.renderOrder = t.renderOrder,
        this.userData = JSON.parse(JSON.stringify(t.userData)),
        !0 === e)
        for (let e = 0; e < t.children.length; e++) {
          const i = t.children[e];
          this.add(i.clone())
        }
      return this
    }
  }
  mn.DefaultUp = new di(0, 1, 0),
    mn.DefaultMatrixAutoUpdate = !0;
  const yn = new di
    , vn = new di
    , An = new di
    , bn = new di
    , xn = new di
    , In = new di
    , Cn = new di
    , wn = new di
    , _n = new di
    , Sn = new di;
  class Mn {
    constructor(t = new di, e = new di, i = new di) {
      this.a = t,
        this.b = e,
        this.c = i
    }
    static getNormal(t, e, i, n) {
      n.subVectors(i, e),
        yn.subVectors(t, e),
        n.cross(yn);
      const r = n.lengthSq();
      return r > 0 ? n.multiplyScalar(1 / Math.sqrt(r)) : n.set(0, 0, 0)
    }
    static getBarycoord(t, e, i, n, r) {
      yn.subVectors(n, e),
        vn.subVectors(i, e),
        An.subVectors(t, e);
      const o = yn.dot(yn)
        , s = yn.dot(vn)
        , a = yn.dot(An)
        , l = vn.dot(vn)
        , h = vn.dot(An)
        , c = o * l - s * s;
      if (0 === c)
        return r.set(-2, -1, -1);
      const u = 1 / c
        , p = (l * a - s * h) * u
        , d = (o * h - s * a) * u;
      return r.set(1 - p - d, d, p)
    }
    static containsPoint(t, e, i, n) {
      return this.getBarycoord(t, e, i, n, bn),
        bn.x >= 0 && bn.y >= 0 && bn.x + bn.y <= 1
    }
    static getUV(t, e, i, n, r, o, s, a) {
      return this.getBarycoord(t, e, i, n, bn),
        a.set(0, 0),
        a.addScaledVector(r, bn.x),
        a.addScaledVector(o, bn.y),
        a.addScaledVector(s, bn.z),
        a
    }
    static isFrontFacing(t, e, i, n) {
      return yn.subVectors(i, e),
        vn.subVectors(t, e),
        yn.cross(vn).dot(n) < 0
    }
    set(t, e, i) {
      return this.a.copy(t),
        this.b.copy(e),
        this.c.copy(i),
        this
    }
    setFromPointsAndIndices(t, e, i, n) {
      return this.a.copy(t[e]),
        this.b.copy(t[i]),
        this.c.copy(t[n]),
        this
    }
    setFromAttributeAndIndices(t, e, i, n) {
      return this.a.fromBufferAttribute(t, e),
        this.b.fromBufferAttribute(t, i),
        this.c.fromBufferAttribute(t, n),
        this
    }
    clone() {
      return (new this.constructor).copy(this)
    }
    copy(t) {
      return this.a.copy(t.a),
        this.b.copy(t.b),
        this.c.copy(t.c),
        this
    }
    getArea() {
      return yn.subVectors(this.c, this.b),
        vn.subVectors(this.a, this.b),
        .5 * yn.cross(vn).length()
    }
    getMidpoint(t) {
      return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    }
    getNormal(t) {
      return Mn.getNormal(this.a, this.b, this.c, t)
    }
    getPlane(t) {
      return t.setFromCoplanarPoints(this.a, this.b, this.c)
    }
    getBarycoord(t, e) {
      return Mn.getBarycoord(t, this.a, this.b, this.c, e)
    }
    getUV(t, e, i, n, r) {
      return Mn.getUV(t, this.a, this.b, this.c, e, i, n, r)
    }
    containsPoint(t) {
      return Mn.containsPoint(t, this.a, this.b, this.c)
    }
    isFrontFacing(t) {
      return Mn.isFrontFacing(this.a, this.b, this.c, t)
    }
    intersectsBox(t) {
      return t.intersectsTriangle(this)
    }
    closestPointToPoint(t, e) {
      const i = this.a
        , n = this.b
        , r = this.c;
      let o, s;
      xn.subVectors(n, i),
        In.subVectors(r, i),
        wn.subVectors(t, i);
      const a = xn.dot(wn)
        , l = In.dot(wn);
      if (a <= 0 && l <= 0)
        return e.copy(i);
      _n.subVectors(t, n);
      const h = xn.dot(_n)
        , c = In.dot(_n);
      if (h >= 0 && c <= h)
        return e.copy(n);
      const u = a * c - h * l;
      if (u <= 0 && a >= 0 && h <= 0)
        return o = a / (a - h),
          e.copy(i).addScaledVector(xn, o);
      Sn.subVectors(t, r);
      const p = xn.dot(Sn)
        , d = In.dot(Sn);
      if (d >= 0 && p <= d)
        return e.copy(r);
      const f = p * l - a * d;
      if (f <= 0 && l >= 0 && d <= 0)
        return s = l / (l - d),
          e.copy(i).addScaledVector(In, s);
      const g = h * d - p * c;
      if (g <= 0 && c - h >= 0 && p - d >= 0)
        return Cn.subVectors(r, n),
          s = (c - h) / (c - h + (p - d)),
          e.copy(n).addScaledVector(Cn, s);
      const m = 1 / (g + f + u);
      return o = f * m,
        s = u * m,
        e.copy(i).addScaledVector(xn, o).addScaledVector(In, s)
    }
    equals(t) {
      return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
    }
  }
  let Tn = 0;
  class En extends Se {
    constructor() {
      super(),
        this.isMaterial = !0,
        Object.defineProperty(this, "id", {
          value: Tn++
        }),
        this.uuid = Re(),
        this.name = "",
        this.type = "Material",
        this.blending = p,
        this.side = l,
        this.vertexColors = !1,
        this.opacity = 1,
        this.transparent = !1,
        this.blendSrc = S,
        this.blendDst = M,
        this.blendEquation = y,
        this.blendSrcAlpha = null,
        this.blendDstAlpha = null,
        this.blendEquationAlpha = null,
        this.depthFunc = D,
        this.depthTest = !0,
        this.depthWrite = !0,
        this.stencilWriteMask = 255,
        this.stencilFunc = 519,
        this.stencilRef = 0,
        this.stencilFuncMask = 255,
        this.stencilFail = xe,
        this.stencilZFail = xe,
        this.stencilZPass = xe,
        this.stencilWrite = !1,
        this.clippingPlanes = null,
        this.clipIntersection = !1,
        this.clipShadows = !1,
        this.shadowSide = null,
        this.colorWrite = !0,
        this.precision = null,
        this.polygonOffset = !1,
        this.polygonOffsetFactor = 0,
        this.polygonOffsetUnits = 0,
        this.dithering = !1,
        this.alphaToCoverage = !1,
        this.premultipliedAlpha = !1,
        this.visible = !0,
        this.toneMapped = !0,
        this.userData = {},
        this.version = 0,
        this._alphaTest = 0
    }
    get alphaTest() {
      return this._alphaTest
    }
    set alphaTest(t) {
      this._alphaTest > 0 != t > 0 && this.version++,
        this._alphaTest = t
    }
    onBuild() { }
    onBeforeRender() { }
    onBeforeCompile() { }
    customProgramCacheKey() {
      return this.onBeforeCompile.toString()
    }
    setValues(t) {
      if (void 0 !== t)
        for (const e in t) {
          const i = t[e];
          if (void 0 === i) {
            console.warn("THREE.Material: '" + e + "' parameter is undefined.");
            continue
          }
          if ("shading" === e) {
            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."),
              this.flatShading = 1 === i;
            continue
          }
          const n = this[e];
          void 0 !== n ? n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[e] = i : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
        }
    }
    toJSON(t) {
      const e = void 0 === t || "string" == typeof t;
      e && (t = {
        textures: {},
        images: {}
      });
      const i = {
        metadata: {
          version: 4.5,
          type: "Material",
          generator: "Material.toJSON"
        }
      };
      function n(t) {
        const e = [];
        for (const i in t) {
          const n = t[i];
          delete n.metadata,
            e.push(n)
        }
        return e
      }
      if (i.uuid = this.uuid,
        i.type = this.type,
        "" !== this.name && (i.name = this.name),
        this.color && this.color.isColor && (i.color = this.color.getHex()),
        void 0 !== this.roughness && (i.roughness = this.roughness),
        void 0 !== this.metalness && (i.metalness = this.metalness),
        void 0 !== this.sheen && (i.sheen = this.sheen),
        this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()),
        void 0 !== this.sheenRoughness && (i.sheenRoughness = this.sheenRoughness),
        this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()),
        this.emissiveIntensity && 1 !== this.emissiveIntensity && (i.emissiveIntensity = this.emissiveIntensity),
        this.specular && this.specular.isColor && (i.specular = this.specular.getHex()),
        void 0 !== this.specularIntensity && (i.specularIntensity = this.specularIntensity),
        this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()),
        void 0 !== this.shininess && (i.shininess = this.shininess),
        void 0 !== this.clearcoat && (i.clearcoat = this.clearcoat),
        void 0 !== this.clearcoatRoughness && (i.clearcoatRoughness = this.clearcoatRoughness),
        this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
        this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid),
        this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid,
          i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
        void 0 !== this.iridescence && (i.iridescence = this.iridescence),
        void 0 !== this.iridescenceIOR && (i.iridescenceIOR = this.iridescenceIOR),
        void 0 !== this.iridescenceThicknessRange && (i.iridescenceThicknessRange = this.iridescenceThicknessRange),
        this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(t).uuid),
        this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(t).uuid),
        this.map && this.map.isTexture && (i.map = this.map.toJSON(t).uuid),
        this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(t).uuid),
        this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(t).uuid),
        this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(t).uuid,
          i.lightMapIntensity = this.lightMapIntensity),
        this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(t).uuid,
          i.aoMapIntensity = this.aoMapIntensity),
        this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(t).uuid,
          i.bumpScale = this.bumpScale),
        this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(t).uuid,
          i.normalMapType = this.normalMapType,
          i.normalScale = this.normalScale.toArray()),
        this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(t).uuid,
          i.displacementScale = this.displacementScale,
          i.displacementBias = this.displacementBias),
        this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(t).uuid),
        this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(t).uuid),
        this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(t).uuid),
        this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(t).uuid),
        this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid),
        this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(t).uuid),
        this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(t).uuid,
          void 0 !== this.combine && (i.combine = this.combine)),
        void 0 !== this.envMapIntensity && (i.envMapIntensity = this.envMapIntensity),
        void 0 !== this.reflectivity && (i.reflectivity = this.reflectivity),
        void 0 !== this.refractionRatio && (i.refractionRatio = this.refractionRatio),
        this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(t).uuid),
        void 0 !== this.transmission && (i.transmission = this.transmission),
        this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(t).uuid),
        void 0 !== this.thickness && (i.thickness = this.thickness),
        this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(t).uuid),
        void 0 !== this.attenuationDistance && (i.attenuationDistance = this.attenuationDistance),
        void 0 !== this.attenuationColor && (i.attenuationColor = this.attenuationColor.getHex()),
        void 0 !== this.size && (i.size = this.size),
        null !== this.shadowSide && (i.shadowSide = this.shadowSide),
        void 0 !== this.sizeAttenuation && (i.sizeAttenuation = this.sizeAttenuation),
        this.blending !== p && (i.blending = this.blending),
        this.side !== l && (i.side = this.side),
        this.vertexColors && (i.vertexColors = !0),
        this.opacity < 1 && (i.opacity = this.opacity),
        !0 === this.transparent && (i.transparent = this.transparent),
        i.depthFunc = this.depthFunc,
        i.depthTest = this.depthTest,
        i.depthWrite = this.depthWrite,
        i.colorWrite = this.colorWrite,
        i.stencilWrite = this.stencilWrite,
        i.stencilWriteMask = this.stencilWriteMask,
        i.stencilFunc = this.stencilFunc,
        i.stencilRef = this.stencilRef,
        i.stencilFuncMask = this.stencilFuncMask,
        i.stencilFail = this.stencilFail,
        i.stencilZFail = this.stencilZFail,
        i.stencilZPass = this.stencilZPass,
        void 0 !== this.rotation && 0 !== this.rotation && (i.rotation = this.rotation),
        !0 === this.polygonOffset && (i.polygonOffset = !0),
        0 !== this.polygonOffsetFactor && (i.polygonOffsetFactor = this.polygonOffsetFactor),
        0 !== this.polygonOffsetUnits && (i.polygonOffsetUnits = this.polygonOffsetUnits),
        void 0 !== this.linewidth && 1 !== this.linewidth && (i.linewidth = this.linewidth),
        void 0 !== this.dashSize && (i.dashSize = this.dashSize),
        void 0 !== this.gapSize && (i.gapSize = this.gapSize),
        void 0 !== this.scale && (i.scale = this.scale),
        !0 === this.dithering && (i.dithering = !0),
        this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
        !0 === this.alphaToCoverage && (i.alphaToCoverage = this.alphaToCoverage),
        !0 === this.premultipliedAlpha && (i.premultipliedAlpha = this.premultipliedAlpha),
        !0 === this.wireframe && (i.wireframe = this.wireframe),
        this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth),
        "round" !== this.wireframeLinecap && (i.wireframeLinecap = this.wireframeLinecap),
        "round" !== this.wireframeLinejoin && (i.wireframeLinejoin = this.wireframeLinejoin),
        !0 === this.flatShading && (i.flatShading = this.flatShading),
        !1 === this.visible && (i.visible = !1),
        !1 === this.toneMapped && (i.toneMapped = !1),
        !1 === this.fog && (i.fog = !1),
        "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData),
        e) {
        const e = n(t.textures)
          , r = n(t.images);
        e.length > 0 && (i.textures = e),
          r.length > 0 && (i.images = r)
      }
      return i
    }
    clone() {
      return (new this.constructor).copy(this)
    }
    copy(t) {
      this.name = t.name,
        this.blending = t.blending,
        this.side = t.side,
        this.vertexColors = t.vertexColors,
        this.opacity = t.opacity,
        this.transparent = t.transparent,
        this.blendSrc = t.blendSrc,
        this.blendDst = t.blendDst,
        this.blendEquation = t.blendEquation,
        this.blendSrcAlpha = t.blendSrcAlpha,
        this.blendDstAlpha = t.blendDstAlpha,
        this.blendEquationAlpha = t.blendEquationAlpha,
        this.depthFunc = t.depthFunc,
        this.depthTest = t.depthTest,
        this.depthWrite = t.depthWrite,
        this.stencilWriteMask = t.stencilWriteMask,
        this.stencilFunc = t.stencilFunc,
        this.stencilRef = t.stencilRef,
        this.stencilFuncMask = t.stencilFuncMask,
        this.stencilFail = t.stencilFail,
        this.stencilZFail = t.stencilZFail,
        this.stencilZPass = t.stencilZPass,
        this.stencilWrite = t.stencilWrite;
      const e = t.clippingPlanes;
      let i = null;
      if (null !== e) {
        const t = e.length;
        i = new Array(t);
        for (let n = 0; n !== t; ++n)
          i[n] = e[n].clone()
      }
      return this.clippingPlanes = i,
        this.clipIntersection = t.clipIntersection,
        this.clipShadows = t.clipShadows,
        this.shadowSide = t.shadowSide,
        this.colorWrite = t.colorWrite,
        this.precision = t.precision,
        this.polygonOffset = t.polygonOffset,
        this.polygonOffsetFactor = t.polygonOffsetFactor,
        this.polygonOffsetUnits = t.polygonOffsetUnits,
        this.dithering = t.dithering,
        this.alphaTest = t.alphaTest,
        this.alphaToCoverage = t.alphaToCoverage,
        this.premultipliedAlpha = t.premultipliedAlpha,
        this.visible = t.visible,
        this.toneMapped = t.toneMapped,
        this.userData = JSON.parse(JSON.stringify(t.userData)),
        this
    }
    dispose() {
      this.dispatchEvent({
        type: "dispose"
      })
    }
    set needsUpdate(t) {
      !0 === t && this.version++
    }
  }
  class kn extends En {
    constructor(t) {
      super(),
        this.isMeshBasicMaterial = !0,
        this.type = "MeshBasicMaterial",
        this.color = new ei(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = j,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.fog = !0,
        this.setValues(t)
    }
    copy(t) {
      return super.copy(t),
        this.color.copy(t.color),
        this.map = t.map,
        this.lightMap = t.lightMap,
        this.lightMapIntensity = t.lightMapIntensity,
        this.aoMap = t.aoMap,
        this.aoMapIntensity = t.aoMapIntensity,
        this.specularMap = t.specularMap,
        this.alphaMap = t.alphaMap,
        this.envMap = t.envMap,
        this.combine = t.combine,
        this.reflectivity = t.reflectivity,
        this.refractionRatio = t.refractionRatio,
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this.wireframeLinecap = t.wireframeLinecap,
        this.wireframeLinejoin = t.wireframeLinejoin,
        this.fog = t.fog,
        this
    }
  }
  const Rn = new di
    , Ln = new Fe;
  class Pn {
    constructor(t, e, i) {
      if (Array.isArray(t))
        throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
      this.isBufferAttribute = !0,
        this.name = "",
        this.array = t,
        this.itemSize = e,
        this.count = void 0 !== t ? t.length / e : 0,
        this.normalized = !0 === i,
        this.usage = Ie,
        this.updateRange = {
          offset: 0,
          count: -1
        },
        this.version = 0
    }
    onUploadCallback() { }
    set needsUpdate(t) {
      !0 === t && this.version++
    }
    setUsage(t) {
      return this.usage = t,
        this
    }
    copy(t) {
      return this.name = t.name,
        this.array = new t.array.constructor(t.array),
        this.itemSize = t.itemSize,
        this.count = t.count,
        this.normalized = t.normalized,
        this.usage = t.usage,
        this
    }
    copyAt(t, e, i) {
      t *= this.itemSize,
        i *= e.itemSize;
      for (let n = 0, r = this.itemSize; n < r; n++)
        this.array[t + n] = e.array[i + n];
      return this
    }
    copyArray(t) {
      return this.array.set(t),
        this
    }
    copyColorsArray(t) {
      const e = this.array;
      let i = 0;
      for (let n = 0, r = t.length; n < r; n++) {
        let r = t[n];
        void 0 === r && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n),
          r = new ei),
          e[i++] = r.r,
          e[i++] = r.g,
          e[i++] = r.b
      }
      return this
    }
    copyVector2sArray(t) {
      const e = this.array;
      let i = 0;
      for (let n = 0, r = t.length; n < r; n++) {
        let r = t[n];
        void 0 === r && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", n),
          r = new Fe),
          e[i++] = r.x,
          e[i++] = r.y
      }
      return this
    }
    copyVector3sArray(t) {
      const e = this.array;
      let i = 0;
      for (let n = 0, r = t.length; n < r; n++) {
        let r = t[n];
        void 0 === r && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n),
          r = new di),
          e[i++] = r.x,
          e[i++] = r.y,
          e[i++] = r.z
      }
      return this
    }
    copyVector4sArray(t) {
      const e = this.array;
      let i = 0;
      for (let n = 0, r = t.length; n < r; n++) {
        let r = t[n];
        void 0 === r && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n),
          r = new li),
          e[i++] = r.x,
          e[i++] = r.y,
          e[i++] = r.z,
          e[i++] = r.w
      }
      return this
    }
    applyMatrix3(t) {
      if (2 === this.itemSize)
        for (let e = 0, i = this.count; e < i; e++)
          Ln.fromBufferAttribute(this, e),
            Ln.applyMatrix3(t),
            this.setXY(e, Ln.x, Ln.y);
      else if (3 === this.itemSize)
        for (let e = 0, i = this.count; e < i; e++)
          Rn.fromBufferAttribute(this, e),
            Rn.applyMatrix3(t),
            this.setXYZ(e, Rn.x, Rn.y, Rn.z);
      return this
    }
    applyMatrix4(t) {
      for (let e = 0, i = this.count; e < i; e++)
        Rn.fromBufferAttribute(this, e),
          Rn.applyMatrix4(t),
          this.setXYZ(e, Rn.x, Rn.y, Rn.z);
      return this
    }
    applyNormalMatrix(t) {
      for (let e = 0, i = this.count; e < i; e++)
        Rn.fromBufferAttribute(this, e),
          Rn.applyNormalMatrix(t),
          this.setXYZ(e, Rn.x, Rn.y, Rn.z);
      return this
    }
    transformDirection(t) {
      for (let e = 0, i = this.count; e < i; e++)
        Rn.fromBufferAttribute(this, e),
          Rn.transformDirection(t),
          this.setXYZ(e, Rn.x, Rn.y, Rn.z);
      return this
    }
    set(t, e = 0) {
      return this.array.set(t, e),
        this
    }
    getX(t) {
      return this.array[t * this.itemSize]
    }
    setX(t, e) {
      return this.array[t * this.itemSize] = e,
        this
    }
    getY(t) {
      return this.array[t * this.itemSize + 1]
    }
    setY(t, e) {
      return this.array[t * this.itemSize + 1] = e,
        this
    }
    getZ(t) {
      return this.array[t * this.itemSize + 2]
    }
    setZ(t, e) {
      return this.array[t * this.itemSize + 2] = e,
        this
    }
    getW(t) {
      return this.array[t * this.itemSize + 3]
    }
    setW(t, e) {
      return this.array[t * this.itemSize + 3] = e,
        this
    }
    setXY(t, e, i) {
      return t *= this.itemSize,
        this.array[t + 0] = e,
        this.array[t + 1] = i,
        this
    }
    setXYZ(t, e, i, n) {
      return t *= this.itemSize,
        this.array[t + 0] = e,
        this.array[t + 1] = i,
        this.array[t + 2] = n,
        this
    }
    setXYZW(t, e, i, n, r) {
      return t *= this.itemSize,
        this.array[t + 0] = e,
        this.array[t + 1] = i,
        this.array[t + 2] = n,
        this.array[t + 3] = r,
        this
    }
    onUpload(t) {
      return this.onUploadCallback = t,
        this
    }
    clone() {
      return new this.constructor(this.array, this.itemSize).copy(this)
    }
    toJSON() {
      const t = {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: Array.from(this.array),
        normalized: this.normalized
      };
      return "" !== this.name && (t.name = this.name),
        this.usage !== Ie && (t.usage = this.usage),
        0 === this.updateRange.offset && -1 === this.updateRange.count || (t.updateRange = this.updateRange),
        t
    }
  }
  class zn extends Pn {
    constructor(t, e, i) {
      super(new Uint16Array(t), e, i)
    }
  }
  class On extends Pn {
    constructor(t, e, i) {
      super(new Uint32Array(t), e, i)
    }
  }
  class Dn extends Pn {
    constructor(t, e, i) {
      super(new Float32Array(t), e, i)
    }
  }
  let Un = 0;
  const Nn = new Wi
    , Fn = new mn
    , Bn = new di
    , jn = new mi
    , Vn = new mi
    , Gn = new di;
  class Wn extends Se {
    constructor() {
      super(),
        this.isBufferGeometry = !0,
        Object.defineProperty(this, "id", {
          value: Un++
        }),
        this.uuid = Re(),
        this.name = "",
        this.type = "BufferGeometry",
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.morphTargetsRelative = !1,
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.drawRange = {
          start: 0,
          count: 1 / 0
        },
        this.userData = {}
    }
    getIndex() {
      return this.index
    }
    setIndex(t) {
      return Array.isArray(t) ? this.index = new (je(t) ? On : zn)(t, 1) : this.index = t,
        this
    }
    getAttribute(t) {
      return this.attributes[t]
    }
    setAttribute(t, e) {
      return this.attributes[t] = e,
        this
    }
    deleteAttribute(t) {
      return delete this.attributes[t],
        this
    }
    hasAttribute(t) {
      return void 0 !== this.attributes[t]
    }
    addGroup(t, e, i = 0) {
      this.groups.push({
        start: t,
        count: e,
        materialIndex: i
      })
    }
    clearGroups() {
      this.groups = []
    }
    setDrawRange(t, e) {
      this.drawRange.start = t,
        this.drawRange.count = e
    }
    applyMatrix4(t) {
      const e = this.attributes.position;
      void 0 !== e && (e.applyMatrix4(t),
        e.needsUpdate = !0);
      const i = this.attributes.normal;
      if (void 0 !== i) {
        const e = (new Be).getNormalMatrix(t);
        i.applyNormalMatrix(e),
          i.needsUpdate = !0
      }
      const n = this.attributes.tangent;
      return void 0 !== n && (n.transformDirection(t),
        n.needsUpdate = !0),
        null !== this.boundingBox && this.computeBoundingBox(),
        null !== this.boundingSphere && this.computeBoundingSphere(),
        this
    }
    applyQuaternion(t) {
      return Nn.makeRotationFromQuaternion(t),
        this.applyMatrix4(Nn),
        this
    }
    rotateX(t) {
      return Nn.makeRotationX(t),
        this.applyMatrix4(Nn),
        this
    }
    rotateY(t) {
      return Nn.makeRotationY(t),
        this.applyMatrix4(Nn),
        this
    }
    rotateZ(t) {
      return Nn.makeRotationZ(t),
        this.applyMatrix4(Nn),
        this
    }
    translate(t, e, i) {
      return Nn.makeTranslation(t, e, i),
        this.applyMatrix4(Nn),
        this
    }
    scale(t, e, i) {
      return Nn.makeScale(t, e, i),
        this.applyMatrix4(Nn),
        this
    }
    lookAt(t) {
      return Fn.lookAt(t),
        Fn.updateMatrix(),
        this.applyMatrix4(Fn.matrix),
        this
    }
    center() {
      return this.computeBoundingBox(),
        this.boundingBox.getCenter(Bn).negate(),
        this.translate(Bn.x, Bn.y, Bn.z),
        this
    }
    setFromPoints(t) {
      const e = [];
      for (let i = 0, n = t.length; i < n; i++) {
        const n = t[i];
        e.push(n.x, n.y, n.z || 0)
      }
      return this.setAttribute("position", new Dn(e, 3)),
        this
    }
    computeBoundingBox() {
      null === this.boundingBox && (this.boundingBox = new mi);
      const t = this.attributes.position
        , e = this.morphAttributes.position;
      if (t && t.isGLBufferAttribute)
        return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this),
          void this.boundingBox.set(new di(-1 / 0, -1 / 0, -1 / 0), new di(1 / 0, 1 / 0, 1 / 0));
      if (void 0 !== t) {
        if (this.boundingBox.setFromBufferAttribute(t),
          e)
          for (let t = 0, i = e.length; t < i; t++) {
            const i = e[t];
            jn.setFromBufferAttribute(i),
              this.morphTargetsRelative ? (Gn.addVectors(this.boundingBox.min, jn.min),
                this.boundingBox.expandByPoint(Gn),
                Gn.addVectors(this.boundingBox.max, jn.max),
                this.boundingBox.expandByPoint(Gn)) : (this.boundingBox.expandByPoint(jn.min),
                  this.boundingBox.expandByPoint(jn.max))
          }
      } else
        this.boundingBox.makeEmpty();
      (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
    }
    computeBoundingSphere() {
      null === this.boundingSphere && (this.boundingSphere = new Oi);
      const t = this.attributes.position
        , e = this.morphAttributes.position;
      if (t && t.isGLBufferAttribute)
        return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this),
          void this.boundingSphere.set(new di, 1 / 0);
      if (t) {
        const i = this.boundingSphere.center;
        if (jn.setFromBufferAttribute(t),
          e)
          for (let t = 0, i = e.length; t < i; t++) {
            const i = e[t];
            Vn.setFromBufferAttribute(i),
              this.morphTargetsRelative ? (Gn.addVectors(jn.min, Vn.min),
                jn.expandByPoint(Gn),
                Gn.addVectors(jn.max, Vn.max),
                jn.expandByPoint(Gn)) : (jn.expandByPoint(Vn.min),
                  jn.expandByPoint(Vn.max))
          }
        jn.getCenter(i);
        let n = 0;
        for (let e = 0, r = t.count; e < r; e++)
          Gn.fromBufferAttribute(t, e),
            n = Math.max(n, i.distanceToSquared(Gn));
        if (e)
          for (let r = 0, o = e.length; r < o; r++) {
            const o = e[r]
              , s = this.morphTargetsRelative;
            for (let e = 0, r = o.count; e < r; e++)
              Gn.fromBufferAttribute(o, e),
                s && (Bn.fromBufferAttribute(t, e),
                  Gn.add(Bn)),
                n = Math.max(n, i.distanceToSquared(Gn))
          }
        this.boundingSphere.radius = Math.sqrt(n),
          isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
      }
    }
    computeTangents() {
      const t = this.index
        , e = this.attributes;
      if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv)
        return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      const i = t.array
        , n = e.position.array
        , r = e.normal.array
        , o = e.uv.array
        , s = n.length / 3;
      !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new Pn(new Float32Array(4 * s), 4));
      const a = this.getAttribute("tangent").array
        , l = []
        , h = [];
      for (let t = 0; t < s; t++)
        l[t] = new di,
          h[t] = new di;
      const c = new di
        , u = new di
        , p = new di
        , d = new Fe
        , f = new Fe
        , g = new Fe
        , m = new di
        , y = new di;
      function v(t, e, i) {
        c.fromArray(n, 3 * t),
          u.fromArray(n, 3 * e),
          p.fromArray(n, 3 * i),
          d.fromArray(o, 2 * t),
          f.fromArray(o, 2 * e),
          g.fromArray(o, 2 * i),
          u.sub(c),
          p.sub(c),
          f.sub(d),
          g.sub(d);
        const r = 1 / (f.x * g.y - g.x * f.y);
        isFinite(r) && (m.copy(u).multiplyScalar(g.y).addScaledVector(p, -f.y).multiplyScalar(r),
          y.copy(p).multiplyScalar(f.x).addScaledVector(u, -g.x).multiplyScalar(r),
          l[t].add(m),
          l[e].add(m),
          l[i].add(m),
          h[t].add(y),
          h[e].add(y),
          h[i].add(y))
      }
      let A = this.groups;
      0 === A.length && (A = [{
        start: 0,
        count: i.length
      }]);
      for (let t = 0, e = A.length; t < e; ++t) {
        const e = A[t]
          , n = e.start;
        for (let t = n, r = n + e.count; t < r; t += 3)
          v(i[t + 0], i[t + 1], i[t + 2])
      }
      const b = new di
        , x = new di
        , I = new di
        , C = new di;
      function w(t) {
        I.fromArray(r, 3 * t),
          C.copy(I);
        const e = l[t];
        b.copy(e),
          b.sub(I.multiplyScalar(I.dot(e))).normalize(),
          x.crossVectors(C, e);
        const i = x.dot(h[t]) < 0 ? -1 : 1;
        a[4 * t] = b.x,
          a[4 * t + 1] = b.y,
          a[4 * t + 2] = b.z,
          a[4 * t + 3] = i
      }
      for (let t = 0, e = A.length; t < e; ++t) {
        const e = A[t]
          , n = e.start;
        for (let t = n, r = n + e.count; t < r; t += 3)
          w(i[t + 0]),
            w(i[t + 1]),
            w(i[t + 2])
      }
    }
    computeVertexNormals() {
      const t = this.index
        , e = this.getAttribute("position");
      if (void 0 !== e) {
        let i = this.getAttribute("normal");
        if (void 0 === i)
          i = new Pn(new Float32Array(3 * e.count), 3),
            this.setAttribute("normal", i);
        else
          for (let t = 0, e = i.count; t < e; t++)
            i.setXYZ(t, 0, 0, 0);
        const n = new di
          , r = new di
          , o = new di
          , s = new di
          , a = new di
          , l = new di
          , h = new di
          , c = new di;
        if (t)
          for (let u = 0, p = t.count; u < p; u += 3) {
            const p = t.getX(u + 0)
              , d = t.getX(u + 1)
              , f = t.getX(u + 2);
            n.fromBufferAttribute(e, p),
              r.fromBufferAttribute(e, d),
              o.fromBufferAttribute(e, f),
              h.subVectors(o, r),
              c.subVectors(n, r),
              h.cross(c),
              s.fromBufferAttribute(i, p),
              a.fromBufferAttribute(i, d),
              l.fromBufferAttribute(i, f),
              s.add(h),
              a.add(h),
              l.add(h),
              i.setXYZ(p, s.x, s.y, s.z),
              i.setXYZ(d, a.x, a.y, a.z),
              i.setXYZ(f, l.x, l.y, l.z)
          }
        else
          for (let t = 0, s = e.count; t < s; t += 3)
            n.fromBufferAttribute(e, t + 0),
              r.fromBufferAttribute(e, t + 1),
              o.fromBufferAttribute(e, t + 2),
              h.subVectors(o, r),
              c.subVectors(n, r),
              h.cross(c),
              i.setXYZ(t + 0, h.x, h.y, h.z),
              i.setXYZ(t + 1, h.x, h.y, h.z),
              i.setXYZ(t + 2, h.x, h.y, h.z);
        this.normalizeNormals(),
          i.needsUpdate = !0
      }
    }
    merge(t, e) {
      if (!t || !t.isBufferGeometry)
        return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t);
      void 0 === e && (e = 0,
        console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
      const i = this.attributes;
      for (const n in i) {
        if (void 0 === t.attributes[n])
          continue;
        const r = i[n].array
          , o = t.attributes[n]
          , s = o.array
          , a = o.itemSize * e
          , l = Math.min(s.length, r.length - a);
        for (let t = 0, e = a; t < l; t++,
          e++)
          r[e] = s[t]
      }
      return this
    }
    normalizeNormals() {
      const t = this.attributes.normal;
      for (let e = 0, i = t.count; e < i; e++)
        Gn.fromBufferAttribute(t, e),
          Gn.normalize(),
          t.setXYZ(e, Gn.x, Gn.y, Gn.z)
    }
    toNonIndexed() {
      function t(t, e) {
        const i = t.array
          , n = t.itemSize
          , r = t.normalized
          , o = new i.constructor(e.length * n);
        let s = 0
          , a = 0;
        for (let r = 0, l = e.length; r < l; r++) {
          s = t.isInterleavedBufferAttribute ? e[r] * t.data.stride + t.offset : e[r] * n;
          for (let t = 0; t < n; t++)
            o[a++] = i[s++]
        }
        return new Pn(o, n, r)
      }
      if (null === this.index)
        return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
          this;
      const e = new Wn
        , i = this.index.array
        , n = this.attributes;
      for (const r in n) {
        const o = t(n[r], i);
        e.setAttribute(r, o)
      }
      const r = this.morphAttributes;
      for (const n in r) {
        const o = []
          , s = r[n];
        for (let e = 0, n = s.length; e < n; e++) {
          const n = t(s[e], i);
          o.push(n)
        }
        e.morphAttributes[n] = o
      }
      e.morphTargetsRelative = this.morphTargetsRelative;
      const o = this.groups;
      for (let t = 0, i = o.length; t < i; t++) {
        const i = o[t];
        e.addGroup(i.start, i.count, i.materialIndex)
      }
      return e
    }
    toJSON() {
      const t = {
        metadata: {
          version: 4.5,
          type: "BufferGeometry",
          generator: "BufferGeometry.toJSON"
        }
      };
      if (t.uuid = this.uuid,
        t.type = this.type,
        "" !== this.name && (t.name = this.name),
        Object.keys(this.userData).length > 0 && (t.userData = this.userData),
        void 0 !== this.parameters) {
        const e = this.parameters;
        for (const i in e)
          void 0 !== e[i] && (t[i] = e[i]);
        return t
      }
      t.data = {
        attributes: {}
      };
      const e = this.index;
      null !== e && (t.data.index = {
        type: e.array.constructor.name,
        array: Array.prototype.slice.call(e.array)
      });
      const i = this.attributes;
      for (const e in i) {
        const n = i[e];
        t.data.attributes[e] = n.toJSON(t.data)
      }
      const n = {};
      let r = !1;
      for (const e in this.morphAttributes) {
        const i = this.morphAttributes[e]
          , o = [];
        for (let e = 0, n = i.length; e < n; e++) {
          const n = i[e];
          o.push(n.toJSON(t.data))
        }
        o.length > 0 && (n[e] = o,
          r = !0)
      }
      r && (t.data.morphAttributes = n,
        t.data.morphTargetsRelative = this.morphTargetsRelative);
      const o = this.groups;
      o.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(o)));
      const s = this.boundingSphere;
      return null !== s && (t.data.boundingSphere = {
        center: s.center.toArray(),
        radius: s.radius
      }),
        t
    }
    clone() {
      return (new this.constructor).copy(this)
    }
    copy(t) {
      this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null;
      const e = {};
      this.name = t.name;
      const i = t.index;
      null !== i && this.setIndex(i.clone(e));
      const n = t.attributes;
      for (const t in n) {
        const i = n[t];
        this.setAttribute(t, i.clone(e))
      }
      const r = t.morphAttributes;
      for (const t in r) {
        const i = []
          , n = r[t];
        for (let t = 0, r = n.length; t < r; t++)
          i.push(n[t].clone(e));
        this.morphAttributes[t] = i
      }
      this.morphTargetsRelative = t.morphTargetsRelative;
      const o = t.groups;
      for (let t = 0, e = o.length; t < e; t++) {
        const e = o[t];
        this.addGroup(e.start, e.count, e.materialIndex)
      }
      const s = t.boundingBox;
      null !== s && (this.boundingBox = s.clone());
      const a = t.boundingSphere;
      return null !== a && (this.boundingSphere = a.clone()),
        this.drawRange.start = t.drawRange.start,
        this.drawRange.count = t.drawRange.count,
        this.userData = t.userData,
        void 0 !== t.parameters && (this.parameters = Object.assign({}, t.parameters)),
        this
    }
    dispose() {
      this.dispatchEvent({
        type: "dispose"
      })
    }
  }
  const Jn = new Wi
    , Hn = new Gi
    , Zn = new Oi
    , Qn = new di
    , Kn = new di
    , Yn = new di
    , qn = new di
    , Xn = new di
    , $n = new di
    , tr = new di
    , er = new di
    , ir = new di
    , nr = new Fe
    , rr = new Fe
    , or = new Fe
    , sr = new di
    , ar = new di;
  class lr extends mn {
    constructor(t = new Wn, e = new kn) {
      super(),
        this.isMesh = !0,
        this.type = "Mesh",
        this.geometry = t,
        this.material = e,
        this.updateMorphTargets()
    }
    copy(t, e) {
      return super.copy(t, e),
        void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
        void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)),
        this.material = t.material,
        this.geometry = t.geometry,
        this
    }
    updateMorphTargets() {
      const t = this.geometry.morphAttributes
        , e = Object.keys(t);
      if (e.length > 0) {
        const i = t[e[0]];
        if (void 0 !== i) {
          this.morphTargetInfluences = [],
            this.morphTargetDictionary = {};
          for (let t = 0, e = i.length; t < e; t++) {
            const e = i[t].name || String(t);
            this.morphTargetInfluences.push(0),
              this.morphTargetDictionary[e] = t
          }
        }
      }
    }
    raycast(t, e) {
      const i = this.geometry
        , n = this.material
        , r = this.matrixWorld;
      if (void 0 === n)
        return;
      if (null === i.boundingSphere && i.computeBoundingSphere(),
        Zn.copy(i.boundingSphere),
        Zn.applyMatrix4(r),
        !1 === t.ray.intersectsSphere(Zn))
        return;
      if (Jn.copy(r).invert(),
        Hn.copy(t.ray).applyMatrix4(Jn),
        null !== i.boundingBox && !1 === Hn.intersectsBox(i.boundingBox))
        return;
      let o;
      const s = i.index
        , a = i.attributes.position
        , l = i.morphAttributes.position
        , h = i.morphTargetsRelative
        , c = i.attributes.uv
        , u = i.attributes.uv2
        , p = i.groups
        , d = i.drawRange;
      if (null !== s)
        if (Array.isArray(n))
          for (let i = 0, r = p.length; i < r; i++) {
            const r = p[i]
              , f = n[r.materialIndex];
            for (let i = Math.max(r.start, d.start), n = Math.min(s.count, Math.min(r.start + r.count, d.start + d.count)); i < n; i += 3) {
              const n = s.getX(i)
                , p = s.getX(i + 1)
                , d = s.getX(i + 2);
              o = hr(this, f, t, Hn, a, l, h, c, u, n, p, d),
                o && (o.faceIndex = Math.floor(i / 3),
                  o.face.materialIndex = r.materialIndex,
                  e.push(o))
            }
          }
        else {
          for (let i = Math.max(0, d.start), r = Math.min(s.count, d.start + d.count); i < r; i += 3) {
            const r = s.getX(i)
              , p = s.getX(i + 1)
              , d = s.getX(i + 2);
            o = hr(this, n, t, Hn, a, l, h, c, u, r, p, d),
              o && (o.faceIndex = Math.floor(i / 3),
                e.push(o))
          }
        }
      else if (void 0 !== a)
        if (Array.isArray(n))
          for (let i = 0, r = p.length; i < r; i++) {
            const r = p[i]
              , s = n[r.materialIndex];
            for (let i = Math.max(r.start, d.start), n = Math.min(a.count, Math.min(r.start + r.count, d.start + d.count)); i < n; i += 3) {
              o = hr(this, s, t, Hn, a, l, h, c, u, i, i + 1, i + 2),
                o && (o.faceIndex = Math.floor(i / 3),
                  o.face.materialIndex = r.materialIndex,
                  e.push(o))
            }
          }
        else {
          for (let i = Math.max(0, d.start), r = Math.min(a.count, d.start + d.count); i < r; i += 3) {
            o = hr(this, n, t, Hn, a, l, h, c, u, i, i + 1, i + 2),
              o && (o.faceIndex = Math.floor(i / 3),
                e.push(o))
          }
        }
    }
  }
  function hr(t, e, i, n, r, o, s, a, l, u, p, d) {
    Qn.fromBufferAttribute(r, u),
      Kn.fromBufferAttribute(r, p),
      Yn.fromBufferAttribute(r, d);
    const f = t.morphTargetInfluences;
    if (o && f) {
      tr.set(0, 0, 0),
        er.set(0, 0, 0),
        ir.set(0, 0, 0);
      for (let t = 0, e = o.length; t < e; t++) {
        const e = f[t]
          , i = o[t];
        0 !== e && (qn.fromBufferAttribute(i, u),
          Xn.fromBufferAttribute(i, p),
          $n.fromBufferAttribute(i, d),
          s ? (tr.addScaledVector(qn, e),
            er.addScaledVector(Xn, e),
            ir.addScaledVector($n, e)) : (tr.addScaledVector(qn.sub(Qn), e),
              er.addScaledVector(Xn.sub(Kn), e),
              ir.addScaledVector($n.sub(Yn), e)))
      }
      Qn.add(tr),
        Kn.add(er),
        Yn.add(ir)
    }
    t.isSkinnedMesh && (t.boneTransform(u, Qn),
      t.boneTransform(p, Kn),
      t.boneTransform(d, Yn));
    const g = function (t, e, i, n, r, o, s, a) {
      let l;
      if (l = e.side === h ? n.intersectTriangle(s, o, r, !0, a) : n.intersectTriangle(r, o, s, e.side !== c, a),
        null === l)
        return null;
      ar.copy(a),
        ar.applyMatrix4(t.matrixWorld);
      const u = i.ray.origin.distanceTo(ar);
      return u < i.near || u > i.far ? null : {
        distance: u,
        point: ar.clone(),
        object: t
      }
    }(t, e, i, n, Qn, Kn, Yn, sr);
    if (g) {
      a && (nr.fromBufferAttribute(a, u),
        rr.fromBufferAttribute(a, p),
        or.fromBufferAttribute(a, d),
        g.uv = Mn.getUV(sr, Qn, Kn, Yn, nr, rr, or, new Fe)),
        l && (nr.fromBufferAttribute(l, u),
          rr.fromBufferAttribute(l, p),
          or.fromBufferAttribute(l, d),
          g.uv2 = Mn.getUV(sr, Qn, Kn, Yn, nr, rr, or, new Fe));
      const t = {
        a: u,
        b: p,
        c: d,
        normal: new di,
        materialIndex: 0
      };
      Mn.getNormal(Qn, Kn, Yn, t.normal),
        g.face = t
    }
    return g
  }
  class cr extends Wn {
    constructor(t = 1, e = 1, i = 1, n = 1, r = 1, o = 1) {
      super(),
        this.type = "BoxGeometry",
        this.parameters = {
          width: t,
          height: e,
          depth: i,
          widthSegments: n,
          heightSegments: r,
          depthSegments: o
        };
      const s = this;
      n = Math.floor(n),
        r = Math.floor(r),
        o = Math.floor(o);
      const a = []
        , l = []
        , h = []
        , c = [];
      let u = 0
        , p = 0;
      function d(t, e, i, n, r, o, d, f, g, m, y) {
        const v = o / g
          , A = d / m
          , b = o / 2
          , x = d / 2
          , I = f / 2
          , C = g + 1
          , w = m + 1;
        let _ = 0
          , S = 0;
        const M = new di;
        for (let o = 0; o < w; o++) {
          const s = o * A - x;
          for (let a = 0; a < C; a++) {
            const u = a * v - b;
            M[t] = u * n,
              M[e] = s * r,
              M[i] = I,
              l.push(M.x, M.y, M.z),
              M[t] = 0,
              M[e] = 0,
              M[i] = f > 0 ? 1 : -1,
              h.push(M.x, M.y, M.z),
              c.push(a / g),
              c.push(1 - o / m),
              _ += 1
          }
        }
        for (let t = 0; t < m; t++)
          for (let e = 0; e < g; e++) {
            const i = u + e + C * t
              , n = u + e + C * (t + 1)
              , r = u + (e + 1) + C * (t + 1)
              , o = u + (e + 1) + C * t;
            a.push(i, n, o),
              a.push(n, r, o),
              S += 6
          }
        s.addGroup(p, S, y),
          p += S,
          u += _
      }
      d("z", "y", "x", -1, -1, i, e, t, o, r, 0),
        d("z", "y", "x", 1, -1, i, e, -t, o, r, 1),
        d("x", "z", "y", 1, 1, t, i, e, n, o, 2),
        d("x", "z", "y", 1, -1, t, i, -e, n, o, 3),
        d("x", "y", "z", 1, -1, t, e, i, n, r, 4),
        d("x", "y", "z", -1, -1, t, e, -i, n, r, 5),
        this.setIndex(a),
        this.setAttribute("position", new Dn(l, 3)),
        this.setAttribute("normal", new Dn(h, 3)),
        this.setAttribute("uv", new Dn(c, 2))
    }
    static fromJSON(t) {
      return new cr(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments)
    }
  }
  function ur(t) {
    const e = {};
    for (const i in t) {
      e[i] = {};
      for (const n in t[i]) {
        const r = t[i][n];
        r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? e[i][n] = r.clone() : Array.isArray(r) ? e[i][n] = r.slice() : e[i][n] = r
      }
    }
    return e
  }
  function pr(t) {
    const e = {};
    for (let i = 0; i < t.length; i++) {
      const n = ur(t[i]);
      for (const t in n)
        e[t] = n[t]
    }
    return e
  }
  const dr = {
    clone: ur,
    merge: pr
  };
  class fr extends En {
    constructor(t) {
      super(),
        this.isShaderMaterial = !0,
        this.type = "ShaderMaterial",
        this.defines = {},
        this.uniforms = {},
        this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
        this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",
        this.linewidth = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.lights = !1,
        this.clipping = !1,
        this.extensions = {
          derivatives: !1,
          fragDepth: !1,
          drawBuffers: !1,
          shaderTextureLOD: !1
        },
        this.defaultAttributeValues = {
          color: [1, 1, 1],
          uv: [0, 0],
          uv2: [0, 0]
        },
        this.index0AttributeName = void 0,
        this.uniformsNeedUpdate = !1,
        this.glslVersion = null,
        void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),
          this.setValues(t))
    }
    copy(t) {
      return super.copy(t),
        this.fragmentShader = t.fragmentShader,
        this.vertexShader = t.vertexShader,
        this.uniforms = ur(t.uniforms),
        this.defines = Object.assign({}, t.defines),
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this.fog = t.fog,
        this.lights = t.lights,
        this.clipping = t.clipping,
        this.extensions = Object.assign({}, t.extensions),
        this.glslVersion = t.glslVersion,
        this
    }
    toJSON(t) {
      const e = super.toJSON(t);
      e.glslVersion = this.glslVersion,
        e.uniforms = {};
      for (const i in this.uniforms) {
        const n = this.uniforms[i].value;
        n && n.isTexture ? e.uniforms[i] = {
          type: "t",
          value: n.toJSON(t).uuid
        } : n && n.isColor ? e.uniforms[i] = {
          type: "c",
          value: n.getHex()
        } : n && n.isVector2 ? e.uniforms[i] = {
          type: "v2",
          value: n.toArray()
        } : n && n.isVector3 ? e.uniforms[i] = {
          type: "v3",
          value: n.toArray()
        } : n && n.isVector4 ? e.uniforms[i] = {
          type: "v4",
          value: n.toArray()
        } : n && n.isMatrix3 ? e.uniforms[i] = {
          type: "m3",
          value: n.toArray()
        } : n && n.isMatrix4 ? e.uniforms[i] = {
          type: "m4",
          value: n.toArray()
        } : e.uniforms[i] = {
          value: n
        }
      }
      Object.keys(this.defines).length > 0 && (e.defines = this.defines),
        e.vertexShader = this.vertexShader,
        e.fragmentShader = this.fragmentShader;
      const i = {};
      for (const t in this.extensions)
        !0 === this.extensions[t] && (i[t] = !0);
      return Object.keys(i).length > 0 && (e.extensions = i),
        e
    }
  }
  class gr extends mn {
    constructor() {
      super(),
        this.isCamera = !0,
        this.type = "Camera",
        this.matrixWorldInverse = new Wi,
        this.projectionMatrix = new Wi,
        this.projectionMatrixInverse = new Wi
    }
    copy(t, e) {
      return super.copy(t, e),
        this.matrixWorldInverse.copy(t.matrixWorldInverse),
        this.projectionMatrix.copy(t.projectionMatrix),
        this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
        this
    }
    getWorldDirection(t) {
      this.updateWorldMatrix(!0, !1);
      const e = this.matrixWorld.elements;
      return t.set(-e[8], -e[9], -e[10]).normalize()
    }
    updateMatrixWorld(t) {
      super.updateMatrixWorld(t),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    updateWorldMatrix(t, e) {
      super.updateWorldMatrix(t, e),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    clone() {
      return (new this.constructor).copy(this)
    }
  }
  class mr extends gr {
    constructor(t = 50, e = 1, i = .1, n = 2e3) {
      super(),
        this.isPerspectiveCamera = !0,
        this.type = "PerspectiveCamera",
        this.fov = t,
        this.zoom = 1,
        this.near = i,
        this.far = n,
        this.focus = 10,
        this.aspect = e,
        this.view = null,
        this.filmGauge = 35,
        this.filmOffset = 0,
        this.updateProjectionMatrix()
    }
    copy(t, e) {
      return super.copy(t, e),
        this.fov = t.fov,
        this.zoom = t.zoom,
        this.near = t.near,
        this.far = t.far,
        this.focus = t.focus,
        this.aspect = t.aspect,
        this.view = null === t.view ? null : Object.assign({}, t.view),
        this.filmGauge = t.filmGauge,
        this.filmOffset = t.filmOffset,
        this
    }
    setFocalLength(t) {
      const e = .5 * this.getFilmHeight() / t;
      this.fov = 2 * ke * Math.atan(e),
        this.updateProjectionMatrix()
    }
    getFocalLength() {
      const t = Math.tan(.5 * Ee * this.fov);
      return .5 * this.getFilmHeight() / t
    }
    getEffectiveFOV() {
      return 2 * ke * Math.atan(Math.tan(.5 * Ee * this.fov) / this.zoom)
    }
    getFilmWidth() {
      return this.filmGauge * Math.min(this.aspect, 1)
    }
    getFilmHeight() {
      return this.filmGauge / Math.max(this.aspect, 1)
    }
    setViewOffset(t, e, i, n, r, o) {
      this.aspect = t / e,
        null === this.view && (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = t,
        this.view.fullHeight = e,
        this.view.offsetX = i,
        this.view.offsetY = n,
        this.view.width = r,
        this.view.height = o,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
      null !== this.view && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
      const t = this.near;
      let e = t * Math.tan(.5 * Ee * this.fov) / this.zoom
        , i = 2 * e
        , n = this.aspect * i
        , r = -.5 * n;
      const o = this.view;
      if (null !== this.view && this.view.enabled) {
        const t = o.fullWidth
          , s = o.fullHeight;
        r += o.offsetX * n / t,
          e -= o.offsetY * i / s,
          n *= o.width / t,
          i *= o.height / s
      }
      const s = this.filmOffset;
      0 !== s && (r += t * s / this.getFilmWidth()),
        this.projectionMatrix.makePerspective(r, r + n, e, e - i, t, this.far),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(t) {
      const e = super.toJSON(t);
      return e.object.fov = this.fov,
        e.object.zoom = this.zoom,
        e.object.near = this.near,
        e.object.far = this.far,
        e.object.focus = this.focus,
        e.object.aspect = this.aspect,
        null !== this.view && (e.object.view = Object.assign({}, this.view)),
        e.object.filmGauge = this.filmGauge,
        e.object.filmOffset = this.filmOffset,
        e
    }
  }
  const yr = 90;
  class vr extends mn {
    constructor(t, e, i) {
      if (super(),
        this.type = "CubeCamera",
        !0 !== i.isWebGLCubeRenderTarget)
        return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
      this.renderTarget = i;
      const n = new mr(yr, 1, t, e);
      n.layers = this.layers,
        n.up.set(0, -1, 0),
        n.lookAt(new di(1, 0, 0)),
        this.add(n);
      const r = new mr(yr, 1, t, e);
      r.layers = this.layers,
        r.up.set(0, -1, 0),
        r.lookAt(new di(-1, 0, 0)),
        this.add(r);
      const o = new mr(yr, 1, t, e);
      o.layers = this.layers,
        o.up.set(0, 0, 1),
        o.lookAt(new di(0, 1, 0)),
        this.add(o);
      const s = new mr(yr, 1, t, e);
      s.layers = this.layers,
        s.up.set(0, 0, -1),
        s.lookAt(new di(0, -1, 0)),
        this.add(s);
      const a = new mr(yr, 1, t, e);
      a.layers = this.layers,
        a.up.set(0, -1, 0),
        a.lookAt(new di(0, 0, 1)),
        this.add(a);
      const l = new mr(yr, 1, t, e);
      l.layers = this.layers,
        l.up.set(0, -1, 0),
        l.lookAt(new di(0, 0, -1)),
        this.add(l)
    }
    update(t, e) {
      null === this.parent && this.updateMatrixWorld();
      const i = this.renderTarget
        , [n, r, o, s, a, l] = this.children
        , h = t.getRenderTarget()
        , c = t.toneMapping
        , u = t.xr.enabled;
      t.toneMapping = W,
        t.xr.enabled = !1;
      const p = i.texture.generateMipmaps;
      i.texture.generateMipmaps = !1,
        t.setRenderTarget(i, 0),
        t.render(e, n),
        t.setRenderTarget(i, 1),
        t.render(e, r),
        t.setRenderTarget(i, 2),
        t.render(e, o),
        t.setRenderTarget(i, 3),
        t.render(e, s),
        t.setRenderTarget(i, 4),
        t.render(e, a),
        i.texture.generateMipmaps = p,
        t.setRenderTarget(i, 5),
        t.render(e, l),
        t.setRenderTarget(h),
        t.toneMapping = c,
        t.xr.enabled = u,
        i.texture.needsPMREMUpdate = !0
    }
  }
  class Ar extends ai {
    constructor(t, e, i, n, r, o, s, a, l, h) {
      super(t = void 0 !== t ? t : [], e = void 0 !== e ? e : q, i, n, r, o, s, a, l, h),
        this.isCubeTexture = !0,
        this.flipY = !1
    }
    get images() {
      return this.image
    }
    set images(t) {
      this.image = t
    }
  }
  class br extends hi {
    constructor(t, e = {}) {
      super(t, t, e),
        this.isWebGLCubeRenderTarget = !0;
      const i = {
        width: t,
        height: t,
        depth: 1
      }
        , n = [i, i, i, i, i, i];
      this.texture = new Ar(n, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.encoding),
        this.texture.isRenderTargetTexture = !0,
        this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps,
        this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : lt
    }
    fromEquirectangularTexture(t, e) {
      this.texture.type = e.type,
        this.texture.encoding = e.encoding,
        this.texture.generateMipmaps = e.generateMipmaps,
        this.texture.minFilter = e.minFilter,
        this.texture.magFilter = e.magFilter;
      const i = {
        uniforms: {
          tEquirect: {
            value: null
          }
        },
        vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
        fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
      }
        , n = new cr(5, 5, 5)
        , r = new fr({
          name: "CubemapFromEquirect",
          uniforms: ur(i.uniforms),
          vertexShader: i.vertexShader,
          fragmentShader: i.fragmentShader,
          side: h,
          blending: u
        });
      r.uniforms.tEquirect.value = e;
      const o = new lr(n, r)
        , s = e.minFilter;
      e.minFilter === ct && (e.minFilter = lt);
      return new vr(1, 10, this).update(t, o),
        e.minFilter = s,
        o.geometry.dispose(),
        o.material.dispose(),
        this
    }
    clear(t, e, i, n) {
      const r = t.getRenderTarget();
      for (let r = 0; r < 6; r++)
        t.setRenderTarget(this, r),
          t.clear(e, i, n);
      t.setRenderTarget(r)
    }
  }
  const xr = new di
    , Ir = new di
    , Cr = new Be;
  class wr {
    constructor(t = new di(1, 0, 0), e = 0) {
      this.isPlane = !0,
        this.normal = t,
        this.constant = e
    }
    set(t, e) {
      return this.normal.copy(t),
        this.constant = e,
        this
    }
    setComponents(t, e, i, n) {
      return this.normal.set(t, e, i),
        this.constant = n,
        this
    }
    setFromNormalAndCoplanarPoint(t, e) {
      return this.normal.copy(t),
        this.constant = -e.dot(this.normal),
        this
    }
    setFromCoplanarPoints(t, e, i) {
      const n = xr.subVectors(i, e).cross(Ir.subVectors(t, e)).normalize();
      return this.setFromNormalAndCoplanarPoint(n, t),
        this
    }
    copy(t) {
      return this.normal.copy(t.normal),
        this.constant = t.constant,
        this
    }
    normalize() {
      const t = 1 / this.normal.length();
      return this.normal.multiplyScalar(t),
        this.constant *= t,
        this
    }
    negate() {
      return this.constant *= -1,
        this.normal.negate(),
        this
    }
    distanceToPoint(t) {
      return this.normal.dot(t) + this.constant
    }
    distanceToSphere(t) {
      return this.distanceToPoint(t.center) - t.radius
    }
    projectPoint(t, e) {
      return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
    }
    intersectLine(t, e) {
      const i = t.delta(xr)
        , n = this.normal.dot(i);
      if (0 === n)
        return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
      const r = -(t.start.dot(this.normal) + this.constant) / n;
      return r < 0 || r > 1 ? null : e.copy(i).multiplyScalar(r).add(t.start)
    }
    intersectsLine(t) {
      const e = this.distanceToPoint(t.start)
        , i = this.distanceToPoint(t.end);
      return e < 0 && i > 0 || i < 0 && e > 0
    }
    intersectsBox(t) {
      return t.intersectsPlane(this)
    }
    intersectsSphere(t) {
      return t.intersectsPlane(this)
    }
    coplanarPoint(t) {
      return t.copy(this.normal).multiplyScalar(-this.constant)
    }
    applyMatrix4(t, e) {
      const i = e || Cr.getNormalMatrix(t)
        , n = this.coplanarPoint(xr).applyMatrix4(t)
        , r = this.normal.applyMatrix3(i).normalize();
      return this.constant = -n.dot(r),
        this
    }
    translate(t) {
      return this.constant -= t.dot(this.normal),
        this
    }
    equals(t) {
      return t.normal.equals(this.normal) && t.constant === this.constant
    }
    clone() {
      return (new this.constructor).copy(this)
    }
  }
  const _r = new Oi
    , Sr = new di;
  class Mr {
    constructor(t = new wr, e = new wr, i = new wr, n = new wr, r = new wr, o = new wr) {
      this.planes = [t, e, i, n, r, o]
    }
    set(t, e, i, n, r, o) {
      const s = this.planes;
      return s[0].copy(t),
        s[1].copy(e),
        s[2].copy(i),
        s[3].copy(n),
        s[4].copy(r),
        s[5].copy(o),
        this
    }
    copy(t) {
      const e = this.planes;
      for (let i = 0; i < 6; i++)
        e[i].copy(t.planes[i]);
      return this
    }
    setFromProjectionMatrix(t) {
      const e = this.planes
        , i = t.elements
        , n = i[0]
        , r = i[1]
        , o = i[2]
        , s = i[3]
        , a = i[4]
        , l = i[5]
        , h = i[6]
        , c = i[7]
        , u = i[8]
        , p = i[9]
        , d = i[10]
        , f = i[11]
        , g = i[12]
        , m = i[13]
        , y = i[14]
        , v = i[15];
      return e[0].setComponents(s - n, c - a, f - u, v - g).normalize(),
        e[1].setComponents(s + n, c + a, f + u, v + g).normalize(),
        e[2].setComponents(s + r, c + l, f + p, v + m).normalize(),
        e[3].setComponents(s - r, c - l, f - p, v - m).normalize(),
        e[4].setComponents(s - o, c - h, f - d, v - y).normalize(),
        e[5].setComponents(s + o, c + h, f + d, v + y).normalize(),
        this
    }
    intersectsObject(t) {
      const e = t.geometry;
      return null === e.boundingSphere && e.computeBoundingSphere(),
        _r.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),
        this.intersectsSphere(_r)
    }
    intersectsSprite(t) {
      return _r.center.set(0, 0, 0),
        _r.radius = .7071067811865476,
        _r.applyMatrix4(t.matrixWorld),
        this.intersectsSphere(_r)
    }
    intersectsSphere(t) {
      const e = this.planes
        , i = t.center
        , n = -t.radius;
      for (let t = 0; t < 6; t++) {
        if (e[t].distanceToPoint(i) < n)
          return !1
      }
      return !0
    }
    intersectsBox(t) {
      const e = this.planes;
      for (let i = 0; i < 6; i++) {
        const n = e[i];
        if (Sr.x = n.normal.x > 0 ? t.max.x : t.min.x,
          Sr.y = n.normal.y > 0 ? t.max.y : t.min.y,
          Sr.z = n.normal.z > 0 ? t.max.z : t.min.z,
          n.distanceToPoint(Sr) < 0)
          return !1
      }
      return !0
    }
    containsPoint(t) {
      const e = this.planes;
      for (let i = 0; i < 6; i++)
        if (e[i].distanceToPoint(t) < 0)
          return !1;
      return !0
    }
    clone() {
      return (new this.constructor).copy(this)
    }
  }
  function Tr() {
    let t = null
      , e = !1
      , i = null
      , n = null;
    function r(e, o) {
      i(e, o),
        n = t.requestAnimationFrame(r)
    }
    return {
      start: function () {
        !0 !== e && null !== i && (n = t.requestAnimationFrame(r),
          e = !0)
      },
      stop: function () {
        t.cancelAnimationFrame(n),
          e = !1
      },
      setAnimationLoop: function (t) {
        i = t
      },
      setContext: function (e) {
        t = e
      }
    }
  }
  function Er(t, e) {
    const i = e.isWebGL2
      , n = new WeakMap;
    return {
      get: function (t) {
        return t.isInterleavedBufferAttribute && (t = t.data),
          n.get(t)
      },
      remove: function (e) {
        e.isInterleavedBufferAttribute && (e = e.data);
        const i = n.get(e);
        i && (t.deleteBuffer(i.buffer),
          n.delete(e))
      },
      update: function (e, r) {
        if (e.isGLBufferAttribute) {
          const t = n.get(e);
          return void ((!t || t.version < e.version) && n.set(e, {
            buffer: e.buffer,
            type: e.type,
            bytesPerElement: e.elementSize,
            version: e.version
          }))
        }
        e.isInterleavedBufferAttribute && (e = e.data);
        const o = n.get(e);
        void 0 === o ? n.set(e, function (e, n) {
          const r = e.array
            , o = e.usage
            , s = t.createBuffer();
          let a;
          if (t.bindBuffer(n, s),
            t.bufferData(n, r, o),
            e.onUploadCallback(),
            r instanceof Float32Array)
            a = 5126;
          else if (r instanceof Uint16Array)
            if (e.isFloat16BufferAttribute) {
              if (!i)
                throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
              a = 5131
            } else
              a = 5123;
          else if (r instanceof Int16Array)
            a = 5122;
          else if (r instanceof Uint32Array)
            a = 5125;
          else if (r instanceof Int32Array)
            a = 5124;
          else if (r instanceof Int8Array)
            a = 5120;
          else if (r instanceof Uint8Array)
            a = 5121;
          else {
            if (!(r instanceof Uint8ClampedArray))
              throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + r);
            a = 5121
          }
          return {
            buffer: s,
            type: a,
            bytesPerElement: r.BYTES_PER_ELEMENT,
            version: e.version
          }
        }(e, r)) : o.version < e.version && (!function (e, n, r) {
          const o = n.array
            , s = n.updateRange;
          t.bindBuffer(r, e),
            -1 === s.count ? t.bufferSubData(r, 0, o) : (i ? t.bufferSubData(r, s.offset * o.BYTES_PER_ELEMENT, o, s.offset, s.count) : t.bufferSubData(r, s.offset * o.BYTES_PER_ELEMENT, o.subarray(s.offset, s.offset + s.count)),
              s.count = -1)
        }(o.buffer, e, r),
          o.version = e.version)
      }
    }
  }
  class kr extends Wn {
    constructor(t = 1, e = 1, i = 1, n = 1) {
      super(),
        this.type = "PlaneGeometry",
        this.parameters = {
          width: t,
          height: e,
          widthSegments: i,
          heightSegments: n
        };
      const r = t / 2
        , o = e / 2
        , s = Math.floor(i)
        , a = Math.floor(n)
        , l = s + 1
        , h = a + 1
        , c = t / s
        , u = e / a
        , p = []
        , d = []
        , f = []
        , g = [];
      for (let t = 0; t < h; t++) {
        const e = t * u - o;
        for (let i = 0; i < l; i++) {
          const n = i * c - r;
          d.push(n, -e, 0),
            f.push(0, 0, 1),
            g.push(i / s),
            g.push(1 - t / a)
        }
      }
      for (let t = 0; t < a; t++)
        for (let e = 0; e < s; e++) {
          const i = e + l * t
            , n = e + l * (t + 1)
            , r = e + 1 + l * (t + 1)
            , o = e + 1 + l * t;
          p.push(i, n, o),
            p.push(n, r, o)
        }
      this.setIndex(p),
        this.setAttribute("position", new Dn(d, 3)),
        this.setAttribute("normal", new Dn(f, 3)),
        this.setAttribute("uv", new Dn(g, 2))
    }
    static fromJSON(t) {
      return new kr(t.width, t.height, t.widthSegments, t.heightSegments)
    }
  }
  const Rr = {
    alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
    alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
    alphatest_fragment: "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
    alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
    aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
    aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
    begin_vertex: "vec3 transformed = vec3( position );",
    beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
    bsdfs: "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\nvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = mix(F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence);\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif",
    iridescence_fragment: "#ifdef USE_IRIDESCENCE\nconst mat3 XYZ_TO_REC709 = mat3(\n    3.2404542, -0.9692660,  0.0556434,\n   -1.5371385,  1.8760108, -0.2040259,\n   -0.4985314,  0.0415560,  1.0572252\n);\nvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n   vec3 sqrtF0 = sqrt( fresnel0 );\n   return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n}\nvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n   return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n}\nfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n   return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n}\nvec3 evalSensitivity( float OPD, vec3 shift ) {\n   float phase = 2.0 * PI * OPD * 1.0e-9;\n   vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n   vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n   vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n   vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( -pow2( phase ) * var );\n   xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[0] ) * exp( -4.5282e+09 * pow2( phase ) );\n   xyz /= 1.0685e-7;\n   vec3 srgb = XYZ_TO_REC709 * xyz;\n   return srgb;\n}\nvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n   vec3 I;\n   float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n   float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n   float cosTheta2Sq = 1.0 - sinTheta2Sq;\n   if ( cosTheta2Sq < 0.0 ) {\n       return vec3( 1.0 );\n   }\n   float cosTheta2 = sqrt( cosTheta2Sq );\n   float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n   float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n   float R21 = R12;\n   float T121 = 1.0 - R12;\n   float phi12 = 0.0;\n   if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n   float phi21 = PI - phi12;\n   vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );   vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n   vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n   vec3 phi23 = vec3( 0.0 );\n   if ( baseIOR[0] < iridescenceIOR ) phi23[0] = PI;\n   if ( baseIOR[1] < iridescenceIOR ) phi23[1] = PI;\n   if ( baseIOR[2] < iridescenceIOR ) phi23[2] = PI;\n   float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n   vec3 phi = vec3( phi21 ) + phi23;\n   vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n   vec3 r123 = sqrt( R123 );\n   vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n   vec3 C0 = R12 + Rs;\n   I = C0;\n   vec3 Cm = Rs - T121;\n   for ( int m = 1; m <= 2; ++m ) {\n       Cm *= r123;\n       vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n       I += Cm * Sm;\n   }\n   return max( I, vec3( 0.0 ) );\n}\n#endif",
    bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
    clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
    clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
    clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
    clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
    color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
    color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
    color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
    color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
    common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
    cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
    defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
    displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
    displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
    emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
    emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
    encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
    encodings_pars_fragment: "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",
    envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
    envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
    envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
    envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
    envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",
    envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
    fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
    fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
    fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
    fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
    gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
    lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
    lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
    lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
    lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
    lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
    lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
    lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
    lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
    lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif",
    lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n\t#else\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
    lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\nfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\nif ( material.iridescenceThickness == 0.0 ) {\n\tmaterial.iridescence = 0.0;\n} else {\n\tmaterial.iridescence = saturate( material.iridescence );\n}\nif ( material.iridescence > 0.0 ) {\n\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
    lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
    lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
    logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
    logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
    logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
    logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
    map_fragment: "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
    map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
    map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
    map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
    metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
    metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
    morphcolor_vertex: "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
    morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
    morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
    morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
    normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
    normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
    normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
    normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
    normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
    normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
    clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
    clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
    clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
    iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
    output_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
    packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
    premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
    project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
    dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
    dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
    roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
    roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
    shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
    shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
    shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
    shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
    skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
    skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif",
    skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
    skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
    specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
    specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
    tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
    tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
    transmission_fragment: "#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif",
    transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef texture2DLodEXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",
    uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
    uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
    uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
    uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
    uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
    uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
    worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
    background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
    background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tgl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n\t#endif\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
    cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
    cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
    depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
    depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
    distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
    distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
    equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
    equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
    linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
    linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
    meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
    meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
    meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
    meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
    meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
    meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
    meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
    meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
    meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
    points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
    shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
    shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
    sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
    sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}"
  }
    , Lr = {
      common: {
        diffuse: {
          value: new ei(16777215)
        },
        opacity: {
          value: 1
        },
        map: {
          value: null
        },
        uvTransform: {
          value: new Be
        },
        uv2Transform: {
          value: new Be
        },
        alphaMap: {
          value: null
        },
        alphaTest: {
          value: 0
        }
      },
      specularmap: {
        specularMap: {
          value: null
        }
      },
      envmap: {
        envMap: {
          value: null
        },
        flipEnvMap: {
          value: -1
        },
        reflectivity: {
          value: 1
        },
        ior: {
          value: 1.5
        },
        refractionRatio: {
          value: .98
        }
      },
      aomap: {
        aoMap: {
          value: null
        },
        aoMapIntensity: {
          value: 1
        }
      },
      lightmap: {
        lightMap: {
          value: null
        },
        lightMapIntensity: {
          value: 1
        }
      },
      emissivemap: {
        emissiveMap: {
          value: null
        }
      },
      bumpmap: {
        bumpMap: {
          value: null
        },
        bumpScale: {
          value: 1
        }
      },
      normalmap: {
        normalMap: {
          value: null
        },
        normalScale: {
          value: new Fe(1, 1)
        }
      },
      displacementmap: {
        displacementMap: {
          value: null
        },
        displacementScale: {
          value: 1
        },
        displacementBias: {
          value: 0
        }
      },
      roughnessmap: {
        roughnessMap: {
          value: null
        }
      },
      metalnessmap: {
        metalnessMap: {
          value: null
        }
      },
      gradientmap: {
        gradientMap: {
          value: null
        }
      },
      fog: {
        fogDensity: {
          value: 25e-5
        },
        fogNear: {
          value: 1
        },
        fogFar: {
          value: 2e3
        },
        fogColor: {
          value: new ei(16777215)
        }
      },
      lights: {
        ambientLightColor: {
          value: []
        },
        lightProbe: {
          value: []
        },
        directionalLights: {
          value: [],
          properties: {
            direction: {},
            color: {}
          }
        },
        directionalLightShadows: {
          value: [],
          properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {}
          }
        },
        directionalShadowMap: {
          value: []
        },
        directionalShadowMatrix: {
          value: []
        },
        spotLights: {
          value: [],
          properties: {
            color: {},
            position: {},
            direction: {},
            distance: {},
            coneCos: {},
            penumbraCos: {},
            decay: {}
          }
        },
        spotLightShadows: {
          value: [],
          properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {}
          }
        },
        spotShadowMap: {
          value: []
        },
        spotShadowMatrix: {
          value: []
        },
        pointLights: {
          value: [],
          properties: {
            color: {},
            position: {},
            decay: {},
            distance: {}
          }
        },
        pointLightShadows: {
          value: [],
          properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {},
            shadowCameraNear: {},
            shadowCameraFar: {}
          }
        },
        pointShadowMap: {
          value: []
        },
        pointShadowMatrix: {
          value: []
        },
        hemisphereLights: {
          value: [],
          properties: {
            direction: {},
            skyColor: {},
            groundColor: {}
          }
        },
        rectAreaLights: {
          value: [],
          properties: {
            color: {},
            position: {},
            width: {},
            height: {}
          }
        },
        ltc_1: {
          value: null
        },
        ltc_2: {
          value: null
        }
      },
      points: {
        diffuse: {
          value: new ei(16777215)
        },
        opacity: {
          value: 1
        },
        size: {
          value: 1
        },
        scale: {
          value: 1
        },
        map: {
          value: null
        },
        alphaMap: {
          value: null
        },
        alphaTest: {
          value: 0
        },
        uvTransform: {
          value: new Be
        }
      },
      sprite: {
        diffuse: {
          value: new ei(16777215)
        },
        opacity: {
          value: 1
        },
        center: {
          value: new Fe(.5, .5)
        },
        rotation: {
          value: 0
        },
        map: {
          value: null
        },
        alphaMap: {
          value: null
        },
        alphaTest: {
          value: 0
        },
        uvTransform: {
          value: new Be
        }
      }
    }
    , Pr = {
      basic: {
        uniforms: pr([Lr.common, Lr.specularmap, Lr.envmap, Lr.aomap, Lr.lightmap, Lr.fog]),
        vertexShader: Rr.meshbasic_vert,
        fragmentShader: Rr.meshbasic_frag
      },
      lambert: {
        uniforms: pr([Lr.common, Lr.specularmap, Lr.envmap, Lr.aomap, Lr.lightmap, Lr.emissivemap, Lr.fog, Lr.lights, {
          emissive: {
            value: new ei(0)
          }
        }]),
        vertexShader: Rr.meshlambert_vert,
        fragmentShader: Rr.meshlambert_frag
      },
      phong: {
        uniforms: pr([Lr.common, Lr.specularmap, Lr.envmap, Lr.aomap, Lr.lightmap, Lr.emissivemap, Lr.bumpmap, Lr.normalmap, Lr.displacementmap, Lr.fog, Lr.lights, {
          emissive: {
            value: new ei(0)
          },
          specular: {
            value: new ei(1118481)
          },
          shininess: {
            value: 30
          }
        }]),
        vertexShader: Rr.meshphong_vert,
        fragmentShader: Rr.meshphong_frag
      },
      standard: {
        uniforms: pr([Lr.common, Lr.envmap, Lr.aomap, Lr.lightmap, Lr.emissivemap, Lr.bumpmap, Lr.normalmap, Lr.displacementmap, Lr.roughnessmap, Lr.metalnessmap, Lr.fog, Lr.lights, {
          emissive: {
            value: new ei(0)
          },
          roughness: {
            value: 1
          },
          metalness: {
            value: 0
          },
          envMapIntensity: {
            value: 1
          }
        }]),
        vertexShader: Rr.meshphysical_vert,
        fragmentShader: Rr.meshphysical_frag
      },
      toon: {
        uniforms: pr([Lr.common, Lr.aomap, Lr.lightmap, Lr.emissivemap, Lr.bumpmap, Lr.normalmap, Lr.displacementmap, Lr.gradientmap, Lr.fog, Lr.lights, {
          emissive: {
            value: new ei(0)
          }
        }]),
        vertexShader: Rr.meshtoon_vert,
        fragmentShader: Rr.meshtoon_frag
      },
      matcap: {
        uniforms: pr([Lr.common, Lr.bumpmap, Lr.normalmap, Lr.displacementmap, Lr.fog, {
          matcap: {
            value: null
          }
        }]),
        vertexShader: Rr.meshmatcap_vert,
        fragmentShader: Rr.meshmatcap_frag
      },
      points: {
        uniforms: pr([Lr.points, Lr.fog]),
        vertexShader: Rr.points_vert,
        fragmentShader: Rr.points_frag
      },
      dashed: {
        uniforms: pr([Lr.common, Lr.fog, {
          scale: {
            value: 1
          },
          dashSize: {
            value: 1
          },
          totalSize: {
            value: 2
          }
        }]),
        vertexShader: Rr.linedashed_vert,
        fragmentShader: Rr.linedashed_frag
      },
      depth: {
        uniforms: pr([Lr.common, Lr.displacementmap]),
        vertexShader: Rr.depth_vert,
        fragmentShader: Rr.depth_frag
      },
      normal: {
        uniforms: pr([Lr.common, Lr.bumpmap, Lr.normalmap, Lr.displacementmap, {
          opacity: {
            value: 1
          }
        }]),
        vertexShader: Rr.meshnormal_vert,
        fragmentShader: Rr.meshnormal_frag
      },
      sprite: {
        uniforms: pr([Lr.sprite, Lr.fog]),
        vertexShader: Rr.sprite_vert,
        fragmentShader: Rr.sprite_frag
      },
      background: {
        uniforms: {
          uvTransform: {
            value: new Be
          },
          t2D: {
            value: null
          }
        },
        vertexShader: Rr.background_vert,
        fragmentShader: Rr.background_frag
      },
      cube: {
        uniforms: pr([Lr.envmap, {
          opacity: {
            value: 1
          }
        }]),
        vertexShader: Rr.cube_vert,
        fragmentShader: Rr.cube_frag
      },
      equirect: {
        uniforms: {
          tEquirect: {
            value: null
          }
        },
        vertexShader: Rr.equirect_vert,
        fragmentShader: Rr.equirect_frag
      },
      distanceRGBA: {
        uniforms: pr([Lr.common, Lr.displacementmap, {
          referencePosition: {
            value: new di
          },
          nearDistance: {
            value: 1
          },
          farDistance: {
            value: 1e3
          }
        }]),
        vertexShader: Rr.distanceRGBA_vert,
        fragmentShader: Rr.distanceRGBA_frag
      },
      shadow: {
        uniforms: pr([Lr.lights, Lr.fog, {
          color: {
            value: new ei(0)
          },
          opacity: {
            value: 1
          }
        }]),
        vertexShader: Rr.shadow_vert,
        fragmentShader: Rr.shadow_frag
      }
    };
  function zr(t, e, i, n, r, o) {
    const s = new ei(0);
    let a, c, u = !0 === r ? 0 : 1, p = null, d = 0, f = null;
    function g(t, e) {
      i.buffers.color.setClear(t.r, t.g, t.b, e, o)
    }
    return {
      getClearColor: function () {
        return s
      },
      setClearColor: function (t, e = 1) {
        s.set(t),
          u = e,
          g(s, u)
      },
      getClearAlpha: function () {
        return u
      },
      setClearAlpha: function (t) {
        u = t,
          g(s, u)
      },
      render: function (i, r) {
        let o = !1
          , m = !0 === r.isScene ? r.background : null;
        m && m.isTexture && (m = e.get(m));
        const y = t.xr
          , v = y.getSession && y.getSession();
        v && "additive" === v.environmentBlendMode && (m = null),
          null === m ? g(s, u) : m && m.isColor && (g(m, 1),
            o = !0),
          (t.autoClear || o) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
          m && (m.isCubeTexture || m.mapping === et) ? (void 0 === c && (c = new lr(new cr(1, 1, 1), new fr({
            name: "BackgroundCubeMaterial",
            uniforms: ur(Pr.cube.uniforms),
            vertexShader: Pr.cube.vertexShader,
            fragmentShader: Pr.cube.fragmentShader,
            side: h,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
          })),
            c.geometry.deleteAttribute("normal"),
            c.geometry.deleteAttribute("uv"),
            c.onBeforeRender = function (t, e, i) {
              this.matrixWorld.copyPosition(i.matrixWorld)
            }
            ,
            Object.defineProperty(c.material, "envMap", {
              get: function () {
                return this.uniforms.envMap.value
              }
            }),
            n.update(c)),
            c.material.uniforms.envMap.value = m,
            c.material.uniforms.flipEnvMap.value = m.isCubeTexture && !1 === m.isRenderTargetTexture ? -1 : 1,
            p === m && d === m.version && f === t.toneMapping || (c.material.needsUpdate = !0,
              p = m,
              d = m.version,
              f = t.toneMapping),
            c.layers.enableAll(),
            i.unshift(c, c.geometry, c.material, 0, 0, null)) : m && m.isTexture && (void 0 === a && (a = new lr(new kr(2, 2), new fr({
              name: "BackgroundMaterial",
              uniforms: ur(Pr.background.uniforms),
              vertexShader: Pr.background.vertexShader,
              fragmentShader: Pr.background.fragmentShader,
              side: l,
              depthTest: !1,
              depthWrite: !1,
              fog: !1
            })),
              a.geometry.deleteAttribute("normal"),
              Object.defineProperty(a.material, "map", {
                get: function () {
                  return this.uniforms.t2D.value
                }
              }),
              n.update(a)),
              a.material.uniforms.t2D.value = m,
              !0 === m.matrixAutoUpdate && m.updateMatrix(),
              a.material.uniforms.uvTransform.value.copy(m.matrix),
              p === m && d === m.version && f === t.toneMapping || (a.material.needsUpdate = !0,
                p = m,
                d = m.version,
                f = t.toneMapping),
              a.layers.enableAll(),
              i.unshift(a, a.geometry, a.material, 0, 0, null))
      }
    }
  }
  function Or(t, e, i, n) {
    const r = t.getParameter(34921)
      , o = n.isWebGL2 ? null : e.get("OES_vertex_array_object")
      , s = n.isWebGL2 || null !== o
      , a = {}
      , l = d(null);
    let h = l
      , c = !1;
    function u(e) {
      return n.isWebGL2 ? t.bindVertexArray(e) : o.bindVertexArrayOES(e)
    }
    function p(e) {
      return n.isWebGL2 ? t.deleteVertexArray(e) : o.deleteVertexArrayOES(e)
    }
    function d(t) {
      const e = []
        , i = []
        , n = [];
      for (let t = 0; t < r; t++)
        e[t] = 0,
          i[t] = 0,
          n[t] = 0;
      return {
        geometry: null,
        program: null,
        wireframe: !1,
        newAttributes: e,
        enabledAttributes: i,
        attributeDivisors: n,
        object: t,
        attributes: {},
        index: null
      }
    }
    function f() {
      const t = h.newAttributes;
      for (let e = 0, i = t.length; e < i; e++)
        t[e] = 0
    }
    function g(t) {
      m(t, 0)
    }
    function m(i, r) {
      const o = h.newAttributes
        , s = h.enabledAttributes
        , a = h.attributeDivisors;
      if (o[i] = 1,
        0 === s[i] && (t.enableVertexAttribArray(i),
          s[i] = 1),
        a[i] !== r) {
        (n.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](i, r),
          a[i] = r
      }
    }
    function y() {
      const e = h.newAttributes
        , i = h.enabledAttributes;
      for (let n = 0, r = i.length; n < r; n++)
        i[n] !== e[n] && (t.disableVertexAttribArray(n),
          i[n] = 0)
    }
    function v(e, i, r, o, s, a) {
      !0 !== n.isWebGL2 || 5124 !== r && 5125 !== r ? t.vertexAttribPointer(e, i, r, o, s, a) : t.vertexAttribIPointer(e, i, r, s, a)
    }
    function A() {
      b(),
        c = !0,
        h !== l && (h = l,
          u(h.object))
    }
    function b() {
      l.geometry = null,
        l.program = null,
        l.wireframe = !1
    }
    return {
      setup: function (r, l, p, A, b) {
        let x = !1;
        if (s) {
          const e = function (e, i, r) {
            const s = !0 === r.wireframe;
            let l = a[e.id];
            void 0 === l && (l = {},
              a[e.id] = l);
            let h = l[i.id];
            void 0 === h && (h = {},
              l[i.id] = h);
            let c = h[s];
            void 0 === c && (c = d(n.isWebGL2 ? t.createVertexArray() : o.createVertexArrayOES()),
              h[s] = c);
            return c
          }(A, p, l);
          h !== e && (h = e,
            u(h.object)),
            x = function (t, e, i, n) {
              const r = h.attributes
                , o = e.attributes;
              let s = 0;
              const a = i.getAttributes();
              for (const e in a) {
                if (a[e].location >= 0) {
                  const i = r[e];
                  let n = o[e];
                  if (void 0 === n && ("instanceMatrix" === e && t.instanceMatrix && (n = t.instanceMatrix),
                    "instanceColor" === e && t.instanceColor && (n = t.instanceColor)),
                    void 0 === i)
                    return !0;
                  if (i.attribute !== n)
                    return !0;
                  if (n && i.data !== n.data)
                    return !0;
                  s++
                }
              }
              return h.attributesNum !== s || h.index !== n
            }(r, A, p, b),
            x && function (t, e, i, n) {
              const r = {}
                , o = e.attributes;
              let s = 0;
              const a = i.getAttributes();
              for (const e in a) {
                if (a[e].location >= 0) {
                  let i = o[e];
                  void 0 === i && ("instanceMatrix" === e && t.instanceMatrix && (i = t.instanceMatrix),
                    "instanceColor" === e && t.instanceColor && (i = t.instanceColor));
                  const n = {};
                  n.attribute = i,
                    i && i.data && (n.data = i.data),
                    r[e] = n,
                    s++
                }
              }
              h.attributes = r,
                h.attributesNum = s,
                h.index = n
            }(r, A, p, b)
        } else {
          const t = !0 === l.wireframe;
          h.geometry === A.id && h.program === p.id && h.wireframe === t || (h.geometry = A.id,
            h.program = p.id,
            h.wireframe = t,
            x = !0)
        }
        null !== b && i.update(b, 34963),
          (x || c) && (c = !1,
            function (r, o, s, a) {
              if (!1 === n.isWebGL2 && (r.isInstancedMesh || a.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays"))
                return;
              f();
              const l = a.attributes
                , h = s.getAttributes()
                , c = o.defaultAttributeValues;
              for (const e in h) {
                const n = h[e];
                if (n.location >= 0) {
                  let o = l[e];
                  if (void 0 === o && ("instanceMatrix" === e && r.instanceMatrix && (o = r.instanceMatrix),
                    "instanceColor" === e && r.instanceColor && (o = r.instanceColor)),
                    void 0 !== o) {
                    const e = o.normalized
                      , s = o.itemSize
                      , l = i.get(o);
                    if (void 0 === l)
                      continue;
                    const h = l.buffer
                      , c = l.type
                      , u = l.bytesPerElement;
                    if (o.isInterleavedBufferAttribute) {
                      const i = o.data
                        , l = i.stride
                        , p = o.offset;
                      if (i.isInstancedInterleavedBuffer) {
                        for (let t = 0; t < n.locationSize; t++)
                          m(n.location + t, i.meshPerAttribute);
                        !0 !== r.isInstancedMesh && void 0 === a._maxInstanceCount && (a._maxInstanceCount = i.meshPerAttribute * i.count)
                      } else
                        for (let t = 0; t < n.locationSize; t++)
                          g(n.location + t);
                      t.bindBuffer(34962, h);
                      for (let t = 0; t < n.locationSize; t++)
                        v(n.location + t, s / n.locationSize, c, e, l * u, (p + s / n.locationSize * t) * u)
                    } else {
                      if (o.isInstancedBufferAttribute) {
                        for (let t = 0; t < n.locationSize; t++)
                          m(n.location + t, o.meshPerAttribute);
                        !0 !== r.isInstancedMesh && void 0 === a._maxInstanceCount && (a._maxInstanceCount = o.meshPerAttribute * o.count)
                      } else
                        for (let t = 0; t < n.locationSize; t++)
                          g(n.location + t);
                      t.bindBuffer(34962, h);
                      for (let t = 0; t < n.locationSize; t++)
                        v(n.location + t, s / n.locationSize, c, e, s * u, s / n.locationSize * t * u)
                    }
                  } else if (void 0 !== c) {
                    const i = c[e];
                    if (void 0 !== i)
                      switch (i.length) {
                        case 2:
                          t.vertexAttrib2fv(n.location, i);
                          break;
                        case 3:
                          t.vertexAttrib3fv(n.location, i);
                          break;
                        case 4:
                          t.vertexAttrib4fv(n.location, i);
                          break;
                        default:
                          t.vertexAttrib1fv(n.location, i)
                      }
                  }
                }
              }
              y()
            }(r, l, p, A),
            null !== b && t.bindBuffer(34963, i.get(b).buffer))
      },
      reset: A,
      resetDefaultState: b,
      dispose: function () {
        A();
        for (const t in a) {
          const e = a[t];
          for (const t in e) {
            const i = e[t];
            for (const t in i)
              p(i[t].object),
                delete i[t];
            delete e[t]
          }
          delete a[t]
        }
      },
      releaseStatesOfGeometry: function (t) {
        if (void 0 === a[t.id])
          return;
        const e = a[t.id];
        for (const t in e) {
          const i = e[t];
          for (const t in i)
            p(i[t].object),
              delete i[t];
          delete e[t]
        }
        delete a[t.id]
      },
      releaseStatesOfProgram: function (t) {
        for (const e in a) {
          const i = a[e];
          if (void 0 === i[t.id])
            continue;
          const n = i[t.id];
          for (const t in n)
            p(n[t].object),
              delete n[t];
          delete i[t.id]
        }
      },
      initAttributes: f,
      enableAttribute: g,
      disableUnusedAttributes: y
    }
  }
  function Dr(t, e, i, n) {
    const r = n.isWebGL2;
    let o;
    this.setMode = function (t) {
      o = t
    }
      ,
      this.render = function (e, n) {
        t.drawArrays(o, e, n),
          i.update(n, o, 1)
      }
      ,
      this.renderInstances = function (n, s, a) {
        if (0 === a)
          return;
        let l, h;
        if (r)
          l = t,
            h = "drawArraysInstanced";
        else if (l = e.get("ANGLE_instanced_arrays"),
          h = "drawArraysInstancedANGLE",
          null === l)
          return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        l[h](o, n, s, a),
          i.update(s, o, a)
      }
  }
  function Ur(t, e, i) {
    let n;
    function r(e) {
      if ("highp" === e) {
        if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0)
          return "highp";
        e = "mediump"
      }
      return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
    }
    const o = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext;
    let s = void 0 !== i.precision ? i.precision : "highp";
    const a = r(s);
    a !== s && (console.warn("THREE.WebGLRenderer:", s, "not supported, using", a, "instead."),
      s = a);
    const l = o || e.has("WEBGL_draw_buffers")
      , h = !0 === i.logarithmicDepthBuffer
      , c = t.getParameter(34930)
      , u = t.getParameter(35660)
      , p = t.getParameter(3379)
      , d = t.getParameter(34076)
      , f = t.getParameter(34921)
      , g = t.getParameter(36347)
      , m = t.getParameter(36348)
      , y = t.getParameter(36349)
      , v = u > 0
      , A = o || e.has("OES_texture_float");
    return {
      isWebGL2: o,
      drawBuffers: l,
      getMaxAnisotropy: function () {
        if (void 0 !== n)
          return n;
        if (!0 === e.has("EXT_texture_filter_anisotropic")) {
          const i = e.get("EXT_texture_filter_anisotropic");
          n = t.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
        } else
          n = 0;
        return n
      },
      getMaxPrecision: r,
      precision: s,
      logarithmicDepthBuffer: h,
      maxTextures: c,
      maxVertexTextures: u,
      maxTextureSize: p,
      maxCubemapSize: d,
      maxAttributes: f,
      maxVertexUniforms: g,
      maxVaryings: m,
      maxFragmentUniforms: y,
      vertexTextures: v,
      floatFragmentTextures: A,
      floatVertexTextures: v && A,
      maxSamples: o ? t.getParameter(36183) : 0
    }
  }
  function Nr(t) {
    const e = this;
    let i = null
      , n = 0
      , r = !1
      , o = !1;
    const s = new wr
      , a = new Be
      , l = {
        value: null,
        needsUpdate: !1
      };
    function h() {
      l.value !== i && (l.value = i,
        l.needsUpdate = n > 0),
        e.numPlanes = n,
        e.numIntersection = 0
    }
    function c(t, i, n, r) {
      const o = null !== t ? t.length : 0;
      let h = null;
      if (0 !== o) {
        if (h = l.value,
          !0 !== r || null === h) {
          const e = n + 4 * o
            , r = i.matrixWorldInverse;
          a.getNormalMatrix(r),
            (null === h || h.length < e) && (h = new Float32Array(e));
          for (let e = 0, i = n; e !== o; ++e,
            i += 4)
            s.copy(t[e]).applyMatrix4(r, a),
              s.normal.toArray(h, i),
              h[i + 3] = s.constant
        }
        l.value = h,
          l.needsUpdate = !0
      }
      return e.numPlanes = o,
        e.numIntersection = 0,
        h
    }
    this.uniform = l,
      this.numPlanes = 0,
      this.numIntersection = 0,
      this.init = function (t, e, o) {
        const s = 0 !== t.length || e || 0 !== n || r;
        return r = e,
          i = c(t, o, 0),
          n = t.length,
          s
      }
      ,
      this.beginShadows = function () {
        o = !0,
          c(null)
      }
      ,
      this.endShadows = function () {
        o = !1,
          h()
      }
      ,
      this.setState = function (e, s, a) {
        const u = e.clippingPlanes
          , p = e.clipIntersection
          , d = e.clipShadows
          , f = t.get(e);
        if (!r || null === u || 0 === u.length || o && !d)
          o ? c(null) : h();
        else {
          const t = o ? 0 : n
            , e = 4 * t;
          let r = f.clippingState || null;
          l.value = r,
            r = c(u, s, e, a);
          for (let t = 0; t !== e; ++t)
            r[t] = i[t];
          f.clippingState = r,
            this.numIntersection = p ? this.numPlanes : 0,
            this.numPlanes += t
        }
      }
  }
  function Fr(t) {
    let e = new WeakMap;
    function i(t, e) {
      return e === $ ? t.mapping = q : e === tt && (t.mapping = X),
        t
    }
    function n(t) {
      const i = t.target;
      i.removeEventListener("dispose", n);
      const r = e.get(i);
      void 0 !== r && (e.delete(i),
        r.dispose())
    }
    return {
      get: function (r) {
        if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
          const o = r.mapping;
          if (o === $ || o === tt) {
            if (e.has(r)) {
              return i(e.get(r).texture, r.mapping)
            }
            {
              const o = r.image;
              if (o && o.height > 0) {
                const s = new br(o.height / 2);
                return s.fromEquirectangularTexture(t, r),
                  e.set(r, s),
                  r.addEventListener("dispose", n),
                  i(s.texture, r.mapping)
              }
              return null
            }
          }
        }
        return r
      },
      dispose: function () {
        e = new WeakMap
      }
    }
  }
  Pr.physical = {
    uniforms: pr([Pr.standard.uniforms, {
      clearcoat: {
        value: 0
      },
      clearcoatMap: {
        value: null
      },
      clearcoatRoughness: {
        value: 0
      },
      clearcoatRoughnessMap: {
        value: null
      },
      clearcoatNormalScale: {
        value: new Fe(1, 1)
      },
      clearcoatNormalMap: {
        value: null
      },
      iridescence: {
        value: 0
      },
      iridescenceMap: {
        value: null
      },
      iridescenceIOR: {
        value: 1.3
      },
      iridescenceThicknessMinimum: {
        value: 100
      },
      iridescenceThicknessMaximum: {
        value: 400
      },
      iridescenceThicknessMap: {
        value: null
      },
      sheen: {
        value: 0
      },
      sheenColor: {
        value: new ei(0)
      },
      sheenColorMap: {
        value: null
      },
      sheenRoughness: {
        value: 1
      },
      sheenRoughnessMap: {
        value: null
      },
      transmission: {
        value: 0
      },
      transmissionMap: {
        value: null
      },
      transmissionSamplerSize: {
        value: new Fe
      },
      transmissionSamplerMap: {
        value: null
      },
      thickness: {
        value: 0
      },
      thicknessMap: {
        value: null
      },
      attenuationDistance: {
        value: 0
      },
      attenuationColor: {
        value: new ei(0)
      },
      specularIntensity: {
        value: 1
      },
      specularIntensityMap: {
        value: null
      },
      specularColor: {
        value: new ei(1, 1, 1)
      },
      specularColorMap: {
        value: null
      }
    }]),
    vertexShader: Rr.meshphysical_vert,
    fragmentShader: Rr.meshphysical_frag
  };
  class Br extends gr {
    constructor(t = -1, e = 1, i = 1, n = -1, r = .1, o = 2e3) {
      super(),
        this.isOrthographicCamera = !0,
        this.type = "OrthographicCamera",
        this.zoom = 1,
        this.view = null,
        this.left = t,
        this.right = e,
        this.top = i,
        this.bottom = n,
        this.near = r,
        this.far = o,
        this.updateProjectionMatrix()
    }
    copy(t, e) {
      return super.copy(t, e),
        this.left = t.left,
        this.right = t.right,
        this.top = t.top,
        this.bottom = t.bottom,
        this.near = t.near,
        this.far = t.far,
        this.zoom = t.zoom,
        this.view = null === t.view ? null : Object.assign({}, t.view),
        this
    }
    setViewOffset(t, e, i, n, r, o) {
      null === this.view && (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      }),
        this.view.enabled = !0,
        this.view.fullWidth = t,
        this.view.fullHeight = e,
        this.view.offsetX = i,
        this.view.offsetY = n,
        this.view.width = r,
        this.view.height = o,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
      null !== this.view && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
      const t = (this.right - this.left) / (2 * this.zoom)
        , e = (this.top - this.bottom) / (2 * this.zoom)
        , i = (this.right + this.left) / 2
        , n = (this.top + this.bottom) / 2;
      let r = i - t
        , o = i + t
        , s = n + e
        , a = n - e;
      if (null !== this.view && this.view.enabled) {
        const t = (this.right - this.left) / this.view.fullWidth / this.zoom
          , e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
        r += t * this.view.offsetX,
          o = r + t * this.view.width,
          s -= e * this.view.offsetY,
          a = s - e * this.view.height
      }
      this.projectionMatrix.makeOrthographic(r, o, s, a, this.near, this.far),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(t) {
      const e = super.toJSON(t);
      return e.object.zoom = this.zoom,
        e.object.left = this.left,
        e.object.right = this.right,
        e.object.top = this.top,
        e.object.bottom = this.bottom,
        e.object.near = this.near,
        e.object.far = this.far,
        null !== this.view && (e.object.view = Object.assign({}, this.view)),
        e
    }
  }
  const jr = [.125, .215, .35, .446, .526, .582]
    , Vr = 20
    , Gr = new Br
    , Wr = new ei;
  let Jr = null;
  const Hr = (1 + Math.sqrt(5)) / 2
    , Zr = 1 / Hr
    , Qr = [new di(1, 1, 1), new di(-1, 1, 1), new di(1, 1, -1), new di(-1, 1, -1), new di(0, Hr, Zr), new di(0, Hr, -Zr), new di(Zr, 0, Hr), new di(-Zr, 0, Hr), new di(Hr, Zr, 0), new di(-Hr, Zr, 0)];
  class Kr {
    constructor(t) {
      this._renderer = t,
        this._pingPongRenderTarget = null,
        this._lodMax = 0,
        this._cubeSize = 0,
        this._lodPlanes = [],
        this._sizeLods = [],
        this._sigmas = [],
        this._blurMaterial = null,
        this._cubemapMaterial = null,
        this._equirectMaterial = null,
        this._compileMaterial(this._blurMaterial)
    }
    fromScene(t, e = 0, i = .1, n = 100) {
      Jr = this._renderer.getRenderTarget(),
        this._setSize(256);
      const r = this._allocateTargets();
      return r.depthBuffer = !0,
        this._sceneToCubeUV(t, i, n, r),
        e > 0 && this._blur(r, 0, 0, e),
        this._applyPMREM(r),
        this._cleanup(r),
        r
    }
    fromEquirectangular(t, e = null) {
      return this._fromTexture(t, e)
    }
    fromCubemap(t, e = null) {
      return this._fromTexture(t, e)
    }
    compileCubemapShader() {
      null === this._cubemapMaterial && (this._cubemapMaterial = $r(),
        this._compileMaterial(this._cubemapMaterial))
    }
    compileEquirectangularShader() {
      null === this._equirectMaterial && (this._equirectMaterial = Xr(),
        this._compileMaterial(this._equirectMaterial))
    }
    dispose() {
      this._dispose(),
        null !== this._cubemapMaterial && this._cubemapMaterial.dispose(),
        null !== this._equirectMaterial && this._equirectMaterial.dispose()
    }
    _setSize(t) {
      this._lodMax = Math.floor(Math.log2(t)),
        this._cubeSize = Math.pow(2, this._lodMax)
    }
    _dispose() {
      null !== this._blurMaterial && this._blurMaterial.dispose(),
        null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
      for (let t = 0; t < this._lodPlanes.length; t++)
        this._lodPlanes[t].dispose()
    }
    _cleanup(t) {
      this._renderer.setRenderTarget(Jr),
        t.scissorTest = !1,
        qr(t, 0, 0, t.width, t.height)
    }
    _fromTexture(t, e) {
      t.mapping === q || t.mapping === X ? this._setSize(0 === t.image.length ? 16 : t.image[0].width || t.image[0].image.width) : this._setSize(t.image.width / 4),
        Jr = this._renderer.getRenderTarget();
      const i = e || this._allocateTargets();
      return this._textureToCubeUV(t, i),
        this._applyPMREM(i),
        this._cleanup(i),
        i
    }
    _allocateTargets() {
      const t = 3 * Math.max(this._cubeSize, 112)
        , e = 4 * this._cubeSize
        , i = {
          magFilter: lt,
          minFilter: lt,
          generateMipmaps: !1,
          type: vt,
          format: wt,
          encoding: fe,
          depthBuffer: !1
        }
        , n = Yr(t, e, i);
      if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== t) {
        null !== this._pingPongRenderTarget && this._dispose(),
          this._pingPongRenderTarget = Yr(t, e, i);
        const { _lodMax: n } = this;
        ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = function (t) {
          const e = []
            , i = []
            , n = [];
          let r = t;
          const o = t - 4 + 1 + jr.length;
          for (let s = 0; s < o; s++) {
            const o = Math.pow(2, r);
            i.push(o);
            let a = 1 / o;
            s > t - 4 ? a = jr[s - t + 4 - 1] : 0 === s && (a = 0),
              n.push(a);
            const l = 1 / (o - 2)
              , h = -l
              , c = 1 + l
              , u = [h, h, c, h, c, c, h, h, c, c, h, c]
              , p = 6
              , d = 6
              , f = 3
              , g = 2
              , m = 1
              , y = new Float32Array(f * d * p)
              , v = new Float32Array(g * d * p)
              , A = new Float32Array(m * d * p);
            for (let t = 0; t < p; t++) {
              const e = t % 3 * 2 / 3 - 1
                , i = t > 2 ? 0 : -1
                , n = [e, i, 0, e + 2 / 3, i, 0, e + 2 / 3, i + 1, 0, e, i, 0, e + 2 / 3, i + 1, 0, e, i + 1, 0];
              y.set(n, f * d * t),
                v.set(u, g * d * t);
              const r = [t, t, t, t, t, t];
              A.set(r, m * d * t)
            }
            const b = new Wn;
            b.setAttribute("position", new Pn(y, f)),
              b.setAttribute("uv", new Pn(v, g)),
              b.setAttribute("faceIndex", new Pn(A, m)),
              e.push(b),
              r > 4 && r--
          }
          return {
            lodPlanes: e,
            sizeLods: i,
            sigmas: n
          }
        }(n)),
          this._blurMaterial = function (t, e, i) {
            const n = new Float32Array(Vr)
              , r = new di(0, 1, 0)
              , o = new fr({
                name: "SphericalGaussianBlur",
                defines: {
                  n: Vr,
                  CUBEUV_TEXEL_WIDTH: 1 / e,
                  CUBEUV_TEXEL_HEIGHT: 1 / i,
                  CUBEUV_MAX_MIP: `${t}.0`
                },
                uniforms: {
                  envMap: {
                    value: null
                  },
                  samples: {
                    value: 1
                  },
                  weights: {
                    value: n
                  },
                  latitudinal: {
                    value: !1
                  },
                  dTheta: {
                    value: 0
                  },
                  mipInt: {
                    value: 0
                  },
                  poleAxis: {
                    value: r
                  }
                },
                vertexShader: to(),
                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                blending: u,
                depthTest: !1,
                depthWrite: !1
              });
            return o
          }(n, t, e)
      }
      return n
    }
    _compileMaterial(t) {
      const e = new lr(this._lodPlanes[0], t);
      this._renderer.compile(e, Gr)
    }
    _sceneToCubeUV(t, e, i, n) {
      const r = new mr(90, 1, e, i)
        , o = [1, -1, 1, 1, 1, 1]
        , s = [1, 1, 1, -1, -1, -1]
        , a = this._renderer
        , l = a.autoClear
        , c = a.toneMapping;
      a.getClearColor(Wr),
        a.toneMapping = W,
        a.autoClear = !1;
      const u = new kn({
        name: "PMREM.Background",
        side: h,
        depthWrite: !1,
        depthTest: !1
      })
        , p = new lr(new cr, u);
      let d = !1;
      const f = t.background;
      f ? f.isColor && (u.color.copy(f),
        t.background = null,
        d = !0) : (u.color.copy(Wr),
          d = !0);
      for (let e = 0; e < 6; e++) {
        const i = e % 3;
        0 === i ? (r.up.set(0, o[e], 0),
          r.lookAt(s[e], 0, 0)) : 1 === i ? (r.up.set(0, 0, o[e]),
            r.lookAt(0, s[e], 0)) : (r.up.set(0, o[e], 0),
              r.lookAt(0, 0, s[e]));
        const l = this._cubeSize;
        qr(n, i * l, e > 2 ? l : 0, l, l),
          a.setRenderTarget(n),
          d && a.render(p, r),
          a.render(t, r)
      }
      p.geometry.dispose(),
        p.material.dispose(),
        a.toneMapping = c,
        a.autoClear = l,
        t.background = f
    }
    _textureToCubeUV(t, e) {
      const i = this._renderer
        , n = t.mapping === q || t.mapping === X;
      n ? (null === this._cubemapMaterial && (this._cubemapMaterial = $r()),
        this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === t.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = Xr());
      const r = n ? this._cubemapMaterial : this._equirectMaterial
        , o = new lr(this._lodPlanes[0], r);
      r.uniforms.envMap.value = t;
      const s = this._cubeSize;
      qr(e, 0, 0, 3 * s, 2 * s),
        i.setRenderTarget(e),
        i.render(o, Gr)
    }
    _applyPMREM(t) {
      const e = this._renderer
        , i = e.autoClear;
      e.autoClear = !1;
      for (let e = 1; e < this._lodPlanes.length; e++) {
        const i = Math.sqrt(this._sigmas[e] * this._sigmas[e] - this._sigmas[e - 1] * this._sigmas[e - 1])
          , n = Qr[(e - 1) % Qr.length];
        this._blur(t, e - 1, e, i, n)
      }
      e.autoClear = i
    }
    _blur(t, e, i, n, r) {
      const o = this._pingPongRenderTarget;
      this._halfBlur(t, o, e, i, n, "latitudinal", r),
        this._halfBlur(o, t, i, i, n, "longitudinal", r)
    }
    _halfBlur(t, e, i, n, r, o, s) {
      const a = this._renderer
        , l = this._blurMaterial;
      "latitudinal" !== o && "longitudinal" !== o && console.error("blur direction must be either latitudinal or longitudinal!");
      const h = new lr(this._lodPlanes[n], l)
        , c = l.uniforms
        , u = this._sizeLods[i] - 1
        , p = isFinite(r) ? Math.PI / (2 * u) : 2 * Math.PI / 39
        , d = r / p
        , f = isFinite(r) ? 1 + Math.floor(3 * d) : Vr;
      f > Vr && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`);
      const g = [];
      let m = 0;
      for (let t = 0; t < Vr; ++t) {
        const e = t / d
          , i = Math.exp(-e * e / 2);
        g.push(i),
          0 === t ? m += i : t < f && (m += 2 * i)
      }
      for (let t = 0; t < g.length; t++)
        g[t] = g[t] / m;
      c.envMap.value = t.texture,
        c.samples.value = f,
        c.weights.value = g,
        c.latitudinal.value = "latitudinal" === o,
        s && (c.poleAxis.value = s);
      const { _lodMax: y } = this;
      c.dTheta.value = p,
        c.mipInt.value = y - i;
      const v = this._sizeLods[n];
      qr(e, 3 * v * (n > y - 4 ? n - y + 4 : 0), 4 * (this._cubeSize - v), 3 * v, 2 * v),
        a.setRenderTarget(e),
        a.render(h, Gr)
    }
  }
  function Yr(t, e, i) {
    const n = new hi(t, e, i);
    return n.texture.mapping = et,
      n.texture.name = "PMREM.cubeUv",
      n.scissorTest = !0,
      n
  }
  function qr(t, e, i, n, r) {
    t.viewport.set(e, i, n, r),
      t.scissor.set(e, i, n, r)
  }
  function Xr() {
    return new fr({
      name: "EquirectangularToCubeUV",
      uniforms: {
        envMap: {
          value: null
        }
      },
      vertexShader: to(),
      fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
      blending: u,
      depthTest: !1,
      depthWrite: !1
    })
  }
  function $r() {
    return new fr({
      name: "CubemapToCubeUV",
      uniforms: {
        envMap: {
          value: null
        },
        flipEnvMap: {
          value: -1
        }
      },
      vertexShader: to(),
      fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
      blending: u,
      depthTest: !1,
      depthWrite: !1
    })
  }
  function to() {
    return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"
  }
  function eo(t) {
    let e = new WeakMap
      , i = null;
    function n(t) {
      const i = t.target;
      i.removeEventListener("dispose", n);
      const r = e.get(i);
      void 0 !== r && (e.delete(i),
        r.dispose())
    }
    return {
      get: function (r) {
        if (r && r.isTexture) {
          const o = r.mapping
            , s = o === $ || o === tt
            , a = o === q || o === X;
          if (s || a) {
            if (r.isRenderTargetTexture && !0 === r.needsPMREMUpdate) {
              r.needsPMREMUpdate = !1;
              let n = e.get(r);
              return null === i && (i = new Kr(t)),
                n = s ? i.fromEquirectangular(r, n) : i.fromCubemap(r, n),
                e.set(r, n),
                n.texture
            }
            if (e.has(r))
              return e.get(r).texture;
            {
              const o = r.image;
              if (s && o && o.height > 0 || a && o && function (t) {
                let e = 0;
                const i = 6;
                for (let n = 0; n < i; n++)
                  void 0 !== t[n] && e++;
                return e === i
              }(o)) {
                null === i && (i = new Kr(t));
                const o = s ? i.fromEquirectangular(r) : i.fromCubemap(r);
                return e.set(r, o),
                  r.addEventListener("dispose", n),
                  o.texture
              }
              return null
            }
          }
        }
        return r
      },
      dispose: function () {
        e = new WeakMap,
          null !== i && (i.dispose(),
            i = null)
      }
    }
  }
  function io(t) {
    const e = {};
    function i(i) {
      if (void 0 !== e[i])
        return e[i];
      let n;
      switch (i) {
        case "WEBGL_depth_texture":
          n = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
          break;
        case "EXT_texture_filter_anisotropic":
          n = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
          break;
        case "WEBGL_compressed_texture_s3tc":
          n = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
          break;
        case "WEBGL_compressed_texture_pvrtc":
          n = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
          break;
        default:
          n = t.getExtension(i)
      }
      return e[i] = n,
        n
    }
    return {
      has: function (t) {
        return null !== i(t)
      },
      init: function (t) {
        t.isWebGL2 ? i("EXT_color_buffer_float") : (i("WEBGL_depth_texture"),
          i("OES_texture_float"),
          i("OES_texture_half_float"),
          i("OES_texture_half_float_linear"),
          i("OES_standard_derivatives"),
          i("OES_element_index_uint"),
          i("OES_vertex_array_object"),
          i("ANGLE_instanced_arrays")),
          i("OES_texture_float_linear"),
          i("EXT_color_buffer_half_float"),
          i("WEBGL_multisampled_render_to_texture")
      },
      get: function (t) {
        const e = i(t);
        return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."),
          e
      }
    }
  }
  function no(t, e, i, n) {
    const r = {}
      , o = new WeakMap;
    function s(t) {
      const a = t.target;
      null !== a.index && e.remove(a.index);
      for (const t in a.attributes)
        e.remove(a.attributes[t]);
      a.removeEventListener("dispose", s),
        delete r[a.id];
      const l = o.get(a);
      l && (e.remove(l),
        o.delete(a)),
        n.releaseStatesOfGeometry(a),
        !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount,
        i.memory.geometries--
    }
    function a(t) {
      const i = []
        , n = t.index
        , r = t.attributes.position;
      let s = 0;
      if (null !== n) {
        const t = n.array;
        s = n.version;
        for (let e = 0, n = t.length; e < n; e += 3) {
          const n = t[e + 0]
            , r = t[e + 1]
            , o = t[e + 2];
          i.push(n, r, r, o, o, n)
        }
      } else {
        const t = r.array;
        s = r.version;
        for (let e = 0, n = t.length / 3 - 1; e < n; e += 3) {
          const t = e + 0
            , n = e + 1
            , r = e + 2;
          i.push(t, n, n, r, r, t)
        }
      }
      const a = new (je(i) ? On : zn)(i, 1);
      a.version = s;
      const l = o.get(t);
      l && e.remove(l),
        o.set(t, a)
    }
    return {
      get: function (t, e) {
        return !0 === r[e.id] || (e.addEventListener("dispose", s),
          r[e.id] = !0,
          i.memory.geometries++),
          e
      },
      update: function (t) {
        const i = t.attributes;
        for (const t in i)
          e.update(i[t], 34962);
        const n = t.morphAttributes;
        for (const t in n) {
          const i = n[t];
          for (let t = 0, n = i.length; t < n; t++)
            e.update(i[t], 34962)
        }
      },
      getWireframeAttribute: function (t) {
        const e = o.get(t);
        if (e) {
          const i = t.index;
          null !== i && e.version < i.version && a(t)
        } else
          a(t);
        return o.get(t)
      }
    }
  }
  function ro(t, e, i, n) {
    const r = n.isWebGL2;
    let o, s, a;
    this.setMode = function (t) {
      o = t
    }
      ,
      this.setIndex = function (t) {
        s = t.type,
          a = t.bytesPerElement
      }
      ,
      this.render = function (e, n) {
        t.drawElements(o, n, s, e * a),
          i.update(n, o, 1)
      }
      ,
      this.renderInstances = function (n, l, h) {
        if (0 === h)
          return;
        let c, u;
        if (r)
          c = t,
            u = "drawElementsInstanced";
        else if (c = e.get("ANGLE_instanced_arrays"),
          u = "drawElementsInstancedANGLE",
          null === c)
          return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        c[u](o, l, s, n * a, h),
          i.update(l, o, h)
      }
  }
  function oo(t) {
    const e = {
      frame: 0,
      calls: 0,
      triangles: 0,
      points: 0,
      lines: 0
    };
    return {
      memory: {
        geometries: 0,
        textures: 0
      },
      render: e,
      programs: null,
      autoReset: !0,
      reset: function () {
        e.frame++,
          e.calls = 0,
          e.triangles = 0,
          e.points = 0,
          e.lines = 0
      },
      update: function (t, i, n) {
        switch (e.calls++,
        i) {
          case 4:
            e.triangles += n * (t / 3);
            break;
          case 1:
            e.lines += n * (t / 2);
            break;
          case 3:
            e.lines += n * (t - 1);
            break;
          case 2:
            e.lines += n * t;
            break;
          case 0:
            e.points += n * t;
            break;
          default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", i)
        }
      }
    }
  }
  function so(t, e) {
    return t[0] - e[0]
  }
  function ao(t, e) {
    return Math.abs(e[1]) - Math.abs(t[1])
  }
  function lo(t, e) {
    let i = 1;
    const n = e.isInterleavedBufferAttribute ? e.data.array : e.array;
    n instanceof Int8Array ? i = 127 : n instanceof Uint8Array ? i = 255 : n instanceof Uint16Array ? i = 65535 : n instanceof Int16Array ? i = 32767 : n instanceof Int32Array ? i = 2147483647 : console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", n),
      t.divideScalar(i)
  }
  function ho(t, e, i) {
    const n = {}
      , r = new Float32Array(8)
      , o = new WeakMap
      , s = new li
      , a = [];
    for (let t = 0; t < 8; t++)
      a[t] = [t, 0];
    return {
      update: function (l, h, c, u) {
        const p = l.morphTargetInfluences;
        if (!0 === e.isWebGL2) {
          const d = h.morphAttributes.position || h.morphAttributes.normal || h.morphAttributes.color
            , f = void 0 !== d ? d.length : 0;
          let g = o.get(h);
          if (void 0 === g || g.count !== f) {
            void 0 !== g && g.texture.dispose();
            const v = void 0 !== h.morphAttributes.position
              , A = void 0 !== h.morphAttributes.normal
              , b = void 0 !== h.morphAttributes.color
              , x = h.morphAttributes.position || []
              , I = h.morphAttributes.normal || []
              , C = h.morphAttributes.color || [];
            let w = 0;
            !0 === v && (w = 1),
              !0 === A && (w = 2),
              !0 === b && (w = 3);
            let _ = h.attributes.position.count * w
              , S = 1;
            _ > e.maxTextureSize && (S = Math.ceil(_ / e.maxTextureSize),
              _ = e.maxTextureSize);
            const M = new Float32Array(_ * S * 4 * f)
              , T = new ci(M, _, S, f);
            T.type = yt,
              T.needsUpdate = !0;
            const E = 4 * w;
            for (let R = 0; R < f; R++) {
              const L = x[R]
                , P = I[R]
                , z = C[R]
                , O = _ * S * 4 * R;
              for (let D = 0; D < L.count; D++) {
                const U = D * E;
                !0 === v && (s.fromBufferAttribute(L, D),
                  !0 === L.normalized && lo(s, L),
                  M[O + U + 0] = s.x,
                  M[O + U + 1] = s.y,
                  M[O + U + 2] = s.z,
                  M[O + U + 3] = 0),
                  !0 === A && (s.fromBufferAttribute(P, D),
                    !0 === P.normalized && lo(s, P),
                    M[O + U + 4] = s.x,
                    M[O + U + 5] = s.y,
                    M[O + U + 6] = s.z,
                    M[O + U + 7] = 0),
                  !0 === b && (s.fromBufferAttribute(z, D),
                    !0 === z.normalized && lo(s, z),
                    M[O + U + 8] = s.x,
                    M[O + U + 9] = s.y,
                    M[O + U + 10] = s.z,
                    M[O + U + 11] = 4 === z.itemSize ? s.w : 1)
              }
            }
            function k() {
              T.dispose(),
                o.delete(h),
                h.removeEventListener("dispose", k)
            }
            g = {
              count: f,
              texture: T,
              size: new Fe(_, S)
            },
              o.set(h, g),
              h.addEventListener("dispose", k)
          }
          let m = 0;
          for (let N = 0; N < p.length; N++)
            m += p[N];
          const y = h.morphTargetsRelative ? 1 : 1 - m;
          u.getUniforms().setValue(t, "morphTargetBaseInfluence", y),
            u.getUniforms().setValue(t, "morphTargetInfluences", p),
            u.getUniforms().setValue(t, "morphTargetsTexture", g.texture, i),
            u.getUniforms().setValue(t, "morphTargetsTextureSize", g.size)
        } else {
          const F = void 0 === p ? 0 : p.length;
          let B = n[h.id];
          if (void 0 === B || B.length !== F) {
            B = [];
            for (let J = 0; J < F; J++)
              B[J] = [J, 0];
            n[h.id] = B
          }
          for (let H = 0; H < F; H++) {
            const Z = B[H];
            Z[0] = H,
              Z[1] = p[H]
          }
          B.sort(ao);
          for (let Q = 0; Q < 8; Q++)
            Q < F && B[Q][1] ? (a[Q][0] = B[Q][0],
              a[Q][1] = B[Q][1]) : (a[Q][0] = Number.MAX_SAFE_INTEGER,
                a[Q][1] = 0);
          a.sort(so);
          const j = h.morphAttributes.position
            , V = h.morphAttributes.normal;
          let G = 0;
          for (let K = 0; K < 8; K++) {
            const Y = a[K]
              , q = Y[0]
              , X = Y[1];
            q !== Number.MAX_SAFE_INTEGER && X ? (j && h.getAttribute("morphTarget" + K) !== j[q] && h.setAttribute("morphTarget" + K, j[q]),
              V && h.getAttribute("morphNormal" + K) !== V[q] && h.setAttribute("morphNormal" + K, V[q]),
              r[K] = X,
              G += X) : (j && !0 === h.hasAttribute("morphTarget" + K) && h.deleteAttribute("morphTarget" + K),
                V && !0 === h.hasAttribute("morphNormal" + K) && h.deleteAttribute("morphNormal" + K),
                r[K] = 0)
          }
          const W = h.morphTargetsRelative ? 1 : 1 - G;
          u.getUniforms().setValue(t, "morphTargetBaseInfluence", W),
            u.getUniforms().setValue(t, "morphTargetInfluences", r)
        }
      }
    }
  }
  function co(t, e, i, n) {
    let r = new WeakMap;
    function o(t) {
      const e = t.target;
      e.removeEventListener("dispose", o),
        i.remove(e.instanceMatrix),
        null !== e.instanceColor && i.remove(e.instanceColor)
    }
    return {
      update: function (t) {
        const s = n.render.frame
          , a = t.geometry
          , l = e.get(t, a);
        return r.get(l) !== s && (e.update(l),
          r.set(l, s)),
          t.isInstancedMesh && (!1 === t.hasEventListener("dispose", o) && t.addEventListener("dispose", o),
            i.update(t.instanceMatrix, 34962),
            null !== t.instanceColor && i.update(t.instanceColor, 34962)),
          l
      },
      dispose: function () {
        r = new WeakMap
      }
    }
  }
  const uo = new ai
    , po = new ci
    , fo = new ui
    , go = new Ar
    , mo = []
    , yo = []
    , vo = new Float32Array(16)
    , Ao = new Float32Array(9)
    , bo = new Float32Array(4);
  function xo(t, e, i) {
    const n = t[0];
    if (n <= 0 || n > 0)
      return t;
    const r = e * i;
    let o = mo[r];
    if (void 0 === o && (o = new Float32Array(r),
      mo[r] = o),
      0 !== e) {
      n.toArray(o, 0);
      for (let n = 1, r = 0; n !== e; ++n)
        r += i,
          t[n].toArray(o, r)
    }
    return o
  }
  function Io(t, e) {
    if (t.length !== e.length)
      return !1;
    for (let i = 0, n = t.length; i < n; i++)
      if (t[i] !== e[i])
        return !1;
    return !0
  }
  function Co(t, e) {
    for (let i = 0, n = e.length; i < n; i++)
      t[i] = e[i]
  }
  function wo(t, e) {
    let i = yo[e];
    void 0 === i && (i = new Int32Array(e),
      yo[e] = i);
    for (let n = 0; n !== e; ++n)
      i[n] = t.allocateTextureUnit();
    return i
  }
  function _o(t, e) {
    const i = this.cache;
    i[0] !== e && (t.uniform1f(this.addr, e),
      i[0] = e)
  }
  function So(t, e) {
    const i = this.cache;
    if (void 0 !== e.x)
      i[0] === e.x && i[1] === e.y || (t.uniform2f(this.addr, e.x, e.y),
        i[0] = e.x,
        i[1] = e.y);
    else {
      if (Io(i, e))
        return;
      t.uniform2fv(this.addr, e),
        Co(i, e)
    }
  }
  function Mo(t, e) {
    const i = this.cache;
    if (void 0 !== e.x)
      i[0] === e.x && i[1] === e.y && i[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z),
        i[0] = e.x,
        i[1] = e.y,
        i[2] = e.z);
    else if (void 0 !== e.r)
      i[0] === e.r && i[1] === e.g && i[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b),
        i[0] = e.r,
        i[1] = e.g,
        i[2] = e.b);
    else {
      if (Io(i, e))
        return;
      t.uniform3fv(this.addr, e),
        Co(i, e)
    }
  }
  function To(t, e) {
    const i = this.cache;
    if (void 0 !== e.x)
      i[0] === e.x && i[1] === e.y && i[2] === e.z && i[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
        i[0] = e.x,
        i[1] = e.y,
        i[2] = e.z,
        i[3] = e.w);
    else {
      if (Io(i, e))
        return;
      t.uniform4fv(this.addr, e),
        Co(i, e)
    }
  }
  function Eo(t, e) {
    const i = this.cache
      , n = e.elements;
    if (void 0 === n) {
      if (Io(i, e))
        return;
      t.uniformMatrix2fv(this.addr, !1, e),
        Co(i, e)
    } else {
      if (Io(i, n))
        return;
      bo.set(n),
        t.uniformMatrix2fv(this.addr, !1, bo),
        Co(i, n)
    }
  }
  function ko(t, e) {
    const i = this.cache
      , n = e.elements;
    if (void 0 === n) {
      if (Io(i, e))
        return;
      t.uniformMatrix3fv(this.addr, !1, e),
        Co(i, e)
    } else {
      if (Io(i, n))
        return;
      Ao.set(n),
        t.uniformMatrix3fv(this.addr, !1, Ao),
        Co(i, n)
    }
  }
  function Ro(t, e) {
    const i = this.cache
      , n = e.elements;
    if (void 0 === n) {
      if (Io(i, e))
        return;
      t.uniformMatrix4fv(this.addr, !1, e),
        Co(i, e)
    } else {
      if (Io(i, n))
        return;
      vo.set(n),
        t.uniformMatrix4fv(this.addr, !1, vo),
        Co(i, n)
    }
  }
  function Lo(t, e) {
    const i = this.cache;
    i[0] !== e && (t.uniform1i(this.addr, e),
      i[0] = e)
  }
  function Po(t, e) {
    const i = this.cache;
    Io(i, e) || (t.uniform2iv(this.addr, e),
      Co(i, e))
  }
  function zo(t, e) {
    const i = this.cache;
    Io(i, e) || (t.uniform3iv(this.addr, e),
      Co(i, e))
  }
  function Oo(t, e) {
    const i = this.cache;
    Io(i, e) || (t.uniform4iv(this.addr, e),
      Co(i, e))
  }
  function Do(t, e) {
    const i = this.cache;
    i[0] !== e && (t.uniform1ui(this.addr, e),
      i[0] = e)
  }
  function Uo(t, e) {
    const i = this.cache;
    Io(i, e) || (t.uniform2uiv(this.addr, e),
      Co(i, e))
  }
  function No(t, e) {
    const i = this.cache;
    Io(i, e) || (t.uniform3uiv(this.addr, e),
      Co(i, e))
  }
  function Fo(t, e) {
    const i = this.cache;
    Io(i, e) || (t.uniform4uiv(this.addr, e),
      Co(i, e))
  }
  function Bo(t, e, i) {
    const n = this.cache
      , r = i.allocateTextureUnit();
    n[0] !== r && (t.uniform1i(this.addr, r),
      n[0] = r),
      i.setTexture2D(e || uo, r)
  }
  function jo(t, e, i) {
    const n = this.cache
      , r = i.allocateTextureUnit();
    n[0] !== r && (t.uniform1i(this.addr, r),
      n[0] = r),
      i.setTexture3D(e || fo, r)
  }
  function Vo(t, e, i) {
    const n = this.cache
      , r = i.allocateTextureUnit();
    n[0] !== r && (t.uniform1i(this.addr, r),
      n[0] = r),
      i.setTextureCube(e || go, r)
  }
  function Go(t, e, i) {
    const n = this.cache
      , r = i.allocateTextureUnit();
    n[0] !== r && (t.uniform1i(this.addr, r),
      n[0] = r),
      i.setTexture2DArray(e || po, r)
  }
  function Wo(t, e) {
    t.uniform1fv(this.addr, e)
  }
  function Jo(t, e) {
    const i = xo(e, this.size, 2);
    t.uniform2fv(this.addr, i)
  }
  function Ho(t, e) {
    const i = xo(e, this.size, 3);
    t.uniform3fv(this.addr, i)
  }
  function Zo(t, e) {
    const i = xo(e, this.size, 4);
    t.uniform4fv(this.addr, i)
  }
  function Qo(t, e) {
    const i = xo(e, this.size, 4);
    t.uniformMatrix2fv(this.addr, !1, i)
  }
  function Ko(t, e) {
    const i = xo(e, this.size, 9);
    t.uniformMatrix3fv(this.addr, !1, i)
  }
  function Yo(t, e) {
    const i = xo(e, this.size, 16);
    t.uniformMatrix4fv(this.addr, !1, i)
  }
  function qo(t, e) {
    t.uniform1iv(this.addr, e)
  }
  function Xo(t, e) {
    t.uniform2iv(this.addr, e)
  }
  function $o(t, e) {
    t.uniform3iv(this.addr, e)
  }
  function ts(t, e) {
    t.uniform4iv(this.addr, e)
  }
  function es(t, e) {
    t.uniform1uiv(this.addr, e)
  }
  function is(t, e) {
    t.uniform2uiv(this.addr, e)
  }
  function ns(t, e) {
    t.uniform3uiv(this.addr, e)
  }
  function rs(t, e) {
    t.uniform4uiv(this.addr, e)
  }
  function os(t, e, i) {
    const n = e.length
      , r = wo(i, n);
    t.uniform1iv(this.addr, r);
    for (let t = 0; t !== n; ++t)
      i.setTexture2D(e[t] || uo, r[t])
  }
  function ss(t, e, i) {
    const n = e.length
      , r = wo(i, n);
    t.uniform1iv(this.addr, r);
    for (let t = 0; t !== n; ++t)
      i.setTexture3D(e[t] || fo, r[t])
  }
  function as(t, e, i) {
    const n = e.length
      , r = wo(i, n);
    t.uniform1iv(this.addr, r);
    for (let t = 0; t !== n; ++t)
      i.setTextureCube(e[t] || go, r[t])
  }
  function ls(t, e, i) {
    const n = e.length
      , r = wo(i, n);
    t.uniform1iv(this.addr, r);
    for (let t = 0; t !== n; ++t)
      i.setTexture2DArray(e[t] || po, r[t])
  }
  class hs {
    constructor(t, e, i) {
      this.id = t,
        this.addr = i,
        this.cache = [],
        this.setValue = function (t) {
          switch (t) {
            case 5126:
              return _o;
            case 35664:
              return So;
            case 35665:
              return Mo;
            case 35666:
              return To;
            case 35674:
              return Eo;
            case 35675:
              return ko;
            case 35676:
              return Ro;
            case 5124:
            case 35670:
              return Lo;
            case 35667:
            case 35671:
              return Po;
            case 35668:
            case 35672:
              return zo;
            case 35669:
            case 35673:
              return Oo;
            case 5125:
              return Do;
            case 36294:
              return Uo;
            case 36295:
              return No;
            case 36296:
              return Fo;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
              return Bo;
            case 35679:
            case 36299:
            case 36307:
              return jo;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
              return Vo;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
              return Go
          }
        }(e.type)
    }
  }
  class cs {
    constructor(t, e, i) {
      this.id = t,
        this.addr = i,
        this.cache = [],
        this.size = e.size,
        this.setValue = function (t) {
          switch (t) {
            case 5126:
              return Wo;
            case 35664:
              return Jo;
            case 35665:
              return Ho;
            case 35666:
              return Zo;
            case 35674:
              return Qo;
            case 35675:
              return Ko;
            case 35676:
              return Yo;
            case 5124:
            case 35670:
              return qo;
            case 35667:
            case 35671:
              return Xo;
            case 35668:
            case 35672:
              return $o;
            case 35669:
            case 35673:
              return ts;
            case 5125:
              return es;
            case 36294:
              return is;
            case 36295:
              return ns;
            case 36296:
              return rs;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
              return os;
            case 35679:
            case 36299:
            case 36307:
              return ss;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
              return as;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
              return ls
          }
        }(e.type)
    }
  }
  class us {
    constructor(t) {
      this.id = t,
        this.seq = [],
        this.map = {}
    }
    setValue(t, e, i) {
      const n = this.seq;
      for (let r = 0, o = n.length; r !== o; ++r) {
        const o = n[r];
        o.setValue(t, e[o.id], i)
      }
    }
  }
  const ps = /(\w+)(\])?(\[|\.)?/g;
  function ds(t, e) {
    t.seq.push(e),
      t.map[e.id] = e
  }
  function fs(t, e, i) {
    const n = t.name
      , r = n.length;
    for (ps.lastIndex = 0; ;) {
      const o = ps.exec(n)
        , s = ps.lastIndex;
      let a = o[1];
      const l = "]" === o[2]
        , h = o[3];
      if (l && (a |= 0),
        void 0 === h || "[" === h && s + 2 === r) {
        ds(i, void 0 === h ? new hs(a, t, e) : new cs(a, t, e));
        break
      }
      {
        let t = i.map[a];
        void 0 === t && (t = new us(a),
          ds(i, t)),
          i = t
      }
    }
  }
  class gs {
    constructor(t, e) {
      this.seq = [],
        this.map = {};
      const i = t.getProgramParameter(e, 35718);
      for (let n = 0; n < i; ++n) {
        const i = t.getActiveUniform(e, n);
        fs(i, t.getUniformLocation(e, i.name), this)
      }
    }
    setValue(t, e, i, n) {
      const r = this.map[e];
      void 0 !== r && r.setValue(t, i, n)
    }
    setOptional(t, e, i) {
      const n = e[i];
      void 0 !== n && this.setValue(t, i, n)
    }
    static upload(t, e, i, n) {
      for (let r = 0, o = e.length; r !== o; ++r) {
        const o = e[r]
          , s = i[o.id];
        !1 !== s.needsUpdate && o.setValue(t, s.value, n)
      }
    }
    static seqWithValue(t, e) {
      const i = [];
      for (let n = 0, r = t.length; n !== r; ++n) {
        const r = t[n];
        r.id in e && i.push(r)
      }
      return i
    }
  }
  function ms(t, e, i) {
    const n = t.createShader(e);
    return t.shaderSource(n, i),
      t.compileShader(n),
      n
  }
  let ys = 0;
  function vs(t, e, i) {
    const n = t.getShaderParameter(e, 35713)
      , r = t.getShaderInfoLog(e).trim();
    if (n && "" === r)
      return "";
    const o = /ERROR: 0:(\d+)/.exec(r);
    if (o) {
      const n = parseInt(o[1]);
      return i.toUpperCase() + "\n\n" + r + "\n\n" + function (t, e) {
        const i = t.split("\n")
          , n = []
          , r = Math.max(e - 6, 0)
          , o = Math.min(e + 6, i.length);
        for (let t = r; t < o; t++) {
          const r = t + 1;
          n.push(`${r === e ? ">" : " "} ${r}: ${i[t]}`)
        }
        return n.join("\n")
      }(t.getShaderSource(e), n)
    }
    return r
  }
  function As(t, e) {
    const i = function (t) {
      switch (t) {
        case fe:
          return ["Linear", "( value )"];
        case ge:
          return ["sRGB", "( value )"];
        default:
          return console.warn("THREE.WebGLProgram: Unsupported encoding:", t),
            ["Linear", "( value )"]
      }
    }(e);
    return "vec4 " + t + "( vec4 value ) { return LinearTo" + i[0] + i[1] + "; }"
  }
  function bs(t, e) {
    let i;
    switch (e) {
      case J:
        i = "Linear";
        break;
      case H:
        i = "Reinhard";
        break;
      case Z:
        i = "OptimizedCineon";
        break;
      case Q:
        i = "ACESFilmic";
        break;
      case K:
        i = "Custom";
        break;
      default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
          i = "Linear"
    }
    return "vec3 " + t + "( vec3 color ) { return " + i + "ToneMapping( color ); }"
  }
  function xs(t) {
    return "" !== t
  }
  function Is(t, e) {
    return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
  }
  function Cs(t, e) {
    return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
  }
  const ws = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function _s(t) {
    return t.replace(ws, Ss)
  }
  function Ss(t, e) {
    const i = Rr[e];
    if (void 0 === i)
      throw new Error("Can not resolve #include <" + e + ">");
    return _s(i)
  }
  const Ms = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g
    , Ts = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
  function Es(t) {
    return t.replace(Ts, Rs).replace(Ms, ks)
  }
  function ks(t, e, i, n) {
    return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),
      Rs(t, e, i, n)
  }
  function Rs(t, e, i, n) {
    let r = "";
    for (let t = parseInt(e); t < parseInt(i); t++)
      r += n.replace(/\[\s*i\s*\]/g, "[ " + t + " ]").replace(/UNROLLED_LOOP_INDEX/g, t);
    return r
  }
  function Ls(t) {
    let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
    return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"),
      e
  }
  function Ps(t, e, i, n) {
    const r = t.getContext()
      , l = i.defines;
    let h = i.vertexShader
      , c = i.fragmentShader;
    const u = function (t) {
      let e = "SHADOWMAP_TYPE_BASIC";
      return t.shadowMapType === o ? e = "SHADOWMAP_TYPE_PCF" : t.shadowMapType === s ? e = "SHADOWMAP_TYPE_PCF_SOFT" : t.shadowMapType === a && (e = "SHADOWMAP_TYPE_VSM"),
        e
    }(i)
      , p = function (t) {
        let e = "ENVMAP_TYPE_CUBE";
        if (t.envMap)
          switch (t.envMapMode) {
            case q:
            case X:
              e = "ENVMAP_TYPE_CUBE";
              break;
            case et:
              e = "ENVMAP_TYPE_CUBE_UV"
          }
        return e
      }(i)
      , d = function (t) {
        let e = "ENVMAP_MODE_REFLECTION";
        t.envMap && t.envMapMode === X && (e = "ENVMAP_MODE_REFRACTION");
        return e
      }(i)
      , f = function (t) {
        let e = "ENVMAP_BLENDING_NONE";
        if (t.envMap)
          switch (t.combine) {
            case j:
              e = "ENVMAP_BLENDING_MULTIPLY";
              break;
            case V:
              e = "ENVMAP_BLENDING_MIX";
              break;
            case G:
              e = "ENVMAP_BLENDING_ADD"
          }
        return e
      }(i)
      , g = function (t) {
        const e = t.envMapCubeUVHeight;
        if (null === e)
          return null;
        const i = Math.log2(e) - 2
          , n = 1 / e;
        return {
          texelWidth: 1 / (3 * Math.max(Math.pow(2, i), 112)),
          texelHeight: n,
          maxMip: i
        }
      }(i)
      , m = i.isWebGL2 ? "" : function (t) {
        return [t.extensionDerivatives || t.envMapCubeUVHeight || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap || t.transmission) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(xs).join("\n")
      }(i)
      , y = function (t) {
        const e = [];
        for (const i in t) {
          const n = t[i];
          !1 !== n && e.push("#define " + i + " " + n)
        }
        return e.join("\n")
      }(l)
      , v = r.createProgram();
    let A, b, x = i.glslVersion ? "#version " + i.glslVersion + "\n" : "";
    i.isRawShaderMaterial ? (A = [y].filter(xs).join("\n"),
      A.length > 0 && (A += "\n"),
      b = [m, y].filter(xs).join("\n"),
      b.length > 0 && (b += "\n")) : (A = [Ls(i), "#define SHADER_NAME " + i.shaderName, y, i.instancing ? "#define USE_INSTANCING" : "", i.instancingColor ? "#define USE_INSTANCING_COLOR" : "", i.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "", i.map ? "#define USE_MAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + d : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.normalMap && i.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", i.normalMap && i.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", i.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", i.displacementMap && i.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", i.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.transmission ? "#define USE_TRANSMISSION" : "", i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i.thicknessMap ? "#define USE_THICKNESSMAP" : "", i.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", i.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", i.vertexTangents ? "#define USE_TANGENT" : "", i.vertexColors ? "#define USE_COLOR" : "", i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", i.vertexUvs ? "#define USE_UV" : "", i.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.skinning ? "#define USE_SKINNING" : "", i.morphTargets ? "#define USE_MORPHTARGETS" : "", i.morphNormals && !1 === i.flatShading ? "#define USE_MORPHNORMALS" : "", i.morphColors && i.isWebGL2 ? "#define USE_MORPHCOLORS" : "", i.morphTargetsCount > 0 && i.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", i.morphTargetsCount > 0 && i.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + i.morphTextureStride : "", i.morphTargetsCount > 0 && i.isWebGL2 ? "#define MORPHTARGETS_COUNT " + i.morphTargetsCount : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + u : "", i.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i.logarithmicDepthBuffer && i.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(xs).join("\n"),
        b = [m, Ls(i), "#define SHADER_NAME " + i.shaderName, y, i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "", i.map ? "#define USE_MAP" : "", i.matcap ? "#define USE_MATCAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + p : "", i.envMap ? "#define " + d : "", i.envMap ? "#define " + f : "", g ? "#define CUBEUV_TEXEL_WIDTH " + g.texelWidth : "", g ? "#define CUBEUV_TEXEL_HEIGHT " + g.texelHeight : "", g ? "#define CUBEUV_MAX_MIP " + g.maxMip + ".0" : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.normalMap && i.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", i.normalMap && i.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", i.clearcoat ? "#define USE_CLEARCOAT" : "", i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i.iridescence ? "#define USE_IRIDESCENCE" : "", i.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", i.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", i.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.alphaTest ? "#define USE_ALPHATEST" : "", i.sheen ? "#define USE_SHEEN" : "", i.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", i.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", i.transmission ? "#define USE_TRANSMISSION" : "", i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i.thicknessMap ? "#define USE_THICKNESSMAP" : "", i.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", i.vertexTangents ? "#define USE_TANGENT" : "", i.vertexColors || i.instancingColor ? "#define USE_COLOR" : "", i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", i.vertexUvs ? "#define USE_UV" : "", i.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", i.gradientMap ? "#define USE_GRADIENTMAP" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + u : "", i.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", i.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i.logarithmicDepthBuffer && i.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", i.toneMapping !== W ? "#define TONE_MAPPING" : "", i.toneMapping !== W ? Rr.tonemapping_pars_fragment : "", i.toneMapping !== W ? bs("toneMapping", i.toneMapping) : "", i.dithering ? "#define DITHERING" : "", i.opaque ? "#define OPAQUE" : "", Rr.encodings_pars_fragment, As("linearToOutputTexel", i.outputEncoding), i.useDepthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "", "\n"].filter(xs).join("\n")),
      h = _s(h),
      h = Is(h, i),
      h = Cs(h, i),
      c = _s(c),
      c = Is(c, i),
      c = Cs(c, i),
      h = Es(h),
      c = Es(c),
      i.isWebGL2 && !0 !== i.isRawShaderMaterial && (x = "#version 300 es\n",
        A = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + A,
        b = ["#define varying in", i.glslVersion === we ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", i.glslVersion === we ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + b);
    const I = x + b + c
      , C = ms(r, 35633, x + A + h)
      , w = ms(r, 35632, I);
    if (r.attachShader(v, C),
      r.attachShader(v, w),
      void 0 !== i.index0AttributeName ? r.bindAttribLocation(v, 0, i.index0AttributeName) : !0 === i.morphTargets && r.bindAttribLocation(v, 0, "position"),
      r.linkProgram(v),
      t.debug.checkShaderErrors) {
      const t = r.getProgramInfoLog(v).trim()
        , e = r.getShaderInfoLog(C).trim()
        , i = r.getShaderInfoLog(w).trim();
      let n = !0
        , o = !0;
      if (!1 === r.getProgramParameter(v, 35714)) {
        n = !1;
        const e = vs(r, C, "vertex")
          , i = vs(r, w, "fragment");
        console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(v, 35715) + "\n\nProgram Info Log: " + t + "\n" + e + "\n" + i)
      } else
        "" !== t ? console.warn("THREE.WebGLProgram: Program Info Log:", t) : "" !== e && "" !== i || (o = !1);
      o && (this.diagnostics = {
        runnable: n,
        programLog: t,
        vertexShader: {
          log: e,
          prefix: A
        },
        fragmentShader: {
          log: i,
          prefix: b
        }
      })
    }
    let _, S;
    return r.deleteShader(C),
      r.deleteShader(w),
      this.getUniforms = function () {
        return void 0 === _ && (_ = new gs(r, v)),
          _
      }
      ,
      this.getAttributes = function () {
        return void 0 === S && (S = function (t, e) {
          const i = {}
            , n = t.getProgramParameter(e, 35721);
          for (let r = 0; r < n; r++) {
            const n = t.getActiveAttrib(e, r)
              , o = n.name;
            let s = 1;
            35674 === n.type && (s = 2),
              35675 === n.type && (s = 3),
              35676 === n.type && (s = 4),
              i[o] = {
                type: n.type,
                location: t.getAttribLocation(e, o),
                locationSize: s
              }
          }
          return i
        }(r, v)),
          S
      }
      ,
      this.destroy = function () {
        n.releaseStatesOfProgram(this),
          r.deleteProgram(v),
          this.program = void 0
      }
      ,
      this.name = i.shaderName,
      this.id = ys++,
      this.cacheKey = e,
      this.usedTimes = 1,
      this.program = v,
      this.vertexShader = C,
      this.fragmentShader = w,
      this
  }
  let zs = 0;
  class Os {
    constructor() {
      this.shaderCache = new Map,
        this.materialCache = new Map
    }
    update(t) {
      const e = t.vertexShader
        , i = t.fragmentShader
        , n = this._getShaderStage(e)
        , r = this._getShaderStage(i)
        , o = this._getShaderCacheForMaterial(t);
      return !1 === o.has(n) && (o.add(n),
        n.usedTimes++),
        !1 === o.has(r) && (o.add(r),
          r.usedTimes++),
        this
    }
    remove(t) {
      const e = this.materialCache.get(t);
      for (const t of e)
        t.usedTimes--,
          0 === t.usedTimes && this.shaderCache.delete(t.code);
      return this.materialCache.delete(t),
        this
    }
    getVertexShaderID(t) {
      return this._getShaderStage(t.vertexShader).id
    }
    getFragmentShaderID(t) {
      return this._getShaderStage(t.fragmentShader).id
    }
    dispose() {
      this.shaderCache.clear(),
        this.materialCache.clear()
    }
    _getShaderCacheForMaterial(t) {
      const e = this.materialCache;
      return !1 === e.has(t) && e.set(t, new Set),
        e.get(t)
    }
    _getShaderStage(t) {
      const e = this.shaderCache;
      if (!1 === e.has(t)) {
        const i = new Ds(t);
        e.set(t, i)
      }
      return e.get(t)
    }
  }
  class Ds {
    constructor(t) {
      this.id = zs++,
        this.code = t,
        this.usedTimes = 0
    }
  }
  function Us(t, e, i, n, r, o, s) {
    const a = new en
      , l = new Os
      , u = []
      , d = r.isWebGL2
      , f = r.logarithmicDepthBuffer
      , g = r.vertexTextures;
    let m = r.precision;
    const y = {
      MeshDepthMaterial: "depth",
      MeshDistanceMaterial: "distanceRGBA",
      MeshNormalMaterial: "normal",
      MeshBasicMaterial: "basic",
      MeshLambertMaterial: "lambert",
      MeshPhongMaterial: "phong",
      MeshToonMaterial: "toon",
      MeshStandardMaterial: "physical",
      MeshPhysicalMaterial: "physical",
      MeshMatcapMaterial: "matcap",
      LineBasicMaterial: "basic",
      LineDashedMaterial: "dashed",
      PointsMaterial: "points",
      ShadowMaterial: "shadow",
      SpriteMaterial: "sprite"
    };
    return {
      getParameters: function (o, a, u, v, A) {
        const b = v.fog
          , x = A.geometry
          , I = o.isMeshStandardMaterial ? v.environment : null
          , C = (o.isMeshStandardMaterial ? i : e).get(o.envMap || I)
          , w = C && C.mapping === et ? C.image.height : null
          , _ = y[o.type];
        null !== o.precision && (m = r.getMaxPrecision(o.precision),
          m !== o.precision && console.warn("THREE.WebGLProgram.getParameters:", o.precision, "not supported, using", m, "instead."));
        const S = x.morphAttributes.position || x.morphAttributes.normal || x.morphAttributes.color
          , M = void 0 !== S ? S.length : 0;
        let T, E, k, R, L = 0;
        if (void 0 !== x.morphAttributes.position && (L = 1),
          void 0 !== x.morphAttributes.normal && (L = 2),
          void 0 !== x.morphAttributes.color && (L = 3),
          _) {
          const t = Pr[_];
          T = t.vertexShader,
            E = t.fragmentShader
        } else
          T = o.vertexShader,
            E = o.fragmentShader,
            l.update(o),
            k = l.getVertexShaderID(o),
            R = l.getFragmentShaderID(o);
        const P = t.getRenderTarget()
          , z = o.alphaTest > 0
          , O = o.clearcoat > 0
          , D = o.iridescence > 0;
        return {
          isWebGL2: d,
          shaderID: _,
          shaderName: o.type,
          vertexShader: T,
          fragmentShader: E,
          defines: o.defines,
          customVertexShaderID: k,
          customFragmentShaderID: R,
          isRawShaderMaterial: !0 === o.isRawShaderMaterial,
          glslVersion: o.glslVersion,
          precision: m,
          instancing: !0 === A.isInstancedMesh,
          instancingColor: !0 === A.isInstancedMesh && null !== A.instanceColor,
          supportsVertexTextures: g,
          outputEncoding: null === P ? t.outputEncoding : !0 === P.isXRRenderTarget ? P.texture.encoding : fe,
          map: !!o.map,
          matcap: !!o.matcap,
          envMap: !!C,
          envMapMode: C && C.mapping,
          envMapCubeUVHeight: w,
          lightMap: !!o.lightMap,
          aoMap: !!o.aoMap,
          emissiveMap: !!o.emissiveMap,
          bumpMap: !!o.bumpMap,
          normalMap: !!o.normalMap,
          objectSpaceNormalMap: o.normalMapType === ve,
          tangentSpaceNormalMap: o.normalMapType === ye,
          decodeVideoTexture: !!o.map && !0 === o.map.isVideoTexture && o.map.encoding === ge,
          clearcoat: O,
          clearcoatMap: O && !!o.clearcoatMap,
          clearcoatRoughnessMap: O && !!o.clearcoatRoughnessMap,
          clearcoatNormalMap: O && !!o.clearcoatNormalMap,
          iridescence: D,
          iridescenceMap: D && !!o.iridescenceMap,
          iridescenceThicknessMap: D && !!o.iridescenceThicknessMap,
          displacementMap: !!o.displacementMap,
          roughnessMap: !!o.roughnessMap,
          metalnessMap: !!o.metalnessMap,
          specularMap: !!o.specularMap,
          specularIntensityMap: !!o.specularIntensityMap,
          specularColorMap: !!o.specularColorMap,
          opaque: !1 === o.transparent && o.blending === p,
          alphaMap: !!o.alphaMap,
          alphaTest: z,
          gradientMap: !!o.gradientMap,
          sheen: o.sheen > 0,
          sheenColorMap: !!o.sheenColorMap,
          sheenRoughnessMap: !!o.sheenRoughnessMap,
          transmission: o.transmission > 0,
          transmissionMap: !!o.transmissionMap,
          thicknessMap: !!o.thicknessMap,
          combine: o.combine,
          vertexTangents: !!o.normalMap && !!x.attributes.tangent,
          vertexColors: o.vertexColors,
          vertexAlphas: !0 === o.vertexColors && !!x.attributes.color && 4 === x.attributes.color.itemSize,
          vertexUvs: !!(o.map || o.bumpMap || o.normalMap || o.specularMap || o.alphaMap || o.emissiveMap || o.roughnessMap || o.metalnessMap || o.clearcoatMap || o.clearcoatRoughnessMap || o.clearcoatNormalMap || o.iridescenceMap || o.iridescenceThicknessMap || o.displacementMap || o.transmissionMap || o.thicknessMap || o.specularIntensityMap || o.specularColorMap || o.sheenColorMap || o.sheenRoughnessMap),
          uvsVertexOnly: !(o.map || o.bumpMap || o.normalMap || o.specularMap || o.alphaMap || o.emissiveMap || o.roughnessMap || o.metalnessMap || o.clearcoatNormalMap || o.iridescenceMap || o.iridescenceThicknessMap || o.transmission > 0 || o.transmissionMap || o.thicknessMap || o.specularIntensityMap || o.specularColorMap || o.sheen > 0 || o.sheenColorMap || o.sheenRoughnessMap || !o.displacementMap),
          fog: !!b,
          useFog: !0 === o.fog,
          fogExp2: b && b.isFogExp2,
          flatShading: !!o.flatShading,
          sizeAttenuation: o.sizeAttenuation,
          logarithmicDepthBuffer: f,
          skinning: !0 === A.isSkinnedMesh,
          morphTargets: void 0 !== x.morphAttributes.position,
          morphNormals: void 0 !== x.morphAttributes.normal,
          morphColors: void 0 !== x.morphAttributes.color,
          morphTargetsCount: M,
          morphTextureStride: L,
          numDirLights: a.directional.length,
          numPointLights: a.point.length,
          numSpotLights: a.spot.length,
          numRectAreaLights: a.rectArea.length,
          numHemiLights: a.hemi.length,
          numDirLightShadows: a.directionalShadowMap.length,
          numPointLightShadows: a.pointShadowMap.length,
          numSpotLightShadows: a.spotShadowMap.length,
          numClippingPlanes: s.numPlanes,
          numClipIntersection: s.numIntersection,
          dithering: o.dithering,
          shadowMapEnabled: t.shadowMap.enabled && u.length > 0,
          shadowMapType: t.shadowMap.type,
          toneMapping: o.toneMapped ? t.toneMapping : W,
          physicallyCorrectLights: t.physicallyCorrectLights,
          premultipliedAlpha: o.premultipliedAlpha,
          doubleSided: o.side === c,
          flipSided: o.side === h,
          useDepthPacking: !!o.depthPacking,
          depthPacking: o.depthPacking || 0,
          index0AttributeName: o.index0AttributeName,
          extensionDerivatives: o.extensions && o.extensions.derivatives,
          extensionFragDepth: o.extensions && o.extensions.fragDepth,
          extensionDrawBuffers: o.extensions && o.extensions.drawBuffers,
          extensionShaderTextureLOD: o.extensions && o.extensions.shaderTextureLOD,
          rendererExtensionFragDepth: d || n.has("EXT_frag_depth"),
          rendererExtensionDrawBuffers: d || n.has("WEBGL_draw_buffers"),
          rendererExtensionShaderTextureLod: d || n.has("EXT_shader_texture_lod"),
          customProgramCacheKey: o.customProgramCacheKey()
        }
      },
      getProgramCacheKey: function (e) {
        const i = [];
        if (e.shaderID ? i.push(e.shaderID) : (i.push(e.customVertexShaderID),
          i.push(e.customFragmentShaderID)),
          void 0 !== e.defines)
          for (const t in e.defines)
            i.push(t),
              i.push(e.defines[t]);
        return !1 === e.isRawShaderMaterial && (!function (t, e) {
          t.push(e.precision),
            t.push(e.outputEncoding),
            t.push(e.envMapMode),
            t.push(e.envMapCubeUVHeight),
            t.push(e.combine),
            t.push(e.vertexUvs),
            t.push(e.fogExp2),
            t.push(e.sizeAttenuation),
            t.push(e.morphTargetsCount),
            t.push(e.morphAttributeCount),
            t.push(e.numDirLights),
            t.push(e.numPointLights),
            t.push(e.numSpotLights),
            t.push(e.numHemiLights),
            t.push(e.numRectAreaLights),
            t.push(e.numDirLightShadows),
            t.push(e.numPointLightShadows),
            t.push(e.numSpotLightShadows),
            t.push(e.shadowMapType),
            t.push(e.toneMapping),
            t.push(e.numClippingPlanes),
            t.push(e.numClipIntersection),
            t.push(e.depthPacking)
        }(i, e),
          function (t, e) {
            a.disableAll(),
              e.isWebGL2 && a.enable(0);
            e.supportsVertexTextures && a.enable(1);
            e.instancing && a.enable(2);
            e.instancingColor && a.enable(3);
            e.map && a.enable(4);
            e.matcap && a.enable(5);
            e.envMap && a.enable(6);
            e.lightMap && a.enable(7);
            e.aoMap && a.enable(8);
            e.emissiveMap && a.enable(9);
            e.bumpMap && a.enable(10);
            e.normalMap && a.enable(11);
            e.objectSpaceNormalMap && a.enable(12);
            e.tangentSpaceNormalMap && a.enable(13);
            e.clearcoat && a.enable(14);
            e.clearcoatMap && a.enable(15);
            e.clearcoatRoughnessMap && a.enable(16);
            e.clearcoatNormalMap && a.enable(17);
            e.iridescence && a.enable(18);
            e.iridescenceMap && a.enable(19);
            e.iridescenceThicknessMap && a.enable(20);
            e.displacementMap && a.enable(21);
            e.specularMap && a.enable(22);
            e.roughnessMap && a.enable(23);
            e.metalnessMap && a.enable(24);
            e.gradientMap && a.enable(25);
            e.alphaMap && a.enable(26);
            e.alphaTest && a.enable(27);
            e.vertexColors && a.enable(28);
            e.vertexAlphas && a.enable(29);
            e.vertexUvs && a.enable(30);
            e.vertexTangents && a.enable(31);
            e.uvsVertexOnly && a.enable(32);
            e.fog && a.enable(33);
            t.push(a.mask),
              a.disableAll(),
              e.useFog && a.enable(0);
            e.flatShading && a.enable(1);
            e.logarithmicDepthBuffer && a.enable(2);
            e.skinning && a.enable(3);
            e.morphTargets && a.enable(4);
            e.morphNormals && a.enable(5);
            e.morphColors && a.enable(6);
            e.premultipliedAlpha && a.enable(7);
            e.shadowMapEnabled && a.enable(8);
            e.physicallyCorrectLights && a.enable(9);
            e.doubleSided && a.enable(10);
            e.flipSided && a.enable(11);
            e.useDepthPacking && a.enable(12);
            e.dithering && a.enable(13);
            e.specularIntensityMap && a.enable(14);
            e.specularColorMap && a.enable(15);
            e.transmission && a.enable(16);
            e.transmissionMap && a.enable(17);
            e.thicknessMap && a.enable(18);
            e.sheen && a.enable(19);
            e.sheenColorMap && a.enable(20);
            e.sheenRoughnessMap && a.enable(21);
            e.decodeVideoTexture && a.enable(22);
            e.opaque && a.enable(23);
            t.push(a.mask)
          }(i, e),
          i.push(t.outputEncoding)),
          i.push(e.customProgramCacheKey),
          i.join()
      },
      getUniforms: function (t) {
        const e = y[t.type];
        let i;
        if (e) {
          const t = Pr[e];
          i = dr.clone(t.uniforms)
        } else
          i = t.uniforms;
        return i
      },
      acquireProgram: function (e, i) {
        let n;
        for (let t = 0, e = u.length; t < e; t++) {
          const e = u[t];
          if (e.cacheKey === i) {
            n = e,
              ++n.usedTimes;
            break
          }
        }
        return void 0 === n && (n = new Ps(t, i, e, o),
          u.push(n)),
          n
      },
      releaseProgram: function (t) {
        if (0 == --t.usedTimes) {
          const e = u.indexOf(t);
          u[e] = u[u.length - 1],
            u.pop(),
            t.destroy()
        }
      },
      releaseShaderCache: function (t) {
        l.remove(t)
      },
      programs: u,
      dispose: function () {
        l.dispose()
      }
    }
  }
  function Ns() {
    let t = new WeakMap;
    return {
      get: function (e) {
        let i = t.get(e);
        return void 0 === i && (i = {},
          t.set(e, i)),
          i
      },
      remove: function (e) {
        t.delete(e)
      },
      update: function (e, i, n) {
        t.get(e)[i] = n
      },
      dispose: function () {
        t = new WeakMap
      }
    }
  }
  function Fs(t, e) {
    return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
  }
  function Bs(t, e) {
    return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
  }
  function js() {
    const t = [];
    let e = 0;
    const i = []
      , n = []
      , r = [];
    function o(i, n, r, o, s, a) {
      let l = t[e];
      return void 0 === l ? (l = {
        id: i.id,
        object: i,
        geometry: n,
        material: r,
        groupOrder: o,
        renderOrder: i.renderOrder,
        z: s,
        group: a
      },
        t[e] = l) : (l.id = i.id,
          l.object = i,
          l.geometry = n,
          l.material = r,
          l.groupOrder = o,
          l.renderOrder = i.renderOrder,
          l.z = s,
          l.group = a),
        e++,
        l
    }
    return {
      opaque: i,
      transmissive: n,
      transparent: r,
      init: function () {
        e = 0,
          i.length = 0,
          n.length = 0,
          r.length = 0
      },
      push: function (t, e, s, a, l, h) {
        const c = o(t, e, s, a, l, h);
        s.transmission > 0 ? n.push(c) : !0 === s.transparent ? r.push(c) : i.push(c)
      },
      unshift: function (t, e, s, a, l, h) {
        const c = o(t, e, s, a, l, h);
        s.transmission > 0 ? n.unshift(c) : !0 === s.transparent ? r.unshift(c) : i.unshift(c)
      },
      finish: function () {
        for (let i = e, n = t.length; i < n; i++) {
          const e = t[i];
          if (null === e.id)
            break;
          e.id = null,
            e.object = null,
            e.geometry = null,
            e.material = null,
            e.group = null
        }
      },
      sort: function (t, e) {
        i.length > 1 && i.sort(t || Fs),
          n.length > 1 && n.sort(e || Bs),
          r.length > 1 && r.sort(e || Bs)
      }
    }
  }
  function Vs() {
    let t = new WeakMap;
    return {
      get: function (e, i) {
        let n;
        return !1 === t.has(e) ? (n = new js,
          t.set(e, [n])) : i >= t.get(e).length ? (n = new js,
            t.get(e).push(n)) : n = t.get(e)[i],
          n
      },
      dispose: function () {
        t = new WeakMap
      }
    }
  }
  function Gs() {
    const t = {};
    return {
      get: function (e) {
        if (void 0 !== t[e.id])
          return t[e.id];
        let i;
        switch (e.type) {
          case "DirectionalLight":
            i = {
              direction: new di,
              color: new ei
            };
            break;
          case "SpotLight":
            i = {
              position: new di,
              direction: new di,
              color: new ei,
              distance: 0,
              coneCos: 0,
              penumbraCos: 0,
              decay: 0
            };
            break;
          case "PointLight":
            i = {
              position: new di,
              color: new ei,
              distance: 0,
              decay: 0
            };
            break;
          case "HemisphereLight":
            i = {
              direction: new di,
              skyColor: new ei,
              groundColor: new ei
            };
            break;
          case "RectAreaLight":
            i = {
              color: new ei,
              position: new di,
              halfWidth: new di,
              halfHeight: new di
            }
        }
        return t[e.id] = i,
          i
      }
    }
  }
  let Ws = 0;
  function Js(t, e) {
    return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0)
  }
  function Hs(t, e) {
    const i = new Gs
      , n = function () {
        const t = {};
        return {
          get: function (e) {
            if (void 0 !== t[e.id])
              return t[e.id];
            let i;
            switch (e.type) {
              case "DirectionalLight":
              case "SpotLight":
                i = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new Fe
                };
                break;
              case "PointLight":
                i = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new Fe,
                  shadowCameraNear: 1,
                  shadowCameraFar: 1e3
                }
            }
            return t[e.id] = i,
              i
          }
        }
      }()
      , r = {
        version: 0,
        hash: {
          directionalLength: -1,
          pointLength: -1,
          spotLength: -1,
          rectAreaLength: -1,
          hemiLength: -1,
          numDirectionalShadows: -1,
          numPointShadows: -1,
          numSpotShadows: -1
        },
        ambient: [0, 0, 0],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotShadow: [],
        spotShadowMap: [],
        spotShadowMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: []
      };
    for (let t = 0; t < 9; t++)
      r.probe.push(new di);
    const o = new di
      , s = new Wi
      , a = new Wi;
    return {
      setup: function (o, s) {
        let a = 0
          , l = 0
          , h = 0;
        for (let t = 0; t < 9; t++)
          r.probe[t].set(0, 0, 0);
        let c = 0
          , u = 0
          , p = 0
          , d = 0
          , f = 0
          , g = 0
          , m = 0
          , y = 0;
        o.sort(Js);
        const v = !0 !== s ? Math.PI : 1;
        for (let t = 0, e = o.length; t < e; t++) {
          const e = o[t]
            , s = e.color
            , A = e.intensity
            , b = e.distance
            , x = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
          if (e.isAmbientLight)
            a += s.r * A * v,
              l += s.g * A * v,
              h += s.b * A * v;
          else if (e.isLightProbe)
            for (let t = 0; t < 9; t++)
              r.probe[t].addScaledVector(e.sh.coefficients[t], A);
          else if (e.isDirectionalLight) {
            const t = i.get(e);
            if (t.color.copy(e.color).multiplyScalar(e.intensity * v),
              e.castShadow) {
              const t = e.shadow
                , i = n.get(e);
              i.shadowBias = t.bias,
                i.shadowNormalBias = t.normalBias,
                i.shadowRadius = t.radius,
                i.shadowMapSize = t.mapSize,
                r.directionalShadow[c] = i,
                r.directionalShadowMap[c] = x,
                r.directionalShadowMatrix[c] = e.shadow.matrix,
                g++
            }
            r.directional[c] = t,
              c++
          } else if (e.isSpotLight) {
            const t = i.get(e);
            if (t.position.setFromMatrixPosition(e.matrixWorld),
              t.color.copy(s).multiplyScalar(A * v),
              t.distance = b,
              t.coneCos = Math.cos(e.angle),
              t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra)),
              t.decay = e.decay,
              e.castShadow) {
              const t = e.shadow
                , i = n.get(e);
              i.shadowBias = t.bias,
                i.shadowNormalBias = t.normalBias,
                i.shadowRadius = t.radius,
                i.shadowMapSize = t.mapSize,
                r.spotShadow[p] = i,
                r.spotShadowMap[p] = x,
                r.spotShadowMatrix[p] = e.shadow.matrix,
                y++
            }
            r.spot[p] = t,
              p++
          } else if (e.isRectAreaLight) {
            const t = i.get(e);
            t.color.copy(s).multiplyScalar(A),
              t.halfWidth.set(.5 * e.width, 0, 0),
              t.halfHeight.set(0, .5 * e.height, 0),
              r.rectArea[d] = t,
              d++
          } else if (e.isPointLight) {
            const t = i.get(e);
            if (t.color.copy(e.color).multiplyScalar(e.intensity * v),
              t.distance = e.distance,
              t.decay = e.decay,
              e.castShadow) {
              const t = e.shadow
                , i = n.get(e);
              i.shadowBias = t.bias,
                i.shadowNormalBias = t.normalBias,
                i.shadowRadius = t.radius,
                i.shadowMapSize = t.mapSize,
                i.shadowCameraNear = t.camera.near,
                i.shadowCameraFar = t.camera.far,
                r.pointShadow[u] = i,
                r.pointShadowMap[u] = x,
                r.pointShadowMatrix[u] = e.shadow.matrix,
                m++
            }
            r.point[u] = t,
              u++
          } else if (e.isHemisphereLight) {
            const t = i.get(e);
            t.skyColor.copy(e.color).multiplyScalar(A * v),
              t.groundColor.copy(e.groundColor).multiplyScalar(A * v),
              r.hemi[f] = t,
              f++
          }
        }
        d > 0 && (e.isWebGL2 || !0 === t.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = Lr.LTC_FLOAT_1,
          r.rectAreaLTC2 = Lr.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = Lr.LTC_HALF_1,
            r.rectAreaLTC2 = Lr.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),
          r.ambient[0] = a,
          r.ambient[1] = l,
          r.ambient[2] = h;
        const A = r.hash;
        A.directionalLength === c && A.pointLength === u && A.spotLength === p && A.rectAreaLength === d && A.hemiLength === f && A.numDirectionalShadows === g && A.numPointShadows === m && A.numSpotShadows === y || (r.directional.length = c,
          r.spot.length = p,
          r.rectArea.length = d,
          r.point.length = u,
          r.hemi.length = f,
          r.directionalShadow.length = g,
          r.directionalShadowMap.length = g,
          r.pointShadow.length = m,
          r.pointShadowMap.length = m,
          r.spotShadow.length = y,
          r.spotShadowMap.length = y,
          r.directionalShadowMatrix.length = g,
          r.pointShadowMatrix.length = m,
          r.spotShadowMatrix.length = y,
          A.directionalLength = c,
          A.pointLength = u,
          A.spotLength = p,
          A.rectAreaLength = d,
          A.hemiLength = f,
          A.numDirectionalShadows = g,
          A.numPointShadows = m,
          A.numSpotShadows = y,
          r.version = Ws++)
      },
      setupView: function (t, e) {
        let i = 0
          , n = 0
          , l = 0
          , h = 0
          , c = 0;
        const u = e.matrixWorldInverse;
        for (let e = 0, p = t.length; e < p; e++) {
          const p = t[e];
          if (p.isDirectionalLight) {
            const t = r.directional[i];
            t.direction.setFromMatrixPosition(p.matrixWorld),
              o.setFromMatrixPosition(p.target.matrixWorld),
              t.direction.sub(o),
              t.direction.transformDirection(u),
              i++
          } else if (p.isSpotLight) {
            const t = r.spot[l];
            t.position.setFromMatrixPosition(p.matrixWorld),
              t.position.applyMatrix4(u),
              t.direction.setFromMatrixPosition(p.matrixWorld),
              o.setFromMatrixPosition(p.target.matrixWorld),
              t.direction.sub(o),
              t.direction.transformDirection(u),
              l++
          } else if (p.isRectAreaLight) {
            const t = r.rectArea[h];
            t.position.setFromMatrixPosition(p.matrixWorld),
              t.position.applyMatrix4(u),
              a.identity(),
              s.copy(p.matrixWorld),
              s.premultiply(u),
              a.extractRotation(s),
              t.halfWidth.set(.5 * p.width, 0, 0),
              t.halfHeight.set(0, .5 * p.height, 0),
              t.halfWidth.applyMatrix4(a),
              t.halfHeight.applyMatrix4(a),
              h++
          } else if (p.isPointLight) {
            const t = r.point[n];
            t.position.setFromMatrixPosition(p.matrixWorld),
              t.position.applyMatrix4(u),
              n++
          } else if (p.isHemisphereLight) {
            const t = r.hemi[c];
            t.direction.setFromMatrixPosition(p.matrixWorld),
              t.direction.transformDirection(u),
              c++
          }
        }
      },
      state: r
    }
  }
  function Zs(t, e) {
    const i = new Hs(t, e)
      , n = []
      , r = [];
    return {
      init: function () {
        n.length = 0,
          r.length = 0
      },
      state: {
        lightsArray: n,
        shadowsArray: r,
        lights: i
      },
      setupLights: function (t) {
        i.setup(n, t)
      },
      setupLightsView: function (t) {
        i.setupView(n, t)
      },
      pushLight: function (t) {
        n.push(t)
      },
      pushShadow: function (t) {
        r.push(t)
      }
    }
  }
  function Qs(t, e) {
    let i = new WeakMap;
    return {
      get: function (n, r = 0) {
        let o;
        return !1 === i.has(n) ? (o = new Zs(t, e),
          i.set(n, [o])) : r >= i.get(n).length ? (o = new Zs(t, e),
            i.get(n).push(o)) : o = i.get(n)[r],
          o
      },
      dispose: function () {
        i = new WeakMap
      }
    }
  }
  class Ks extends En {
    constructor(t) {
      super(),
        this.isMeshDepthMaterial = !0,
        this.type = "MeshDepthMaterial",
        this.depthPacking = 3200,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.setValues(t)
    }
    copy(t) {
      return super.copy(t),
        this.depthPacking = t.depthPacking,
        this.map = t.map,
        this.alphaMap = t.alphaMap,
        this.displacementMap = t.displacementMap,
        this.displacementScale = t.displacementScale,
        this.displacementBias = t.displacementBias,
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this
    }
  }
  class Ys extends En {
    constructor(t) {
      super(),
        this.isMeshDistanceMaterial = !0,
        this.type = "MeshDistanceMaterial",
        this.referencePosition = new di,
        this.nearDistance = 1,
        this.farDistance = 1e3,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.setValues(t)
    }
    copy(t) {
      return super.copy(t),
        this.referencePosition.copy(t.referencePosition),
        this.nearDistance = t.nearDistance,
        this.farDistance = t.farDistance,
        this.map = t.map,
        this.alphaMap = t.alphaMap,
        this.displacementMap = t.displacementMap,
        this.displacementScale = t.displacementScale,
        this.displacementBias = t.displacementBias,
        this
    }
  }
  const qs = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}"
    , Xs = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
  function $s(t, e, i) {
    let n = new Mr;
    const r = new Fe
      , s = new Fe
      , p = new li
      , d = new Ks({
        depthPacking: me
      })
      , f = new Ys
      , g = {}
      , m = i.maxTextureSize
      , y = {
        0: h,
        1: l,
        2: c
      }
      , v = new fr({
        defines: {
          VSM_SAMPLES: 8
        },
        uniforms: {
          shadow_pass: {
            value: null
          },
          resolution: {
            value: new Fe
          },
          radius: {
            value: 4
          }
        },
        vertexShader: qs,
        fragmentShader: Xs
      })
      , A = v.clone();
    A.defines.HORIZONTAL_PASS = 1;
    const b = new Wn;
    b.setAttribute("position", new Pn(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
    const x = new lr(b, v)
      , I = this;
    function C(i, n) {
      const o = e.update(x);
      v.defines.VSM_SAMPLES !== i.blurSamples && (v.defines.VSM_SAMPLES = i.blurSamples,
        A.defines.VSM_SAMPLES = i.blurSamples,
        v.needsUpdate = !0,
        A.needsUpdate = !0),
        null === i.mapPass && (i.mapPass = new hi(r.x, r.y)),
        v.uniforms.shadow_pass.value = i.map.texture,
        v.uniforms.resolution.value = i.mapSize,
        v.uniforms.radius.value = i.radius,
        t.setRenderTarget(i.mapPass),
        t.clear(),
        t.renderBufferDirect(n, null, o, v, x, null),
        A.uniforms.shadow_pass.value = i.mapPass.texture,
        A.uniforms.resolution.value = i.mapSize,
        A.uniforms.radius.value = i.radius,
        t.setRenderTarget(i.map),
        t.clear(),
        t.renderBufferDirect(n, null, o, A, x, null)
    }
    function w(e, i, n, r, o, s) {
      let l = null;
      const h = !0 === n.isPointLight ? e.customDistanceMaterial : e.customDepthMaterial;
      if (l = void 0 !== h ? h : !0 === n.isPointLight ? f : d,
        t.localClippingEnabled && !0 === i.clipShadows && Array.isArray(i.clippingPlanes) && 0 !== i.clippingPlanes.length || i.displacementMap && 0 !== i.displacementScale || i.alphaMap && i.alphaTest > 0) {
        const t = l.uuid
          , e = i.uuid;
        let n = g[t];
        void 0 === n && (n = {},
          g[t] = n);
        let r = n[e];
        void 0 === r && (r = l.clone(),
          n[e] = r),
          l = r
      }
      return l.visible = i.visible,
        l.wireframe = i.wireframe,
        l.side = s === a ? null !== i.shadowSide ? i.shadowSide : i.side : null !== i.shadowSide ? i.shadowSide : y[i.side],
        l.alphaMap = i.alphaMap,
        l.alphaTest = i.alphaTest,
        l.clipShadows = i.clipShadows,
        l.clippingPlanes = i.clippingPlanes,
        l.clipIntersection = i.clipIntersection,
        l.displacementMap = i.displacementMap,
        l.displacementScale = i.displacementScale,
        l.displacementBias = i.displacementBias,
        l.wireframeLinewidth = i.wireframeLinewidth,
        l.linewidth = i.linewidth,
        !0 === n.isPointLight && !0 === l.isMeshDistanceMaterial && (l.referencePosition.setFromMatrixPosition(n.matrixWorld),
          l.nearDistance = r,
          l.farDistance = o),
        l
    }
    function _(i, r, o, s, l) {
      if (!1 === i.visible)
        return;
      if (i.layers.test(r.layers) && (i.isMesh || i.isLine || i.isPoints) && (i.castShadow || i.receiveShadow && l === a) && (!i.frustumCulled || n.intersectsObject(i))) {
        i.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse, i.matrixWorld);
        const n = e.update(i)
          , r = i.material;
        if (Array.isArray(r)) {
          const e = n.groups;
          for (let a = 0, h = e.length; a < h; a++) {
            const h = e[a]
              , c = r[h.materialIndex];
            if (c && c.visible) {
              const e = w(i, c, s, o.near, o.far, l);
              t.renderBufferDirect(o, null, n, e, i, h)
            }
          }
        } else if (r.visible) {
          const e = w(i, r, s, o.near, o.far, l);
          t.renderBufferDirect(o, null, n, e, i, null)
        }
      }
      const h = i.children;
      for (let t = 0, e = h.length; t < e; t++)
        _(h[t], r, o, s, l)
    }
    this.enabled = !1,
      this.autoUpdate = !0,
      this.needsUpdate = !1,
      this.type = o,
      this.render = function (e, i, o) {
        if (!1 === I.enabled)
          return;
        if (!1 === I.autoUpdate && !1 === I.needsUpdate)
          return;
        if (0 === e.length)
          return;
        const l = t.getRenderTarget()
          , h = t.getActiveCubeFace()
          , c = t.getActiveMipmapLevel()
          , d = t.state;
        d.setBlending(u),
          d.buffers.color.setClear(1, 1, 1, 1),
          d.buffers.depth.setTest(!0),
          d.setScissorTest(!1);
        for (let l = 0, h = e.length; l < h; l++) {
          const h = e[l]
            , c = h.shadow;
          if (void 0 === c) {
            console.warn("THREE.WebGLShadowMap:", h, "has no shadow.");
            continue
          }
          if (!1 === c.autoUpdate && !1 === c.needsUpdate)
            continue;
          r.copy(c.mapSize);
          const u = c.getFrameExtents();
          if (r.multiply(u),
            s.copy(c.mapSize),
            (r.x > m || r.y > m) && (r.x > m && (s.x = Math.floor(m / u.x),
              r.x = s.x * u.x,
              c.mapSize.x = s.x),
              r.y > m && (s.y = Math.floor(m / u.y),
                r.y = s.y * u.y,
                c.mapSize.y = s.y)),
            null === c.map) {
            const t = this.type !== a ? {
              minFilter: ot,
              magFilter: ot
            } : {};
            c.map = new hi(r.x, r.y, t),
              c.map.texture.name = h.name + ".shadowMap",
              c.camera.updateProjectionMatrix()
          }
          t.setRenderTarget(c.map),
            t.clear();
          const f = c.getViewportCount();
          for (let t = 0; t < f; t++) {
            const e = c.getViewport(t);
            p.set(s.x * e.x, s.y * e.y, s.x * e.z, s.y * e.w),
              d.viewport(p),
              c.updateMatrices(h, t),
              n = c.getFrustum(),
              _(i, o, c.camera, h, this.type)
          }
          !0 !== c.isPointLightShadow && this.type === a && C(c, o),
            c.needsUpdate = !1
        }
        I.needsUpdate = !1,
          t.setRenderTarget(l, h, c)
      }
  }
  function ta(t, e, o) {
    const s = o.isWebGL2;
    const a = new function () {
      let e = !1;
      const i = new li;
      let n = null;
      const r = new li(0, 0, 0, 0);
      return {
        setMask: function (i) {
          n === i || e || (t.colorMask(i, i, i, i),
            n = i)
        },
        setLocked: function (t) {
          e = t
        },
        setClear: function (e, n, o, s, a) {
          !0 === a && (e *= s,
            n *= s,
            o *= s),
            i.set(e, n, o, s),
            !1 === r.equals(i) && (t.clearColor(e, n, o, s),
              r.copy(i))
        },
        reset: function () {
          e = !1,
            n = null,
            r.set(-1, 0, 0, 0)
        }
      }
    }
      , l = new function () {
        let e = !1
          , i = null
          , n = null
          , r = null;
        return {
          setTest: function (t) {
            t ? At(2929) : bt(2929)
          },
          setMask: function (n) {
            i === n || e || (t.depthMask(n),
              i = n)
          },
          setFunc: function (e) {
            if (n !== e) {
              if (e)
                switch (e) {
                  case P:
                    t.depthFunc(512);
                    break;
                  case z:
                    t.depthFunc(519);
                    break;
                  case O:
                    t.depthFunc(513);
                    break;
                  case D:
                    t.depthFunc(515);
                    break;
                  case U:
                    t.depthFunc(514);
                    break;
                  case N:
                    t.depthFunc(518);
                    break;
                  case F:
                    t.depthFunc(516);
                    break;
                  case B:
                    t.depthFunc(517);
                    break;
                  default:
                    t.depthFunc(515)
                }
              else
                t.depthFunc(515);
              n = e
            }
          },
          setLocked: function (t) {
            e = t
          },
          setClear: function (e) {
            r !== e && (t.clearDepth(e),
              r = e)
          },
          reset: function () {
            e = !1,
              i = null,
              n = null,
              r = null
          }
        }
      }
      , j = new function () {
        let e = !1
          , i = null
          , n = null
          , r = null
          , o = null
          , s = null
          , a = null
          , l = null
          , h = null;
        return {
          setTest: function (t) {
            e || (t ? At(2960) : bt(2960))
          },
          setMask: function (n) {
            i === n || e || (t.stencilMask(n),
              i = n)
          },
          setFunc: function (e, i, s) {
            n === e && r === i && o === s || (t.stencilFunc(e, i, s),
              n = e,
              r = i,
              o = s)
          },
          setOp: function (e, i, n) {
            s === e && a === i && l === n || (t.stencilOp(e, i, n),
              s = e,
              a = i,
              l = n)
          },
          setLocked: function (t) {
            e = t
          },
          setClear: function (e) {
            h !== e && (t.clearStencil(e),
              h = e)
          },
          reset: function () {
            e = !1,
              i = null,
              n = null,
              r = null,
              o = null,
              s = null,
              a = null,
              l = null,
              h = null
          }
        }
      }
      ;
    let V = {}
      , G = {}
      , W = new WeakMap
      , J = []
      , H = null
      , Z = !1
      , Q = null
      , K = null
      , Y = null
      , q = null
      , X = null
      , $ = null
      , tt = null
      , et = !1
      , it = null
      , nt = null
      , rt = null
      , ot = null
      , st = null;
    const at = t.getParameter(35661);
    let lt = !1
      , ht = 0;
    const ct = t.getParameter(7938);
    -1 !== ct.indexOf("WebGL") ? (ht = parseFloat(/^WebGL (\d)/.exec(ct)[1]),
      lt = ht >= 1) : -1 !== ct.indexOf("OpenGL ES") && (ht = parseFloat(/^OpenGL ES (\d)/.exec(ct)[1]),
        lt = ht >= 2);
    let ut = null
      , pt = {};
    const dt = t.getParameter(3088)
      , ft = t.getParameter(2978)
      , gt = (new li).fromArray(dt)
      , mt = (new li).fromArray(ft);
    function yt(e, i, n) {
      const r = new Uint8Array(4)
        , o = t.createTexture();
      t.bindTexture(e, o),
        t.texParameteri(e, 10241, 9728),
        t.texParameteri(e, 10240, 9728);
      for (let e = 0; e < n; e++)
        t.texImage2D(i + e, 0, 6408, 1, 1, 0, 6408, 5121, r);
      return o
    }
    const vt = {};
    function At(e) {
      !0 !== V[e] && (t.enable(e),
        V[e] = !0)
    }
    function bt(e) {
      !1 !== V[e] && (t.disable(e),
        V[e] = !1)
    }
    vt[3553] = yt(3553, 3553, 1),
      vt[34067] = yt(34067, 34069, 6),
      a.setClear(0, 0, 0, 1),
      l.setClear(1),
      j.setClear(0),
      At(2929),
      l.setFunc(D),
      wt(!1),
      _t(n),
      At(2884),
      Ct(u);
    const xt = {
      [y]: 32774,
      [v]: 32778,
      [A]: 32779
    };
    if (s)
      xt[b] = 32775,
        xt[x] = 32776;
    else {
      const t = e.get("EXT_blend_minmax");
      null !== t && (xt[b] = t.MIN_EXT,
        xt[x] = t.MAX_EXT)
    }
    const It = {
      [I]: 0,
      [C]: 1,
      [w]: 768,
      [S]: 770,
      [L]: 776,
      [k]: 774,
      [T]: 772,
      [_]: 769,
      [M]: 771,
      [R]: 775,
      [E]: 773
    };
    function Ct(e, i, n, r, o, s, a, l) {
      if (e !== u) {
        if (!1 === Z && (At(3042),
          Z = !0),
          e === m)
          o = o || i,
            s = s || n,
            a = a || r,
            i === K && o === X || (t.blendEquationSeparate(xt[i], xt[o]),
              K = i,
              X = o),
            n === Y && r === q && s === $ && a === tt || (t.blendFuncSeparate(It[n], It[r], It[s], It[a]),
              Y = n,
              q = r,
              $ = s,
              tt = a),
            Q = e,
            et = null;
        else if (e !== Q || l !== et) {
          if (K === y && X === y || (t.blendEquation(32774),
            K = y,
            X = y),
            l)
            switch (e) {
              case p:
                t.blendFuncSeparate(1, 771, 1, 771);
                break;
              case d:
                t.blendFunc(1, 1);
                break;
              case f:
                t.blendFuncSeparate(0, 769, 0, 1);
                break;
              case g:
                t.blendFuncSeparate(0, 768, 0, 770);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", e)
            }
          else
            switch (e) {
              case p:
                t.blendFuncSeparate(770, 771, 1, 771);
                break;
              case d:
                t.blendFunc(770, 1);
                break;
              case f:
                t.blendFuncSeparate(0, 769, 0, 1);
                break;
              case g:
                t.blendFunc(0, 768);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", e)
            }
          Y = null,
            q = null,
            $ = null,
            tt = null,
            Q = e,
            et = l
        }
      } else
        !0 === Z && (bt(3042),
          Z = !1)
    }
    function wt(e) {
      it !== e && (e ? t.frontFace(2304) : t.frontFace(2305),
        it = e)
    }
    function _t(e) {
      e !== i ? (At(2884),
        e !== nt && (e === n ? t.cullFace(1029) : e === r ? t.cullFace(1028) : t.cullFace(1032))) : bt(2884),
        nt = e
    }
    function St(e, i, n) {
      e ? (At(32823),
        ot === i && st === n || (t.polygonOffset(i, n),
          ot = i,
          st = n)) : bt(32823)
    }
    function Mt(e) {
      void 0 === e && (e = 33984 + at - 1),
        ut !== e && (t.activeTexture(e),
          ut = e)
    }
    return {
      buffers: {
        color: a,
        depth: l,
        stencil: j
      },
      enable: At,
      disable: bt,
      bindFramebuffer: function (e, i) {
        return G[e] !== i && (t.bindFramebuffer(e, i),
          G[e] = i,
          s && (36009 === e && (G[36160] = i),
            36160 === e && (G[36009] = i)),
          !0)
      },
      drawBuffers: function (i, n) {
        let r = J
          , s = !1;
        if (i)
          if (r = W.get(n),
            void 0 === r && (r = [],
              W.set(n, r)),
            i.isWebGLMultipleRenderTargets) {
            const t = i.texture;
            if (r.length !== t.length || 36064 !== r[0]) {
              for (let e = 0, i = t.length; e < i; e++)
                r[e] = 36064 + e;
              r.length = t.length,
                s = !0
            }
          } else
            36064 !== r[0] && (r[0] = 36064,
              s = !0);
        else
          1029 !== r[0] && (r[0] = 1029,
            s = !0);
        s && (o.isWebGL2 ? t.drawBuffers(r) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(r))
      },
      useProgram: function (e) {
        return H !== e && (t.useProgram(e),
          H = e,
          !0)
      },
      setBlending: Ct,
      setMaterial: function (t, e) {
        t.side === c ? bt(2884) : At(2884);
        let i = t.side === h;
        e && (i = !i),
          wt(i),
          t.blending === p && !1 === t.transparent ? Ct(u) : Ct(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha),
          l.setFunc(t.depthFunc),
          l.setTest(t.depthTest),
          l.setMask(t.depthWrite),
          a.setMask(t.colorWrite);
        const n = t.stencilWrite;
        j.setTest(n),
          n && (j.setMask(t.stencilWriteMask),
            j.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask),
            j.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)),
          St(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits),
          !0 === t.alphaToCoverage ? At(32926) : bt(32926)
      },
      setFlipSided: wt,
      setCullFace: _t,
      setLineWidth: function (e) {
        e !== rt && (lt && t.lineWidth(e),
          rt = e)
      },
      setPolygonOffset: St,
      setScissorTest: function (t) {
        t ? At(3089) : bt(3089)
      },
      activeTexture: Mt,
      bindTexture: function (e, i) {
        null === ut && Mt();
        let n = pt[ut];
        void 0 === n && (n = {
          type: void 0,
          texture: void 0
        },
          pt[ut] = n),
          n.type === e && n.texture === i || (t.bindTexture(e, i || vt[e]),
            n.type = e,
            n.texture = i)
      },
      unbindTexture: function () {
        const e = pt[ut];
        void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null),
          e.type = void 0,
          e.texture = void 0)
      },
      compressedTexImage2D: function () {
        try {
          t.compressedTexImage2D.apply(t, arguments)
        } catch (t) {
          console.error("THREE.WebGLState:", t)
        }
      },
      texImage2D: function () {
        try {
          t.texImage2D.apply(t, arguments)
        } catch (t) {
          console.error("THREE.WebGLState:", t)
        }
      },
      texImage3D: function () {
        try {
          t.texImage3D.apply(t, arguments)
        } catch (t) {
          console.error("THREE.WebGLState:", t)
        }
      },
      texStorage2D: function () {
        try {
          t.texStorage2D.apply(t, arguments)
        } catch (t) {
          console.error("THREE.WebGLState:", t)
        }
      },
      texStorage3D: function () {
        try {
          t.texStorage3D.apply(t, arguments)
        } catch (t) {
          console.error("THREE.WebGLState:", t)
        }
      },
      texSubImage2D: function () {
        try {
          t.texSubImage2D.apply(t, arguments)
        } catch (t) {
          console.error("THREE.WebGLState:", t)
        }
      },
      texSubImage3D: function () {
        try {
          t.texSubImage3D.apply(t, arguments)
        } catch (t) {
          console.error("THREE.WebGLState:", t)
        }
      },
      compressedTexSubImage2D: function () {
        try {
          t.compressedTexSubImage2D.apply(t, arguments)
        } catch (t) {
          console.error("THREE.WebGLState:", t)
        }
      },
      scissor: function (e) {
        !1 === gt.equals(e) && (t.scissor(e.x, e.y, e.z, e.w),
          gt.copy(e))
      },
      viewport: function (e) {
        !1 === mt.equals(e) && (t.viewport(e.x, e.y, e.z, e.w),
          mt.copy(e))
      },
      reset: function () {
        t.disable(3042),
          t.disable(2884),
          t.disable(2929),
          t.disable(32823),
          t.disable(3089),
          t.disable(2960),
          t.disable(32926),
          t.blendEquation(32774),
          t.blendFunc(1, 0),
          t.blendFuncSeparate(1, 0, 1, 0),
          t.colorMask(!0, !0, !0, !0),
          t.clearColor(0, 0, 0, 0),
          t.depthMask(!0),
          t.depthFunc(513),
          t.clearDepth(1),
          t.stencilMask(4294967295),
          t.stencilFunc(519, 0, 4294967295),
          t.stencilOp(7680, 7680, 7680),
          t.clearStencil(0),
          t.cullFace(1029),
          t.frontFace(2305),
          t.polygonOffset(0, 0),
          t.activeTexture(33984),
          t.bindFramebuffer(36160, null),
          !0 === s && (t.bindFramebuffer(36009, null),
            t.bindFramebuffer(36008, null)),
          t.useProgram(null),
          t.lineWidth(1),
          t.scissor(0, 0, t.canvas.width, t.canvas.height),
          t.viewport(0, 0, t.canvas.width, t.canvas.height),
          V = {},
          ut = null,
          pt = {},
          G = {},
          W = new WeakMap,
          J = [],
          H = null,
          Z = !1,
          Q = null,
          K = null,
          Y = null,
          q = null,
          X = null,
          $ = null,
          tt = null,
          et = !1,
          it = null,
          nt = null,
          rt = null,
          ot = null,
          st = null,
          gt.set(0, 0, t.canvas.width, t.canvas.height),
          mt.set(0, 0, t.canvas.width, t.canvas.height),
          a.reset(),
          l.reset(),
          j.reset()
      }
    }
  }
  function ea(t, e, i, n, r, o, s) {
    const a = r.isWebGL2
      , l = r.maxTextures
      , h = r.maxCubemapSize
      , c = r.maxTextureSize
      , u = r.maxSamples
      , p = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null
      , d = /OculusBrowser/g.test(navigator.userAgent)
      , f = new WeakMap;
    let g;
    const m = new WeakMap;
    let y = !1;
    try {
      y = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
    } catch (t) { }
    function v(t, e) {
      return y ? new OffscreenCanvas(t, e) : We("canvas")
    }
    function A(t, e, i, n) {
      let r = 1;
      if ((t.width > n || t.height > n) && (r = n / Math.max(t.width, t.height)),
        r < 1 || !0 === e) {
        if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
          const n = e ? Ue : Math.floor
            , o = n(r * t.width)
            , s = n(r * t.height);
          void 0 === g && (g = v(o, s));
          const a = i ? v(o, s) : g;
          a.width = o,
            a.height = s;
          return a.getContext("2d").drawImage(t, 0, 0, o, s),
            console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + o + "x" + s + ")."),
            a
        }
        return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."),
          t
      }
      return t
    }
    function b(t) {
      return Oe(t.width) && Oe(t.height)
    }
    function x(t, e) {
      return t.generateMipmaps && e && t.minFilter !== ot && t.minFilter !== lt
    }
    function I(e) {
      t.generateMipmap(e)
    }
    function C(i, n, r, o, s = !1) {
      if (!1 === a)
        return n;
      if (null !== i) {
        if (void 0 !== t[i])
          return t[i];
        console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + i + "'")
      }
      let l = n;
      return 6403 === n && (5126 === r && (l = 33326),
        5131 === r && (l = 33325),
        5121 === r && (l = 33321)),
        33319 === n && (5126 === r && (l = 33328),
          5131 === r && (l = 33327),
          5121 === r && (l = 33323)),
        6408 === n && (5126 === r && (l = 34836),
          5131 === r && (l = 34842),
          5121 === r && (l = o === ge && !1 === s ? 35907 : 32856),
          32819 === r && (l = 32854),
          32820 === r && (l = 32855)),
        33325 !== l && 33326 !== l && 33327 !== l && 33328 !== l && 34842 !== l && 34836 !== l || e.get("EXT_color_buffer_float"),
        l
    }
    function w(t, e, i) {
      return !0 === x(t, i) || t.isFramebufferTexture && t.minFilter !== ot && t.minFilter !== lt ? Math.log2(Math.max(e.width, e.height)) + 1 : void 0 !== t.mipmaps && t.mipmaps.length > 0 ? t.mipmaps.length : t.isCompressedTexture && Array.isArray(t.image) ? e.mipmaps.length : 1
    }
    function _(t) {
      return t === ot || t === st || t === at ? 9728 : 9729
    }
    function S(t) {
      const e = t.target;
      e.removeEventListener("dispose", S),
        function (t) {
          const e = n.get(t);
          if (void 0 === e.__webglInit)
            return;
          const i = t.source
            , r = m.get(i);
          if (r) {
            const n = r[e.__cacheKey];
            n.usedTimes--,
              0 === n.usedTimes && T(t),
              0 === Object.keys(r).length && m.delete(i)
          }
          n.remove(t)
        }(e),
        e.isVideoTexture && f.delete(e)
    }
    function M(e) {
      const i = e.target;
      i.removeEventListener("dispose", M),
        function (e) {
          const i = e.texture
            , r = n.get(e)
            , o = n.get(i);
          void 0 !== o.__webglTexture && (t.deleteTexture(o.__webglTexture),
            s.memory.textures--);
          e.depthTexture && e.depthTexture.dispose();
          if (e.isWebGLCubeRenderTarget)
            for (let e = 0; e < 6; e++)
              t.deleteFramebuffer(r.__webglFramebuffer[e]),
                r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer[e]);
          else {
            if (t.deleteFramebuffer(r.__webglFramebuffer),
              r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer),
              r.__webglMultisampledFramebuffer && t.deleteFramebuffer(r.__webglMultisampledFramebuffer),
              r.__webglColorRenderbuffer)
              for (let e = 0; e < r.__webglColorRenderbuffer.length; e++)
                r.__webglColorRenderbuffer[e] && t.deleteRenderbuffer(r.__webglColorRenderbuffer[e]);
            r.__webglDepthRenderbuffer && t.deleteRenderbuffer(r.__webglDepthRenderbuffer)
          }
          if (e.isWebGLMultipleRenderTargets)
            for (let e = 0, r = i.length; e < r; e++) {
              const r = n.get(i[e]);
              r.__webglTexture && (t.deleteTexture(r.__webglTexture),
                s.memory.textures--),
                n.remove(i[e])
            }
          n.remove(i),
            n.remove(e)
        }(i)
    }
    function T(e) {
      const i = n.get(e);
      t.deleteTexture(i.__webglTexture);
      const r = e.source;
      delete m.get(r)[i.__cacheKey],
        s.memory.textures--
    }
    let E = 0;
    function k(t, e) {
      const r = n.get(t);
      if (t.isVideoTexture && function (t) {
        const e = s.render.frame;
        f.get(t) !== e && (f.set(t, e),
          t.update())
      }(t),
        !1 === t.isRenderTargetTexture && t.version > 0 && r.__version !== t.version) {
        const i = t.image;
        if (null === i)
          console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
        else {
          if (!1 !== i.complete)
            return void O(r, t, e);
          console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
        }
      }
      i.activeTexture(33984 + e),
        i.bindTexture(3553, r.__webglTexture)
    }
    const R = {
      [it]: 10497,
      [nt]: 33071,
      [rt]: 33648
    }
      , L = {
        [ot]: 9728,
        [st]: 9984,
        [at]: 9986,
        [lt]: 9729,
        [ht]: 9985,
        [ct]: 9987
      };
    function P(i, o, s) {
      if (s ? (t.texParameteri(i, 10242, R[o.wrapS]),
        t.texParameteri(i, 10243, R[o.wrapT]),
        32879 !== i && 35866 !== i || t.texParameteri(i, 32882, R[o.wrapR]),
        t.texParameteri(i, 10240, L[o.magFilter]),
        t.texParameteri(i, 10241, L[o.minFilter])) : (t.texParameteri(i, 10242, 33071),
          t.texParameteri(i, 10243, 33071),
          32879 !== i && 35866 !== i || t.texParameteri(i, 32882, 33071),
          o.wrapS === nt && o.wrapT === nt || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),
          t.texParameteri(i, 10240, _(o.magFilter)),
          t.texParameteri(i, 10241, _(o.minFilter)),
          o.minFilter !== ot && o.minFilter !== lt && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),
        !0 === e.has("EXT_texture_filter_anisotropic")) {
        const s = e.get("EXT_texture_filter_anisotropic");
        if (o.type === yt && !1 === e.has("OES_texture_float_linear"))
          return;
        if (!1 === a && o.type === vt && !1 === e.has("OES_texture_half_float_linear"))
          return;
        (o.anisotropy > 1 || n.get(o).__currentAnisotropy) && (t.texParameterf(i, s.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(o.anisotropy, r.getMaxAnisotropy())),
          n.get(o).__currentAnisotropy = o.anisotropy)
      }
    }
    function z(e, i) {
      let n = !1;
      void 0 === e.__webglInit && (e.__webglInit = !0,
        i.addEventListener("dispose", S));
      const r = i.source;
      let o = m.get(r);
      void 0 === o && (o = {},
        m.set(r, o));
      const a = function (t) {
        const e = [];
        return e.push(t.wrapS),
          e.push(t.wrapT),
          e.push(t.magFilter),
          e.push(t.minFilter),
          e.push(t.anisotropy),
          e.push(t.internalFormat),
          e.push(t.format),
          e.push(t.type),
          e.push(t.generateMipmaps),
          e.push(t.premultiplyAlpha),
          e.push(t.flipY),
          e.push(t.unpackAlignment),
          e.push(t.encoding),
          e.join()
      }(i);
      if (a !== e.__cacheKey) {
        void 0 === o[a] && (o[a] = {
          texture: t.createTexture(),
          usedTimes: 0
        },
          s.memory.textures++,
          n = !0),
          o[a].usedTimes++;
        const r = o[e.__cacheKey];
        void 0 !== r && (o[e.__cacheKey].usedTimes--,
          0 === r.usedTimes && T(i)),
          e.__cacheKey = a,
          e.__webglTexture = o[a].texture
      }
      return n
    }
    function O(e, n, r) {
      let s = 3553;
      n.isDataArrayTexture && (s = 35866),
        n.isData3DTexture && (s = 32879);
      const l = z(e, n)
        , h = n.source;
      if (i.activeTexture(33984 + r),
        i.bindTexture(s, e.__webglTexture),
        h.version !== h.__currentVersion || !0 === l) {
        t.pixelStorei(37440, n.flipY),
          t.pixelStorei(37441, n.premultiplyAlpha),
          t.pixelStorei(3317, n.unpackAlignment),
          t.pixelStorei(37443, 0);
        const e = function (t) {
          return !a && (t.wrapS !== nt || t.wrapT !== nt || t.minFilter !== ot && t.minFilter !== lt)
        }(n) && !1 === b(n.image);
        let r = A(n.image, e, !1, c);
        r = j(n, r);
        const u = b(r) || a
          , p = o.convert(n.format, n.encoding);
        let d, f = o.convert(n.type), g = C(n.internalFormat, p, f, n.encoding, n.isVideoTexture);
        P(s, n, u);
        const m = n.mipmaps
          , y = a && !0 !== n.isVideoTexture
          , v = void 0 === h.__currentVersion || !0 === l
          , _ = w(n, r, u);
        if (n.isDepthTexture)
          g = 6402,
            a ? g = n.type === yt ? 36012 : n.type === mt ? 33190 : n.type === xt ? 35056 : 33189 : n.type === yt && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),
            n.format === Mt && 6402 === g && n.type !== ft && n.type !== mt && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
              n.type = mt,
              f = o.convert(n.type)),
            n.format === Tt && 6402 === g && (g = 34041,
              n.type !== xt && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),
                n.type = xt,
                f = o.convert(n.type))),
            v && (y ? i.texStorage2D(3553, 1, g, r.width, r.height) : i.texImage2D(3553, 0, g, r.width, r.height, 0, p, f, null));
        else if (n.isDataTexture)
          if (m.length > 0 && u) {
            y && v && i.texStorage2D(3553, _, g, m[0].width, m[0].height);
            for (let t = 0, e = m.length; t < e; t++)
              d = m[t],
                y ? i.texSubImage2D(3553, t, 0, 0, d.width, d.height, p, f, d.data) : i.texImage2D(3553, t, g, d.width, d.height, 0, p, f, d.data);
            n.generateMipmaps = !1
          } else
            y ? (v && i.texStorage2D(3553, _, g, r.width, r.height),
              i.texSubImage2D(3553, 0, 0, 0, r.width, r.height, p, f, r.data)) : i.texImage2D(3553, 0, g, r.width, r.height, 0, p, f, r.data);
        else if (n.isCompressedTexture) {
          y && v && i.texStorage2D(3553, _, g, m[0].width, m[0].height);
          for (let t = 0, e = m.length; t < e; t++)
            d = m[t],
              n.format !== wt ? null !== p ? y ? i.compressedTexSubImage2D(3553, t, 0, 0, d.width, d.height, p, d.data) : i.compressedTexImage2D(3553, t, g, d.width, d.height, 0, d.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : y ? i.texSubImage2D(3553, t, 0, 0, d.width, d.height, p, f, d.data) : i.texImage2D(3553, t, g, d.width, d.height, 0, p, f, d.data)
        } else if (n.isDataArrayTexture)
          y ? (v && i.texStorage3D(35866, _, g, r.width, r.height, r.depth),
            i.texSubImage3D(35866, 0, 0, 0, 0, r.width, r.height, r.depth, p, f, r.data)) : i.texImage3D(35866, 0, g, r.width, r.height, r.depth, 0, p, f, r.data);
        else if (n.isData3DTexture)
          y ? (v && i.texStorage3D(32879, _, g, r.width, r.height, r.depth),
            i.texSubImage3D(32879, 0, 0, 0, 0, r.width, r.height, r.depth, p, f, r.data)) : i.texImage3D(32879, 0, g, r.width, r.height, r.depth, 0, p, f, r.data);
        else if (n.isFramebufferTexture) {
          if (v)
            if (y)
              i.texStorage2D(3553, _, g, r.width, r.height);
            else {
              let t = r.width
                , e = r.height;
              for (let n = 0; n < _; n++)
                i.texImage2D(3553, n, g, t, e, 0, p, f, null),
                  t >>= 1,
                  e >>= 1
            }
        } else if (m.length > 0 && u) {
          y && v && i.texStorage2D(3553, _, g, m[0].width, m[0].height);
          for (let t = 0, e = m.length; t < e; t++)
            d = m[t],
              y ? i.texSubImage2D(3553, t, 0, 0, p, f, d) : i.texImage2D(3553, t, g, p, f, d);
          n.generateMipmaps = !1
        } else
          y ? (v && i.texStorage2D(3553, _, g, r.width, r.height),
            i.texSubImage2D(3553, 0, 0, 0, p, f, r)) : i.texImage2D(3553, 0, g, p, f, r);
        x(n, u) && I(s),
          h.__currentVersion = h.version,
          n.onUpdate && n.onUpdate(n)
      }
      e.__version = n.version
    }
    function D(e, r, s, a, l) {
      const h = o.convert(s.format, s.encoding)
        , c = o.convert(s.type)
        , u = C(s.internalFormat, h, c, s.encoding);
      n.get(r).__hasExternalTextures || (32879 === l || 35866 === l ? i.texImage3D(l, 0, u, r.width, r.height, r.depth, 0, h, c, null) : i.texImage2D(l, 0, u, r.width, r.height, 0, h, c, null)),
        i.bindFramebuffer(36160, e),
        B(r) ? p.framebufferTexture2DMultisampleEXT(36160, a, l, n.get(s).__webglTexture, 0, F(r)) : t.framebufferTexture2D(36160, a, l, n.get(s).__webglTexture, 0),
        i.bindFramebuffer(36160, null)
    }
    function U(e, i, n) {
      if (t.bindRenderbuffer(36161, e),
        i.depthBuffer && !i.stencilBuffer) {
        let r = 33189;
        if (n || B(i)) {
          const e = i.depthTexture;
          e && e.isDepthTexture && (e.type === yt ? r = 36012 : e.type === mt && (r = 33190));
          const n = F(i);
          B(i) ? p.renderbufferStorageMultisampleEXT(36161, n, r, i.width, i.height) : t.renderbufferStorageMultisample(36161, n, r, i.width, i.height)
        } else
          t.renderbufferStorage(36161, r, i.width, i.height);
        t.framebufferRenderbuffer(36160, 36096, 36161, e)
      } else if (i.depthBuffer && i.stencilBuffer) {
        const r = F(i);
        n && !1 === B(i) ? t.renderbufferStorageMultisample(36161, r, 35056, i.width, i.height) : B(i) ? p.renderbufferStorageMultisampleEXT(36161, r, 35056, i.width, i.height) : t.renderbufferStorage(36161, 34041, i.width, i.height),
          t.framebufferRenderbuffer(36160, 33306, 36161, e)
      } else {
        const e = !0 === i.isWebGLMultipleRenderTargets ? i.texture : [i.texture];
        for (let r = 0; r < e.length; r++) {
          const s = e[r]
            , a = o.convert(s.format, s.encoding)
            , l = o.convert(s.type)
            , h = C(s.internalFormat, a, l, s.encoding)
            , c = F(i);
          n && !1 === B(i) ? t.renderbufferStorageMultisample(36161, c, h, i.width, i.height) : B(i) ? p.renderbufferStorageMultisampleEXT(36161, c, h, i.width, i.height) : t.renderbufferStorage(36161, h, i.width, i.height)
        }
      }
      t.bindRenderbuffer(36161, null)
    }
    function N(e) {
      const r = n.get(e)
        , o = !0 === e.isWebGLCubeRenderTarget;
      if (e.depthTexture && !r.__autoAllocateDepthBuffer) {
        if (o)
          throw new Error("target.depthTexture not supported in Cube render targets");
        !function (e, r) {
          if (r && r.isWebGLCubeRenderTarget)
            throw new Error("Depth Texture with cube render targets is not supported");
          if (i.bindFramebuffer(36160, e),
            !r.depthTexture || !r.depthTexture.isDepthTexture)
            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
          n.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width,
            r.depthTexture.image.height = r.height,
            r.depthTexture.needsUpdate = !0),
            k(r.depthTexture, 0);
          const o = n.get(r.depthTexture).__webglTexture
            , s = F(r);
          if (r.depthTexture.format === Mt)
            B(r) ? p.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, o, 0, s) : t.framebufferTexture2D(36160, 36096, 3553, o, 0);
          else {
            if (r.depthTexture.format !== Tt)
              throw new Error("Unknown depthTexture format");
            B(r) ? p.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, o, 0, s) : t.framebufferTexture2D(36160, 33306, 3553, o, 0)
          }
        }(r.__webglFramebuffer, e)
      } else if (o) {
        r.__webglDepthbuffer = [];
        for (let n = 0; n < 6; n++)
          i.bindFramebuffer(36160, r.__webglFramebuffer[n]),
            r.__webglDepthbuffer[n] = t.createRenderbuffer(),
            U(r.__webglDepthbuffer[n], e, !1)
      } else
        i.bindFramebuffer(36160, r.__webglFramebuffer),
          r.__webglDepthbuffer = t.createRenderbuffer(),
          U(r.__webglDepthbuffer, e, !1);
      i.bindFramebuffer(36160, null)
    }
    function F(t) {
      return Math.min(u, t.samples)
    }
    function B(t) {
      const i = n.get(t);
      return a && t.samples > 0 && !0 === e.has("WEBGL_multisampled_render_to_texture") && !1 !== i.__useRenderToTexture
    }
    function j(t, i) {
      const n = t.encoding
        , r = t.format
        , o = t.type;
      return !0 === t.isCompressedTexture || !0 === t.isVideoTexture || t.format === _e || n !== fe && (n === ge ? !1 === a ? !0 === e.has("EXT_sRGB") && r === wt ? (t.format = _e,
        t.minFilter = lt,
        t.generateMipmaps = !1) : i = ni.sRGBToLinear(i) : r === wt && o === ut || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", n)),
        i
    }
    this.allocateTextureUnit = function () {
      const t = E;
      return t >= l && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + l),
        E += 1,
        t
    }
      ,
      this.resetTextureUnits = function () {
        E = 0
      }
      ,
      this.setTexture2D = k,
      this.setTexture2DArray = function (t, e) {
        const r = n.get(t);
        t.version > 0 && r.__version !== t.version ? O(r, t, e) : (i.activeTexture(33984 + e),
          i.bindTexture(35866, r.__webglTexture))
      }
      ,
      this.setTexture3D = function (t, e) {
        const r = n.get(t);
        t.version > 0 && r.__version !== t.version ? O(r, t, e) : (i.activeTexture(33984 + e),
          i.bindTexture(32879, r.__webglTexture))
      }
      ,
      this.setTextureCube = function (e, r) {
        const s = n.get(e);
        e.version > 0 && s.__version !== e.version ? function (e, n, r) {
          if (6 !== n.image.length)
            return;
          const s = z(e, n)
            , l = n.source;
          if (i.activeTexture(33984 + r),
            i.bindTexture(34067, e.__webglTexture),
            l.version !== l.__currentVersion || !0 === s) {
            t.pixelStorei(37440, n.flipY),
              t.pixelStorei(37441, n.premultiplyAlpha),
              t.pixelStorei(3317, n.unpackAlignment),
              t.pixelStorei(37443, 0);
            const e = n.isCompressedTexture || n.image[0].isCompressedTexture
              , r = n.image[0] && n.image[0].isDataTexture
              , c = [];
            for (let t = 0; t < 6; t++)
              c[t] = e || r ? r ? n.image[t].image : n.image[t] : A(n.image[t], !1, !0, h),
                c[t] = j(n, c[t]);
            const u = c[0]
              , p = b(u) || a
              , d = o.convert(n.format, n.encoding)
              , f = o.convert(n.type)
              , g = C(n.internalFormat, d, f, n.encoding)
              , m = a && !0 !== n.isVideoTexture
              , y = void 0 === l.__currentVersion || !0 === s;
            let v, _ = w(n, u, p);
            if (P(34067, n, p),
              e) {
              m && y && i.texStorage2D(34067, _, g, u.width, u.height);
              for (let t = 0; t < 6; t++) {
                v = c[t].mipmaps;
                for (let e = 0; e < v.length; e++) {
                  const r = v[e];
                  n.format !== wt ? null !== d ? m ? i.compressedTexSubImage2D(34069 + t, e, 0, 0, r.width, r.height, d, r.data) : i.compressedTexImage2D(34069 + t, e, g, r.width, r.height, 0, r.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : m ? i.texSubImage2D(34069 + t, e, 0, 0, r.width, r.height, d, f, r.data) : i.texImage2D(34069 + t, e, g, r.width, r.height, 0, d, f, r.data)
                }
              }
            } else {
              v = n.mipmaps,
                m && y && (v.length > 0 && _++,
                  i.texStorage2D(34067, _, g, c[0].width, c[0].height));
              for (let t = 0; t < 6; t++)
                if (r) {
                  m ? i.texSubImage2D(34069 + t, 0, 0, 0, c[t].width, c[t].height, d, f, c[t].data) : i.texImage2D(34069 + t, 0, g, c[t].width, c[t].height, 0, d, f, c[t].data);
                  for (let e = 0; e < v.length; e++) {
                    const n = v[e].image[t].image;
                    m ? i.texSubImage2D(34069 + t, e + 1, 0, 0, n.width, n.height, d, f, n.data) : i.texImage2D(34069 + t, e + 1, g, n.width, n.height, 0, d, f, n.data)
                  }
                } else {
                  m ? i.texSubImage2D(34069 + t, 0, 0, 0, d, f, c[t]) : i.texImage2D(34069 + t, 0, g, d, f, c[t]);
                  for (let e = 0; e < v.length; e++) {
                    const n = v[e];
                    m ? i.texSubImage2D(34069 + t, e + 1, 0, 0, d, f, n.image[t]) : i.texImage2D(34069 + t, e + 1, g, d, f, n.image[t])
                  }
                }
            }
            x(n, p) && I(34067),
              l.__currentVersion = l.version,
              n.onUpdate && n.onUpdate(n)
          }
          e.__version = n.version
        }(s, e, r) : (i.activeTexture(33984 + r),
          i.bindTexture(34067, s.__webglTexture))
      }
      ,
      this.rebindTextures = function (t, e, i) {
        const r = n.get(t);
        void 0 !== e && D(r.__webglFramebuffer, t, t.texture, 36064, 3553),
          void 0 !== i && N(t)
      }
      ,
      this.setupRenderTarget = function (e) {
        const l = e.texture
          , h = n.get(e)
          , c = n.get(l);
        e.addEventListener("dispose", M),
          !0 !== e.isWebGLMultipleRenderTargets && (void 0 === c.__webglTexture && (c.__webglTexture = t.createTexture()),
            c.__version = l.version,
            s.memory.textures++);
        const u = !0 === e.isWebGLCubeRenderTarget
          , p = !0 === e.isWebGLMultipleRenderTargets
          , d = b(e) || a;
        if (u) {
          h.__webglFramebuffer = [];
          for (let e = 0; e < 6; e++)
            h.__webglFramebuffer[e] = t.createFramebuffer()
        } else {
          if (h.__webglFramebuffer = t.createFramebuffer(),
            p)
            if (r.drawBuffers) {
              const i = e.texture;
              for (let e = 0, r = i.length; e < r; e++) {
                const r = n.get(i[e]);
                void 0 === r.__webglTexture && (r.__webglTexture = t.createTexture(),
                  s.memory.textures++)
              }
            } else
              console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
          if (a && e.samples > 0 && !1 === B(e)) {
            const n = p ? l : [l];
            h.__webglMultisampledFramebuffer = t.createFramebuffer(),
              h.__webglColorRenderbuffer = [],
              i.bindFramebuffer(36160, h.__webglMultisampledFramebuffer);
            for (let i = 0; i < n.length; i++) {
              const r = n[i];
              h.__webglColorRenderbuffer[i] = t.createRenderbuffer(),
                t.bindRenderbuffer(36161, h.__webglColorRenderbuffer[i]);
              const s = o.convert(r.format, r.encoding)
                , a = o.convert(r.type)
                , l = C(r.internalFormat, s, a, r.encoding)
                , c = F(e);
              t.renderbufferStorageMultisample(36161, c, l, e.width, e.height),
                t.framebufferRenderbuffer(36160, 36064 + i, 36161, h.__webglColorRenderbuffer[i])
            }
            t.bindRenderbuffer(36161, null),
              e.depthBuffer && (h.__webglDepthRenderbuffer = t.createRenderbuffer(),
                U(h.__webglDepthRenderbuffer, e, !0)),
              i.bindFramebuffer(36160, null)
          }
        }
        if (u) {
          i.bindTexture(34067, c.__webglTexture),
            P(34067, l, d);
          for (let t = 0; t < 6; t++)
            D(h.__webglFramebuffer[t], e, l, 36064, 34069 + t);
          x(l, d) && I(34067),
            i.unbindTexture()
        } else if (p) {
          const t = e.texture;
          for (let r = 0, o = t.length; r < o; r++) {
            const o = t[r]
              , s = n.get(o);
            i.bindTexture(3553, s.__webglTexture),
              P(3553, o, d),
              D(h.__webglFramebuffer, e, o, 36064 + r, 3553),
              x(o, d) && I(3553)
          }
          i.unbindTexture()
        } else {
          let t = 3553;
          (e.isWebGL3DRenderTarget || e.isWebGLArrayRenderTarget) && (a ? t = e.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),
            i.bindTexture(t, c.__webglTexture),
            P(t, l, d),
            D(h.__webglFramebuffer, e, l, 36064, t),
            x(l, d) && I(t),
            i.unbindTexture()
        }
        e.depthBuffer && N(e)
      }
      ,
      this.updateRenderTargetMipmap = function (t) {
        const e = b(t) || a
          , r = !0 === t.isWebGLMultipleRenderTargets ? t.texture : [t.texture];
        for (let o = 0, s = r.length; o < s; o++) {
          const s = r[o];
          if (x(s, e)) {
            const e = t.isWebGLCubeRenderTarget ? 34067 : 3553
              , r = n.get(s).__webglTexture;
            i.bindTexture(e, r),
              I(e),
              i.unbindTexture()
          }
        }
      }
      ,
      this.updateMultisampleRenderTarget = function (e) {
        if (a && e.samples > 0 && !1 === B(e)) {
          const r = e.isWebGLMultipleRenderTargets ? e.texture : [e.texture]
            , o = e.width
            , s = e.height;
          let a = 16384;
          const l = []
            , h = e.stencilBuffer ? 33306 : 36096
            , c = n.get(e)
            , u = !0 === e.isWebGLMultipleRenderTargets;
          if (u)
            for (let e = 0; e < r.length; e++)
              i.bindFramebuffer(36160, c.__webglMultisampledFramebuffer),
                t.framebufferRenderbuffer(36160, 36064 + e, 36161, null),
                i.bindFramebuffer(36160, c.__webglFramebuffer),
                t.framebufferTexture2D(36009, 36064 + e, 3553, null, 0);
          i.bindFramebuffer(36008, c.__webglMultisampledFramebuffer),
            i.bindFramebuffer(36009, c.__webglFramebuffer);
          for (let i = 0; i < r.length; i++) {
            l.push(36064 + i),
              e.depthBuffer && l.push(h);
            const p = void 0 !== c.__ignoreDepthValues && c.__ignoreDepthValues;
            if (!1 === p && (e.depthBuffer && (a |= 256),
              e.stencilBuffer && (a |= 1024)),
              u && t.framebufferRenderbuffer(36008, 36064, 36161, c.__webglColorRenderbuffer[i]),
              !0 === p && (t.invalidateFramebuffer(36008, [h]),
                t.invalidateFramebuffer(36009, [h])),
              u) {
              const e = n.get(r[i]).__webglTexture;
              t.framebufferTexture2D(36009, 36064, 3553, e, 0)
            }
            t.blitFramebuffer(0, 0, o, s, 0, 0, o, s, a, 9728),
              d && t.invalidateFramebuffer(36008, l)
          }
          if (i.bindFramebuffer(36008, null),
            i.bindFramebuffer(36009, null),
            u)
            for (let e = 0; e < r.length; e++) {
              i.bindFramebuffer(36160, c.__webglMultisampledFramebuffer),
                t.framebufferRenderbuffer(36160, 36064 + e, 36161, c.__webglColorRenderbuffer[e]);
              const o = n.get(r[e]).__webglTexture;
              i.bindFramebuffer(36160, c.__webglFramebuffer),
                t.framebufferTexture2D(36009, 36064 + e, 3553, o, 0)
            }
          i.bindFramebuffer(36009, c.__webglMultisampledFramebuffer)
        }
      }
      ,
      this.setupDepthRenderbuffer = N,
      this.setupFrameBufferTexture = D,
      this.useMultisampledRTT = B
  }
  function ia(t, e, i) {
    const n = i.isWebGL2;
    return {
      convert: function (i, r = null) {
        let o;
        if (i === ut)
          return 5121;
        if (i === At)
          return 32819;
        if (i === bt)
          return 32820;
        if (i === pt)
          return 5120;
        if (i === dt)
          return 5122;
        if (i === ft)
          return 5123;
        if (i === gt)
          return 5124;
        if (i === mt)
          return 5125;
        if (i === yt)
          return 5126;
        if (i === vt)
          return n ? 5131 : (o = e.get("OES_texture_half_float"),
            null !== o ? o.HALF_FLOAT_OES : null);
        if (i === It)
          return 6406;
        if (i === wt)
          return 6408;
        if (i === _t)
          return 6409;
        if (i === St)
          return 6410;
        if (i === Mt)
          return 6402;
        if (i === Tt)
          return 34041;
        if (i === Et)
          return 6403;
        if (i === Ct)
          return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"),
            6408;
        if (i === _e)
          return o = e.get("EXT_sRGB"),
            null !== o ? o.SRGB_ALPHA_EXT : null;
        if (i === kt)
          return 36244;
        if (i === Rt)
          return 33319;
        if (i === Lt)
          return 33320;
        if (i === Pt)
          return 36249;
        if (i === zt || i === Ot || i === Dt || i === Ut)
          if (r === ge) {
            if (o = e.get("WEBGL_compressed_texture_s3tc_srgb"),
              null === o)
              return null;
            if (i === zt)
              return o.COMPRESSED_SRGB_S3TC_DXT1_EXT;
            if (i === Ot)
              return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
            if (i === Dt)
              return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
            if (i === Ut)
              return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
          } else {
            if (o = e.get("WEBGL_compressed_texture_s3tc"),
              null === o)
              return null;
            if (i === zt)
              return o.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (i === Ot)
              return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (i === Dt)
              return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (i === Ut)
              return o.COMPRESSED_RGBA_S3TC_DXT5_EXT
          }
        if (i === Nt || i === Ft || i === Bt || i === jt) {
          if (o = e.get("WEBGL_compressed_texture_pvrtc"),
            null === o)
            return null;
          if (i === Nt)
            return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
          if (i === Ft)
            return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
          if (i === Bt)
            return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
          if (i === jt)
            return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
        }
        if (i === Vt)
          return o = e.get("WEBGL_compressed_texture_etc1"),
            null !== o ? o.COMPRESSED_RGB_ETC1_WEBGL : null;
        if (i === Gt || i === Wt) {
          if (o = e.get("WEBGL_compressed_texture_etc"),
            null === o)
            return null;
          if (i === Gt)
            return r === ge ? o.COMPRESSED_SRGB8_ETC2 : o.COMPRESSED_RGB8_ETC2;
          if (i === Wt)
            return r === ge ? o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : o.COMPRESSED_RGBA8_ETC2_EAC
        }
        if (i === Jt || i === Ht || i === Zt || i === Qt || i === Kt || i === Yt || i === qt || i === Xt || i === $t || i === te || i === ee || i === ie || i === ne || i === re) {
          if (o = e.get("WEBGL_compressed_texture_astc"),
            null === o)
            return null;
          if (i === Jt)
            return r === ge ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : o.COMPRESSED_RGBA_ASTC_4x4_KHR;
          if (i === Ht)
            return r === ge ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : o.COMPRESSED_RGBA_ASTC_5x4_KHR;
          if (i === Zt)
            return r === ge ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : o.COMPRESSED_RGBA_ASTC_5x5_KHR;
          if (i === Qt)
            return r === ge ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : o.COMPRESSED_RGBA_ASTC_6x5_KHR;
          if (i === Kt)
            return r === ge ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : o.COMPRESSED_RGBA_ASTC_6x6_KHR;
          if (i === Yt)
            return r === ge ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : o.COMPRESSED_RGBA_ASTC_8x5_KHR;
          if (i === qt)
            return r === ge ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : o.COMPRESSED_RGBA_ASTC_8x6_KHR;
          if (i === Xt)
            return r === ge ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : o.COMPRESSED_RGBA_ASTC_8x8_KHR;
          if (i === $t)
            return r === ge ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : o.COMPRESSED_RGBA_ASTC_10x5_KHR;
          if (i === te)
            return r === ge ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : o.COMPRESSED_RGBA_ASTC_10x6_KHR;
          if (i === ee)
            return r === ge ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : o.COMPRESSED_RGBA_ASTC_10x8_KHR;
          if (i === ie)
            return r === ge ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : o.COMPRESSED_RGBA_ASTC_10x10_KHR;
          if (i === ne)
            return r === ge ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : o.COMPRESSED_RGBA_ASTC_12x10_KHR;
          if (i === re)
            return r === ge ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : o.COMPRESSED_RGBA_ASTC_12x12_KHR
        }
        if (i === oe) {
          if (o = e.get("EXT_texture_compression_bptc"),
            null === o)
            return null;
          if (i === oe)
            return r === ge ? o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : o.COMPRESSED_RGBA_BPTC_UNORM_EXT
        }
        return i === xt ? n ? 34042 : (o = e.get("WEBGL_depth_texture"),
          null !== o ? o.UNSIGNED_INT_24_8_WEBGL : null) : void 0 !== t[i] ? t[i] : null
      }
    }
  }
  class na extends mr {
    constructor(t = []) {
      super(),
        this.isArrayCamera = !0,
        this.cameras = t
    }
  }
  let ra = class extends mn {
    constructor() {
      super(),
        this.isGroup = !0,
        this.type = "Group"
    }
  }
    ;
  const oa = {
    type: "move"
  };
  class sa {
    constructor() {
      this._targetRay = null,
        this._grip = null,
        this._hand = null
    }
    getHandSpace() {
      return null === this._hand && (this._hand = new ra,
        this._hand.matrixAutoUpdate = !1,
        this._hand.visible = !1,
        this._hand.joints = {},
        this._hand.inputState = {
          pinching: !1
        }),
        this._hand
    }
    getTargetRaySpace() {
      return null === this._targetRay && (this._targetRay = new ra,
        this._targetRay.matrixAutoUpdate = !1,
        this._targetRay.visible = !1,
        this._targetRay.hasLinearVelocity = !1,
        this._targetRay.linearVelocity = new di,
        this._targetRay.hasAngularVelocity = !1,
        this._targetRay.angularVelocity = new di),
        this._targetRay
    }
    getGripSpace() {
      return null === this._grip && (this._grip = new ra,
        this._grip.matrixAutoUpdate = !1,
        this._grip.visible = !1,
        this._grip.hasLinearVelocity = !1,
        this._grip.linearVelocity = new di,
        this._grip.hasAngularVelocity = !1,
        this._grip.angularVelocity = new di),
        this._grip
    }
    dispatchEvent(t) {
      return null !== this._targetRay && this._targetRay.dispatchEvent(t),
        null !== this._grip && this._grip.dispatchEvent(t),
        null !== this._hand && this._hand.dispatchEvent(t),
        this
    }
    disconnect(t) {
      return this.dispatchEvent({
        type: "disconnected",
        data: t
      }),
        null !== this._targetRay && (this._targetRay.visible = !1),
        null !== this._grip && (this._grip.visible = !1),
        null !== this._hand && (this._hand.visible = !1),
        this
    }
    update(t, e, i) {
      let n = null
        , r = null
        , o = null;
      const s = this._targetRay
        , a = this._grip
        , l = this._hand;
      if (t && "visible-blurred" !== e.session.visibilityState) {
        if (l && t.hand) {
          o = !0;
          for (const n of t.hand.values()) {
            const t = e.getJointPose(n, i);
            if (void 0 === l.joints[n.jointName]) {
              const t = new ra;
              t.matrixAutoUpdate = !1,
                t.visible = !1,
                l.joints[n.jointName] = t,
                l.add(t)
            }
            const r = l.joints[n.jointName];
            null !== t && (r.matrix.fromArray(t.transform.matrix),
              r.matrix.decompose(r.position, r.rotation, r.scale),
              r.jointRadius = t.radius),
              r.visible = null !== t
          }
          const n = l.joints["index-finger-tip"]
            , r = l.joints["thumb-tip"]
            , s = n.position.distanceTo(r.position)
            , a = .02
            , h = .005;
          l.inputState.pinching && s > a + h ? (l.inputState.pinching = !1,
            this.dispatchEvent({
              type: "pinchend",
              handedness: t.handedness,
              target: this
            })) : !l.inputState.pinching && s <= a - h && (l.inputState.pinching = !0,
              this.dispatchEvent({
                type: "pinchstart",
                handedness: t.handedness,
                target: this
              }))
        } else
          null !== a && t.gripSpace && (r = e.getPose(t.gripSpace, i),
            null !== r && (a.matrix.fromArray(r.transform.matrix),
              a.matrix.decompose(a.position, a.rotation, a.scale),
              r.linearVelocity ? (a.hasLinearVelocity = !0,
                a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = !1,
              r.angularVelocity ? (a.hasAngularVelocity = !0,
                a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = !1));
        null !== s && (n = e.getPose(t.targetRaySpace, i),
          null === n && null !== r && (n = r),
          null !== n && (s.matrix.fromArray(n.transform.matrix),
            s.matrix.decompose(s.position, s.rotation, s.scale),
            n.linearVelocity ? (s.hasLinearVelocity = !0,
              s.linearVelocity.copy(n.linearVelocity)) : s.hasLinearVelocity = !1,
            n.angularVelocity ? (s.hasAngularVelocity = !0,
              s.angularVelocity.copy(n.angularVelocity)) : s.hasAngularVelocity = !1,
            this.dispatchEvent(oa)))
      }
      return null !== s && (s.visible = null !== n),
        null !== a && (a.visible = null !== r),
        null !== l && (l.visible = null !== o),
        this
    }
  }
  class aa extends ai {
    constructor(t, e, i, n, r, o, s, a, l, h) {
      if ((h = void 0 !== h ? h : Mt) !== Mt && h !== Tt)
        throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
      void 0 === i && h === Mt && (i = mt),
        void 0 === i && h === Tt && (i = xt),
        super(null, n, r, o, s, a, h, i, l),
        this.isDepthTexture = !0,
        this.image = {
          width: t,
          height: e
        },
        this.magFilter = void 0 !== s ? s : ot,
        this.minFilter = void 0 !== a ? a : ot,
        this.flipY = !1,
        this.generateMipmaps = !1
    }
  }
  class la extends Se {
    constructor(t, e) {
      super();
      const i = this;
      let n = null
        , r = 1
        , o = null
        , s = "local-floor"
        , a = null
        , l = null
        , h = null
        , c = null
        , u = null
        , p = null;
      const d = e.getContextAttributes();
      let f = null
        , g = null;
      const m = []
        , y = []
        , v = new mr;
      v.layers.enable(1),
        v.viewport = new li;
      const A = new mr;
      A.layers.enable(2),
        A.viewport = new li;
      const b = [v, A]
        , x = new na;
      x.layers.enable(1),
        x.layers.enable(2);
      let I = null
        , C = null;
      function w(t) {
        const e = y.indexOf(t.inputSource);
        if (-1 === e)
          return;
        const i = m[e];
        void 0 !== i && i.dispatchEvent({
          type: t.type,
          data: t.inputSource
        })
      }
      function _() {
        n.removeEventListener("select", w),
          n.removeEventListener("selectstart", w),
          n.removeEventListener("selectend", w),
          n.removeEventListener("squeeze", w),
          n.removeEventListener("squeezestart", w),
          n.removeEventListener("squeezeend", w),
          n.removeEventListener("end", _),
          n.removeEventListener("inputsourceschange", S);
        for (let t = 0; t < m.length; t++) {
          const e = y[t];
          null !== e && (y[t] = null,
            m[t].disconnect(e))
        }
        I = null,
          C = null,
          t.setRenderTarget(f),
          u = null,
          c = null,
          h = null,
          n = null,
          g = null,
          R.stop(),
          i.isPresenting = !1,
          i.dispatchEvent({
            type: "sessionend"
          })
      }
      function S(t) {
        for (let e = 0; e < t.removed.length; e++) {
          const i = t.removed[e]
            , n = y.indexOf(i);
          n >= 0 && (y[n] = null,
            m[n].dispatchEvent({
              type: "disconnected",
              data: i
            }))
        }
        for (let e = 0; e < t.added.length; e++) {
          const i = t.added[e];
          let n = y.indexOf(i);
          if (-1 === n) {
            for (let t = 0; t < m.length; t++) {
              if (t >= y.length) {
                y.push(i),
                  n = t;
                break
              }
              if (null === y[t]) {
                y[t] = i,
                  n = t;
                break
              }
            }
            if (-1 === n)
              break
          }
          const r = m[n];
          r && r.dispatchEvent({
            type: "connected",
            data: i
          })
        }
      }
      this.cameraAutoUpdate = !0,
        this.enabled = !1,
        this.isPresenting = !1,
        this.getController = function (t) {
          let e = m[t];
          return void 0 === e && (e = new sa,
            m[t] = e),
            e.getTargetRaySpace()
        }
        ,
        this.getControllerGrip = function (t) {
          let e = m[t];
          return void 0 === e && (e = new sa,
            m[t] = e),
            e.getGripSpace()
        }
        ,
        this.getHand = function (t) {
          let e = m[t];
          return void 0 === e && (e = new sa,
            m[t] = e),
            e.getHandSpace()
        }
        ,
        this.setFramebufferScaleFactor = function (t) {
          r = t,
            !0 === i.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
        }
        ,
        this.setReferenceSpaceType = function (t) {
          s = t,
            !0 === i.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
        }
        ,
        this.getReferenceSpace = function () {
          return a || o
        }
        ,
        this.setReferenceSpace = function (t) {
          a = t
        }
        ,
        this.getBaseLayer = function () {
          return null !== c ? c : u
        }
        ,
        this.getBinding = function () {
          return h
        }
        ,
        this.getFrame = function () {
          return p
        }
        ,
        this.getSession = function () {
          return n
        }
        ,
        this.setSession = async function (l) {
          if (n = l,
            null !== n) {
            if (f = t.getRenderTarget(),
              n.addEventListener("select", w),
              n.addEventListener("selectstart", w),
              n.addEventListener("selectend", w),
              n.addEventListener("squeeze", w),
              n.addEventListener("squeezestart", w),
              n.addEventListener("squeezeend", w),
              n.addEventListener("end", _),
              n.addEventListener("inputsourceschange", S),
              !0 !== d.xrCompatible && await e.makeXRCompatible(),
              void 0 === n.renderState.layers || !1 === t.capabilities.isWebGL2) {
              const i = {
                antialias: void 0 !== n.renderState.layers || d.antialias,
                alpha: d.alpha,
                depth: d.depth,
                stencil: d.stencil,
                framebufferScaleFactor: r
              };
              u = new XRWebGLLayer(n, e, i),
                n.updateRenderState({
                  baseLayer: u
                }),
                g = new hi(u.framebufferWidth, u.framebufferHeight, {
                  format: wt,
                  type: ut,
                  encoding: t.outputEncoding
                })
            } else {
              let i = null
                , o = null
                , s = null;
              d.depth && (s = d.stencil ? 35056 : 33190,
                i = d.stencil ? Tt : Mt,
                o = d.stencil ? xt : mt);
              const a = {
                colorFormat: 32856,
                depthFormat: s,
                scaleFactor: r
              };
              h = new XRWebGLBinding(n, e),
                c = h.createProjectionLayer(a),
                n.updateRenderState({
                  layers: [c]
                }),
                g = new hi(c.textureWidth, c.textureHeight, {
                  format: wt,
                  type: ut,
                  depthTexture: new aa(c.textureWidth, c.textureHeight, o, void 0, void 0, void 0, void 0, void 0, void 0, i),
                  stencilBuffer: d.stencil,
                  encoding: t.outputEncoding,
                  samples: d.antialias ? 4 : 0
                });
              t.properties.get(g).__ignoreDepthValues = c.ignoreDepthValues
            }
            g.isXRRenderTarget = !0,
              this.setFoveation(1),
              a = null,
              o = await n.requestReferenceSpace(s),
              R.setContext(n),
              R.start(),
              i.isPresenting = !0,
              i.dispatchEvent({
                type: "sessionstart"
              })
          }
        }
        ;
      const M = new di
        , T = new di;
      function E(t, e) {
        null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
          t.matrixWorldInverse.copy(t.matrixWorld).invert()
      }
      this.updateCamera = function (t) {
        if (null === n)
          return;
        x.near = A.near = v.near = t.near,
          x.far = A.far = v.far = t.far,
          I === x.near && C === x.far || (n.updateRenderState({
            depthNear: x.near,
            depthFar: x.far
          }),
            I = x.near,
            C = x.far);
        const e = t.parent
          , i = x.cameras;
        E(x, e);
        for (let t = 0; t < i.length; t++)
          E(i[t], e);
        x.matrixWorld.decompose(x.position, x.quaternion, x.scale),
          t.position.copy(x.position),
          t.quaternion.copy(x.quaternion),
          t.scale.copy(x.scale),
          t.matrix.copy(x.matrix),
          t.matrixWorld.copy(x.matrixWorld);
        const r = t.children;
        for (let t = 0, e = r.length; t < e; t++)
          r[t].updateMatrixWorld(!0);
        2 === i.length ? function (t, e, i) {
          M.setFromMatrixPosition(e.matrixWorld),
            T.setFromMatrixPosition(i.matrixWorld);
          const n = M.distanceTo(T)
            , r = e.projectionMatrix.elements
            , o = i.projectionMatrix.elements
            , s = r[14] / (r[10] - 1)
            , a = r[14] / (r[10] + 1)
            , l = (r[9] + 1) / r[5]
            , h = (r[9] - 1) / r[5]
            , c = (r[8] - 1) / r[0]
            , u = (o[8] + 1) / o[0]
            , p = s * c
            , d = s * u
            , f = n / (-c + u)
            , g = f * -c;
          e.matrixWorld.decompose(t.position, t.quaternion, t.scale),
            t.translateX(g),
            t.translateZ(f),
            t.matrixWorld.compose(t.position, t.quaternion, t.scale),
            t.matrixWorldInverse.copy(t.matrixWorld).invert();
          const m = s + f
            , y = a + f
            , v = p - g
            , A = d + (n - g)
            , b = l * a / y * m
            , x = h * a / y * m;
          t.projectionMatrix.makePerspective(v, A, b, x, m, y)
        }(x, v, A) : x.projectionMatrix.copy(v.projectionMatrix)
      }
        ,
        this.getCamera = function () {
          return x
        }
        ,
        this.getFoveation = function () {
          return null !== c ? c.fixedFoveation : null !== u ? u.fixedFoveation : void 0
        }
        ,
        this.setFoveation = function (t) {
          null !== c && (c.fixedFoveation = t),
            null !== u && void 0 !== u.fixedFoveation && (u.fixedFoveation = t)
        }
        ;
      let k = null;
      const R = new Tr;
      R.setAnimationLoop((function (e, i) {
        if (l = i.getViewerPose(a || o),
          p = i,
          null !== l) {
          const e = l.views;
          null !== u && (t.setRenderTargetFramebuffer(g, u.framebuffer),
            t.setRenderTarget(g));
          let i = !1;
          e.length !== x.cameras.length && (x.cameras.length = 0,
            i = !0);
          for (let n = 0; n < e.length; n++) {
            const r = e[n];
            let o = null;
            if (null !== u)
              o = u.getViewport(r);
            else {
              const e = h.getViewSubImage(c, r);
              o = e.viewport,
                0 === n && (t.setRenderTargetTextures(g, e.colorTexture, c.ignoreDepthValues ? void 0 : e.depthStencilTexture),
                  t.setRenderTarget(g))
            }
            let s = b[n];
            void 0 === s && (s = new mr,
              s.layers.enable(n),
              s.viewport = new li,
              b[n] = s),
              s.matrix.fromArray(r.transform.matrix),
              s.projectionMatrix.fromArray(r.projectionMatrix),
              s.viewport.set(o.x, o.y, o.width, o.height),
              0 === n && x.matrix.copy(s.matrix),
              !0 === i && x.cameras.push(s)
          }
        }
        for (let t = 0; t < m.length; t++) {
          const e = y[t]
            , n = m[t];
          null !== e && void 0 !== n && n.update(e, i, a || o)
        }
        k && k(e, i),
          p = null
      }
      )),
        this.setAnimationLoop = function (t) {
          k = t
        }
        ,
        this.dispose = function () { }
    }
  }
  function ha(t, e) {
    function i(i, n) {
      i.opacity.value = n.opacity,
        n.color && i.diffuse.value.copy(n.color),
        n.emissive && i.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity),
        n.map && (i.map.value = n.map),
        n.alphaMap && (i.alphaMap.value = n.alphaMap),
        n.bumpMap && (i.bumpMap.value = n.bumpMap,
          i.bumpScale.value = n.bumpScale,
          n.side === h && (i.bumpScale.value *= -1)),
        n.displacementMap && (i.displacementMap.value = n.displacementMap,
          i.displacementScale.value = n.displacementScale,
          i.displacementBias.value = n.displacementBias),
        n.emissiveMap && (i.emissiveMap.value = n.emissiveMap),
        n.normalMap && (i.normalMap.value = n.normalMap,
          i.normalScale.value.copy(n.normalScale),
          n.side === h && i.normalScale.value.negate()),
        n.specularMap && (i.specularMap.value = n.specularMap),
        n.alphaTest > 0 && (i.alphaTest.value = n.alphaTest);
      const r = e.get(n).envMap;
      if (r && (i.envMap.value = r,
        i.flipEnvMap.value = r.isCubeTexture && !1 === r.isRenderTargetTexture ? -1 : 1,
        i.reflectivity.value = n.reflectivity,
        i.ior.value = n.ior,
        i.refractionRatio.value = n.refractionRatio),
        n.lightMap) {
        i.lightMap.value = n.lightMap;
        const e = !0 !== t.physicallyCorrectLights ? Math.PI : 1;
        i.lightMapIntensity.value = n.lightMapIntensity * e
      }
      let o, s;
      n.aoMap && (i.aoMap.value = n.aoMap,
        i.aoMapIntensity.value = n.aoMapIntensity),
        n.map ? o = n.map : n.specularMap ? o = n.specularMap : n.displacementMap ? o = n.displacementMap : n.normalMap ? o = n.normalMap : n.bumpMap ? o = n.bumpMap : n.roughnessMap ? o = n.roughnessMap : n.metalnessMap ? o = n.metalnessMap : n.alphaMap ? o = n.alphaMap : n.emissiveMap ? o = n.emissiveMap : n.clearcoatMap ? o = n.clearcoatMap : n.clearcoatNormalMap ? o = n.clearcoatNormalMap : n.clearcoatRoughnessMap ? o = n.clearcoatRoughnessMap : n.iridescenceMap ? o = n.iridescenceMap : n.iridescenceThicknessMap ? o = n.iridescenceThicknessMap : n.specularIntensityMap ? o = n.specularIntensityMap : n.specularColorMap ? o = n.specularColorMap : n.transmissionMap ? o = n.transmissionMap : n.thicknessMap ? o = n.thicknessMap : n.sheenColorMap ? o = n.sheenColorMap : n.sheenRoughnessMap && (o = n.sheenRoughnessMap),
        void 0 !== o && (o.isWebGLRenderTarget && (o = o.texture),
          !0 === o.matrixAutoUpdate && o.updateMatrix(),
          i.uvTransform.value.copy(o.matrix)),
        n.aoMap ? s = n.aoMap : n.lightMap && (s = n.lightMap),
        void 0 !== s && (s.isWebGLRenderTarget && (s = s.texture),
          !0 === s.matrixAutoUpdate && s.updateMatrix(),
          i.uv2Transform.value.copy(s.matrix))
    }
    return {
      refreshFogUniforms: function (t, e) {
        t.fogColor.value.copy(e.color),
          e.isFog ? (t.fogNear.value = e.near,
            t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
      },
      refreshMaterialUniforms: function (t, n, r, o, s) {
        n.isMeshBasicMaterial || n.isMeshLambertMaterial ? i(t, n) : n.isMeshToonMaterial ? (i(t, n),
          function (t, e) {
            e.gradientMap && (t.gradientMap.value = e.gradientMap)
          }(t, n)) : n.isMeshPhongMaterial ? (i(t, n),
            function (t, e) {
              t.specular.value.copy(e.specular),
                t.shininess.value = Math.max(e.shininess, 1e-4)
            }(t, n)) : n.isMeshStandardMaterial ? (i(t, n),
              function (t, i) {
                t.roughness.value = i.roughness,
                  t.metalness.value = i.metalness,
                  i.roughnessMap && (t.roughnessMap.value = i.roughnessMap);
                i.metalnessMap && (t.metalnessMap.value = i.metalnessMap);
                const n = e.get(i).envMap;
                n && (t.envMapIntensity.value = i.envMapIntensity)
              }(t, n),
              n.isMeshPhysicalMaterial && function (t, e, i) {
                t.ior.value = e.ior,
                  e.sheen > 0 && (t.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen),
                    t.sheenRoughness.value = e.sheenRoughness,
                    e.sheenColorMap && (t.sheenColorMap.value = e.sheenColorMap),
                    e.sheenRoughnessMap && (t.sheenRoughnessMap.value = e.sheenRoughnessMap));
                e.clearcoat > 0 && (t.clearcoat.value = e.clearcoat,
                  t.clearcoatRoughness.value = e.clearcoatRoughness,
                  e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap),
                  e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap),
                  e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),
                    t.clearcoatNormalMap.value = e.clearcoatNormalMap,
                    e.side === h && t.clearcoatNormalScale.value.negate()));
                e.iridescence > 0 && (t.iridescence.value = e.iridescence,
                  t.iridescenceIOR.value = e.iridescenceIOR,
                  t.iridescenceThicknessMinimum.value = e.iridescenceThicknessRange[0],
                  t.iridescenceThicknessMaximum.value = e.iridescenceThicknessRange[1],
                  e.iridescenceMap && (t.iridescenceMap.value = e.iridescenceMap),
                  e.iridescenceThicknessMap && (t.iridescenceThicknessMap.value = e.iridescenceThicknessMap));
                e.transmission > 0 && (t.transmission.value = e.transmission,
                  t.transmissionSamplerMap.value = i.texture,
                  t.transmissionSamplerSize.value.set(i.width, i.height),
                  e.transmissionMap && (t.transmissionMap.value = e.transmissionMap),
                  t.thickness.value = e.thickness,
                  e.thicknessMap && (t.thicknessMap.value = e.thicknessMap),
                  t.attenuationDistance.value = e.attenuationDistance,
                  t.attenuationColor.value.copy(e.attenuationColor));
                t.specularIntensity.value = e.specularIntensity,
                  t.specularColor.value.copy(e.specularColor),
                  e.specularIntensityMap && (t.specularIntensityMap.value = e.specularIntensityMap);
                e.specularColorMap && (t.specularColorMap.value = e.specularColorMap)
              }(t, n, s)) : n.isMeshMatcapMaterial ? (i(t, n),
                function (t, e) {
                  e.matcap && (t.matcap.value = e.matcap)
                }(t, n)) : n.isMeshDepthMaterial ? i(t, n) : n.isMeshDistanceMaterial ? (i(t, n),
                  function (t, e) {
                    t.referencePosition.value.copy(e.referencePosition),
                      t.nearDistance.value = e.nearDistance,
                      t.farDistance.value = e.farDistance
                  }(t, n)) : n.isMeshNormalMaterial ? i(t, n) : n.isLineBasicMaterial ? (function (t, e) {
                    t.diffuse.value.copy(e.color),
                      t.opacity.value = e.opacity
                  }(t, n),
                    n.isLineDashedMaterial && function (t, e) {
                      t.dashSize.value = e.dashSize,
                        t.totalSize.value = e.dashSize + e.gapSize,
                        t.scale.value = e.scale
                    }(t, n)) : n.isPointsMaterial ? function (t, e, i, n) {
                      t.diffuse.value.copy(e.color),
                        t.opacity.value = e.opacity,
                        t.size.value = e.size * i,
                        t.scale.value = .5 * n,
                        e.map && (t.map.value = e.map);
                      e.alphaMap && (t.alphaMap.value = e.alphaMap);
                      e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest);
                      let r;
                      e.map ? r = e.map : e.alphaMap && (r = e.alphaMap);
                      void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(),
                        t.uvTransform.value.copy(r.matrix))
                    }(t, n, r, o) : n.isSpriteMaterial ? function (t, e) {
                      t.diffuse.value.copy(e.color),
                        t.opacity.value = e.opacity,
                        t.rotation.value = e.rotation,
                        e.map && (t.map.value = e.map);
                      e.alphaMap && (t.alphaMap.value = e.alphaMap);
                      e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest);
                      let i;
                      e.map ? i = e.map : e.alphaMap && (i = e.alphaMap);
                      void 0 !== i && (!0 === i.matrixAutoUpdate && i.updateMatrix(),
                        t.uvTransform.value.copy(i.matrix))
                    }(t, n) : n.isShadowMaterial ? (t.color.value.copy(n.color),
                      t.opacity.value = n.opacity) : n.isShaderMaterial && (n.uniformsNeedUpdate = !1)
      }
    }
  }
  function ca(t = {}) {
    this.isWebGLRenderer = !0;
    const i = void 0 !== t.canvas ? t.canvas : function () {
      const t = We("canvas");
      return t.style.display = "block",
        t
    }()
      , n = void 0 !== t.context ? t.context : null
      , r = void 0 === t.depth || t.depth
      , o = void 0 === t.stencil || t.stencil
      , s = void 0 !== t.antialias && t.antialias
      , a = void 0 === t.premultipliedAlpha || t.premultipliedAlpha
      , u = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer
      , p = void 0 !== t.powerPreference ? t.powerPreference : "default"
      , d = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat;
    let f;
    f = null !== n ? n.getContextAttributes().alpha : void 0 !== t.alpha && t.alpha;
    let g = null
      , m = null;
    const y = []
      , v = [];
    this.domElement = i,
      this.debug = {
        checkShaderErrors: !0
      },
      this.autoClear = !0,
      this.autoClearColor = !0,
      this.autoClearDepth = !0,
      this.autoClearStencil = !0,
      this.sortObjects = !0,
      this.clippingPlanes = [],
      this.localClippingEnabled = !1,
      this.outputEncoding = fe,
      this.physicallyCorrectLights = !1,
      this.toneMapping = W,
      this.toneMappingExposure = 1,
      Object.defineProperties(this, {
        gammaFactor: {
          get: function () {
            return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."),
              2
          },
          set: function () {
            console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")
          }
        }
      });
    const A = this;
    let b = !1
      , x = 0
      , I = 0
      , C = null
      , w = -1
      , _ = null;
    const S = new li
      , M = new li;
    let T = null
      , E = i.width
      , k = i.height
      , R = 1
      , L = null
      , P = null;
    const z = new li(0, 0, E, k)
      , O = new li(0, 0, E, k);
    let D = !1;
    const U = new Mr;
    let N = !1
      , F = !1
      , B = null;
    const j = new Wi
      , V = new Fe
      , G = new di
      , J = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0
      };
    function H() {
      return null === C ? R : 1
    }
    let Z, Q, K, Y, q, X, $, tt, et, it, nt, rt, ot, st, at, lt, ht, pt, dt, ft, gt, mt, At, bt = n;
    function xt(t, e) {
      for (let n = 0; n < t.length; n++) {
        const r = t[n]
          , o = i.getContext(r, e);
        if (null !== o)
          return o
      }
      return null
    }
    try {
      const t = {
        alpha: !0,
        depth: r,
        stencil: o,
        antialias: s,
        premultipliedAlpha: a,
        preserveDrawingBuffer: u,
        powerPreference: p,
        failIfMajorPerformanceCaveat: d
      };
      if ("setAttribute" in i && i.setAttribute("data-engine", `three.js r${e}`),
        i.addEventListener("webglcontextlost", _t, !1),
        i.addEventListener("webglcontextrestored", St, !1),
        i.addEventListener("webglcontextcreationerror", Mt, !1),
        null === bt) {
        const e = ["webgl2", "webgl", "experimental-webgl"];
        if (!0 === A.isWebGL1Renderer && e.shift(),
          bt = xt(e, t),
          null === bt)
          throw xt(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
      }
      void 0 === bt.getShaderPrecisionFormat && (bt.getShaderPrecisionFormat = function () {
        return {
          rangeMin: 1,
          rangeMax: 1,
          precision: 1
        }
      }
      )
    } catch (t) {
      throw console.error("THREE.WebGLRenderer: " + t.message),
      t
    }
    function It() {
      Z = new io(bt),
        Q = new Ur(bt, Z, t),
        Z.init(Q),
        mt = new ia(bt, Z, Q),
        K = new ta(bt, Z, Q),
        Y = new oo,
        q = new Ns,
        X = new ea(bt, Z, K, q, Q, mt, Y),
        $ = new Fr(A),
        tt = new eo(A),
        et = new Er(bt, Q),
        At = new Or(bt, Z, et, Q),
        it = new no(bt, et, Y, At),
        nt = new co(bt, it, et, Y),
        dt = new ho(bt, Q, X),
        lt = new Nr(q),
        rt = new Us(A, $, tt, Z, Q, At, lt),
        ot = new ha(A, q),
        st = new Vs,
        at = new Qs(Z, Q),
        pt = new zr(A, $, K, nt, f, a),
        ht = new $s(A, nt, Q),
        ft = new Dr(bt, Z, Y, Q),
        gt = new ro(bt, Z, Y, Q),
        Y.programs = rt.programs,
        A.capabilities = Q,
        A.extensions = Z,
        A.properties = q,
        A.renderLists = st,
        A.shadowMap = ht,
        A.state = K,
        A.info = Y
    }
    It();
    const Ct = new la(A, bt);
    function _t(t) {
      t.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        b = !0
    }
    function St() {
      console.log("THREE.WebGLRenderer: Context Restored."),
        b = !1;
      const t = Y.autoReset
        , e = ht.enabled
        , i = ht.autoUpdate
        , n = ht.needsUpdate
        , r = ht.type;
      It(),
        Y.autoReset = t,
        ht.enabled = e,
        ht.autoUpdate = i,
        ht.needsUpdate = n,
        ht.type = r
    }
    function Mt(t) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", t.statusMessage)
    }
    function Tt(t) {
      const e = t.target;
      e.removeEventListener("dispose", Tt),
        function (t) {
          (function (t) {
            const e = q.get(t).programs;
            void 0 !== e && (e.forEach((function (t) {
              rt.releaseProgram(t)
            }
            )),
              t.isShaderMaterial && rt.releaseShaderCache(t))
          }
          )(t),
            q.remove(t)
        }(e)
    }
    this.xr = Ct,
      this.getContext = function () {
        return bt
      }
      ,
      this.getContextAttributes = function () {
        return bt.getContextAttributes()
      }
      ,
      this.forceContextLoss = function () {
        const t = Z.get("WEBGL_lose_context");
        t && t.loseContext()
      }
      ,
      this.forceContextRestore = function () {
        const t = Z.get("WEBGL_lose_context");
        t && t.restoreContext()
      }
      ,
      this.getPixelRatio = function () {
        return R
      }
      ,
      this.setPixelRatio = function (t) {
        void 0 !== t && (R = t,
          this.setSize(E, k, !1))
      }
      ,
      this.getSize = function (t) {
        return t.set(E, k)
      }
      ,
      this.setSize = function (t, e, n) {
        Ct.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (E = t,
          k = e,
          i.width = Math.floor(t * R),
          i.height = Math.floor(e * R),
          !1 !== n && (i.style.width = t + "px",
            i.style.height = e + "px"),
          this.setViewport(0, 0, t, e))
      }
      ,
      this.getDrawingBufferSize = function (t) {
        return t.set(E * R, k * R).floor()
      }
      ,
      this.setDrawingBufferSize = function (t, e, n) {
        E = t,
          k = e,
          R = n,
          i.width = Math.floor(t * n),
          i.height = Math.floor(e * n),
          this.setViewport(0, 0, t, e)
      }
      ,
      this.getCurrentViewport = function (t) {
        return t.copy(S)
      }
      ,
      this.getViewport = function (t) {
        return t.copy(z)
      }
      ,
      this.setViewport = function (t, e, i, n) {
        t.isVector4 ? z.set(t.x, t.y, t.z, t.w) : z.set(t, e, i, n),
          K.viewport(S.copy(z).multiplyScalar(R).floor())
      }
      ,
      this.getScissor = function (t) {
        return t.copy(O)
      }
      ,
      this.setScissor = function (t, e, i, n) {
        t.isVector4 ? O.set(t.x, t.y, t.z, t.w) : O.set(t, e, i, n),
          K.scissor(M.copy(O).multiplyScalar(R).floor())
      }
      ,
      this.getScissorTest = function () {
        return D
      }
      ,
      this.setScissorTest = function (t) {
        K.setScissorTest(D = t)
      }
      ,
      this.setOpaqueSort = function (t) {
        L = t
      }
      ,
      this.setTransparentSort = function (t) {
        P = t
      }
      ,
      this.getClearColor = function (t) {
        return t.copy(pt.getClearColor())
      }
      ,
      this.setClearColor = function () {
        pt.setClearColor.apply(pt, arguments)
      }
      ,
      this.getClearAlpha = function () {
        return pt.getClearAlpha()
      }
      ,
      this.setClearAlpha = function () {
        pt.setClearAlpha.apply(pt, arguments)
      }
      ,
      this.clear = function (t = !0, e = !0, i = !0) {
        let n = 0;
        t && (n |= 16384),
          e && (n |= 256),
          i && (n |= 1024),
          bt.clear(n)
      }
      ,
      this.clearColor = function () {
        this.clear(!0, !1, !1)
      }
      ,
      this.clearDepth = function () {
        this.clear(!1, !0, !1)
      }
      ,
      this.clearStencil = function () {
        this.clear(!1, !1, !0)
      }
      ,
      this.dispose = function () {
        i.removeEventListener("webglcontextlost", _t, !1),
          i.removeEventListener("webglcontextrestored", St, !1),
          i.removeEventListener("webglcontextcreationerror", Mt, !1),
          st.dispose(),
          at.dispose(),
          q.dispose(),
          $.dispose(),
          tt.dispose(),
          nt.dispose(),
          At.dispose(),
          rt.dispose(),
          Ct.dispose(),
          Ct.removeEventListener("sessionstart", kt),
          Ct.removeEventListener("sessionend", Rt),
          B && (B.dispose(),
            B = null),
          Lt.stop()
      }
      ,
      this.renderBufferDirect = function (t, e, i, n, r, o) {
        null === e && (e = J);
        const s = r.isMesh && r.matrixWorld.determinant() < 0
          , a = function (t, e, i, n, r) {
            !0 !== e.isScene && (e = J);
            X.resetTextureUnits();
            const o = e.fog
              , s = n.isMeshStandardMaterial ? e.environment : null
              , a = null === C ? A.outputEncoding : !0 === C.isXRRenderTarget ? C.texture.encoding : fe
              , l = (n.isMeshStandardMaterial ? tt : $).get(n.envMap || s)
              , h = !0 === n.vertexColors && !!i.attributes.color && 4 === i.attributes.color.itemSize
              , c = !!n.normalMap && !!i.attributes.tangent
              , u = !!i.morphAttributes.position
              , p = !!i.morphAttributes.normal
              , d = !!i.morphAttributes.color
              , f = n.toneMapped ? A.toneMapping : W
              , g = i.morphAttributes.position || i.morphAttributes.normal || i.morphAttributes.color
              , y = void 0 !== g ? g.length : 0
              , v = q.get(n)
              , b = m.state.lights;
            if (!0 === N && (!0 === F || t !== _)) {
              const e = t === _ && n.id === w;
              lt.setState(n, t, e)
            }
            let x = !1;
            n.version === v.__version ? v.needsLights && v.lightsStateVersion !== b.state.version || v.outputEncoding !== a || r.isInstancedMesh && !1 === v.instancing ? x = !0 : r.isInstancedMesh || !0 !== v.instancing ? r.isSkinnedMesh && !1 === v.skinning ? x = !0 : r.isSkinnedMesh || !0 !== v.skinning ? v.envMap !== l || !0 === n.fog && v.fog !== o ? x = !0 : void 0 === v.numClippingPlanes || v.numClippingPlanes === lt.numPlanes && v.numIntersection === lt.numIntersection ? (v.vertexAlphas !== h || v.vertexTangents !== c || v.morphTargets !== u || v.morphNormals !== p || v.morphColors !== d || v.toneMapping !== f || !0 === Q.isWebGL2 && v.morphTargetsCount !== y) && (x = !0) : x = !0 : x = !0 : x = !0 : (x = !0,
              v.__version = n.version);
            let I = v.currentProgram;
            !0 === x && (I = Ut(n, e, r));
            let S = !1
              , M = !1
              , T = !1;
            const E = I.getUniforms()
              , L = v.uniforms;
            K.useProgram(I.program) && (S = !0,
              M = !0,
              T = !0);
            n.id !== w && (w = n.id,
              M = !0);
            if (S || _ !== t) {
              if (E.setValue(bt, "projectionMatrix", t.projectionMatrix),
                Q.logarithmicDepthBuffer && E.setValue(bt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)),
                _ !== t && (_ = t,
                  M = !0,
                  T = !0),
                n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.envMap) {
                const e = E.map.cameraPosition;
                void 0 !== e && e.setValue(bt, G.setFromMatrixPosition(t.matrixWorld))
              }
              (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && E.setValue(bt, "isOrthographic", !0 === t.isOrthographicCamera),
                (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.isShadowMaterial || r.isSkinnedMesh) && E.setValue(bt, "viewMatrix", t.matrixWorldInverse)
            }
            if (r.isSkinnedMesh) {
              E.setOptional(bt, r, "bindMatrix"),
                E.setOptional(bt, r, "bindMatrixInverse");
              const t = r.skeleton;
              t && (Q.floatVertexTextures ? (null === t.boneTexture && t.computeBoneTexture(),
                E.setValue(bt, "boneTexture", t.boneTexture, X),
                E.setValue(bt, "boneTextureSize", t.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))
            }
            const P = i.morphAttributes;
            (void 0 !== P.position || void 0 !== P.normal || void 0 !== P.color && !0 === Q.isWebGL2) && dt.update(r, i, n, I);
            (M || v.receiveShadow !== r.receiveShadow) && (v.receiveShadow = r.receiveShadow,
              E.setValue(bt, "receiveShadow", r.receiveShadow));
            M && (E.setValue(bt, "toneMappingExposure", A.toneMappingExposure),
              v.needsLights && (O = T,
                (z = L).ambientLightColor.needsUpdate = O,
                z.lightProbe.needsUpdate = O,
                z.directionalLights.needsUpdate = O,
                z.directionalLightShadows.needsUpdate = O,
                z.pointLights.needsUpdate = O,
                z.pointLightShadows.needsUpdate = O,
                z.spotLights.needsUpdate = O,
                z.spotLightShadows.needsUpdate = O,
                z.rectAreaLights.needsUpdate = O,
                z.hemisphereLights.needsUpdate = O),
              o && !0 === n.fog && ot.refreshFogUniforms(L, o),
              ot.refreshMaterialUniforms(L, n, R, k, B),
              gs.upload(bt, v.uniformsList, L, X));
            var z, O;
            n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (gs.upload(bt, v.uniformsList, L, X),
              n.uniformsNeedUpdate = !1);
            n.isSpriteMaterial && E.setValue(bt, "center", r.center);
            return E.setValue(bt, "modelViewMatrix", r.modelViewMatrix),
              E.setValue(bt, "normalMatrix", r.normalMatrix),
              E.setValue(bt, "modelMatrix", r.matrixWorld),
              I
          }(t, e, i, n, r);
        K.setMaterial(n, s);
        let l = i.index;
        const h = i.attributes.position;
        if (null === l) {
          if (void 0 === h || 0 === h.count)
            return
        } else if (0 === l.count)
          return;
        let c, u = 1;
        !0 === n.wireframe && (l = it.getWireframeAttribute(i),
          u = 2),
          At.setup(r, n, a, i, l);
        let p = ft;
        null !== l && (c = et.get(l),
          p = gt,
          p.setIndex(c));
        const d = null !== l ? l.count : h.count
          , f = i.drawRange.start * u
          , g = i.drawRange.count * u
          , y = null !== o ? o.start * u : 0
          , v = null !== o ? o.count * u : 1 / 0
          , b = Math.max(f, y)
          , x = Math.min(d, f + g, y + v) - 1
          , I = Math.max(0, x - b + 1);
        if (0 !== I) {
          if (r.isMesh)
            !0 === n.wireframe ? (K.setLineWidth(n.wireframeLinewidth * H()),
              p.setMode(1)) : p.setMode(4);
          else if (r.isLine) {
            let t = n.linewidth;
            void 0 === t && (t = 1),
              K.setLineWidth(t * H()),
              r.isLineSegments ? p.setMode(1) : r.isLineLoop ? p.setMode(2) : p.setMode(3)
          } else
            r.isPoints ? p.setMode(0) : r.isSprite && p.setMode(4);
          if (r.isInstancedMesh)
            p.renderInstances(b, I, r.count);
          else if (i.isInstancedBufferGeometry) {
            const t = Math.min(i.instanceCount, i._maxInstanceCount);
            p.renderInstances(b, I, t)
          } else
            p.render(b, I)
        }
      }
      ,
      this.compile = function (t, e) {
        m = at.get(t),
          m.init(),
          v.push(m),
          t.traverseVisible((function (t) {
            t.isLight && t.layers.test(e.layers) && (m.pushLight(t),
              t.castShadow && m.pushShadow(t))
          }
          )),
          m.setupLights(A.physicallyCorrectLights),
          t.traverse((function (e) {
            const i = e.material;
            if (i)
              if (Array.isArray(i))
                for (let n = 0; n < i.length; n++) {
                  Ut(i[n], t, e)
                }
              else
                Ut(i, t, e)
          }
          )),
          v.pop(),
          m = null
      }
      ;
    let Et = null;
    function kt() {
      Lt.stop()
    }
    function Rt() {
      Lt.start()
    }
    const Lt = new Tr;
    function Pt(t, e, i, n) {
      if (!1 === t.visible)
        return;
      if (t.layers.test(e.layers))
        if (t.isGroup)
          i = t.renderOrder;
        else if (t.isLOD)
          !0 === t.autoUpdate && t.update(e);
        else if (t.isLight)
          m.pushLight(t),
            t.castShadow && m.pushShadow(t);
        else if (t.isSprite) {
          if (!t.frustumCulled || U.intersectsSprite(t)) {
            n && G.setFromMatrixPosition(t.matrixWorld).applyMatrix4(j);
            const e = nt.update(t)
              , r = t.material;
            r.visible && g.push(t, e, r, i, G.z, null)
          }
        } else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== Y.render.frame && (t.skeleton.update(),
          t.skeleton.frame = Y.render.frame),
          !t.frustumCulled || U.intersectsObject(t))) {
          n && G.setFromMatrixPosition(t.matrixWorld).applyMatrix4(j);
          const e = nt.update(t)
            , r = t.material;
          if (Array.isArray(r)) {
            const n = e.groups;
            for (let o = 0, s = n.length; o < s; o++) {
              const s = n[o]
                , a = r[s.materialIndex];
              a && a.visible && g.push(t, e, a, i, G.z, s)
            }
          } else
            r.visible && g.push(t, e, r, i, G.z, null)
        }
      const r = t.children;
      for (let t = 0, o = r.length; t < o; t++)
        Pt(r[t], e, i, n)
    }
    function zt(t, e, i, n) {
      const r = t.opaque
        , o = t.transmissive
        , a = t.transparent;
      m.setupLightsView(i),
        o.length > 0 && function (t, e, i) {
          const n = Q.isWebGL2;
          null === B && (B = new hi(1, 1, {
            generateMipmaps: !0,
            type: Z.has("EXT_color_buffer_half_float") ? vt : ut,
            minFilter: ct,
            samples: n && !0 === s ? 4 : 0
          }));
          A.getDrawingBufferSize(V),
            n ? B.setSize(V.x, V.y) : B.setSize(Ue(V.x), Ue(V.y));
          const r = A.getRenderTarget();
          A.setRenderTarget(B),
            A.clear();
          const o = A.toneMapping;
          A.toneMapping = W,
            Ot(t, e, i),
            A.toneMapping = o,
            X.updateMultisampleRenderTarget(B),
            X.updateRenderTargetMipmap(B),
            A.setRenderTarget(r)
        }(r, e, i),
        n && K.viewport(S.copy(n)),
        r.length > 0 && Ot(r, e, i),
        o.length > 0 && Ot(o, e, i),
        a.length > 0 && Ot(a, e, i),
        K.buffers.depth.setTest(!0),
        K.buffers.depth.setMask(!0),
        K.buffers.color.setMask(!0),
        K.setPolygonOffset(!1)
    }
    function Ot(t, e, i) {
      const n = !0 === e.isScene ? e.overrideMaterial : null;
      for (let r = 0, o = t.length; r < o; r++) {
        const o = t[r]
          , s = o.object
          , a = o.geometry
          , l = null === n ? o.material : n
          , h = o.group;
        s.layers.test(i.layers) && Dt(s, e, i, a, l, h)
      }
    }
    function Dt(t, e, i, n, r, o) {
      t.onBeforeRender(A, e, i, n, r, o),
        t.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, t.matrixWorld),
        t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
        r.onBeforeRender(A, e, i, n, t, o),
        !0 === r.transparent && r.side === c ? (r.side = h,
          r.needsUpdate = !0,
          A.renderBufferDirect(i, e, n, r, t, o),
          r.side = l,
          r.needsUpdate = !0,
          A.renderBufferDirect(i, e, n, r, t, o),
          r.side = c) : A.renderBufferDirect(i, e, n, r, t, o),
        t.onAfterRender(A, e, i, n, r, o)
    }
    function Ut(t, e, i) {
      !0 !== e.isScene && (e = J);
      const n = q.get(t)
        , r = m.state.lights
        , o = m.state.shadowsArray
        , s = r.state.version
        , a = rt.getParameters(t, r.state, o, e, i)
        , l = rt.getProgramCacheKey(a);
      let h = n.programs;
      n.environment = t.isMeshStandardMaterial ? e.environment : null,
        n.fog = e.fog,
        n.envMap = (t.isMeshStandardMaterial ? tt : $).get(t.envMap || n.environment),
        void 0 === h && (t.addEventListener("dispose", Tt),
          h = new Map,
          n.programs = h);
      let c = h.get(l);
      if (void 0 !== c) {
        if (n.currentProgram === c && n.lightsStateVersion === s)
          return Nt(t, a),
            c
      } else
        a.uniforms = rt.getUniforms(t),
          t.onBuild(i, a, A),
          t.onBeforeCompile(a, A),
          c = rt.acquireProgram(a, l),
          h.set(l, c),
          n.uniforms = a.uniforms;
      const u = n.uniforms;
      (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (u.clippingPlanes = lt.uniform),
        Nt(t, a),
        n.needsLights = function (t) {
          return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights
        }(t),
        n.lightsStateVersion = s,
        n.needsLights && (u.ambientLightColor.value = r.state.ambient,
          u.lightProbe.value = r.state.probe,
          u.directionalLights.value = r.state.directional,
          u.directionalLightShadows.value = r.state.directionalShadow,
          u.spotLights.value = r.state.spot,
          u.spotLightShadows.value = r.state.spotShadow,
          u.rectAreaLights.value = r.state.rectArea,
          u.ltc_1.value = r.state.rectAreaLTC1,
          u.ltc_2.value = r.state.rectAreaLTC2,
          u.pointLights.value = r.state.point,
          u.pointLightShadows.value = r.state.pointShadow,
          u.hemisphereLights.value = r.state.hemi,
          u.directionalShadowMap.value = r.state.directionalShadowMap,
          u.directionalShadowMatrix.value = r.state.directionalShadowMatrix,
          u.spotShadowMap.value = r.state.spotShadowMap,
          u.spotShadowMatrix.value = r.state.spotShadowMatrix,
          u.pointShadowMap.value = r.state.pointShadowMap,
          u.pointShadowMatrix.value = r.state.pointShadowMatrix);
      const p = c.getUniforms()
        , d = gs.seqWithValue(p.seq, u);
      return n.currentProgram = c,
        n.uniformsList = d,
        c
    }
    function Nt(t, e) {
      const i = q.get(t);
      i.outputEncoding = e.outputEncoding,
        i.instancing = e.instancing,
        i.skinning = e.skinning,
        i.morphTargets = e.morphTargets,
        i.morphNormals = e.morphNormals,
        i.morphColors = e.morphColors,
        i.morphTargetsCount = e.morphTargetsCount,
        i.numClippingPlanes = e.numClippingPlanes,
        i.numIntersection = e.numClipIntersection,
        i.vertexAlphas = e.vertexAlphas,
        i.vertexTangents = e.vertexTangents,
        i.toneMapping = e.toneMapping
    }
    Lt.setAnimationLoop((function (t) {
      Et && Et(t)
    }
    )),
      "undefined" != typeof self && Lt.setContext(self),
      this.setAnimationLoop = function (t) {
        Et = t,
          Ct.setAnimationLoop(t),
          null === t ? Lt.stop() : Lt.start()
      }
      ,
      Ct.addEventListener("sessionstart", kt),
      Ct.addEventListener("sessionend", Rt),
      this.render = function (t, e) {
        if (void 0 !== e && !0 !== e.isCamera)
          return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        if (!0 === b)
          return;
        !0 === t.autoUpdate && t.updateMatrixWorld(),
          null === e.parent && e.updateMatrixWorld(),
          !0 === Ct.enabled && !0 === Ct.isPresenting && (!0 === Ct.cameraAutoUpdate && Ct.updateCamera(e),
            e = Ct.getCamera()),
          !0 === t.isScene && t.onBeforeRender(A, t, e, C),
          m = at.get(t, v.length),
          m.init(),
          v.push(m),
          j.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
          U.setFromProjectionMatrix(j),
          F = this.localClippingEnabled,
          N = lt.init(this.clippingPlanes, F, e),
          g = st.get(t, y.length),
          g.init(),
          y.push(g),
          Pt(t, e, 0, A.sortObjects),
          g.finish(),
          !0 === A.sortObjects && g.sort(L, P),
          !0 === N && lt.beginShadows();
        const i = m.state.shadowsArray;
        if (ht.render(i, t, e),
          !0 === N && lt.endShadows(),
          !0 === this.info.autoReset && this.info.reset(),
          pt.render(g, t),
          m.setupLights(A.physicallyCorrectLights),
          e.isArrayCamera) {
          const i = e.cameras;
          for (let e = 0, n = i.length; e < n; e++) {
            const n = i[e];
            zt(g, t, n, n.viewport)
          }
        } else
          zt(g, t, e);
        null !== C && (X.updateMultisampleRenderTarget(C),
          X.updateRenderTargetMipmap(C)),
          !0 === t.isScene && t.onAfterRender(A, t, e),
          At.resetDefaultState(),
          w = -1,
          _ = null,
          v.pop(),
          m = v.length > 0 ? v[v.length - 1] : null,
          y.pop(),
          g = y.length > 0 ? y[y.length - 1] : null
      }
      ,
      this.getActiveCubeFace = function () {
        return x
      }
      ,
      this.getActiveMipmapLevel = function () {
        return I
      }
      ,
      this.getRenderTarget = function () {
        return C
      }
      ,
      this.setRenderTargetTextures = function (t, e, i) {
        q.get(t.texture).__webglTexture = e,
          q.get(t.depthTexture).__webglTexture = i;
        const n = q.get(t);
        n.__hasExternalTextures = !0,
          n.__hasExternalTextures && (n.__autoAllocateDepthBuffer = void 0 === i,
            n.__autoAllocateDepthBuffer || !0 === Z.has("WEBGL_multisampled_render_to_texture") && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),
              n.__useRenderToTexture = !1))
      }
      ,
      this.setRenderTargetFramebuffer = function (t, e) {
        const i = q.get(t);
        i.__webglFramebuffer = e,
          i.__useDefaultFramebuffer = void 0 === e
      }
      ,
      this.setRenderTarget = function (t, e = 0, i = 0) {
        C = t,
          x = e,
          I = i;
        let n = !0;
        if (t) {
          const e = q.get(t);
          void 0 !== e.__useDefaultFramebuffer ? (K.bindFramebuffer(36160, null),
            n = !1) : void 0 === e.__webglFramebuffer ? X.setupRenderTarget(t) : e.__hasExternalTextures && X.rebindTextures(t, q.get(t.texture).__webglTexture, q.get(t.depthTexture).__webglTexture)
        }
        let r = null
          , o = !1
          , s = !1;
        if (t) {
          const i = t.texture;
          (i.isData3DTexture || i.isDataArrayTexture) && (s = !0);
          const n = q.get(t).__webglFramebuffer;
          t.isWebGLCubeRenderTarget ? (r = n[e],
            o = !0) : r = Q.isWebGL2 && t.samples > 0 && !1 === X.useMultisampledRTT(t) ? q.get(t).__webglMultisampledFramebuffer : n,
            S.copy(t.viewport),
            M.copy(t.scissor),
            T = t.scissorTest
        } else
          S.copy(z).multiplyScalar(R).floor(),
            M.copy(O).multiplyScalar(R).floor(),
            T = D;
        if (K.bindFramebuffer(36160, r) && Q.drawBuffers && n && K.drawBuffers(t, r),
          K.viewport(S),
          K.scissor(M),
          K.setScissorTest(T),
          o) {
          const n = q.get(t.texture);
          bt.framebufferTexture2D(36160, 36064, 34069 + e, n.__webglTexture, i)
        } else if (s) {
          const n = q.get(t.texture)
            , r = e || 0;
          bt.framebufferTextureLayer(36160, 36064, n.__webglTexture, i || 0, r)
        }
        w = -1
      }
      ,
      this.readRenderTargetPixels = function (t, e, i, n, r, o, s) {
        if (!t || !t.isWebGLRenderTarget)
          return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        let a = q.get(t).__webglFramebuffer;
        if (t.isWebGLCubeRenderTarget && void 0 !== s && (a = a[s]),
          a) {
          K.bindFramebuffer(36160, a);
          try {
            const s = t.texture
              , a = s.format
              , l = s.type;
            if (a !== wt && mt.convert(a) !== bt.getParameter(35739))
              return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            const h = l === vt && (Z.has("EXT_color_buffer_half_float") || Q.isWebGL2 && Z.has("EXT_color_buffer_float"));
            if (!(l === ut || mt.convert(l) === bt.getParameter(35738) || l === yt && (Q.isWebGL2 || Z.has("OES_texture_float") || Z.has("WEBGL_color_buffer_float")) || h))
              return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            e >= 0 && e <= t.width - n && i >= 0 && i <= t.height - r && bt.readPixels(e, i, n, r, mt.convert(a), mt.convert(l), o)
          } finally {
            const t = null !== C ? q.get(C).__webglFramebuffer : null;
            K.bindFramebuffer(36160, t)
          }
        }
      }
      ,
      this.copyFramebufferToTexture = function (t, e, i = 0) {
        const n = Math.pow(2, -i)
          , r = Math.floor(e.image.width * n)
          , o = Math.floor(e.image.height * n);
        X.setTexture2D(e, 0),
          bt.copyTexSubImage2D(3553, i, 0, 0, t.x, t.y, r, o),
          K.unbindTexture()
      }
      ,
      this.copyTextureToTexture = function (t, e, i, n = 0) {
        const r = e.image.width
          , o = e.image.height
          , s = mt.convert(i.format)
          , a = mt.convert(i.type);
        X.setTexture2D(i, 0),
          bt.pixelStorei(37440, i.flipY),
          bt.pixelStorei(37441, i.premultiplyAlpha),
          bt.pixelStorei(3317, i.unpackAlignment),
          e.isDataTexture ? bt.texSubImage2D(3553, n, t.x, t.y, r, o, s, a, e.image.data) : e.isCompressedTexture ? bt.compressedTexSubImage2D(3553, n, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, s, e.mipmaps[0].data) : bt.texSubImage2D(3553, n, t.x, t.y, s, a, e.image),
          0 === n && i.generateMipmaps && bt.generateMipmap(3553),
          K.unbindTexture()
      }
      ,
      this.copyTextureToTexture3D = function (t, e, i, n, r = 0) {
        if (A.isWebGL1Renderer)
          return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
        const o = t.max.x - t.min.x + 1
          , s = t.max.y - t.min.y + 1
          , a = t.max.z - t.min.z + 1
          , l = mt.convert(n.format)
          , h = mt.convert(n.type);
        let c;
        if (n.isData3DTexture)
          X.setTexture3D(n, 0),
            c = 32879;
        else {
          if (!n.isDataArrayTexture)
            return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
          X.setTexture2DArray(n, 0),
            c = 35866
        }
        bt.pixelStorei(37440, n.flipY),
          bt.pixelStorei(37441, n.premultiplyAlpha),
          bt.pixelStorei(3317, n.unpackAlignment);
        const u = bt.getParameter(3314)
          , p = bt.getParameter(32878)
          , d = bt.getParameter(3316)
          , f = bt.getParameter(3315)
          , g = bt.getParameter(32877)
          , m = i.isCompressedTexture ? i.mipmaps[0] : i.image;
        bt.pixelStorei(3314, m.width),
          bt.pixelStorei(32878, m.height),
          bt.pixelStorei(3316, t.min.x),
          bt.pixelStorei(3315, t.min.y),
          bt.pixelStorei(32877, t.min.z),
          i.isDataTexture || i.isData3DTexture ? bt.texSubImage3D(c, r, e.x, e.y, e.z, o, s, a, l, h, m.data) : i.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),
            bt.compressedTexSubImage3D(c, r, e.x, e.y, e.z, o, s, a, l, m.data)) : bt.texSubImage3D(c, r, e.x, e.y, e.z, o, s, a, l, h, m),
          bt.pixelStorei(3314, u),
          bt.pixelStorei(32878, p),
          bt.pixelStorei(3316, d),
          bt.pixelStorei(3315, f),
          bt.pixelStorei(32877, g),
          0 === r && n.generateMipmaps && bt.generateMipmap(c),
          K.unbindTexture()
      }
      ,
      this.initTexture = function (t) {
        t.isCubeTexture ? X.setTextureCube(t, 0) : t.isData3DTexture ? X.setTexture3D(t, 0) : t.isDataArrayTexture ? X.setTexture2DArray(t, 0) : X.setTexture2D(t, 0),
          K.unbindTexture()
      }
      ,
      this.resetState = function () {
        x = 0,
          I = 0,
          C = null,
          K.reset(),
          At.reset()
      }
      ,
      "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
        detail: this
      }))
  }
  class ua extends ca {
  }
  ua.prototype.isWebGL1Renderer = !0;
  class pa {
    constructor(t, e = 25e-5) {
      this.isFogExp2 = !0,
        this.name = "",
        this.color = new ei(t),
        this.density = e
    }
    clone() {
      return new pa(this.color, this.density)
    }
    toJSON() {
      return {
        type: "FogExp2",
        color: this.color.getHex(),
        density: this.density
      }
    }
  }
  class da {
    constructor(t, e = 1, i = 1e3) {
      this.isFog = !0,
        this.name = "",
        this.color = new ei(t),
        this.near = e,
        this.far = i
    }
    clone() {
      return new da(this.color, this.near, this.far)
    }
    toJSON() {
      return {
        type: "Fog",
        color: this.color.getHex(),
        near: this.near,
        far: this.far
      }
    }
  }
  class fa extends mn {
    constructor() {
      super(),
        this.isScene = !0,
        this.type = "Scene",
        this.background = null,
        this.environment = null,
        this.fog = null,
        this.overrideMaterial = null,
        this.autoUpdate = !0,
        "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
          detail: this
        }))
    }
    copy(t, e) {
      return super.copy(t, e),
        null !== t.background && (this.background = t.background.clone()),
        null !== t.environment && (this.environment = t.environment.clone()),
        null !== t.fog && (this.fog = t.fog.clone()),
        null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()),
        this.autoUpdate = t.autoUpdate,
        this.matrixAutoUpdate = t.matrixAutoUpdate,
        this
    }
    toJSON(t) {
      const e = super.toJSON(t);
      return null !== this.fog && (e.object.fog = this.fog.toJSON()),
        e
    }
  }
  class ga {
    constructor(t, e) {
      this.isInterleavedBuffer = !0,
        this.array = t,
        this.stride = e,
        this.count = void 0 !== t ? t.length / e : 0,
        this.usage = Ie,
        this.updateRange = {
          offset: 0,
          count: -1
        },
        this.version = 0,
        this.uuid = Re()
    }
    onUploadCallback() { }
    set needsUpdate(t) {
      !0 === t && this.version++
    }
    setUsage(t) {
      return this.usage = t,
        this
    }
    copy(t) {
      return this.array = new t.array.constructor(t.array),
        this.count = t.count,
        this.stride = t.stride,
        this.usage = t.usage,
        this
    }
    copyAt(t, e, i) {
      t *= this.stride,
        i *= e.stride;
      for (let n = 0, r = this.stride; n < r; n++)
        this.array[t + n] = e.array[i + n];
      return this
    }
    set(t, e = 0) {
      return this.array.set(t, e),
        this
    }
    clone(t) {
      void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
        void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Re()),
        void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
      const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid])
        , i = new this.constructor(e, this.stride);
      return i.setUsage(this.usage),
        i
    }
    onUpload(t) {
      return this.onUploadCallback = t,
        this
    }
    toJSON(t) {
      return void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
        void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Re()),
        void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride
      }
    }
  }
  const ma = new di;
  class ya {
    constructor(t, e, i, n = !1) {
      this.isInterleavedBufferAttribute = !0,
        this.name = "",
        this.data = t,
        this.itemSize = e,
        this.offset = i,
        this.normalized = !0 === n
    }
    get count() {
      return this.data.count
    }
    get array() {
      return this.data.array
    }
    set needsUpdate(t) {
      this.data.needsUpdate = t
    }
    applyMatrix4(t) {
      for (let e = 0, i = this.data.count; e < i; e++)
        ma.fromBufferAttribute(this, e),
          ma.applyMatrix4(t),
          this.setXYZ(e, ma.x, ma.y, ma.z);
      return this
    }
    applyNormalMatrix(t) {
      for (let e = 0, i = this.count; e < i; e++)
        ma.fromBufferAttribute(this, e),
          ma.applyNormalMatrix(t),
          this.setXYZ(e, ma.x, ma.y, ma.z);
      return this
    }
    transformDirection(t) {
      for (let e = 0, i = this.count; e < i; e++)
        ma.fromBufferAttribute(this, e),
          ma.transformDirection(t),
          this.setXYZ(e, ma.x, ma.y, ma.z);
      return this
    }
    setX(t, e) {
      return this.data.array[t * this.data.stride + this.offset] = e,
        this
    }
    setY(t, e) {
      return this.data.array[t * this.data.stride + this.offset + 1] = e,
        this
    }
    setZ(t, e) {
      return this.data.array[t * this.data.stride + this.offset + 2] = e,
        this
    }
    setW(t, e) {
      return this.data.array[t * this.data.stride + this.offset + 3] = e,
        this
    }
    getX(t) {
      return this.data.array[t * this.data.stride + this.offset]
    }
    getY(t) {
      return this.data.array[t * this.data.stride + this.offset + 1]
    }
    getZ(t) {
      return this.data.array[t * this.data.stride + this.offset + 2]
    }
    getW(t) {
      return this.data.array[t * this.data.stride + this.offset + 3]
    }
    setXY(t, e, i) {
      return t = t * this.data.stride + this.offset,
        this.data.array[t + 0] = e,
        this.data.array[t + 1] = i,
        this
    }
    setXYZ(t, e, i, n) {
      return t = t * this.data.stride + this.offset,
        this.data.array[t + 0] = e,
        this.data.array[t + 1] = i,
        this.data.array[t + 2] = n,
        this
    }
    setXYZW(t, e, i, n, r) {
      return t = t * this.data.stride + this.offset,
        this.data.array[t + 0] = e,
        this.data.array[t + 1] = i,
        this.data.array[t + 2] = n,
        this.data.array[t + 3] = r,
        this
    }
    clone(t) {
      if (void 0 === t) {
        console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will deinterleave buffer data.");
        const t = [];
        for (let e = 0; e < this.count; e++) {
          const i = e * this.data.stride + this.offset;
          for (let e = 0; e < this.itemSize; e++)
            t.push(this.data.array[i + e])
        }
        return new Pn(new this.array.constructor(t), this.itemSize, this.normalized)
      }
      return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
        void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),
        new ya(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
    }
    toJSON(t) {
      if (void 0 === t) {
        console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will deinterleave buffer data.");
        const t = [];
        for (let e = 0; e < this.count; e++) {
          const i = e * this.data.stride + this.offset;
          for (let e = 0; e < this.itemSize; e++)
            t.push(this.data.array[i + e])
        }
        return {
          itemSize: this.itemSize,
          type: this.array.constructor.name,
          array: t,
          normalized: this.normalized
        }
      }
      return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
        void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)),
      {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      }
    }
  }
  class va extends En {
    constructor(t) {
      super(),
        this.isSpriteMaterial = !0,
        this.type = "SpriteMaterial",
        this.color = new ei(16777215),
        this.map = null,
        this.alphaMap = null,
        this.rotation = 0,
        this.sizeAttenuation = !0,
        this.transparent = !0,
        this.fog = !0,
        this.setValues(t)
    }
    copy(t) {
      return super.copy(t),
        this.color.copy(t.color),
        this.map = t.map,
        this.alphaMap = t.alphaMap,
        this.rotation = t.rotation,
        this.sizeAttenuation = t.sizeAttenuation,
        this.fog = t.fog,
        this
    }
  }
  let Aa;
  const ba = new di
    , xa = new di
    , Ia = new di
    , Ca = new Fe
    , wa = new Fe
    , _a = new Wi
    , Sa = new di
    , Ma = new di
    , Ta = new di
    , Ea = new Fe
    , ka = new Fe
    , Ra = new Fe;
  class La extends mn {
    constructor(t) {
      if (super(),
        this.isSprite = !0,
        this.type = "Sprite",
        void 0 === Aa) {
        Aa = new Wn;
        const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1])
          , e = new ga(t, 5);
        Aa.setIndex([0, 1, 2, 0, 2, 3]),
          Aa.setAttribute("position", new ya(e, 3, 0, !1)),
          Aa.setAttribute("uv", new ya(e, 2, 3, !1))
      }
      this.geometry = Aa,
        this.material = void 0 !== t ? t : new va,
        this.center = new Fe(.5, .5)
    }
    raycast(t, e) {
      null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),
        xa.setFromMatrixScale(this.matrixWorld),
        _a.copy(t.camera.matrixWorld),
        this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld),
        Ia.setFromMatrixPosition(this.modelViewMatrix),
        t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && xa.multiplyScalar(-Ia.z);
      const i = this.material.rotation;
      let n, r;
      0 !== i && (r = Math.cos(i),
        n = Math.sin(i));
      const o = this.center;
      Pa(Sa.set(-.5, -.5, 0), Ia, o, xa, n, r),
        Pa(Ma.set(.5, -.5, 0), Ia, o, xa, n, r),
        Pa(Ta.set(.5, .5, 0), Ia, o, xa, n, r),
        Ea.set(0, 0),
        ka.set(1, 0),
        Ra.set(1, 1);
      let s = t.ray.intersectTriangle(Sa, Ma, Ta, !1, ba);
      if (null === s && (Pa(Ma.set(-.5, .5, 0), Ia, o, xa, n, r),
        ka.set(0, 1),
        s = t.ray.intersectTriangle(Sa, Ta, Ma, !1, ba),
        null === s))
        return;
      const a = t.ray.origin.distanceTo(ba);
      a < t.near || a > t.far || e.push({
        distance: a,
        point: ba.clone(),
        uv: Mn.getUV(ba, Sa, Ma, Ta, Ea, ka, Ra, new Fe),
        face: null,
        object: this
      })
    }
    copy(t, e) {
      return super.copy(t, e),
        void 0 !== t.center && this.center.copy(t.center),
        this.material = t.material,
        this
    }
  }
  function Pa(t, e, i, n, r, o) {
    Ca.subVectors(t, i).addScalar(.5).multiply(n),
      void 0 !== r ? (wa.x = o * Ca.x - r * Ca.y,
        wa.y = r * Ca.x + o * Ca.y) : wa.copy(Ca),
      t.copy(e),
      t.x += wa.x,
      t.y += wa.y,
      t.applyMatrix4(_a)
  }
  const za = new di
    , Oa = new di;
  class Da extends mn {
    constructor() {
      super(),
        this._currentLevel = 0,
        this.type = "LOD",
        Object.defineProperties(this, {
          levels: {
            enumerable: !0,
            value: []
          },
          isLOD: {
            value: !0
          }
        }),
        this.autoUpdate = !0
    }
    copy(t) {
      super.copy(t, !1);
      const e = t.levels;
      for (let t = 0, i = e.length; t < i; t++) {
        const i = e[t];
        this.addLevel(i.object.clone(), i.distance)
      }
      return this.autoUpdate = t.autoUpdate,
        this
    }
    addLevel(t, e = 0) {
      e = Math.abs(e);
      const i = this.levels;
      let n;
      for (n = 0; n < i.length && !(e < i[n].distance); n++)
        ;
      return i.splice(n, 0, {
        distance: e,
        object: t
      }),
        this.add(t),
        this
    }
    getCurrentLevel() {
      return this._currentLevel
    }
    getObjectForDistance(t) {
      const e = this.levels;
      if (e.length > 0) {
        let i, n;
        for (i = 1,
          n = e.length; i < n && !(t < e[i].distance); i++)
          ;
        return e[i - 1].object
      }
      return null
    }
    raycast(t, e) {
      if (this.levels.length > 0) {
        za.setFromMatrixPosition(this.matrixWorld);
        const i = t.ray.origin.distanceTo(za);
        this.getObjectForDistance(i).raycast(t, e)
      }
    }
    update(t) {
      const e = this.levels;
      if (e.length > 1) {
        za.setFromMatrixPosition(t.matrixWorld),
          Oa.setFromMatrixPosition(this.matrixWorld);
        const i = za.distanceTo(Oa) / t.zoom;
        let n, r;
        for (e[0].object.visible = !0,
          n = 1,
          r = e.length; n < r && i >= e[n].distance; n++)
          e[n - 1].object.visible = !1,
            e[n].object.visible = !0;
        for (this._currentLevel = n - 1; n < r; n++)
          e[n].object.visible = !1
      }
    }
    toJSON(t) {
      const e = super.toJSON(t);
      !1 === this.autoUpdate && (e.object.autoUpdate = !1),
        e.object.levels = [];
      const i = this.levels;
      for (let t = 0, n = i.length; t < n; t++) {
        const n = i[t];
        e.object.levels.push({
          object: n.object.uuid,
          distance: n.distance
        })
      }
      return e
    }
  }
  const Ua = new di
    , Na = new li
    , Fa = new li
    , Ba = new di
    , ja = new Wi;
  class Va extends lr {
    constructor(t, e) {
      super(t, e),
        this.isSkinnedMesh = !0,
        this.type = "SkinnedMesh",
        this.bindMode = "attached",
        this.bindMatrix = new Wi,
        this.bindMatrixInverse = new Wi
    }
    copy(t, e) {
      return super.copy(t, e),
        this.bindMode = t.bindMode,
        this.bindMatrix.copy(t.bindMatrix),
        this.bindMatrixInverse.copy(t.bindMatrixInverse),
        this.skeleton = t.skeleton,
        this
    }
    bind(t, e) {
      this.skeleton = t,
        void 0 === e && (this.updateMatrixWorld(!0),
          this.skeleton.calculateInverses(),
          e = this.matrixWorld),
        this.bindMatrix.copy(e),
        this.bindMatrixInverse.copy(e).invert()
    }
    pose() {
      this.skeleton.pose()
    }
    normalizeSkinWeights() {
      const t = new li
        , e = this.geometry.attributes.skinWeight;
      for (let i = 0, n = e.count; i < n; i++) {
        t.fromBufferAttribute(e, i);
        const n = 1 / t.manhattanLength();
        n !== 1 / 0 ? t.multiplyScalar(n) : t.set(1, 0, 0, 0),
          e.setXYZW(i, t.x, t.y, t.z, t.w)
      }
    }
    updateMatrixWorld(t) {
      super.updateMatrixWorld(t),
        "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
    }
    boneTransform(t, e) {
      const i = this.skeleton
        , n = this.geometry;
      Na.fromBufferAttribute(n.attributes.skinIndex, t),
        Fa.fromBufferAttribute(n.attributes.skinWeight, t),
        Ua.copy(e).applyMatrix4(this.bindMatrix),
        e.set(0, 0, 0);
      for (let t = 0; t < 4; t++) {
        const n = Fa.getComponent(t);
        if (0 !== n) {
          const r = Na.getComponent(t);
          ja.multiplyMatrices(i.bones[r].matrixWorld, i.boneInverses[r]),
            e.addScaledVector(Ba.copy(Ua).applyMatrix4(ja), n)
        }
      }
      return e.applyMatrix4(this.bindMatrixInverse)
    }
  }
  class Ga extends mn {
    constructor() {
      super(),
        this.isBone = !0,
        this.type = "Bone"
    }
  }
  class Wa extends ai {
    constructor(t = null, e = 1, i = 1, n, r, o, s, a, l = ot, h = ot, c, u) {
      super(null, o, s, a, l, h, n, r, c, u),
        this.isDataTexture = !0,
        this.image = {
          data: t,
          width: e,
          height: i
        },
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
  }
  const Ja = new Wi
    , Ha = new Wi;
  class Za {
    constructor(t = [], e = []) {
      this.uuid = Re(),
        this.bones = t.slice(0),
        this.boneInverses = e,
        this.boneMatrices = null,
        this.boneTexture = null,
        this.boneTextureSize = 0,
        this.frame = -1,
        this.init()
    }
    init() {
      const t = this.bones
        , e = this.boneInverses;
      if (this.boneMatrices = new Float32Array(16 * t.length),
        0 === e.length)
        this.calculateInverses();
      else if (t.length !== e.length) {
        console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),
          this.boneInverses = [];
        for (let t = 0, e = this.bones.length; t < e; t++)
          this.boneInverses.push(new Wi)
      }
    }
    calculateInverses() {
      this.boneInverses.length = 0;
      for (let t = 0, e = this.bones.length; t < e; t++) {
        const e = new Wi;
        this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(),
          this.boneInverses.push(e)
      }
    }
    pose() {
      for (let t = 0, e = this.bones.length; t < e; t++) {
        const e = this.bones[t];
        e && e.matrixWorld.copy(this.boneInverses[t]).invert()
      }
      for (let t = 0, e = this.bones.length; t < e; t++) {
        const e = this.bones[t];
        e && (e.parent && e.parent.isBone ? (e.matrix.copy(e.parent.matrixWorld).invert(),
          e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld),
          e.matrix.decompose(e.position, e.quaternion, e.scale))
      }
    }
    update() {
      const t = this.bones
        , e = this.boneInverses
        , i = this.boneMatrices
        , n = this.boneTexture;
      for (let n = 0, r = t.length; n < r; n++) {
        const r = t[n] ? t[n].matrixWorld : Ha;
        Ja.multiplyMatrices(r, e[n]),
          Ja.toArray(i, 16 * n)
      }
      null !== n && (n.needsUpdate = !0)
    }
    clone() {
      return new Za(this.bones, this.boneInverses)
    }
    computeBoneTexture() {
      let t = Math.sqrt(4 * this.bones.length);
      t = De(t),
        t = Math.max(t, 4);
      const e = new Float32Array(t * t * 4);
      e.set(this.boneMatrices);
      const i = new Wa(e, t, t, wt, yt);
      return i.needsUpdate = !0,
        this.boneMatrices = e,
        this.boneTexture = i,
        this.boneTextureSize = t,
        this
    }
    getBoneByName(t) {
      for (let e = 0, i = this.bones.length; e < i; e++) {
        const i = this.bones[e];
        if (i.name === t)
          return i
      }
    }
    dispose() {
      null !== this.boneTexture && (this.boneTexture.dispose(),
        this.boneTexture = null)
    }
    fromJSON(t, e) {
      this.uuid = t.uuid;
      for (let i = 0, n = t.bones.length; i < n; i++) {
        const n = t.bones[i];
        let r = e[n];
        void 0 === r && (console.warn("THREE.Skeleton: No bone found with UUID:", n),
          r = new Ga),
          this.bones.push(r),
          this.boneInverses.push((new Wi).fromArray(t.boneInverses[i]))
      }
      return this.init(),
        this
    }
    toJSON() {
      const t = {
        metadata: {
          version: 4.5,
          type: "Skeleton",
          generator: "Skeleton.toJSON"
        },
        bones: [],
        boneInverses: []
      };
      t.uuid = this.uuid;
      const e = this.bones
        , i = this.boneInverses;
      for (let n = 0, r = e.length; n < r; n++) {
        const r = e[n];
        t.bones.push(r.uuid);
        const o = i[n];
        t.boneInverses.push(o.toArray())
      }
      return t
    }
  }
  class Qa extends Pn {
    constructor(t, e, i, n = 1) {
      "number" == typeof i && (n = i,
        i = !1,
        console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),
        super(t, e, i),
        this.isInstancedBufferAttribute = !0,
        this.meshPerAttribute = n
    }
    copy(t) {
      return super.copy(t),
        this.meshPerAttribute = t.meshPerAttribute,
        this
    }
    toJSON() {
      const t = super.toJSON();
      return t.meshPerAttribute = this.meshPerAttribute,
        t.isInstancedBufferAttribute = !0,
        t
    }
  }
  const Ka = new Wi
    , Ya = new Wi
    , qa = []
    , Xa = new lr;
  class $a extends lr {
    constructor(t, e, i) {
      super(t, e),
        this.isInstancedMesh = !0,
        this.instanceMatrix = new Qa(new Float32Array(16 * i), 16),
        this.instanceColor = null,
        this.count = i,
        this.frustumCulled = !1
    }
    copy(t, e) {
      return super.copy(t, e),
        this.instanceMatrix.copy(t.instanceMatrix),
        null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()),
        this.count = t.count,
        this
    }
    getColorAt(t, e) {
      e.fromArray(this.instanceColor.array, 3 * t)
    }
    getMatrixAt(t, e) {
      e.fromArray(this.instanceMatrix.array, 16 * t)
    }
    raycast(t, e) {
      const i = this.matrixWorld
        , n = this.count;
      if (Xa.geometry = this.geometry,
        Xa.material = this.material,
        void 0 !== Xa.material)
        for (let r = 0; r < n; r++) {
          this.getMatrixAt(r, Ka),
            Ya.multiplyMatrices(i, Ka),
            Xa.matrixWorld = Ya,
            Xa.raycast(t, qa);
          for (let t = 0, i = qa.length; t < i; t++) {
            const i = qa[t];
            i.instanceId = r,
              i.object = this,
              e.push(i)
          }
          qa.length = 0
        }
    }
    setColorAt(t, e) {
      null === this.instanceColor && (this.instanceColor = new Qa(new Float32Array(3 * this.instanceMatrix.count), 3)),
        e.toArray(this.instanceColor.array, 3 * t)
    }
    setMatrixAt(t, e) {
      e.toArray(this.instanceMatrix.array, 16 * t)
    }
    updateMorphTargets() { }
    dispose() {
      this.dispatchEvent({
        type: "dispose"
      })
    }
  }
  class tl extends En {
    constructor(t) {
      super(),
        this.isLineBasicMaterial = !0,
        this.type = "LineBasicMaterial",
        this.color = new ei(16777215),
        this.linewidth = 1,
        this.linecap = "round",
        this.linejoin = "round",
        this.fog = !0,
        this.setValues(t)
    }
    copy(t) {
      return super.copy(t),
        this.color.copy(t.color),
        this.linewidth = t.linewidth,
        this.linecap = t.linecap,
        this.linejoin = t.linejoin,
        this.fog = t.fog,
        this
    }
  }
  const el = new di
    , il = new di
    , nl = new Wi
    , rl = new Gi
    , ol = new Oi;
  class sl extends mn {
    constructor(t = new Wn, e = new tl) {
      super(),
        this.isLine = !0,
        this.type = "Line",
        this.geometry = t,
        this.material = e,
        this.updateMorphTargets()
    }
    copy(t, e) {
      return super.copy(t, e),
        this.material = t.material,
        this.geometry = t.geometry,
        this
    }
    computeLineDistances() {
      const t = this.geometry;
      if (null === t.index) {
        const e = t.attributes.position
          , i = [0];
        for (let t = 1, n = e.count; t < n; t++)
          el.fromBufferAttribute(e, t - 1),
            il.fromBufferAttribute(e, t),
            i[t] = i[t - 1],
            i[t] += el.distanceTo(il);
        t.setAttribute("lineDistance", new Dn(i, 1))
      } else
        console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      return this
    }
    raycast(t, e) {
      const i = this.geometry
        , n = this.matrixWorld
        , r = t.params.Line.threshold
        , o = i.drawRange;
      if (null === i.boundingSphere && i.computeBoundingSphere(),
        ol.copy(i.boundingSphere),
        ol.applyMatrix4(n),
        ol.radius += r,
        !1 === t.ray.intersectsSphere(ol))
        return;
      nl.copy(n).invert(),
        rl.copy(t.ray).applyMatrix4(nl);
      const s = r / ((this.scale.x + this.scale.y + this.scale.z) / 3)
        , a = s * s
        , l = new di
        , h = new di
        , c = new di
        , u = new di
        , p = this.isLineSegments ? 2 : 1
        , d = i.index
        , f = i.attributes.position;
      if (null !== d) {
        for (let i = Math.max(0, o.start), n = Math.min(d.count, o.start + o.count) - 1; i < n; i += p) {
          const n = d.getX(i)
            , r = d.getX(i + 1);
          l.fromBufferAttribute(f, n),
            h.fromBufferAttribute(f, r);
          if (rl.distanceSqToSegment(l, h, u, c) > a)
            continue;
          u.applyMatrix4(this.matrixWorld);
          const o = t.ray.origin.distanceTo(u);
          o < t.near || o > t.far || e.push({
            distance: o,
            point: c.clone().applyMatrix4(this.matrixWorld),
            index: i,
            face: null,
            faceIndex: null,
            object: this
          })
        }
      } else {
        for (let i = Math.max(0, o.start), n = Math.min(f.count, o.start + o.count) - 1; i < n; i += p) {
          l.fromBufferAttribute(f, i),
            h.fromBufferAttribute(f, i + 1);
          if (rl.distanceSqToSegment(l, h, u, c) > a)
            continue;
          u.applyMatrix4(this.matrixWorld);
          const n = t.ray.origin.distanceTo(u);
          n < t.near || n > t.far || e.push({
            distance: n,
            point: c.clone().applyMatrix4(this.matrixWorld),
            index: i,
            face: null,
            faceIndex: null,
            object: this
          })
        }
      }
    }
    updateMorphTargets() {
      const t = this.geometry.morphAttributes
        , e = Object.keys(t);
      if (e.length > 0) {
        const i = t[e[0]];
        if (void 0 !== i) {
          this.morphTargetInfluences = [],
            this.morphTargetDictionary = {};
          for (let t = 0, e = i.length; t < e; t++) {
            const e = i[t].name || String(t);
            this.morphTargetInfluences.push(0),
              this.morphTargetDictionary[e] = t
          }
        }
      }
    }
  }
  const al = new di
    , ll = new di;
  class hl extends sl {
    constructor(t, e) {
      super(t, e),
        this.isLineSegments = !0,
        this.type = "LineSegments"
    }
    computeLineDistances() {
      const t = this.geometry;
      if (null === t.index) {
        const e = t.attributes.position
          , i = [];
        for (let t = 0, n = e.count; t < n; t += 2)
          al.fromBufferAttribute(e, t),
            ll.fromBufferAttribute(e, t + 1),
            i[t] = 0 === t ? 0 : i[t - 1],
            i[t + 1] = i[t] + al.distanceTo(ll);
        t.setAttribute("lineDistance", new Dn(i, 1))
      } else
        console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      return this
    }
  }
  class cl extends sl {
    constructor(t, e) {
      super(t, e),
        this.isLineLoop = !0,
        this.type = "LineLoop"
    }
  }
  class ul extends En {
    constructor(t) {
      super(),
        this.isPointsMaterial = !0,
        this.type = "PointsMaterial",
        this.color = new ei(16777215),
        this.map = null,
        this.alphaMap = null,
        this.size = 1,
        this.sizeAttenuation = !0,
        this.fog = !0,
        this.setValues(t)
    }
    copy(t) {
      return super.copy(t),
        this.color.copy(t.color),
        this.map = t.map,
        this.alphaMap = t.alphaMap,
        this.size = t.size,
        this.sizeAttenuation = t.sizeAttenuation,
        this.fog = t.fog,
        this
    }
  }
  const pl = new Wi
    , dl = new Gi
    , fl = new Oi
    , gl = new di;
  class ml extends mn {
    constructor(t = new Wn, e = new ul) {
      super(),
        this.isPoints = !0,
        this.type = "Points",
        this.geometry = t,
        this.material = e,
        this.updateMorphTargets()
    }
    copy(t, e) {
      return super.copy(t, e),
        this.material = t.material,
        this.geometry = t.geometry,
        this
    }
    raycast(t, e) {
      const i = this.geometry
        , n = this.matrixWorld
        , r = t.params.Points.threshold
        , o = i.drawRange;
      if (null === i.boundingSphere && i.computeBoundingSphere(),
        fl.copy(i.boundingSphere),
        fl.applyMatrix4(n),
        fl.radius += r,
        !1 === t.ray.intersectsSphere(fl))
        return;
      pl.copy(n).invert(),
        dl.copy(t.ray).applyMatrix4(pl);
      const s = r / ((this.scale.x + this.scale.y + this.scale.z) / 3)
        , a = s * s
        , l = i.index
        , h = i.attributes.position;
      if (null !== l) {
        for (let i = Math.max(0, o.start), r = Math.min(l.count, o.start + o.count); i < r; i++) {
          const r = l.getX(i);
          gl.fromBufferAttribute(h, r),
            yl(gl, r, a, n, t, e, this)
        }
      } else {
        for (let i = Math.max(0, o.start), r = Math.min(h.count, o.start + o.count); i < r; i++)
          gl.fromBufferAttribute(h, i),
            yl(gl, i, a, n, t, e, this)
      }
    }
    updateMorphTargets() {
      const t = this.geometry.morphAttributes
        , e = Object.keys(t);
      if (e.length > 0) {
        const i = t[e[0]];
        if (void 0 !== i) {
          this.morphTargetInfluences = [],
            this.morphTargetDictionary = {};
          for (let t = 0, e = i.length; t < e; t++) {
            const e = i[t].name || String(t);
            this.morphTargetInfluences.push(0),
              this.morphTargetDictionary[e] = t
          }
        }
      }
    }
  }
  function yl(t, e, i, n, r, o, s) {
    const a = dl.distanceSqToPoint(t);
    if (a < i) {
      const i = new di;
      dl.closestPointToPoint(t, i),
        i.applyMatrix4(n);
      const l = r.ray.origin.distanceTo(i);
      if (l < r.near || l > r.far)
        return;
      o.push({
        distance: l,
        distanceToRay: Math.sqrt(a),
        point: i,
        index: e,
        face: null,
        object: s
      })
    }
  }
  class vl extends ai {
    constructor(t, e, i, n, r, o, s, a, l, h, c, u) {
      super(null, o, s, a, l, h, n, r, c, u),
        this.isCompressedTexture = !0,
        this.image = {
          width: e,
          height: i
        },
        this.mipmaps = t,
        this.flipY = !1,
        this.generateMipmaps = !1
    }
  }
  class Al {
    constructor() {
      this.type = "Curve",
        this.arcLengthDivisions = 200
    }
    getPoint() {
      return console.warn("THREE.Curve: .getPoint() not implemented."),
        null
    }
    getPointAt(t, e) {
      const i = this.getUtoTmapping(t);
      return this.getPoint(i, e)
    }
    getPoints(t = 5) {
      const e = [];
      for (let i = 0; i <= t; i++)
        e.push(this.getPoint(i / t));
      return e
    }
    getSpacedPoints(t = 5) {
      const e = [];
      for (let i = 0; i <= t; i++)
        e.push(this.getPointAt(i / t));
      return e
    }
    getLength() {
      const t = this.getLengths();
      return t[t.length - 1]
    }
    getLengths(t = this.arcLengthDivisions) {
      if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate)
        return this.cacheArcLengths;
      this.needsUpdate = !1;
      const e = [];
      let i, n = this.getPoint(0), r = 0;
      e.push(0);
      for (let o = 1; o <= t; o++)
        i = this.getPoint(o / t),
          r += i.distanceTo(n),
          e.push(r),
          n = i;
      return this.cacheArcLengths = e,
        e
    }
    updateArcLengths() {
      this.needsUpdate = !0,
        this.getLengths()
    }
    getUtoTmapping(t, e) {
      const i = this.getLengths();
      let n = 0;
      const r = i.length;
      let o;
      o = e || t * i[r - 1];
      let s, a = 0, l = r - 1;
      for (; a <= l;)
        if (n = Math.floor(a + (l - a) / 2),
          s = i[n] - o,
          s < 0)
          a = n + 1;
        else {
          if (!(s > 0)) {
            l = n;
            break
          }
          l = n - 1
        }
      if (n = l,
        i[n] === o)
        return n / (r - 1);
      const h = i[n];
      return (n + (o - h) / (i[n + 1] - h)) / (r - 1)
    }
    getTangent(t, e) {
      const i = 1e-4;
      let n = t - i
        , r = t + i;
      n < 0 && (n = 0),
        r > 1 && (r = 1);
      const o = this.getPoint(n)
        , s = this.getPoint(r)
        , a = e || (o.isVector2 ? new Fe : new di);
      return a.copy(s).sub(o).normalize(),
        a
    }
    getTangentAt(t, e) {
      const i = this.getUtoTmapping(t);
      return this.getTangent(i, e)
    }
    computeFrenetFrames(t, e) {
      const i = new di
        , n = []
        , r = []
        , o = []
        , s = new di
        , a = new Wi;
      for (let e = 0; e <= t; e++) {
        const i = e / t;
        n[e] = this.getTangentAt(i, new di)
      }
      r[0] = new di,
        o[0] = new di;
      let l = Number.MAX_VALUE;
      const h = Math.abs(n[0].x)
        , c = Math.abs(n[0].y)
        , u = Math.abs(n[0].z);
      h <= l && (l = h,
        i.set(1, 0, 0)),
        c <= l && (l = c,
          i.set(0, 1, 0)),
        u <= l && i.set(0, 0, 1),
        s.crossVectors(n[0], i).normalize(),
        r[0].crossVectors(n[0], s),
        o[0].crossVectors(n[0], r[0]);
      for (let e = 1; e <= t; e++) {
        if (r[e] = r[e - 1].clone(),
          o[e] = o[e - 1].clone(),
          s.crossVectors(n[e - 1], n[e]),
          s.length() > Number.EPSILON) {
          s.normalize();
          const t = Math.acos(Le(n[e - 1].dot(n[e]), -1, 1));
          r[e].applyMatrix4(a.makeRotationAxis(s, t))
        }
        o[e].crossVectors(n[e], r[e])
      }
      if (!0 === e) {
        let e = Math.acos(Le(r[0].dot(r[t]), -1, 1));
        e /= t,
          n[0].dot(s.crossVectors(r[0], r[t])) > 0 && (e = -e);
        for (let i = 1; i <= t; i++)
          r[i].applyMatrix4(a.makeRotationAxis(n[i], e * i)),
            o[i].crossVectors(n[i], r[i])
      }
      return {
        tangents: n,
        normals: r,
        binormals: o
      }
    }
    clone() {
      return (new this.constructor).copy(this)
    }
    copy(t) {
      return this.arcLengthDivisions = t.arcLengthDivisions,
        this
    }
    toJSON() {
      const t = {
        metadata: {
          version: 4.5,
          type: "Curve",
          generator: "Curve.toJSON"
        }
      };
      return t.arcLengthDivisions = this.arcLengthDivisions,
        t.type = this.type,
        t
    }
    fromJSON(t) {
      return this.arcLengthDivisions = t.arcLengthDivisions,
        this
    }
  }
  class bl extends Al {
    constructor(t = 0, e = 0, i = 1, n = 1, r = 0, o = 2 * Math.PI, s = !1, a = 0) {
      super(),
        this.isEllipseCurve = !0,
        this.type = "EllipseCurve",
        this.aX = t,
        this.aY = e,
        this.xRadius = i,
        this.yRadius = n,
        this.aStartAngle = r,
        this.aEndAngle = o,
        this.aClockwise = s,
        this.aRotation = a
    }
    getPoint(t, e) {
      const i = e || new Fe
        , n = 2 * Math.PI;
      let r = this.aEndAngle - this.aStartAngle;
      const o = Math.abs(r) < Number.EPSILON;
      for (; r < 0;)
        r += n;
      for (; r > n;)
        r -= n;
      r < Number.EPSILON && (r = o ? 0 : n),
        !0 !== this.aClockwise || o || (r === n ? r = -n : r -= n);
      const s = this.aStartAngle + t * r;
      let a = this.aX + this.xRadius * Math.cos(s)
        , l = this.aY + this.yRadius * Math.sin(s);
      if (0 !== this.aRotation) {
        const t = Math.cos(this.aRotation)
          , e = Math.sin(this.aRotation)
          , i = a - this.aX
          , n = l - this.aY;
        a = i * t - n * e + this.aX,
          l = i * e + n * t + this.aY
      }
      return i.set(a, l)
    }
    copy(t) {
      return super.copy(t),
        this.aX = t.aX,
        this.aY = t.aY,
        this.xRadius = t.xRadius,
        this.yRadius = t.yRadius,
        this.aStartAngle = t.aStartAngle,
        this.aEndAngle = t.aEndAngle,
        this.aClockwise = t.aClockwise,
        this.aRotation = t.aRotation,
        this
    }
    toJSON() {
      const t = super.toJSON();
      return t.aX = this.aX,
        t.aY = this.aY,
        t.xRadius = this.xRadius,
        t.yRadius = this.yRadius,
        t.aStartAngle = this.aStartAngle,
        t.aEndAngle = this.aEndAngle,
        t.aClockwise = this.aClockwise,
        t.aRotation = this.aRotation,
        t
    }
    fromJSON(t) {
      return super.fromJSON(t),
        this.aX = t.aX,
        this.aY = t.aY,
        this.xRadius = t.xRadius,
        this.yRadius = t.yRadius,
        this.aStartAngle = t.aStartAngle,
        this.aEndAngle = t.aEndAngle,
        this.aClockwise = t.aClockwise,
        this.aRotation = t.aRotation,
        this
    }
  }
  class xl extends bl {
    constructor(t, e, i, n, r, o) {
      super(t, e, i, i, n, r, o),
        this.isArcCurve = !0,
        this.type = "ArcCurve"
    }
  }
  function Il() {
    let t = 0
      , e = 0
      , i = 0
      , n = 0;
    function r(r, o, s, a) {
      t = r,
        e = s,
        i = -3 * r + 3 * o - 2 * s - a,
        n = 2 * r - 2 * o + s + a
    }
    return {
      initCatmullRom: function (t, e, i, n, o) {
        r(e, i, o * (i - t), o * (n - e))
      },
      initNonuniformCatmullRom: function (t, e, i, n, o, s, a) {
        let l = (e - t) / o - (i - t) / (o + s) + (i - e) / s
          , h = (i - e) / s - (n - e) / (s + a) + (n - i) / a;
        l *= s,
          h *= s,
          r(e, i, l, h)
      },
      calc: function (r) {
        const o = r * r;
        return t + e * r + i * o + n * (o * r)
      }
    }
  }
  const Cl = new di
    , wl = new Il
    , _l = new Il
    , Sl = new Il;
  class Ml extends Al {
    constructor(t = [], e = !1, i = "centripetal", n = .5) {
      super(),
        this.isCatmullRomCurve3 = !0,
        this.type = "CatmullRomCurve3",
        this.points = t,
        this.closed = e,
        this.curveType = i,
        this.tension = n
    }
    getPoint(t, e = new di) {
      const i = e
        , n = this.points
        , r = n.length
        , o = (r - (this.closed ? 0 : 1)) * t;
      let s, a, l = Math.floor(o), h = o - l;
      this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r : 0 === h && l === r - 1 && (l = r - 2,
        h = 1),
        this.closed || l > 0 ? s = n[(l - 1) % r] : (Cl.subVectors(n[0], n[1]).add(n[0]),
          s = Cl);
      const c = n[l % r]
        , u = n[(l + 1) % r];
      if (this.closed || l + 2 < r ? a = n[(l + 2) % r] : (Cl.subVectors(n[r - 1], n[r - 2]).add(n[r - 1]),
        a = Cl),
        "centripetal" === this.curveType || "chordal" === this.curveType) {
        const t = "chordal" === this.curveType ? .5 : .25;
        let e = Math.pow(s.distanceToSquared(c), t)
          , i = Math.pow(c.distanceToSquared(u), t)
          , n = Math.pow(u.distanceToSquared(a), t);
        i < 1e-4 && (i = 1),
          e < 1e-4 && (e = i),
          n < 1e-4 && (n = i),
          wl.initNonuniformCatmullRom(s.x, c.x, u.x, a.x, e, i, n),
          _l.initNonuniformCatmullRom(s.y, c.y, u.y, a.y, e, i, n),
          Sl.initNonuniformCatmullRom(s.z, c.z, u.z, a.z, e, i, n)
      } else
        "catmullrom" === this.curveType && (wl.initCatmullRom(s.x, c.x, u.x, a.x, this.tension),
          _l.initCatmullRom(s.y, c.y, u.y, a.y, this.tension),
          Sl.initCatmullRom(s.z, c.z, u.z, a.z, this.tension));
      return i.set(wl.calc(h), _l.calc(h), Sl.calc(h)),
        i
    }
    copy(t) {
      super.copy(t),
        this.points = [];
      for (let e = 0, i = t.points.length; e < i; e++) {
        const i = t.points[e];
        this.points.push(i.clone())
      }
      return this.closed = t.closed,
        this.curveType = t.curveType,
        this.tension = t.tension,
        this
    }
    toJSON() {
      const t = super.toJSON();
      t.points = [];
      for (let e = 0, i = this.points.length; e < i; e++) {
        const i = this.points[e];
        t.points.push(i.toArray())
      }
      return t.closed = this.closed,
        t.curveType = this.curveType,
        t.tension = this.tension,
        t
    }
    fromJSON(t) {
      super.fromJSON(t),
        this.points = [];
      for (let e = 0, i = t.points.length; e < i; e++) {
        const i = t.points[e];
        this.points.push((new di).fromArray(i))
      }
      return this.closed = t.closed,
        this.curveType = t.curveType,
        this.tension = t.tension,
        this
    }
  }
  function Tl(t, e, i, n, r) {
    const o = .5 * (n - e)
      , s = .5 * (r - i)
      , a = t * t;
    return (2 * i - 2 * n + o + s) * (t * a) + (-3 * i + 3 * n - 2 * o - s) * a + o * t + i
  }
  function El(t, e, i, n) {
    return function (t, e) {
      const i = 1 - t;
      return i * i * e
    }(t, e) + function (t, e) {
      return 2 * (1 - t) * t * e
    }(t, i) + function (t, e) {
      return t * t * e
    }(t, n)
  }
  function kl(t, e, i, n, r) {
    return function (t, e) {
      const i = 1 - t;
      return i * i * i * e
    }(t, e) + function (t, e) {
      const i = 1 - t;
      return 3 * i * i * t * e
    }(t, i) + function (t, e) {
      return 3 * (1 - t) * t * t * e
    }(t, n) + function (t, e) {
      return t * t * t * e
    }(t, r)
  }
  class Rl extends Al {
    constructor(t = new Fe, e = new Fe, i = new Fe, n = new Fe) {
      super(),
        this.isCubicBezierCurve = !0,
        this.type = "CubicBezierCurve",
        this.v0 = t,
        this.v1 = e,
        this.v2 = i,
        this.v3 = n
    }
    getPoint(t, e = new Fe) {
      const i = e
        , n = this.v0
        , r = this.v1
        , o = this.v2
        , s = this.v3;
      return i.set(kl(t, n.x, r.x, o.x, s.x), kl(t, n.y, r.y, o.y, s.y)),
        i
    }
    copy(t) {
      return super.copy(t),
        this.v0.copy(t.v0),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this.v3.copy(t.v3),
        this
    }
    toJSON() {
      const t = super.toJSON();
      return t.v0 = this.v0.toArray(),
        t.v1 = this.v1.toArray(),
        t.v2 = this.v2.toArray(),
        t.v3 = this.v3.toArray(),
        t
    }
    fromJSON(t) {
      return super.fromJSON(t),
        this.v0.fromArray(t.v0),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this.v3.fromArray(t.v3),
        this
    }
  }
  class Ll extends Al {
    constructor(t = new di, e = new di, i = new di, n = new di) {
      super(),
        this.isCubicBezierCurve3 = !0,
        this.type = "CubicBezierCurve3",
        this.v0 = t,
        this.v1 = e,
        this.v2 = i,
        this.v3 = n
    }
    getPoint(t, e = new di) {
      const i = e
        , n = this.v0
        , r = this.v1
        , o = this.v2
        , s = this.v3;
      return i.set(kl(t, n.x, r.x, o.x, s.x), kl(t, n.y, r.y, o.y, s.y), kl(t, n.z, r.z, o.z, s.z)),
        i
    }
    copy(t) {
      return super.copy(t),
        this.v0.copy(t.v0),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this.v3.copy(t.v3),
        this
    }
    toJSON() {
      const t = super.toJSON();
      return t.v0 = this.v0.toArray(),
        t.v1 = this.v1.toArray(),
        t.v2 = this.v2.toArray(),
        t.v3 = this.v3.toArray(),
        t
    }
    fromJSON(t) {
      return super.fromJSON(t),
        this.v0.fromArray(t.v0),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this.v3.fromArray(t.v3),
        this
    }
  }
  class Pl extends Al {
    constructor(t = new Fe, e = new Fe) {
      super(),
        this.isLineCurve = !0,
        this.type = "LineCurve",
        this.v1 = t,
        this.v2 = e
    }
    getPoint(t, e = new Fe) {
      const i = e;
      return 1 === t ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1),
        i.multiplyScalar(t).add(this.v1)),
        i
    }
    getPointAt(t, e) {
      return this.getPoint(t, e)
    }
    getTangent(t, e) {
      const i = e || new Fe;
      return i.copy(this.v2).sub(this.v1).normalize(),
        i
    }
    copy(t) {
      return super.copy(t),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this
    }
    toJSON() {
      const t = super.toJSON();
      return t.v1 = this.v1.toArray(),
        t.v2 = this.v2.toArray(),
        t
    }
    fromJSON(t) {
      return super.fromJSON(t),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this
    }
  }
  class zl extends Al {
    constructor(t = new di, e = new di) {
      super(),
        this.isLineCurve3 = !0,
        this.type = "LineCurve3",
        this.v1 = t,
        this.v2 = e
    }
    getPoint(t, e = new di) {
      const i = e;
      return 1 === t ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1),
        i.multiplyScalar(t).add(this.v1)),
        i
    }
    getPointAt(t, e) {
      return this.getPoint(t, e)
    }
    copy(t) {
      return super.copy(t),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this
    }
    toJSON() {
      const t = super.toJSON();
      return t.v1 = this.v1.toArray(),
        t.v2 = this.v2.toArray(),
        t
    }
    fromJSON(t) {
      return super.fromJSON(t),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this
    }
  }
  class Ol extends Al {
    constructor(t = new Fe, e = new Fe, i = new Fe) {
      super(),
        this.isQuadraticBezierCurve = !0,
        this.type = "QuadraticBezierCurve",
        this.v0 = t,
        this.v1 = e,
        this.v2 = i
    }
    getPoint(t, e = new Fe) {
      const i = e
        , n = this.v0
        , r = this.v1
        , o = this.v2;
      return i.set(El(t, n.x, r.x, o.x), El(t, n.y, r.y, o.y)),
        i
    }
    copy(t) {
      return super.copy(t),
        this.v0.copy(t.v0),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this
    }
    toJSON() {
      const t = super.toJSON();
      return t.v0 = this.v0.toArray(),
        t.v1 = this.v1.toArray(),
        t.v2 = this.v2.toArray(),
        t
    }
    fromJSON(t) {
      return super.fromJSON(t),
        this.v0.fromArray(t.v0),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this
    }
  }
  class Dl extends Al {
    constructor(t = new di, e = new di, i = new di) {
      super(),
        this.isQuadraticBezierCurve3 = !0,
        this.type = "QuadraticBezierCurve3",
        this.v0 = t,
        this.v1 = e,
        this.v2 = i
    }
    getPoint(t, e = new di) {
      const i = e
        , n = this.v0
        , r = this.v1
        , o = this.v2;
      return i.set(El(t, n.x, r.x, o.x), El(t, n.y, r.y, o.y), El(t, n.z, r.z, o.z)),
        i
    }
    copy(t) {
      return super.copy(t),
        this.v0.copy(t.v0),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this
    }
    toJSON() {
      const t = super.toJSON();
      return t.v0 = this.v0.toArray(),
        t.v1 = this.v1.toArray(),
        t.v2 = this.v2.toArray(),
        t
    }
    fromJSON(t) {
      return super.fromJSON(t),
        this.v0.fromArray(t.v0),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this
    }
  }
  class Ul extends Al {
    constructor(t = []) {
      super(),
        this.isSplineCurve = !0,
        this.type = "SplineCurve",
        this.points = t
    }
    getPoint(t, e = new Fe) {
      const i = e
        , n = this.points
        , r = (n.length - 1) * t
        , o = Math.floor(r)
        , s = r - o
        , a = n[0 === o ? o : o - 1]
        , l = n[o]
        , h = n[o > n.length - 2 ? n.length - 1 : o + 1]
        , c = n[o > n.length - 3 ? n.length - 1 : o + 2];
      return i.set(Tl(s, a.x, l.x, h.x, c.x), Tl(s, a.y, l.y, h.y, c.y)),
        i
    }
    copy(t) {
      super.copy(t),
        this.points = [];
      for (let e = 0, i = t.points.length; e < i; e++) {
        const i = t.points[e];
        this.points.push(i.clone())
      }
      return this
    }
    toJSON() {
      const t = super.toJSON();
      t.points = [];
      for (let e = 0, i = this.points.length; e < i; e++) {
        const i = this.points[e];
        t.points.push(i.toArray())
      }
      return t
    }
    fromJSON(t) {
      super.fromJSON(t),
        this.points = [];
      for (let e = 0, i = t.points.length; e < i; e++) {
        const i = t.points[e];
        this.points.push((new Fe).fromArray(i))
      }
      return this
    }
  }
  var Nl = Object.freeze({
    __proto__: null,
    ArcCurve: xl,
    CatmullRomCurve3: Ml,
    CubicBezierCurve: Rl,
    CubicBezierCurve3: Ll,
    EllipseCurve: bl,
    LineCurve: Pl,
    LineCurve3: zl,
    QuadraticBezierCurve: Ol,
    QuadraticBezierCurve3: Dl,
    SplineCurve: Ul
  });
  class Fl extends Al {
    constructor() {
      super(),
        this.type = "CurvePath",
        this.curves = [],
        this.autoClose = !1
    }
    add(t) {
      this.curves.push(t)
    }
    closePath() {
      const t = this.curves[0].getPoint(0)
        , e = this.curves[this.curves.length - 1].getPoint(1);
      t.equals(e) || this.curves.push(new Pl(e, t))
    }
    getPoint(t, e) {
      const i = t * this.getLength()
        , n = this.getCurveLengths();
      let r = 0;
      for (; r < n.length;) {
        if (n[r] >= i) {
          const t = n[r] - i
            , o = this.curves[r]
            , s = o.getLength()
            , a = 0 === s ? 0 : 1 - t / s;
          return o.getPointAt(a, e)
        }
        r++
      }
      return null
    }
    getLength() {
      const t = this.getCurveLengths();
      return t[t.length - 1]
    }
    updateArcLengths() {
      this.needsUpdate = !0,
        this.cacheLengths = null,
        this.getCurveLengths()
    }
    getCurveLengths() {
      if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
        return this.cacheLengths;
      const t = [];
      let e = 0;
      for (let i = 0, n = this.curves.length; i < n; i++)
        e += this.curves[i].getLength(),
          t.push(e);
      return this.cacheLengths = t,
        t
    }
    getSpacedPoints(t = 40) {
      const e = [];
      for (let i = 0; i <= t; i++)
        e.push(this.getPoint(i / t));
      return this.autoClose && e.push(e[0]),
        e
    }
    getPoints(t = 12) {
      const e = [];
      let i;
      for (let n = 0, r = this.curves; n < r.length; n++) {
        const o = r[n]
          , s = o.isEllipseCurve ? 2 * t : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? t * o.points.length : t
          , a = o.getPoints(s);
        for (let t = 0; t < a.length; t++) {
          const n = a[t];
          i && i.equals(n) || (e.push(n),
            i = n)
        }
      }
      return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]),
        e
    }
    copy(t) {
      super.copy(t),
        this.curves = [];
      for (let e = 0, i = t.curves.length; e < i; e++) {
        const i = t.curves[e];
        this.curves.push(i.clone())
      }
      return this.autoClose = t.autoClose,
        this
    }
    toJSON() {
      const t = super.toJSON();
      t.autoClose = this.autoClose,
        t.curves = [];
      for (let e = 0, i = this.curves.length; e < i; e++) {
        const i = this.curves[e];
        t.curves.push(i.toJSON())
      }
      return t
    }
    fromJSON(t) {
      super.fromJSON(t),
        this.autoClose = t.autoClose,
        this.curves = [];
      for (let e = 0, i = t.curves.length; e < i; e++) {
        const i = t.curves[e];
        this.curves.push((new Nl[i.type]).fromJSON(i))
      }
      return this
    }
  }
  class Bl extends Fl {
    constructor(t) {
      super(),
        this.type = "Path",
        this.currentPoint = new Fe,
        t && this.setFromPoints(t)
    }
    setFromPoints(t) {
      this.moveTo(t[0].x, t[0].y);
      for (let e = 1, i = t.length; e < i; e++)
        this.lineTo(t[e].x, t[e].y);
      return this
    }
    moveTo(t, e) {
      return this.currentPoint.set(t, e),
        this
    }
    lineTo(t, e) {
      const i = new Pl(this.currentPoint.clone(), new Fe(t, e));
      return this.curves.push(i),
        this.currentPoint.set(t, e),
        this
    }
    quadraticCurveTo(t, e, i, n) {
      const r = new Ol(this.currentPoint.clone(), new Fe(t, e), new Fe(i, n));
      return this.curves.push(r),
        this.currentPoint.set(i, n),
        this
    }
    bezierCurveTo(t, e, i, n, r, o) {
      const s = new Rl(this.currentPoint.clone(), new Fe(t, e), new Fe(i, n), new Fe(r, o));
      return this.curves.push(s),
        this.currentPoint.set(r, o),
        this
    }
    splineThru(t) {
      const e = [this.currentPoint.clone()].concat(t)
        , i = new Ul(e);
      return this.curves.push(i),
        this.currentPoint.copy(t[t.length - 1]),
        this
    }
    arc(t, e, i, n, r, o) {
      const s = this.currentPoint.x
        , a = this.currentPoint.y;
      return this.absarc(t + s, e + a, i, n, r, o),
        this
    }
    absarc(t, e, i, n, r, o) {
      return this.absellipse(t, e, i, i, n, r, o),
        this
    }
    ellipse(t, e, i, n, r, o, s, a) {
      const l = this.currentPoint.x
        , h = this.currentPoint.y;
      return this.absellipse(t + l, e + h, i, n, r, o, s, a),
        this
    }
    absellipse(t, e, i, n, r, o, s, a) {
      const l = new bl(t, e, i, n, r, o, s, a);
      if (this.curves.length > 0) {
        const t = l.getPoint(0);
        t.equals(this.currentPoint) || this.lineTo(t.x, t.y)
      }
      this.curves.push(l);
      const h = l.getPoint(1);
      return this.currentPoint.copy(h),
        this
    }
    copy(t) {
      return super.copy(t),
        this.currentPoint.copy(t.currentPoint),
        this
    }
    toJSON() {
      const t = super.toJSON();
      return t.currentPoint = this.currentPoint.toArray(),
        t
    }
    fromJSON(t) {
      return super.fromJSON(t),
        this.currentPoint.fromArray(t.currentPoint),
        this
    }
  }
  class jl extends Wn {
    constructor(t = [new Fe(0, .5), new Fe(.5, 0), new Fe(0, -.5)], e = 12, i = 0, n = 2 * Math.PI) {
      super(),
        this.type = "LatheGeometry",
        this.parameters = {
          points: t,
          segments: e,
          phiStart: i,
          phiLength: n
        },
        e = Math.floor(e),
        n = Le(n, 0, 2 * Math.PI);
      const r = []
        , o = []
        , s = []
        , a = []
        , l = []
        , h = 1 / e
        , c = new di
        , u = new Fe
        , p = new di
        , d = new di
        , f = new di;
      let g = 0
        , m = 0;
      for (let e = 0; e <= t.length - 1; e++)
        switch (e) {
          case 0:
            g = t[e + 1].x - t[e].x,
              m = t[e + 1].y - t[e].y,
              p.x = 1 * m,
              p.y = -g,
              p.z = 0 * m,
              f.copy(p),
              p.normalize(),
              a.push(p.x, p.y, p.z);
            break;
          case t.length - 1:
            a.push(f.x, f.y, f.z);
            break;
          default:
            g = t[e + 1].x - t[e].x,
              m = t[e + 1].y - t[e].y,
              p.x = 1 * m,
              p.y = -g,
              p.z = 0 * m,
              d.copy(p),
              p.x += f.x,
              p.y += f.y,
              p.z += f.z,
              p.normalize(),
              a.push(p.x, p.y, p.z),
              f.copy(d)
        }
      for (let r = 0; r <= e; r++) {
        const p = i + r * h * n
          , d = Math.sin(p)
          , f = Math.cos(p);
        for (let i = 0; i <= t.length - 1; i++) {
          c.x = t[i].x * d,
            c.y = t[i].y,
            c.z = t[i].x * f,
            o.push(c.x, c.y, c.z),
            u.x = r / e,
            u.y = i / (t.length - 1),
            s.push(u.x, u.y);
          const n = a[3 * i + 0] * d
            , h = a[3 * i + 1]
            , p = a[3 * i + 0] * f;
          l.push(n, h, p)
        }
      }
      for (let i = 0; i < e; i++)
        for (let e = 0; e < t.length - 1; e++) {
          const n = e + i * t.length
            , o = n
            , s = n + t.length
            , a = n + t.length + 1
            , l = n + 1;
          r.push(o, s, l),
            r.push(a, l, s)
        }
      this.setIndex(r),
        this.setAttribute("position", new Dn(o, 3)),
        this.setAttribute("uv", new Dn(s, 2)),
        this.setAttribute("normal", new Dn(l, 3))
    }
    static fromJSON(t) {
      return new jl(t.points, t.segments, t.phiStart, t.phiLength)
    }
  }
  class Vl extends jl {
    constructor(t = 1, e = 1, i = 4, n = 8) {
      const r = new Bl;
      r.absarc(0, -e / 2, t, 1.5 * Math.PI, 0),
        r.absarc(0, e / 2, t, 0, .5 * Math.PI),
        super(r.getPoints(i), n),
        this.type = "CapsuleGeometry",
        this.parameters = {
          radius: t,
          height: e,
          capSegments: i,
          radialSegments: n
        }
    }
    static fromJSON(t) {
      return new Vl(t.radius, t.length, t.capSegments, t.radialSegments)
    }
  }
  class Gl extends Wn {
    constructor(t = 1, e = 8, i = 0, n = 2 * Math.PI) {
      super(),
        this.type = "CircleGeometry",
        this.parameters = {
          radius: t,
          segments: e,
          thetaStart: i,
          thetaLength: n
        },
        e = Math.max(3, e);
      const r = []
        , o = []
        , s = []
        , a = []
        , l = new di
        , h = new Fe;
      o.push(0, 0, 0),
        s.push(0, 0, 1),
        a.push(.5, .5);
      for (let r = 0, c = 3; r <= e; r++,
        c += 3) {
        const u = i + r / e * n;
        l.x = t * Math.cos(u),
          l.y = t * Math.sin(u),
          o.push(l.x, l.y, l.z),
          s.push(0, 0, 1),
          h.x = (o[c] / t + 1) / 2,
          h.y = (o[c + 1] / t + 1) / 2,
          a.push(h.x, h.y)
      }
      for (let t = 1; t <= e; t++)
        r.push(t, t + 1, 0);
      this.setIndex(r),
        this.setAttribute("position", new Dn(o, 3)),
        this.setAttribute("normal", new Dn(s, 3)),
        this.setAttribute("uv", new Dn(a, 2))
    }
    static fromJSON(t) {
      return new Gl(t.radius, t.segments, t.thetaStart, t.thetaLength)
    }
  }
  class Wl extends Wn {
    constructor(t = 1, e = 1, i = 1, n = 8, r = 1, o = !1, s = 0, a = 2 * Math.PI) {
      super(),
        this.type = "CylinderGeometry",
        this.parameters = {
          radiusTop: t,
          radiusBottom: e,
          height: i,
          radialSegments: n,
          heightSegments: r,
          openEnded: o,
          thetaStart: s,
          thetaLength: a
        };
      const l = this;
      n = Math.floor(n),
        r = Math.floor(r);
      const h = []
        , c = []
        , u = []
        , p = [];
      let d = 0;
      const f = []
        , g = i / 2;
      let m = 0;
      function y(i) {
        const r = d
          , o = new Fe
          , f = new di;
        let y = 0;
        const v = !0 === i ? t : e
          , A = !0 === i ? 1 : -1;
        for (let t = 1; t <= n; t++)
          c.push(0, g * A, 0),
            u.push(0, A, 0),
            p.push(.5, .5),
            d++;
        const b = d;
        for (let t = 0; t <= n; t++) {
          const e = t / n * a + s
            , i = Math.cos(e)
            , r = Math.sin(e);
          f.x = v * r,
            f.y = g * A,
            f.z = v * i,
            c.push(f.x, f.y, f.z),
            u.push(0, A, 0),
            o.x = .5 * i + .5,
            o.y = .5 * r * A + .5,
            p.push(o.x, o.y),
            d++
        }
        for (let t = 0; t < n; t++) {
          const e = r + t
            , n = b + t;
          !0 === i ? h.push(n, n + 1, e) : h.push(n + 1, n, e),
            y += 3
        }
        l.addGroup(m, y, !0 === i ? 1 : 2),
          m += y
      }
      !function () {
        const o = new di
          , y = new di;
        let v = 0;
        const A = (e - t) / i;
        for (let l = 0; l <= r; l++) {
          const h = []
            , m = l / r
            , v = m * (e - t) + t;
          for (let t = 0; t <= n; t++) {
            const e = t / n
              , r = e * a + s
              , l = Math.sin(r)
              , f = Math.cos(r);
            y.x = v * l,
              y.y = -m * i + g,
              y.z = v * f,
              c.push(y.x, y.y, y.z),
              o.set(l, A, f).normalize(),
              u.push(o.x, o.y, o.z),
              p.push(e, 1 - m),
              h.push(d++)
          }
          f.push(h)
        }
        for (let t = 0; t < n; t++)
          for (let e = 0; e < r; e++) {
            const i = f[e][t]
              , n = f[e + 1][t]
              , r = f[e + 1][t + 1]
              , o = f[e][t + 1];
            h.push(i, n, o),
              h.push(n, r, o),
              v += 6
          }
        l.addGroup(m, v, 0),
          m += v
      }(),
        !1 === o && (t > 0 && y(!0),
          e > 0 && y(!1)),
        this.setIndex(h),
        this.setAttribute("position", new Dn(c, 3)),
        this.setAttribute("normal", new Dn(u, 3)),
        this.setAttribute("uv", new Dn(p, 2))
    }
    static fromJSON(t) {
      return new Wl(t.radiusTop, t.radiusBottom, t.height, t.radialSegments, t.heightSegments, t.openEnded, t.thetaStart, t.thetaLength)
    }
  }
  class Jl extends Wl {
    constructor(t = 1, e = 1, i = 8, n = 1, r = !1, o = 0, s = 2 * Math.PI) {
      super(0, t, e, i, n, r, o, s),
        this.type = "ConeGeometry",
        this.parameters = {
          radius: t,
          height: e,
          radialSegments: i,
          heightSegments: n,
          openEnded: r,
          thetaStart: o,
          thetaLength: s
        }
    }
    static fromJSON(t) {
      return new Jl(t.radius, t.height, t.radialSegments, t.heightSegments, t.openEnded, t.thetaStart, t.thetaLength)
    }
  }
  class Hl extends Wn {
    constructor(t = [], e = [], i = 1, n = 0) {
      super(),
        this.type = "PolyhedronGeometry",
        this.parameters = {
          vertices: t,
          indices: e,
          radius: i,
          detail: n
        };
      const r = []
        , o = [];
      function s(t, e, i, n) {
        const r = n + 1
          , o = [];
        for (let n = 0; n <= r; n++) {
          o[n] = [];
          const s = t.clone().lerp(i, n / r)
            , a = e.clone().lerp(i, n / r)
            , l = r - n;
          for (let t = 0; t <= l; t++)
            o[n][t] = 0 === t && n === r ? s : s.clone().lerp(a, t / l)
        }
        for (let t = 0; t < r; t++)
          for (let e = 0; e < 2 * (r - t) - 1; e++) {
            const i = Math.floor(e / 2);
            e % 2 == 0 ? (a(o[t][i + 1]),
              a(o[t + 1][i]),
              a(o[t][i])) : (a(o[t][i + 1]),
                a(o[t + 1][i + 1]),
                a(o[t + 1][i]))
          }
      }
      function a(t) {
        r.push(t.x, t.y, t.z)
      }
      function l(e, i) {
        const n = 3 * e;
        i.x = t[n + 0],
          i.y = t[n + 1],
          i.z = t[n + 2]
      }
      function h(t, e, i, n) {
        n < 0 && 1 === t.x && (o[e] = t.x - 1),
          0 === i.x && 0 === i.z && (o[e] = n / 2 / Math.PI + .5)
      }
      function c(t) {
        return Math.atan2(t.z, -t.x)
      }
      !function (t) {
        const i = new di
          , n = new di
          , r = new di;
        for (let o = 0; o < e.length; o += 3)
          l(e[o + 0], i),
            l(e[o + 1], n),
            l(e[o + 2], r),
            s(i, n, r, t)
      }(n),
        function (t) {
          const e = new di;
          for (let i = 0; i < r.length; i += 3)
            e.x = r[i + 0],
              e.y = r[i + 1],
              e.z = r[i + 2],
              e.normalize().multiplyScalar(t),
              r[i + 0] = e.x,
              r[i + 1] = e.y,
              r[i + 2] = e.z
        }(i),
        function () {
          const t = new di;
          for (let i = 0; i < r.length; i += 3) {
            t.x = r[i + 0],
              t.y = r[i + 1],
              t.z = r[i + 2];
            const n = c(t) / 2 / Math.PI + .5
              , s = (e = t,
                Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) / Math.PI + .5);
            o.push(n, 1 - s)
          }
          var e;
          (function () {
            const t = new di
              , e = new di
              , i = new di
              , n = new di
              , s = new Fe
              , a = new Fe
              , l = new Fe;
            for (let u = 0, p = 0; u < r.length; u += 9,
              p += 6) {
              t.set(r[u + 0], r[u + 1], r[u + 2]),
                e.set(r[u + 3], r[u + 4], r[u + 5]),
                i.set(r[u + 6], r[u + 7], r[u + 8]),
                s.set(o[p + 0], o[p + 1]),
                a.set(o[p + 2], o[p + 3]),
                l.set(o[p + 4], o[p + 5]),
                n.copy(t).add(e).add(i).divideScalar(3);
              const d = c(n);
              h(s, p + 0, t, d),
                h(a, p + 2, e, d),
                h(l, p + 4, i, d)
            }
          }
          )(),
            function () {
              for (let t = 0; t < o.length; t += 6) {
                const e = o[t + 0]
                  , i = o[t + 2]
                  , n = o[t + 4]
                  , r = Math.max(e, i, n)
                  , s = Math.min(e, i, n);
                r > .9 && s < .1 && (e < .2 && (o[t + 0] += 1),
                  i < .2 && (o[t + 2] += 1),
                  n < .2 && (o[t + 4] += 1))
              }
            }()
        }(),
        this.setAttribute("position", new Dn(r, 3)),
        this.setAttribute("normal", new Dn(r.slice(), 3)),
        this.setAttribute("uv", new Dn(o, 2)),
        0 === n ? this.computeVertexNormals() : this.normalizeNormals()
    }
    static fromJSON(t) {
      return new Hl(t.vertices, t.indices, t.radius, t.details)
    }
  }
  class Zl extends Hl {
    constructor(t = 1, e = 0) {
      const i = (1 + Math.sqrt(5)) / 2
        , n = 1 / i;
      super([-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, 0, -i, 0, -n, i, 0, -n, -i, 0, n, i, 0, n], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, e),
        this.type = "DodecahedronGeometry",
        this.parameters = {
          radius: t,
          detail: e
        }
    }
    static fromJSON(t) {
      return new Zl(t.radius, t.detail)
    }
  }
  const Ql = new di
    , Kl = new di
    , Yl = new di
    , ql = new Mn;
  class Xl extends Wn {
    constructor(t = null, e = 1) {
      if (super(),
        this.type = "EdgesGeometry",
        this.parameters = {
          geometry: t,
          thresholdAngle: e
        },
        null !== t) {
        const i = 4
          , n = Math.pow(10, i)
          , r = Math.cos(Ee * e)
          , o = t.getIndex()
          , s = t.getAttribute("position")
          , a = o ? o.count : s.count
          , l = [0, 0, 0]
          , h = ["a", "b", "c"]
          , c = new Array(3)
          , u = {}
          , p = [];
        for (let t = 0; t < a; t += 3) {
          o ? (l[0] = o.getX(t),
            l[1] = o.getX(t + 1),
            l[2] = o.getX(t + 2)) : (l[0] = t,
              l[1] = t + 1,
              l[2] = t + 2);
          const { a: e, b: i, c: a } = ql;
          if (e.fromBufferAttribute(s, l[0]),
            i.fromBufferAttribute(s, l[1]),
            a.fromBufferAttribute(s, l[2]),
            ql.getNormal(Yl),
            c[0] = `${Math.round(e.x * n)},${Math.round(e.y * n)},${Math.round(e.z * n)}`,
            c[1] = `${Math.round(i.x * n)},${Math.round(i.y * n)},${Math.round(i.z * n)}`,
            c[2] = `${Math.round(a.x * n)},${Math.round(a.y * n)},${Math.round(a.z * n)}`,
            c[0] !== c[1] && c[1] !== c[2] && c[2] !== c[0])
            for (let t = 0; t < 3; t++) {
              const e = (t + 1) % 3
                , i = c[t]
                , n = c[e]
                , o = ql[h[t]]
                , s = ql[h[e]]
                , a = `${i}_${n}`
                , d = `${n}_${i}`;
              d in u && u[d] ? (Yl.dot(u[d].normal) <= r && (p.push(o.x, o.y, o.z),
                p.push(s.x, s.y, s.z)),
                u[d] = null) : a in u || (u[a] = {
                  index0: l[t],
                  index1: l[e],
                  normal: Yl.clone()
                })
            }
        }
        for (const t in u)
          if (u[t]) {
            const { index0: e, index1: i } = u[t];
            Ql.fromBufferAttribute(s, e),
              Kl.fromBufferAttribute(s, i),
              p.push(Ql.x, Ql.y, Ql.z),
              p.push(Kl.x, Kl.y, Kl.z)
          }
        this.setAttribute("position", new Dn(p, 3))
      }
    }
  }
  class $l extends Bl {
    constructor(t) {
      super(t),
        this.uuid = Re(),
        this.type = "Shape",
        this.holes = []
    }
    getPointsHoles(t) {
      const e = [];
      for (let i = 0, n = this.holes.length; i < n; i++)
        e[i] = this.holes[i].getPoints(t);
      return e
    }
    extractPoints(t) {
      return {
        shape: this.getPoints(t),
        holes: this.getPointsHoles(t)
      }
    }
    copy(t) {
      super.copy(t),
        this.holes = [];
      for (let e = 0, i = t.holes.length; e < i; e++) {
        const i = t.holes[e];
        this.holes.push(i.clone())
      }
      return this
    }
    toJSON() {
      const t = super.toJSON();
      t.uuid = this.uuid,
        t.holes = [];
      for (let e = 0, i = this.holes.length; e < i; e++) {
        const i = this.holes[e];
        t.holes.push(i.toJSON())
      }
      return t
    }
    fromJSON(t) {
      super.fromJSON(t),
        this.uuid = t.uuid,
        this.holes = [];
      for (let e = 0, i = t.holes.length; e < i; e++) {
        const i = t.holes[e];
        this.holes.push((new Bl).fromJSON(i))
      }
      return this
    }
  }
  const th = function (t, e, i = 2) {
    const n = e && e.length
      , r = n ? e[0] * i : t.length;
    let o = eh(t, 0, r, i, !0);
    const s = [];
    if (!o || o.next === o.prev)
      return s;
    let a, l, h, c, u, p, d;
    if (n && (o = function (t, e, i, n) {
      const r = [];
      let o, s, a, l, h;
      for (o = 0,
        s = e.length; o < s; o++)
        a = e[o] * n,
          l = o < s - 1 ? e[o + 1] * n : t.length,
          h = eh(t, a, l, n, !1),
          h === h.next && (h.steiner = !0),
          r.push(ph(h));
      for (r.sort(lh),
        o = 0; o < r.length; o++)
        hh(r[o], i),
          i = ih(i, i.next);
      return i
    }(t, e, o, i)),
      t.length > 80 * i) {
      a = h = t[0],
        l = c = t[1];
      for (let e = i; e < r; e += i)
        u = t[e],
          p = t[e + 1],
          u < a && (a = u),
          p < l && (l = p),
          u > h && (h = u),
          p > c && (c = p);
      d = Math.max(h - a, c - l),
        d = 0 !== d ? 1 / d : 0
    }
    return nh(o, s, i, a, l, d),
      s
  };
  function eh(t, e, i, n, r) {
    let o, s;
    if (r === function (t, e, i, n) {
      let r = 0;
      for (let o = e, s = i - n; o < i; o += n)
        r += (t[s] - t[o]) * (t[o + 1] + t[s + 1]),
          s = o;
      return r
    }(t, e, i, n) > 0)
      for (o = e; o < i; o += n)
        s = Ih(o, t[o], t[o + 1], s);
    else
      for (o = i - n; o >= e; o -= n)
        s = Ih(o, t[o], t[o + 1], s);
    return s && mh(s, s.next) && (Ch(s),
      s = s.next),
      s
  }
  function ih(t, e) {
    if (!t)
      return t;
    e || (e = t);
    let i, n = t;
    do {
      if (i = !1,
        n.steiner || !mh(n, n.next) && 0 !== gh(n.prev, n, n.next))
        n = n.next;
      else {
        if (Ch(n),
          n = e = n.prev,
          n === n.next)
          break;
        i = !0
      }
    } while (i || n !== e);
    return e
  }
  function nh(t, e, i, n, r, o, s) {
    if (!t)
      return;
    !s && o && function (t, e, i, n) {
      let r = t;
      do {
        null === r.z && (r.z = uh(r.x, r.y, e, i, n)),
          r.prevZ = r.prev,
          r.nextZ = r.next,
          r = r.next
      } while (r !== t);
      r.prevZ.nextZ = null,
        r.prevZ = null,
        function (t) {
          let e, i, n, r, o, s, a, l, h = 1;
          do {
            for (i = t,
              t = null,
              o = null,
              s = 0; i;) {
              for (s++,
                n = i,
                a = 0,
                e = 0; e < h && (a++,
                  n = n.nextZ,
                  n); e++)
                ;
              for (l = h; a > 0 || l > 0 && n;)
                0 !== a && (0 === l || !n || i.z <= n.z) ? (r = i,
                  i = i.nextZ,
                  a--) : (r = n,
                    n = n.nextZ,
                    l--),
                  o ? o.nextZ = r : t = r,
                  r.prevZ = o,
                  o = r;
              i = n
            }
            o.nextZ = null,
              h *= 2
          } while (s > 1)
        }(r)
    }(t, n, r, o);
    let a, l, h = t;
    for (; t.prev !== t.next;)
      if (a = t.prev,
        l = t.next,
        o ? oh(t, n, r, o) : rh(t))
        e.push(a.i / i),
          e.push(t.i / i),
          e.push(l.i / i),
          Ch(t),
          t = l.next,
          h = l.next;
      else if ((t = l) === h) {
        s ? 1 === s ? nh(t = sh(ih(t), e, i), e, i, n, r, o, 2) : 2 === s && ah(t, e, i, n, r, o) : nh(ih(t), e, i, n, r, o, 1);
        break
      }
  }
  function rh(t) {
    const e = t.prev
      , i = t
      , n = t.next;
    if (gh(e, i, n) >= 0)
      return !1;
    let r = t.next.next;
    for (; r !== t.prev;) {
      if (dh(e.x, e.y, i.x, i.y, n.x, n.y, r.x, r.y) && gh(r.prev, r, r.next) >= 0)
        return !1;
      r = r.next
    }
    return !0
  }
  function oh(t, e, i, n) {
    const r = t.prev
      , o = t
      , s = t.next;
    if (gh(r, o, s) >= 0)
      return !1;
    const a = r.x < o.x ? r.x < s.x ? r.x : s.x : o.x < s.x ? o.x : s.x
      , l = r.y < o.y ? r.y < s.y ? r.y : s.y : o.y < s.y ? o.y : s.y
      , h = r.x > o.x ? r.x > s.x ? r.x : s.x : o.x > s.x ? o.x : s.x
      , c = r.y > o.y ? r.y > s.y ? r.y : s.y : o.y > s.y ? o.y : s.y
      , u = uh(a, l, e, i, n)
      , p = uh(h, c, e, i, n);
    let d = t.prevZ
      , f = t.nextZ;
    for (; d && d.z >= u && f && f.z <= p;) {
      if (d !== t.prev && d !== t.next && dh(r.x, r.y, o.x, o.y, s.x, s.y, d.x, d.y) && gh(d.prev, d, d.next) >= 0)
        return !1;
      if (d = d.prevZ,
        f !== t.prev && f !== t.next && dh(r.x, r.y, o.x, o.y, s.x, s.y, f.x, f.y) && gh(f.prev, f, f.next) >= 0)
        return !1;
      f = f.nextZ
    }
    for (; d && d.z >= u;) {
      if (d !== t.prev && d !== t.next && dh(r.x, r.y, o.x, o.y, s.x, s.y, d.x, d.y) && gh(d.prev, d, d.next) >= 0)
        return !1;
      d = d.prevZ
    }
    for (; f && f.z <= p;) {
      if (f !== t.prev && f !== t.next && dh(r.x, r.y, o.x, o.y, s.x, s.y, f.x, f.y) && gh(f.prev, f, f.next) >= 0)
        return !1;
      f = f.nextZ
    }
    return !0
  }
  function sh(t, e, i) {
    let n = t;
    do {
      const r = n.prev
        , o = n.next.next;
      !mh(r, o) && yh(r, n, n.next, o) && bh(r, o) && bh(o, r) && (e.push(r.i / i),
        e.push(n.i / i),
        e.push(o.i / i),
        Ch(n),
        Ch(n.next),
        n = t = o),
        n = n.next
    } while (n !== t);
    return ih(n)
  }
  function ah(t, e, i, n, r, o) {
    let s = t;
    do {
      let t = s.next.next;
      for (; t !== s.prev;) {
        if (s.i !== t.i && fh(s, t)) {
          let a = xh(s, t);
          return s = ih(s, s.next),
            a = ih(a, a.next),
            nh(s, e, i, n, r, o),
            void nh(a, e, i, n, r, o)
        }
        t = t.next
      }
      s = s.next
    } while (s !== t)
  }
  function lh(t, e) {
    return t.x - e.x
  }
  function hh(t, e) {
    if (e = function (t, e) {
      let i = e;
      const n = t.x
        , r = t.y;
      let o, s = -1 / 0;
      do {
        if (r <= i.y && r >= i.next.y && i.next.y !== i.y) {
          const t = i.x + (r - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
          if (t <= n && t > s) {
            if (s = t,
              t === n) {
              if (r === i.y)
                return i;
              if (r === i.next.y)
                return i.next
            }
            o = i.x < i.next.x ? i : i.next
          }
        }
        i = i.next
      } while (i !== e);
      if (!o)
        return null;
      if (n === s)
        return o;
      const a = o
        , l = o.x
        , h = o.y;
      let c, u = 1 / 0;
      i = o;
      do {
        n >= i.x && i.x >= l && n !== i.x && dh(r < h ? n : s, r, l, h, r < h ? s : n, r, i.x, i.y) && (c = Math.abs(r - i.y) / (n - i.x),
          bh(i, t) && (c < u || c === u && (i.x > o.x || i.x === o.x && ch(o, i))) && (o = i,
            u = c)),
          i = i.next
      } while (i !== a);
      return o
    }(t, e),
      e) {
      const i = xh(e, t);
      ih(e, e.next),
        ih(i, i.next)
    }
  }
  function ch(t, e) {
    return gh(t.prev, t, e.prev) < 0 && gh(e.next, t, t.next) < 0
  }
  function uh(t, e, i, n, r) {
    return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
  }
  function ph(t) {
    let e = t
      , i = t;
    do {
      (e.x < i.x || e.x === i.x && e.y < i.y) && (i = e),
        e = e.next
    } while (e !== t);
    return i
  }
  function dh(t, e, i, n, r, o, s, a) {
    return (r - s) * (e - a) - (t - s) * (o - a) >= 0 && (t - s) * (n - a) - (i - s) * (e - a) >= 0 && (i - s) * (o - a) - (r - s) * (n - a) >= 0
  }
  function fh(t, e) {
    return t.next.i !== e.i && t.prev.i !== e.i && !function (t, e) {
      let i = t;
      do {
        if (i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && yh(i, i.next, t, e))
          return !0;
        i = i.next
      } while (i !== t);
      return !1
    }(t, e) && (bh(t, e) && bh(e, t) && function (t, e) {
      let i = t
        , n = !1;
      const r = (t.x + e.x) / 2
        , o = (t.y + e.y) / 2;
      do {
        i.y > o != i.next.y > o && i.next.y !== i.y && r < (i.next.x - i.x) * (o - i.y) / (i.next.y - i.y) + i.x && (n = !n),
          i = i.next
      } while (i !== t);
      return n
    }(t, e) && (gh(t.prev, t, e.prev) || gh(t, e.prev, e)) || mh(t, e) && gh(t.prev, t, t.next) > 0 && gh(e.prev, e, e.next) > 0)
  }
  function gh(t, e, i) {
    return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y)
  }
  function mh(t, e) {
    return t.x === e.x && t.y === e.y
  }
  function yh(t, e, i, n) {
    const r = Ah(gh(t, e, i))
      , o = Ah(gh(t, e, n))
      , s = Ah(gh(i, n, t))
      , a = Ah(gh(i, n, e));
    return r !== o && s !== a || (!(0 !== r || !vh(t, i, e)) || (!(0 !== o || !vh(t, n, e)) || (!(0 !== s || !vh(i, t, n)) || !(0 !== a || !vh(i, e, n)))))
  }
  function vh(t, e, i) {
    return e.x <= Math.max(t.x, i.x) && e.x >= Math.min(t.x, i.x) && e.y <= Math.max(t.y, i.y) && e.y >= Math.min(t.y, i.y)
  }
  function Ah(t) {
    return t > 0 ? 1 : t < 0 ? -1 : 0
  }
  function bh(t, e) {
    return gh(t.prev, t, t.next) < 0 ? gh(t, e, t.next) >= 0 && gh(t, t.prev, e) >= 0 : gh(t, e, t.prev) < 0 || gh(t, t.next, e) < 0
  }
  function xh(t, e) {
    const i = new wh(t.i, t.x, t.y)
      , n = new wh(e.i, e.x, e.y)
      , r = t.next
      , o = e.prev;
    return t.next = e,
      e.prev = t,
      i.next = r,
      r.prev = i,
      n.next = i,
      i.prev = n,
      o.next = n,
      n.prev = o,
      n
  }
  function Ih(t, e, i, n) {
    const r = new wh(t, e, i);
    return n ? (r.next = n.next,
      r.prev = n,
      n.next.prev = r,
      n.next = r) : (r.prev = r,
        r.next = r),
      r
  }
  function Ch(t) {
    t.next.prev = t.prev,
      t.prev.next = t.next,
      t.prevZ && (t.prevZ.nextZ = t.nextZ),
      t.nextZ && (t.nextZ.prevZ = t.prevZ)
  }
  function wh(t, e, i) {
    this.i = t,
      this.x = e,
      this.y = i,
      this.prev = null,
      this.next = null,
      this.z = null,
      this.prevZ = null,
      this.nextZ = null,
      this.steiner = !1
  }
  class _h {
    static area(t) {
      const e = t.length;
      let i = 0;
      for (let n = e - 1, r = 0; r < e; n = r++)
        i += t[n].x * t[r].y - t[r].x * t[n].y;
      return .5 * i
    }
    static isClockWise(t) {
      return _h.area(t) < 0
    }
    static triangulateShape(t, e) {
      const i = []
        , n = []
        , r = [];
      Sh(t),
        Mh(i, t);
      let o = t.length;
      e.forEach(Sh);
      for (let t = 0; t < e.length; t++)
        n.push(o),
          o += e[t].length,
          Mh(i, e[t]);
      const s = th(i, n);
      for (let t = 0; t < s.length; t += 3)
        r.push(s.slice(t, t + 3));
      return r
    }
  }
  function Sh(t) {
    const e = t.length;
    e > 2 && t[e - 1].equals(t[0]) && t.pop()
  }
  function Mh(t, e) {
    for (let i = 0; i < e.length; i++)
      t.push(e[i].x),
        t.push(e[i].y)
  }
  class Th extends Wn {
    constructor(t = new $l([new Fe(.5, .5), new Fe(-.5, .5), new Fe(-.5, -.5), new Fe(.5, -.5)]), e = {}) {
      super(),
        this.type = "ExtrudeGeometry",
        this.parameters = {
          shapes: t,
          options: e
        },
        t = Array.isArray(t) ? t : [t];
      const i = this
        , n = []
        , r = [];
      for (let e = 0, i = t.length; e < i; e++) {
        o(t[e])
      }
      function o(t) {
        const o = []
          , s = void 0 !== e.curveSegments ? e.curveSegments : 12
          , a = void 0 !== e.steps ? e.steps : 1;
        let l = void 0 !== e.depth ? e.depth : 1
          , h = void 0 === e.bevelEnabled || e.bevelEnabled
          , c = void 0 !== e.bevelThickness ? e.bevelThickness : .2
          , u = void 0 !== e.bevelSize ? e.bevelSize : c - .1
          , p = void 0 !== e.bevelOffset ? e.bevelOffset : 0
          , d = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
        const f = e.extrudePath
          , g = void 0 !== e.UVGenerator ? e.UVGenerator : Eh;
        void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),
          l = e.amount);
        let m, y, v, A, b, x = !1;
        f && (m = f.getSpacedPoints(a),
          x = !0,
          h = !1,
          y = f.computeFrenetFrames(a, !1),
          v = new di,
          A = new di,
          b = new di),
          h || (d = 0,
            c = 0,
            u = 0,
            p = 0);
        const I = t.extractPoints(s);
        let C = I.shape;
        const w = I.holes;
        if (!_h.isClockWise(C)) {
          C = C.reverse();
          for (let t = 0, e = w.length; t < e; t++) {
            const e = w[t];
            _h.isClockWise(e) && (w[t] = e.reverse())
          }
        }
        const _ = _h.triangulateShape(C, w)
          , S = C;
        for (let t = 0, e = w.length; t < e; t++) {
          const e = w[t];
          C = C.concat(e)
        }
        function M(t, e, i) {
          return e || console.error("THREE.ExtrudeGeometry: vec does not exist"),
            e.clone().multiplyScalar(i).add(t)
        }
        const T = C.length
          , E = _.length;
        function k(t, e, i) {
          let n, r, o;
          const s = t.x - e.x
            , a = t.y - e.y
            , l = i.x - t.x
            , h = i.y - t.y
            , c = s * s + a * a
            , u = s * h - a * l;
          if (Math.abs(u) > Number.EPSILON) {
            const u = Math.sqrt(c)
              , p = Math.sqrt(l * l + h * h)
              , d = e.x - a / u
              , f = e.y + s / u
              , g = ((i.x - h / p - d) * h - (i.y + l / p - f) * l) / (s * h - a * l);
            n = d + s * g - t.x,
              r = f + a * g - t.y;
            const m = n * n + r * r;
            if (m <= 2)
              return new Fe(n, r);
            o = Math.sqrt(m / 2)
          } else {
            let t = !1;
            s > Number.EPSILON ? l > Number.EPSILON && (t = !0) : s < -Number.EPSILON ? l < -Number.EPSILON && (t = !0) : Math.sign(a) === Math.sign(h) && (t = !0),
              t ? (n = -a,
                r = s,
                o = Math.sqrt(c)) : (n = s,
                  r = a,
                  o = Math.sqrt(c / 2))
          }
          return new Fe(n / o, r / o)
        }
        const R = [];
        for (let t = 0, e = S.length, i = e - 1, n = t + 1; t < e; t++,
          i++,
          n++)
          i === e && (i = 0),
            n === e && (n = 0),
            R[t] = k(S[t], S[i], S[n]);
        const L = [];
        let P, z = R.concat();
        for (let t = 0, e = w.length; t < e; t++) {
          const e = w[t];
          P = [];
          for (let t = 0, i = e.length, n = i - 1, r = t + 1; t < i; t++,
            n++,
            r++)
            n === i && (n = 0),
              r === i && (r = 0),
              P[t] = k(e[t], e[n], e[r]);
          L.push(P),
            z = z.concat(P)
        }
        for (let t = 0; t < d; t++) {
          const e = t / d
            , i = c * Math.cos(e * Math.PI / 2)
            , n = u * Math.sin(e * Math.PI / 2) + p;
          for (let t = 0, e = S.length; t < e; t++) {
            const e = M(S[t], R[t], n);
            U(e.x, e.y, -i)
          }
          for (let t = 0, e = w.length; t < e; t++) {
            const e = w[t];
            P = L[t];
            for (let t = 0, r = e.length; t < r; t++) {
              const r = M(e[t], P[t], n);
              U(r.x, r.y, -i)
            }
          }
        }
        const O = u + p;
        for (let t = 0; t < T; t++) {
          const e = h ? M(C[t], z[t], O) : C[t];
          x ? (A.copy(y.normals[0]).multiplyScalar(e.x),
            v.copy(y.binormals[0]).multiplyScalar(e.y),
            b.copy(m[0]).add(A).add(v),
            U(b.x, b.y, b.z)) : U(e.x, e.y, 0)
        }
        for (let t = 1; t <= a; t++)
          for (let e = 0; e < T; e++) {
            const i = h ? M(C[e], z[e], O) : C[e];
            x ? (A.copy(y.normals[t]).multiplyScalar(i.x),
              v.copy(y.binormals[t]).multiplyScalar(i.y),
              b.copy(m[t]).add(A).add(v),
              U(b.x, b.y, b.z)) : U(i.x, i.y, l / a * t)
          }
        for (let t = d - 1; t >= 0; t--) {
          const e = t / d
            , i = c * Math.cos(e * Math.PI / 2)
            , n = u * Math.sin(e * Math.PI / 2) + p;
          for (let t = 0, e = S.length; t < e; t++) {
            const e = M(S[t], R[t], n);
            U(e.x, e.y, l + i)
          }
          for (let t = 0, e = w.length; t < e; t++) {
            const e = w[t];
            P = L[t];
            for (let t = 0, r = e.length; t < r; t++) {
              const r = M(e[t], P[t], n);
              x ? U(r.x, r.y + m[a - 1].y, m[a - 1].x + i) : U(r.x, r.y, l + i)
            }
          }
        }
        function D(t, e) {
          let i = t.length;
          for (; --i >= 0;) {
            const n = i;
            let r = i - 1;
            r < 0 && (r = t.length - 1);
            for (let t = 0, i = a + 2 * d; t < i; t++) {
              const i = T * t
                , o = T * (t + 1);
              F(e + n + i, e + r + i, e + r + o, e + n + o)
            }
          }
        }
        function U(t, e, i) {
          o.push(t),
            o.push(e),
            o.push(i)
        }
        function N(t, e, r) {
          B(t),
            B(e),
            B(r);
          const o = n.length / 3
            , s = g.generateTopUV(i, n, o - 3, o - 2, o - 1);
          j(s[0]),
            j(s[1]),
            j(s[2])
        }
        function F(t, e, r, o) {
          B(t),
            B(e),
            B(o),
            B(e),
            B(r),
            B(o);
          const s = n.length / 3
            , a = g.generateSideWallUV(i, n, s - 6, s - 3, s - 2, s - 1);
          j(a[0]),
            j(a[1]),
            j(a[3]),
            j(a[1]),
            j(a[2]),
            j(a[3])
        }
        function B(t) {
          n.push(o[3 * t + 0]),
            n.push(o[3 * t + 1]),
            n.push(o[3 * t + 2])
        }
        function j(t) {
          r.push(t.x),
            r.push(t.y)
        }
        !function () {
          const t = n.length / 3;
          if (h) {
            let t = 0
              , e = T * t;
            for (let t = 0; t < E; t++) {
              const i = _[t];
              N(i[2] + e, i[1] + e, i[0] + e)
            }
            t = a + 2 * d,
              e = T * t;
            for (let t = 0; t < E; t++) {
              const i = _[t];
              N(i[0] + e, i[1] + e, i[2] + e)
            }
          } else {
            for (let t = 0; t < E; t++) {
              const e = _[t];
              N(e[2], e[1], e[0])
            }
            for (let t = 0; t < E; t++) {
              const e = _[t];
              N(e[0] + T * a, e[1] + T * a, e[2] + T * a)
            }
          }
          i.addGroup(t, n.length / 3 - t, 0)
        }(),
          function () {
            const t = n.length / 3;
            let e = 0;
            D(S, e),
              e += S.length;
            for (let t = 0, i = w.length; t < i; t++) {
              const i = w[t];
              D(i, e),
                e += i.length
            }
            i.addGroup(t, n.length / 3 - t, 1)
          }()
      }
      this.setAttribute("position", new Dn(n, 3)),
        this.setAttribute("uv", new Dn(r, 2)),
        this.computeVertexNormals()
    }
    toJSON() {
      const t = super.toJSON();
      return function (t, e, i) {
        if (i.shapes = [],
          Array.isArray(t))
          for (let e = 0, n = t.length; e < n; e++) {
            const n = t[e];
            i.shapes.push(n.uuid)
          }
        else
          i.shapes.push(t.uuid);
        i.options = Object.assign({}, e),
          void 0 !== e.extrudePath && (i.options.extrudePath = e.extrudePath.toJSON());
        return i
      }(this.parameters.shapes, this.parameters.options, t)
    }
    static fromJSON(t, e) {
      const i = [];
      for (let n = 0, r = t.shapes.length; n < r; n++) {
        const r = e[t.shapes[n]];
        i.push(r)
      }
      const n = t.options.extrudePath;
      return void 0 !== n && (t.options.extrudePath = (new Nl[n.type]).fromJSON(n)),
        new Th(i, t.options)
    }
  }
  const Eh = {
    generateTopUV: function (t, e, i, n, r) {
      const o = e[3 * i]
        , s = e[3 * i + 1]
        , a = e[3 * n]
        , l = e[3 * n + 1]
        , h = e[3 * r]
        , c = e[3 * r + 1];
      return [new Fe(o, s), new Fe(a, l), new Fe(h, c)]
    },
    generateSideWallUV: function (t, e, i, n, r, o) {
      const s = e[3 * i]
        , a = e[3 * i + 1]
        , l = e[3 * i + 2]
        , h = e[3 * n]
        , c = e[3 * n + 1]
        , u = e[3 * n + 2]
        , p = e[3 * r]
        , d = e[3 * r + 1]
        , f = e[3 * r + 2]
        , g = e[3 * o]
        , m = e[3 * o + 1]
        , y = e[3 * o + 2];
      return Math.abs(a - c) < Math.abs(s - h) ? [new Fe(s, 1 - l), new Fe(h, 1 - u), new Fe(p, 1 - f), new Fe(g, 1 - y)] : [new Fe(a, 1 - l), new Fe(c, 1 - u), new Fe(d, 1 - f), new Fe(m, 1 - y)]
    }
  };
  class kh extends Hl {
    constructor(t = 1, e = 0) {
      const i = (1 + Math.sqrt(5)) / 2;
      super([-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e),
        this.type = "IcosahedronGeometry",
        this.parameters = {
          radius: t,
          detail: e
        }
    }
    static fromJSON(t) {
      return new kh(t.radius, t.detail)
    }
  }
  class Rh extends Hl {
    constructor(t = 1, e = 0) {
      super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e),
        this.type = "OctahedronGeometry",
        this.parameters = {
          radius: t,
          detail: e
        }
    }
    static fromJSON(t) {
      return new Rh(t.radius, t.detail)
    }
  }
  class Lh extends Wn {
    constructor(t = .5, e = 1, i = 8, n = 1, r = 0, o = 2 * Math.PI) {
      super(),
        this.type = "RingGeometry",
        this.parameters = {
          innerRadius: t,
          outerRadius: e,
          thetaSegments: i,
          phiSegments: n,
          thetaStart: r,
          thetaLength: o
        },
        i = Math.max(3, i);
      const s = []
        , a = []
        , l = []
        , h = [];
      let c = t;
      const u = (e - t) / (n = Math.max(1, n))
        , p = new di
        , d = new Fe;
      for (let t = 0; t <= n; t++) {
        for (let t = 0; t <= i; t++) {
          const n = r + t / i * o;
          p.x = c * Math.cos(n),
            p.y = c * Math.sin(n),
            a.push(p.x, p.y, p.z),
            l.push(0, 0, 1),
            d.x = (p.x / e + 1) / 2,
            d.y = (p.y / e + 1) / 2,
            h.push(d.x, d.y)
        }
        c += u
      }
      for (let t = 0; t < n; t++) {
        const e = t * (i + 1);
        for (let t = 0; t < i; t++) {
          const n = t + e
            , r = n
            , o = n + i + 1
            , a = n + i + 2
            , l = n + 1;
          s.push(r, o, l),
            s.push(o, a, l)
        }
      }
      this.setIndex(s),
        this.setAttribute("position", new Dn(a, 3)),
        this.setAttribute("normal", new Dn(l, 3)),
        this.setAttribute("uv", new Dn(h, 2))
    }
    static fromJSON(t) {
      return new Lh(t.innerRadius, t.outerRadius, t.thetaSegments, t.phiSegments, t.thetaStart, t.thetaLength)
    }
  }
  class Ph extends Wn {
    constructor(t = new $l([new Fe(0, .5), new Fe(-.5, -.5), new Fe(.5, -.5)]), e = 12) {
      super(),
        this.type = "ShapeGeometry",
        this.parameters = {
          shapes: t,
          curveSegments: e
        };
      const i = []
        , n = []
        , r = []
        , o = [];
      let s = 0
        , a = 0;
      if (!1 === Array.isArray(t))
        l(t);
      else
        for (let e = 0; e < t.length; e++)
          l(t[e]),
            this.addGroup(s, a, e),
            s += a,
            a = 0;
      function l(t) {
        const s = n.length / 3
          , l = t.extractPoints(e);
        let h = l.shape;
        const c = l.holes;
        !1 === _h.isClockWise(h) && (h = h.reverse());
        for (let t = 0, e = c.length; t < e; t++) {
          const e = c[t];
          !0 === _h.isClockWise(e) && (c[t] = e.reverse())
        }
        const u = _h.triangulateShape(h, c);
        for (let t = 0, e = c.length; t < e; t++) {
          const e = c[t];
          h = h.concat(e)
        }
        for (let t = 0, e = h.length; t < e; t++) {
          const e = h[t];
          n.push(e.x, e.y, 0),
            r.push(0, 0, 1),
            o.push(e.x, e.y)
        }
        for (let t = 0, e = u.length; t < e; t++) {
          const e = u[t]
            , n = e[0] + s
            , r = e[1] + s
            , o = e[2] + s;
          i.push(n, r, o),
            a += 3
        }
      }
      this.setIndex(i),
        this.setAttribute("position", new Dn(n, 3)),
        this.setAttribute("normal", new Dn(r, 3)),
        this.setAttribute("uv", new Dn(o, 2))
    }
    toJSON() {
      const t = super.toJSON();
      return function (t, e) {
        if (e.shapes = [],
          Array.isArray(t))
          for (let i = 0, n = t.length; i < n; i++) {
            const n = t[i];
            e.shapes.push(n.uuid)
          }
        else
          e.shapes.push(t.uuid);
        return e
      }(this.parameters.shapes, t)
    }
    static fromJSON(t, e) {
      const i = [];
      for (let n = 0, r = t.shapes.length; n < r; n++) {
        const r = e[t.shapes[n]];
        i.push(r)
      }
      return new Ph(i, t.curveSegments)
    }
  }
  class zh extends Wn {
    constructor(t = 1, e = 32, i = 16, n = 0, r = 2 * Math.PI, o = 0, s = Math.PI) {
      super(),
        this.type = "SphereGeometry",
        this.parameters = {
          radius: t,
          widthSegments: e,
          heightSegments: i,
          phiStart: n,
          phiLength: r,
          thetaStart: o,
          thetaLength: s
        },
        e = Math.max(3, Math.floor(e)),
        i = Math.max(2, Math.floor(i));
      const a = Math.min(o + s, Math.PI);
      let l = 0;
      const h = []
        , c = new di
        , u = new di
        , p = []
        , d = []
        , f = []
        , g = [];
      for (let p = 0; p <= i; p++) {
        const m = []
          , y = p / i;
        let v = 0;
        0 == p && 0 == o ? v = .5 / e : p == i && a == Math.PI && (v = -.5 / e);
        for (let i = 0; i <= e; i++) {
          const a = i / e;
          c.x = -t * Math.cos(n + a * r) * Math.sin(o + y * s),
            c.y = t * Math.cos(o + y * s),
            c.z = t * Math.sin(n + a * r) * Math.sin(o + y * s),
            d.push(c.x, c.y, c.z),
            u.copy(c).normalize(),
            f.push(u.x, u.y, u.z),
            g.push(a + v, 1 - y),
            m.push(l++)
        }
        h.push(m)
      }
      for (let t = 0; t < i; t++)
        for (let n = 0; n < e; n++) {
          const e = h[t][n + 1]
            , r = h[t][n]
            , s = h[t + 1][n]
            , l = h[t + 1][n + 1];
          (0 !== t || o > 0) && p.push(e, r, l),
            (t !== i - 1 || a < Math.PI) && p.push(r, s, l)
        }
      this.setIndex(p),
        this.setAttribute("position", new Dn(d, 3)),
        this.setAttribute("normal", new Dn(f, 3)),
        this.setAttribute("uv", new Dn(g, 2))
    }
    static fromJSON(t) {
      return new zh(t.radius, t.widthSegments, t.heightSegments, t.phiStart, t.phiLength, t.thetaStart, t.thetaLength)
    }
  }
  class Oh extends Hl {
    constructor(t = 1, e = 0) {
      super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e),
        this.type = "TetrahedronGeometry",
        this.parameters = {
          radius: t,
          detail: e
        }
    }
    static fromJSON(t) {
      return new Oh(t.radius, t.detail)
    }
  }
  class Dh extends Wn {
    constructor(t = 1, e = .4, i = 8, n = 6, r = 2 * Math.PI) {
      super(),
        this.type = "TorusGeometry",
        this.parameters = {
          radius: t,
          tube: e,
          radialSegments: i,
          tubularSegments: n,
          arc: r
        },
        i = Math.floor(i),
        n = Math.floor(n);
      const o = []
        , s = []
        , a = []
        , l = []
        , h = new di
        , c = new di
        , u = new di;
      for (let o = 0; o <= i; o++)
        for (let p = 0; p <= n; p++) {
          const d = p / n * r
            , f = o / i * Math.PI * 2;
          c.x = (t + e * Math.cos(f)) * Math.cos(d),
            c.y = (t + e * Math.cos(f)) * Math.sin(d),
            c.z = e * Math.sin(f),
            s.push(c.x, c.y, c.z),
            h.x = t * Math.cos(d),
            h.y = t * Math.sin(d),
            u.subVectors(c, h).normalize(),
            a.push(u.x, u.y, u.z),
            l.push(p / n),
            l.push(o / i)
        }
      for (let t = 1; t <= i; t++)
        for (let e = 1; e <= n; e++) {
          const i = (n + 1) * t + e - 1
            , r = (n + 1) * (t - 1) + e - 1
            , s = (n + 1) * (t - 1) + e
            , a = (n + 1) * t + e;
          o.push(i, r, a),
            o.push(r, s, a)
        }
      this.setIndex(o),
        this.setAttribute("position", new Dn(s, 3)),
        this.setAttribute("normal", new Dn(a, 3)),
        this.setAttribute("uv", new Dn(l, 2))
    }
    static fromJSON(t) {
      return new Dh(t.radius, t.tube, t.radialSegments, t.tubularSegments, t.arc)
    }
  }
  class Uh extends Wn {
    constructor(t = 1, e = .4, i = 64, n = 8, r = 2, o = 3) {
      super(),
        this.type = "TorusKnotGeometry",
        this.parameters = {
          radius: t,
          tube: e,
          tubularSegments: i,
          radialSegments: n,
          p: r,
          q: o
        },
        i = Math.floor(i),
        n = Math.floor(n);
      const s = []
        , a = []
        , l = []
        , h = []
        , c = new di
        , u = new di
        , p = new di
        , d = new di
        , f = new di
        , g = new di
        , m = new di;
      for (let s = 0; s <= i; ++s) {
        const v = s / i * r * Math.PI * 2;
        y(v, r, o, t, p),
          y(v + .01, r, o, t, d),
          g.subVectors(d, p),
          m.addVectors(d, p),
          f.crossVectors(g, m),
          m.crossVectors(f, g),
          f.normalize(),
          m.normalize();
        for (let t = 0; t <= n; ++t) {
          const r = t / n * Math.PI * 2
            , o = -e * Math.cos(r)
            , d = e * Math.sin(r);
          c.x = p.x + (o * m.x + d * f.x),
            c.y = p.y + (o * m.y + d * f.y),
            c.z = p.z + (o * m.z + d * f.z),
            a.push(c.x, c.y, c.z),
            u.subVectors(c, p).normalize(),
            l.push(u.x, u.y, u.z),
            h.push(s / i),
            h.push(t / n)
        }
      }
      for (let t = 1; t <= i; t++)
        for (let e = 1; e <= n; e++) {
          const i = (n + 1) * (t - 1) + (e - 1)
            , r = (n + 1) * t + (e - 1)
            , o = (n + 1) * t + e
            , a = (n + 1) * (t - 1) + e;
          s.push(i, r, a),
            s.push(r, o, a)
        }
      function y(t, e, i, n, r) {
        const o = Math.cos(t)
          , s = Math.sin(t)
          , a = i / e * t
          , l = Math.cos(a);
        r.x = n * (2 + l) * .5 * o,
          r.y = n * (2 + l) * s * .5,
          r.z = n * Math.sin(a) * .5
      }
      this.setIndex(s),
        this.setAttribute("position", new Dn(a, 3)),
        this.setAttribute("normal", new Dn(l, 3)),
        this.setAttribute("uv", new Dn(h, 2))
    }
    static fromJSON(t) {
      return new Uh(t.radius, t.tube, t.tubularSegments, t.radialSegments, t.p, t.q)
    }
  }
  class Nh extends Wn {
    constructor(t = new Dl(new di(-1, -1, 0), new di(-1, 1, 0), new di(1, 1, 0)), e = 64, i = 1, n = 8, r = !1) {
      super(),
        this.type = "TubeGeometry",
        this.parameters = {
          path: t,
          tubularSegments: e,
          radius: i,
          radialSegments: n,
          closed: r
        };
      const o = t.computeFrenetFrames(e, r);
      this.tangents = o.tangents,
        this.normals = o.normals,
        this.binormals = o.binormals;
      const s = new di
        , a = new di
        , l = new Fe;
      let h = new di;
      const c = []
        , u = []
        , p = []
        , d = [];
      function f(r) {
        h = t.getPointAt(r / e, h);
        const l = o.normals[r]
          , p = o.binormals[r];
        for (let t = 0; t <= n; t++) {
          const e = t / n * Math.PI * 2
            , r = Math.sin(e)
            , o = -Math.cos(e);
          a.x = o * l.x + r * p.x,
            a.y = o * l.y + r * p.y,
            a.z = o * l.z + r * p.z,
            a.normalize(),
            u.push(a.x, a.y, a.z),
            s.x = h.x + i * a.x,
            s.y = h.y + i * a.y,
            s.z = h.z + i * a.z,
            c.push(s.x, s.y, s.z)
        }
      }
      !function () {
        for (let t = 0; t < e; t++)
          f(t);
        f(!1 === r ? e : 0),
          function () {
            for (let t = 0; t <= e; t++)
              for (let i = 0; i <= n; i++)
                l.x = t / e,
                  l.y = i / n,
                  p.push(l.x, l.y)
          }(),
          function () {
            for (let t = 1; t <= e; t++)
              for (let e = 1; e <= n; e++) {
                const i = (n + 1) * (t - 1) + (e - 1)
                  , r = (n + 1) * t + (e - 1)
                  , o = (n + 1) * t + e
                  , s = (n + 1) * (t - 1) + e;
                d.push(i, r, s),
                  d.push(r, o, s)
              }
          }()
      }(),
        this.setIndex(d),
        this.setAttribute("position", new Dn(c, 3)),
        this.setAttribute("normal", new Dn(u, 3)),
        this.setAttribute("uv", new Dn(p, 2))
    }
    toJSON() {
      const t = super.toJSON();
      return t.path = this.parameters.path.toJSON(),
        t
    }
    static fromJSON(t) {
      return new Nh((new Nl[t.path.type]).fromJSON(t.path), t.tubularSegments, t.radius, t.radialSegments, t.closed)
    }
  }
  class Fh extends Wn {
    constructor(t = null) {
      if (super(),
        this.type = "WireframeGeometry",
        this.parameters = {
          geometry: t
        },
        null !== t) {
        const e = []
          , i = new Set
          , n = new di
          , r = new di;
        if (null !== t.index) {
          const o = t.attributes.position
            , s = t.index;
          let a = t.groups;
          0 === a.length && (a = [{
            start: 0,
            count: s.count,
            materialIndex: 0
          }]);
          for (let t = 0, l = a.length; t < l; ++t) {
            const l = a[t]
              , h = l.start;
            for (let t = h, a = h + l.count; t < a; t += 3)
              for (let a = 0; a < 3; a++) {
                const l = s.getX(t + a)
                  , h = s.getX(t + (a + 1) % 3);
                n.fromBufferAttribute(o, l),
                  r.fromBufferAttribute(o, h),
                  !0 === Bh(n, r, i) && (e.push(n.x, n.y, n.z),
                    e.push(r.x, r.y, r.z))
              }
          }
        } else {
          const o = t.attributes.position;
          for (let t = 0, s = o.count / 3; t < s; t++)
            for (let s = 0; s < 3; s++) {
              const a = 3 * t + s
                , l = 3 * t + (s + 1) % 3;
              n.fromBufferAttribute(o, a),
                r.fromBufferAttribute(o, l),
                !0 === Bh(n, r, i) && (e.push(n.x, n.y, n.z),
                  e.push(r.x, r.y, r.z))
            }
        }
        this.setAttribute("position", new Dn(e, 3))
      }
    }
  }
  function Bh(t, e, i) {
    const n = `${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`
      , r = `${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`;
    return !0 !== i.has(n) && !0 !== i.has(r) && (i.add(n),
      i.add(r),
      !0)
  }
  var jh = Object.freeze({
    __proto__: null,
    BoxGeometry: cr,
    BoxBufferGeometry: cr,
    CapsuleGeometry: Vl,
    CapsuleBufferGeometry: Vl,
    CircleGeometry: Gl,
    CircleBufferGeometry: Gl,
    ConeGeometry: Jl,
    ConeBufferGeometry: Jl,
    CylinderGeometry: Wl,
    CylinderBufferGeometry: Wl,
    DodecahedronGeometry: Zl,
    DodecahedronBufferGeometry: Zl,
    EdgesGeometry: Xl,
    ExtrudeGeometry: Th,
    ExtrudeBufferGeometry: Th,
    IcosahedronGeometry: kh,
    IcosahedronBufferGeometry: kh,
    LatheGeometry: jl,
    LatheBufferGeometry: jl,
    OctahedronGeometry: Rh,
    OctahedronBufferGeometry: Rh,
    PlaneGeometry: kr,
    PlaneBufferGeometry: kr,
    PolyhedronGeometry: Hl,
    PolyhedronBufferGeometry: Hl,
    RingGeometry: Lh,
    RingBufferGeometry: Lh,
    ShapeGeometry: Ph,
    ShapeBufferGeometry: Ph,
    SphereGeometry: zh,
    SphereBufferGeometry: zh,
    TetrahedronGeometry: Oh,
    TetrahedronBufferGeometry: Oh,
    TorusGeometry: Dh,
    TorusBufferGeometry: Dh,
    TorusKnotGeometry: Uh,
    TorusKnotBufferGeometry: Uh,
    TubeGeometry: Nh,
    TubeBufferGeometry: Nh,
    WireframeGeometry: Fh
  });
  class Vh extends En {
    constructor(t) {
      super(),
        this.isShadowMaterial = !0,
        this.type = "ShadowMaterial",
        this.color = new ei(0),
        this.transparent = !0,
        this.fog = !0,
        this.setValues(t)
    }
    copy(t) {
      return super.copy(t),
        this.color.copy(t.color),
        this.fog = t.fog,
        this
    }
  }
  class Gh extends fr {
    constructor(t) {
      super(t),
        this.isRawShaderMaterial = !0,
        this.type = "RawShaderMaterial"
    }
  }
  class Wh extends En {
    constructor(t) {
      super(),
        this.isMeshStandardMaterial = !0,
        this.defines = {
          STANDARD: ""
        },
        this.type = "MeshStandardMaterial",
        this.color = new ei(16777215),
        this.roughness = 1,
        this.metalness = 0,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new ei(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = ye,
        this.normalScale = new Fe(1, 1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.roughnessMap = null,
        this.metalnessMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapIntensity = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(t)
    }
    copy(t) {
      return super.copy(t),
        this.defines = {
          STANDARD: ""
        },
        this.color.copy(t.color),
        this.roughness = t.roughness,
        this.metalness = t.metalness,
        this.map = t.map,
        this.lightMap = t.lightMap,
        this.lightMapIntensity = t.lightMapIntensity,
        this.aoMap = t.aoMap,
        this.aoMapIntensity = t.aoMapIntensity,
        this.emissive.copy(t.emissive),
        this.emissiveMap = t.emissiveMap,
        this.emissiveIntensity = t.emissiveIntensity,
        this.bumpMap = t.bumpMap,
        this.bumpScale = t.bumpScale,
        this.normalMap = t.normalMap,
        this.normalMapType = t.normalMapType,
        this.normalScale.copy(t.normalScale),
        this.displacementMap = t.displacementMap,
        this.displacementScale = t.displacementScale,
        this.displacementBias = t.displacementBias,
        this.roughnessMap = t.roughnessMap,
        this.metalnessMap = t.metalnessMap,
        this.alphaMap = t.alphaMap,
        this.envMap = t.envMap,
        this.envMapIntensity = t.envMapIntensity,
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this.wireframeLinecap = t.wireframeLinecap,
        this.wireframeLinejoin = t.wireframeLinejoin,
        this.flatShading = t.flatShading,
        this.fog = t.fog,
        this
    }
  }
  class Jh extends Wh {
    constructor(t) {
      super(),
        this.isMeshPhysicalMaterial = !0,
        this.defines = {
          STANDARD: "",
          PHYSICAL: ""
        },
        this.type = "MeshPhysicalMaterial",
        this.clearcoatMap = null,
        this.clearcoatRoughness = 0,
        this.clearcoatRoughnessMap = null,
        this.clearcoatNormalScale = new Fe(1, 1),
        this.clearcoatNormalMap = null,
        this.ior = 1.5,
        Object.defineProperty(this, "reflectivity", {
          get: function () {
            return Le(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
          },
          set: function (t) {
            this.ior = (1 + .4 * t) / (1 - .4 * t)
          }
        }),
        this.iridescenceMap = null,
        this.iridescenceIOR = 1.3,
        this.iridescenceThicknessRange = [100, 400],
        this.iridescenceThicknessMap = null,
        this.sheenColor = new ei(0),
        this.sheenColorMap = null,
        this.sheenRoughness = 1,
        this.sheenRoughnessMap = null,
        this.transmissionMap = null,
        this.thickness = 0,
        this.thicknessMap = null,
        this.attenuationDistance = 0,
        this.attenuationColor = new ei(1, 1, 1),
        this.specularIntensity = 1,
        this.specularIntensityMap = null,
        this.specularColor = new ei(1, 1, 1),
        this.specularColorMap = null,
        this._sheen = 0,
        this._clearcoat = 0,
        this._iridescence = 0,
        this._transmission = 0,
        this.setValues(t)
    }
    get sheen() {
      return this._sheen
    }
    set sheen(t) {
      this._sheen > 0 != t > 0 && this.version++,
        this._sheen = t
    }
    get clearcoat() {
      return this._clearcoat
    }
    set clearcoat(t) {
      this._clearcoat > 0 != t > 0 && this.version++,
        this._clearcoat = t
    }
    get iridescence() {
      return this._iridescence
    }
    set iridescence(t) {
      this._iridescence > 0 != t > 0 && this.version++,
        this._iridescence = t
    }
    get transmission() {
      return this._transmission
    }
    set transmission(t) {
      this._transmission > 0 != t > 0 && this.version++,
        this._transmission = t
    }
    copy(t) {
      return super.copy(t),
        this.defines = {
          STANDARD: "",
          PHYSICAL: ""
        },
        this.clearcoat = t.clearcoat,
        this.clearcoatMap = t.clearcoatMap,
        this.clearcoatRoughness = t.clearcoatRoughness,
        this.clearcoatRoughnessMap = t.clearcoatRoughnessMap,
        this.clearcoatNormalMap = t.clearcoatNormalMap,
        this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
        this.ior = t.ior,
        this.iridescence = t.iridescence,
        this.iridescenceMap = t.iridescenceMap,
        this.iridescenceIOR = t.iridescenceIOR,
        this.iridescenceThicknessRange = [...t.iridescenceThicknessRange],
        this.iridescenceThicknessMap = t.iridescenceThicknessMap,
        this.sheen = t.sheen,
        this.sheenColor.copy(t.sheenColor),
        this.sheenColorMap = t.sheenColorMap,
        this.sheenRoughness = t.sheenRoughness,
        this.sheenRoughnessMap = t.sheenRoughnessMap,
        this.transmission = t.transmission,
        this.transmissionMap = t.transmissionMap,
        this.thickness = t.thickness,
        this.thicknessMap = t.thicknessMap,
        this.attenuationDistance = t.attenuationDistance,
        this.attenuationColor.copy(t.attenuationColor),
        this.specularIntensity = t.specularIntensity,
        this.specularIntensityMap = t.specularIntensityMap,
        this.specularColor.copy(t.specularColor),
        this.specularColorMap = t.specularColorMap,
        this
    }
  }
  class Hh extends En {
    constructor(t) {
      super(),
        this.isMeshPhongMaterial = !0,
        this.type = "MeshPhongMaterial",
        this.color = new ei(16777215),
        this.specular = new ei(1118481),
        this.shininess = 30,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new ei(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = ye,
        this.normalScale = new Fe(1, 1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = j,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(t)
    }
    copy(t) {
      return super.copy(t),
        this.color.copy(t.color),
        this.specular.copy(t.specular),
        this.shininess = t.shininess,
        this.map = t.map,
        this.lightMap = t.lightMap,
        this.lightMapIntensity = t.lightMapIntensity,
        this.aoMap = t.aoMap,
        this.aoMapIntensity = t.aoMapIntensity,
        this.emissive.copy(t.emissive),
        this.emissiveMap = t.emissiveMap,
        this.emissiveIntensity = t.emissiveIntensity,
        this.bumpMap = t.bumpMap,
        this.bumpScale = t.bumpScale,
        this.normalMap = t.normalMap,
        this.normalMapType = t.normalMapType,
        this.normalScale.copy(t.normalScale),
        this.displacementMap = t.displacementMap,
        this.displacementScale = t.displacementScale,
        this.displacementBias = t.displacementBias,
        this.specularMap = t.specularMap,
        this.alphaMap = t.alphaMap,
        this.envMap = t.envMap,
        this.combine = t.combine,
        this.reflectivity = t.reflectivity,
        this.refractionRatio = t.refractionRatio,
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this.wireframeLinecap = t.wireframeLinecap,
        this.wireframeLinejoin = t.wireframeLinejoin,
        this.flatShading = t.flatShading,
        this.fog = t.fog,
        this
    }
  }
  class Zh extends En {
    constructor(t) {
      super(),
        this.isMeshToonMaterial = !0,
        this.defines = {
          TOON: ""
        },
        this.type = "MeshToonMaterial",
        this.color = new ei(16777215),
        this.map = null,
        this.gradientMap = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new ei(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = ye,
        this.normalScale = new Fe(1, 1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.alphaMap = null,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.fog = !0,
        this.setValues(t)
    }
    copy(t) {
      return super.copy(t),
        this.color.copy(t.color),
        this.map = t.map,
        this.gradientMap = t.gradientMap,
        this.lightMap = t.lightMap,
        this.lightMapIntensity = t.lightMapIntensity,
        this.aoMap = t.aoMap,
        this.aoMapIntensity = t.aoMapIntensity,
        this.emissive.copy(t.emissive),
        this.emissiveMap = t.emissiveMap,
        this.emissiveIntensity = t.emissiveIntensity,
        this.bumpMap = t.bumpMap,
        this.bumpScale = t.bumpScale,
        this.normalMap = t.normalMap,
        this.normalMapType = t.normalMapType,
        this.normalScale.copy(t.normalScale),
        this.displacementMap = t.displacementMap,
        this.displacementScale = t.displacementScale,
        this.displacementBias = t.displacementBias,
        this.alphaMap = t.alphaMap,
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this.wireframeLinecap = t.wireframeLinecap,
        this.wireframeLinejoin = t.wireframeLinejoin,
        this.fog = t.fog,
        this
    }
  }
  class Qh extends En {
    constructor(t) {
      super(),
        this.isMeshNormalMaterial = !0,
        this.type = "MeshNormalMaterial",
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = ye,
        this.normalScale = new Fe(1, 1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.flatShading = !1,
        this.setValues(t)
    }
    copy(t) {
      return super.copy(t),
        this.bumpMap = t.bumpMap,
        this.bumpScale = t.bumpScale,
        this.normalMap = t.normalMap,
        this.normalMapType = t.normalMapType,
        this.normalScale.copy(t.normalScale),
        this.displacementMap = t.displacementMap,
        this.displacementScale = t.displacementScale,
        this.displacementBias = t.displacementBias,
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this.flatShading = t.flatShading,
        this
    }
  }
  class Kh extends En {
    constructor(t) {
      super(),
        this.isMeshLambertMaterial = !0,
        this.type = "MeshLambertMaterial",
        this.color = new ei(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new ei(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = j,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.fog = !0,
        this.setValues(t)
    }
    copy(t) {
      return super.copy(t),
        this.color.copy(t.color),
        this.map = t.map,
        this.lightMap = t.lightMap,
        this.lightMapIntensity = t.lightMapIntensity,
        this.aoMap = t.aoMap,
        this.aoMapIntensity = t.aoMapIntensity,
        this.emissive.copy(t.emissive),
        this.emissiveMap = t.emissiveMap,
        this.emissiveIntensity = t.emissiveIntensity,
        this.specularMap = t.specularMap,
        this.alphaMap = t.alphaMap,
        this.envMap = t.envMap,
        this.combine = t.combine,
        this.reflectivity = t.reflectivity,
        this.refractionRatio = t.refractionRatio,
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this.wireframeLinecap = t.wireframeLinecap,
        this.wireframeLinejoin = t.wireframeLinejoin,
        this.fog = t.fog,
        this
    }
  }
  class Yh extends En {
    constructor(t) {
      super(),
        this.isMeshMatcapMaterial = !0,
        this.defines = {
          MATCAP: ""
        },
        this.type = "MeshMatcapMaterial",
        this.color = new ei(16777215),
        this.matcap = null,
        this.map = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = ye,
        this.normalScale = new Fe(1, 1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.alphaMap = null,
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(t)
    }
    copy(t) {
      return super.copy(t),
        this.defines = {
          MATCAP: ""
        },
        this.color.copy(t.color),
        this.matcap = t.matcap,
        this.map = t.map,
        this.bumpMap = t.bumpMap,
        this.bumpScale = t.bumpScale,
        this.normalMap = t.normalMap,
        this.normalMapType = t.normalMapType,
        this.normalScale.copy(t.normalScale),
        this.displacementMap = t.displacementMap,
        this.displacementScale = t.displacementScale,
        this.displacementBias = t.displacementBias,
        this.alphaMap = t.alphaMap,
        this.flatShading = t.flatShading,
        this.fog = t.fog,
        this
    }
  }
  class qh extends tl {
    constructor(t) {
      super(),
        this.isLineDashedMaterial = !0,
        this.type = "LineDashedMaterial",
        this.scale = 1,
        this.dashSize = 3,
        this.gapSize = 1,
        this.setValues(t)
    }
    copy(t) {
      return super.copy(t),
        this.scale = t.scale,
        this.dashSize = t.dashSize,
        this.gapSize = t.gapSize,
        this
    }
  }
  const Xh = {
    arraySlice: function (t, e, i) {
      return Xh.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== i ? i : t.length)) : t.slice(e, i)
    },
    convertArray: function (t, e, i) {
      return !t || !i && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
    },
    isTypedArray: function (t) {
      return ArrayBuffer.isView(t) && !(t instanceof DataView)
    },
    getKeyframeOrder: function (t) {
      const e = t.length
        , i = new Array(e);
      for (let t = 0; t !== e; ++t)
        i[t] = t;
      return i.sort((function (e, i) {
        return t[e] - t[i]
      }
      )),
        i
    },
    sortedArray: function (t, e, i) {
      const n = t.length
        , r = new t.constructor(n);
      for (let o = 0, s = 0; s !== n; ++o) {
        const n = i[o] * e;
        for (let i = 0; i !== e; ++i)
          r[s++] = t[n + i]
      }
      return r
    },
    flattenJSON: function (t, e, i, n) {
      let r = 1
        , o = t[0];
      for (; void 0 !== o && void 0 === o[n];)
        o = t[r++];
      if (void 0 === o)
        return;
      let s = o[n];
      if (void 0 !== s)
        if (Array.isArray(s))
          do {
            s = o[n],
              void 0 !== s && (e.push(o.time),
                i.push.apply(i, s)),
              o = t[r++]
          } while (void 0 !== o);
        else if (void 0 !== s.toArray)
          do {
            s = o[n],
              void 0 !== s && (e.push(o.time),
                s.toArray(i, i.length)),
              o = t[r++]
          } while (void 0 !== o);
        else
          do {
            s = o[n],
              void 0 !== s && (e.push(o.time),
                i.push(s)),
              o = t[r++]
          } while (void 0 !== o)
    },
    subclip: function (t, e, i, n, r = 30) {
      const o = t.clone();
      o.name = e;
      const s = [];
      for (let t = 0; t < o.tracks.length; ++t) {
        const e = o.tracks[t]
          , a = e.getValueSize()
          , l = []
          , h = [];
        for (let t = 0; t < e.times.length; ++t) {
          const o = e.times[t] * r;
          if (!(o < i || o >= n)) {
            l.push(e.times[t]);
            for (let i = 0; i < a; ++i)
              h.push(e.values[t * a + i])
          }
        }
        0 !== l.length && (e.times = Xh.convertArray(l, e.times.constructor),
          e.values = Xh.convertArray(h, e.values.constructor),
          s.push(e))
      }
      o.tracks = s;
      let a = 1 / 0;
      for (let t = 0; t < o.tracks.length; ++t)
        a > o.tracks[t].times[0] && (a = o.tracks[t].times[0]);
      for (let t = 0; t < o.tracks.length; ++t)
        o.tracks[t].shift(-1 * a);
      return o.resetDuration(),
        o
    },
    makeClipAdditive: function (t, e = 0, i = t, n = 30) {
      n <= 0 && (n = 30);
      const r = i.tracks.length
        , o = e / n;
      for (let e = 0; e < r; ++e) {
        const n = i.tracks[e]
          , r = n.ValueTypeName;
        if ("bool" === r || "string" === r)
          continue;
        const s = t.tracks.find((function (t) {
          return t.name === n.name && t.ValueTypeName === r
        }
        ));
        if (void 0 === s)
          continue;
        let a = 0;
        const l = n.getValueSize();
        n.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (a = l / 3);
        let h = 0;
        const c = s.getValueSize();
        s.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (h = c / 3);
        const u = n.times.length - 1;
        let p;
        if (o <= n.times[0]) {
          const t = a
            , e = l - a;
          p = Xh.arraySlice(n.values, t, e)
        } else if (o >= n.times[u]) {
          const t = u * l + a
            , e = t + l - a;
          p = Xh.arraySlice(n.values, t, e)
        } else {
          const t = n.createInterpolant()
            , e = a
            , i = l - a;
          t.evaluate(o),
            p = Xh.arraySlice(t.resultBuffer, e, i)
        }
        if ("quaternion" === r) {
          (new pi).fromArray(p).normalize().conjugate().toArray(p)
        }
        const d = s.times.length;
        for (let t = 0; t < d; ++t) {
          const e = t * c + h;
          if ("quaternion" === r)
            pi.multiplyQuaternionsFlat(s.values, e, p, 0, s.values, e);
          else {
            const t = c - 2 * h;
            for (let i = 0; i < t; ++i)
              s.values[e + i] -= p[i]
          }
        }
      }
      return t.blendMode = de,
        t
    }
  };
  class $h {
    constructor(t, e, i, n) {
      this.parameterPositions = t,
        this._cachedIndex = 0,
        this.resultBuffer = void 0 !== n ? n : new e.constructor(i),
        this.sampleValues = e,
        this.valueSize = i,
        this.settings = null,
        this.DefaultSettings_ = {}
    }
    evaluate(t) {
      const e = this.parameterPositions;
      let i = this._cachedIndex
        , n = e[i]
        , r = e[i - 1];
      t: {
        e: {
          let o;
          i: {
            n: if (!(t < n)) {
              for (let o = i + 2; ;) {
                if (void 0 === n) {
                  if (t < r)
                    break n;
                  return i = e.length,
                    this._cachedIndex = i,
                    this.copySampleValue_(i - 1)
                }
                if (i === o)
                  break;
                if (r = n,
                  n = e[++i],
                  t < n)
                  break e
              }
              o = e.length;
              break i
            }
            if (t >= r)
              break t;
            {
              const s = e[1];
              t < s && (i = 2,
                r = s);
              for (let o = i - 2; ;) {
                if (void 0 === r)
                  return this._cachedIndex = 0,
                    this.copySampleValue_(0);
                if (i === o)
                  break;
                if (n = r,
                  r = e[--i - 1],
                  t >= r)
                  break e
              }
              o = i,
                i = 0
            }
          }
          for (; i < o;) {
            const n = i + o >>> 1;
            t < e[n] ? o = n : i = n + 1
          }
          if (n = e[i],
            r = e[i - 1],
            void 0 === r)
            return this._cachedIndex = 0,
              this.copySampleValue_(0);
          if (void 0 === n)
            return i = e.length,
              this._cachedIndex = i,
              this.copySampleValue_(i - 1)
        }
        this._cachedIndex = i,
          this.intervalChanged_(i, r, n)
      }
      return this.interpolate_(i, r, t, n)
    }
    getSettings_() {
      return this.settings || this.DefaultSettings_
    }
    copySampleValue_(t) {
      const e = this.resultBuffer
        , i = this.sampleValues
        , n = this.valueSize
        , r = t * n;
      for (let t = 0; t !== n; ++t)
        e[t] = i[r + t];
      return e
    }
    interpolate_() {
      throw new Error("call to abstract method")
    }
    intervalChanged_() { }
  }
  class tc extends $h {
    constructor(t, e, i, n) {
      super(t, e, i, n),
        this._weightPrev = -0,
        this._offsetPrev = -0,
        this._weightNext = -0,
        this._offsetNext = -0,
        this.DefaultSettings_ = {
          endingStart: he,
          endingEnd: he
        }
    }
    intervalChanged_(t, e, i) {
      const n = this.parameterPositions;
      let r = t - 2
        , o = t + 1
        , s = n[r]
        , a = n[o];
      if (void 0 === s)
        switch (this.getSettings_().endingStart) {
          case ce:
            r = t,
              s = 2 * e - i;
            break;
          case ue:
            r = n.length - 2,
              s = e + n[r] - n[r + 1];
            break;
          default:
            r = t,
              s = i
        }
      if (void 0 === a)
        switch (this.getSettings_().endingEnd) {
          case ce:
            o = t,
              a = 2 * i - e;
            break;
          case ue:
            o = 1,
              a = i + n[1] - n[0];
            break;
          default:
            o = t - 1,
              a = e
        }
      const l = .5 * (i - e)
        , h = this.valueSize;
      this._weightPrev = l / (e - s),
        this._weightNext = l / (a - i),
        this._offsetPrev = r * h,
        this._offsetNext = o * h
    }
    interpolate_(t, e, i, n) {
      const r = this.resultBuffer
        , o = this.sampleValues
        , s = this.valueSize
        , a = t * s
        , l = a - s
        , h = this._offsetPrev
        , c = this._offsetNext
        , u = this._weightPrev
        , p = this._weightNext
        , d = (i - e) / (n - e)
        , f = d * d
        , g = f * d
        , m = -u * g + 2 * u * f - u * d
        , y = (1 + u) * g + (-1.5 - 2 * u) * f + (-.5 + u) * d + 1
        , v = (-1 - p) * g + (1.5 + p) * f + .5 * d
        , A = p * g - p * f;
      for (let t = 0; t !== s; ++t)
        r[t] = m * o[h + t] + y * o[l + t] + v * o[a + t] + A * o[c + t];
      return r
    }
  }
  class ec extends $h {
    constructor(t, e, i, n) {
      super(t, e, i, n)
    }
    interpolate_(t, e, i, n) {
      const r = this.resultBuffer
        , o = this.sampleValues
        , s = this.valueSize
        , a = t * s
        , l = a - s
        , h = (i - e) / (n - e)
        , c = 1 - h;
      for (let t = 0; t !== s; ++t)
        r[t] = o[l + t] * c + o[a + t] * h;
      return r
    }
  }
  class ic extends $h {
    constructor(t, e, i, n) {
      super(t, e, i, n)
    }
    interpolate_(t) {
      return this.copySampleValue_(t - 1)
    }
  }
  class nc {
    constructor(t, e, i, n) {
      if (void 0 === t)
        throw new Error("THREE.KeyframeTrack: track name is undefined");
      if (void 0 === e || 0 === e.length)
        throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
      this.name = t,
        this.times = Xh.convertArray(e, this.TimeBufferType),
        this.values = Xh.convertArray(i, this.ValueBufferType),
        this.setInterpolation(n || this.DefaultInterpolation)
    }
    static toJSON(t) {
      const e = t.constructor;
      let i;
      if (e.toJSON !== this.toJSON)
        i = e.toJSON(t);
      else {
        i = {
          name: t.name,
          times: Xh.convertArray(t.times, Array),
          values: Xh.convertArray(t.values, Array)
        };
        const e = t.getInterpolation();
        e !== t.DefaultInterpolation && (i.interpolation = e)
      }
      return i.type = t.ValueTypeName,
        i
    }
    InterpolantFactoryMethodDiscrete(t) {
      return new ic(this.times, this.values, this.getValueSize(), t)
    }
    InterpolantFactoryMethodLinear(t) {
      return new ec(this.times, this.values, this.getValueSize(), t)
    }
    InterpolantFactoryMethodSmooth(t) {
      return new tc(this.times, this.values, this.getValueSize(), t)
    }
    setInterpolation(t) {
      let e;
      switch (t) {
        case se:
          e = this.InterpolantFactoryMethodDiscrete;
          break;
        case ae:
          e = this.InterpolantFactoryMethodLinear;
          break;
        case le:
          e = this.InterpolantFactoryMethodSmooth
      }
      if (void 0 === e) {
        const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
        if (void 0 === this.createInterpolant) {
          if (t === this.DefaultInterpolation)
            throw new Error(e);
          this.setInterpolation(this.DefaultInterpolation)
        }
        return console.warn("THREE.KeyframeTrack:", e),
          this
      }
      return this.createInterpolant = e,
        this
    }
    getInterpolation() {
      switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
          return se;
        case this.InterpolantFactoryMethodLinear:
          return ae;
        case this.InterpolantFactoryMethodSmooth:
          return le
      }
    }
    getValueSize() {
      return this.values.length / this.times.length
    }
    shift(t) {
      if (0 !== t) {
        const e = this.times;
        for (let i = 0, n = e.length; i !== n; ++i)
          e[i] += t
      }
      return this
    }
    scale(t) {
      if (1 !== t) {
        const e = this.times;
        for (let i = 0, n = e.length; i !== n; ++i)
          e[i] *= t
      }
      return this
    }
    trim(t, e) {
      const i = this.times
        , n = i.length;
      let r = 0
        , o = n - 1;
      for (; r !== n && i[r] < t;)
        ++r;
      for (; -1 !== o && i[o] > e;)
        --o;
      if (++o,
        0 !== r || o !== n) {
        r >= o && (o = Math.max(o, 1),
          r = o - 1);
        const t = this.getValueSize();
        this.times = Xh.arraySlice(i, r, o),
          this.values = Xh.arraySlice(this.values, r * t, o * t)
      }
      return this
    }
    validate() {
      let t = !0;
      const e = this.getValueSize();
      e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
        t = !1);
      const i = this.times
        , n = this.values
        , r = i.length;
      0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this),
        t = !1);
      let o = null;
      for (let e = 0; e !== r; e++) {
        const n = i[e];
        if ("number" == typeof n && isNaN(n)) {
          console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e, n),
            t = !1;
          break
        }
        if (null !== o && o > n) {
          console.error("THREE.KeyframeTrack: Out of order keys.", this, e, n, o),
            t = !1;
          break
        }
        o = n
      }
      if (void 0 !== n && Xh.isTypedArray(n))
        for (let e = 0, i = n.length; e !== i; ++e) {
          const i = n[e];
          if (isNaN(i)) {
            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e, i),
              t = !1;
            break
          }
        }
      return t
    }
    optimize() {
      const t = Xh.arraySlice(this.times)
        , e = Xh.arraySlice(this.values)
        , i = this.getValueSize()
        , n = this.getInterpolation() === le
        , r = t.length - 1;
      let o = 1;
      for (let s = 1; s < r; ++s) {
        let r = !1;
        const a = t[s];
        if (a !== t[s + 1] && (1 !== s || a !== t[0]))
          if (n)
            r = !0;
          else {
            const t = s * i
              , n = t - i
              , o = t + i;
            for (let s = 0; s !== i; ++s) {
              const i = e[t + s];
              if (i !== e[n + s] || i !== e[o + s]) {
                r = !0;
                break
              }
            }
          }
        if (r) {
          if (s !== o) {
            t[o] = t[s];
            const n = s * i
              , r = o * i;
            for (let t = 0; t !== i; ++t)
              e[r + t] = e[n + t]
          }
          ++o
        }
      }
      if (r > 0) {
        t[o] = t[r];
        for (let t = r * i, n = o * i, s = 0; s !== i; ++s)
          e[n + s] = e[t + s];
        ++o
      }
      return o !== t.length ? (this.times = Xh.arraySlice(t, 0, o),
        this.values = Xh.arraySlice(e, 0, o * i)) : (this.times = t,
          this.values = e),
        this
    }
    clone() {
      const t = Xh.arraySlice(this.times, 0)
        , e = Xh.arraySlice(this.values, 0)
        , i = new (0,
          this.constructor)(this.name, t, e);
      return i.createInterpolant = this.createInterpolant,
        i
    }
  }
  nc.prototype.TimeBufferType = Float32Array,
    nc.prototype.ValueBufferType = Float32Array,
    nc.prototype.DefaultInterpolation = ae;
  class rc extends nc {
  }
  rc.prototype.ValueTypeName = "bool",
    rc.prototype.ValueBufferType = Array,
    rc.prototype.DefaultInterpolation = se,
    rc.prototype.InterpolantFactoryMethodLinear = void 0,
    rc.prototype.InterpolantFactoryMethodSmooth = void 0;
  class oc extends nc {
  }
  oc.prototype.ValueTypeName = "color";
  class sc extends nc {
  }
  sc.prototype.ValueTypeName = "number";
  class ac extends $h {
    constructor(t, e, i, n) {
      super(t, e, i, n)
    }
    interpolate_(t, e, i, n) {
      const r = this.resultBuffer
        , o = this.sampleValues
        , s = this.valueSize
        , a = (i - e) / (n - e);
      let l = t * s;
      for (let t = l + s; l !== t; l += 4)
        pi.slerpFlat(r, 0, o, l - s, o, l, a);
      return r
    }
  }
  class lc extends nc {
    InterpolantFactoryMethodLinear(t) {
      return new ac(this.times, this.values, this.getValueSize(), t)
    }
  }
  lc.prototype.ValueTypeName = "quaternion",
    lc.prototype.DefaultInterpolation = ae,
    lc.prototype.InterpolantFactoryMethodSmooth = void 0;
  class hc extends nc {
  }
  hc.prototype.ValueTypeName = "string",
    hc.prototype.ValueBufferType = Array,
    hc.prototype.DefaultInterpolation = se,
    hc.prototype.InterpolantFactoryMethodLinear = void 0,
    hc.prototype.InterpolantFactoryMethodSmooth = void 0;
  class cc extends nc {
  }
  cc.prototype.ValueTypeName = "vector";
  class uc {
    constructor(t, e = -1, i, n = 2500) {
      this.name = t,
        this.tracks = i,
        this.duration = e,
        this.blendMode = n,
        this.uuid = Re(),
        this.duration < 0 && this.resetDuration()
    }
    static parse(t) {
      const e = []
        , i = t.tracks
        , n = 1 / (t.fps || 1);
      for (let t = 0, r = i.length; t !== r; ++t)
        e.push(pc(i[t]).scale(n));
      const r = new this(t.name, t.duration, e, t.blendMode);
      return r.uuid = t.uuid,
        r
    }
    static toJSON(t) {
      const e = []
        , i = t.tracks
        , n = {
          name: t.name,
          duration: t.duration,
          tracks: e,
          uuid: t.uuid,
          blendMode: t.blendMode
        };
      for (let t = 0, n = i.length; t !== n; ++t)
        e.push(nc.toJSON(i[t]));
      return n
    }
    static CreateFromMorphTargetSequence(t, e, i, n) {
      const r = e.length
        , o = [];
      for (let t = 0; t < r; t++) {
        let s = []
          , a = [];
        s.push((t + r - 1) % r, t, (t + 1) % r),
          a.push(0, 1, 0);
        const l = Xh.getKeyframeOrder(s);
        s = Xh.sortedArray(s, 1, l),
          a = Xh.sortedArray(a, 1, l),
          n || 0 !== s[0] || (s.push(r),
            a.push(a[0])),
          o.push(new sc(".morphTargetInfluences[" + e[t].name + "]", s, a).scale(1 / i))
      }
      return new this(t, -1, o)
    }
    static findByName(t, e) {
      let i = t;
      if (!Array.isArray(t)) {
        const e = t;
        i = e.geometry && e.geometry.animations || e.animations
      }
      for (let t = 0; t < i.length; t++)
        if (i[t].name === e)
          return i[t];
      return null
    }
    static CreateClipsFromMorphTargetSequences(t, e, i) {
      const n = {}
        , r = /^([\w-]*?)([\d]+)$/;
      for (let e = 0, i = t.length; e < i; e++) {
        const i = t[e]
          , o = i.name.match(r);
        if (o && o.length > 1) {
          const t = o[1];
          let e = n[t];
          e || (n[t] = e = []),
            e.push(i)
        }
      }
      const o = [];
      for (const t in n)
        o.push(this.CreateFromMorphTargetSequence(t, n[t], e, i));
      return o
    }
    static parseAnimation(t, e) {
      if (!t)
        return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
          null;
      const i = function (t, e, i, n, r) {
        if (0 !== i.length) {
          const o = []
            , s = [];
          Xh.flattenJSON(i, o, s, n),
            0 !== o.length && r.push(new t(e, o, s))
        }
      }
        , n = []
        , r = t.name || "default"
        , o = t.fps || 30
        , s = t.blendMode;
      let a = t.length || -1;
      const l = t.hierarchy || [];
      for (let t = 0; t < l.length; t++) {
        const r = l[t].keys;
        if (r && 0 !== r.length)
          if (r[0].morphTargets) {
            const t = {};
            let e;
            for (e = 0; e < r.length; e++)
              if (r[e].morphTargets)
                for (let i = 0; i < r[e].morphTargets.length; i++)
                  t[r[e].morphTargets[i]] = -1;
            for (const i in t) {
              const t = []
                , o = [];
              for (let n = 0; n !== r[e].morphTargets.length; ++n) {
                const n = r[e];
                t.push(n.time),
                  o.push(n.morphTarget === i ? 1 : 0)
              }
              n.push(new sc(".morphTargetInfluence[" + i + "]", t, o))
            }
            a = t.length * o
          } else {
            const o = ".bones[" + e[t].name + "]";
            i(cc, o + ".position", r, "pos", n),
              i(lc, o + ".quaternion", r, "rot", n),
              i(cc, o + ".scale", r, "scl", n)
          }
      }
      if (0 === n.length)
        return null;
      return new this(r, a, n, s)
    }
    resetDuration() {
      let t = 0;
      for (let e = 0, i = this.tracks.length; e !== i; ++e) {
        const i = this.tracks[e];
        t = Math.max(t, i.times[i.times.length - 1])
      }
      return this.duration = t,
        this
    }
    trim() {
      for (let t = 0; t < this.tracks.length; t++)
        this.tracks[t].trim(0, this.duration);
      return this
    }
    validate() {
      let t = !0;
      for (let e = 0; e < this.tracks.length; e++)
        t = t && this.tracks[e].validate();
      return t
    }
    optimize() {
      for (let t = 0; t < this.tracks.length; t++)
        this.tracks[t].optimize();
      return this
    }
    clone() {
      const t = [];
      for (let e = 0; e < this.tracks.length; e++)
        t.push(this.tracks[e].clone());
      return new this.constructor(this.name, this.duration, t, this.blendMode)
    }
    toJSON() {
      return this.constructor.toJSON(this)
    }
  }
  function pc(t) {
    if (void 0 === t.type)
      throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    const e = function (t) {
      switch (t.toLowerCase()) {
        case "scalar":
        case "double":
        case "float":
        case "number":
        case "integer":
          return sc;
        case "vector":
        case "vector2":
        case "vector3":
        case "vector4":
          return cc;
        case "color":
          return oc;
        case "quaternion":
          return lc;
        case "bool":
        case "boolean":
          return rc;
        case "string":
          return hc
      }
      throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
    }(t.type);
    if (void 0 === t.times) {
      const e = []
        , i = [];
      Xh.flattenJSON(t.keys, e, i, "value"),
        t.times = e,
        t.values = i
    }
    return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
  }
  const dc = {
    enabled: !1,
    files: {},
    add: function (t, e) {
      !1 !== this.enabled && (this.files[t] = e)
    },
    get: function (t) {
      if (!1 !== this.enabled)
        return this.files[t]
    },
    remove: function (t) {
      delete this.files[t]
    },
    clear: function () {
      this.files = {}
    }
  };
  class fc {
    constructor(t, e, i) {
      const n = this;
      let r, o = !1, s = 0, a = 0;
      const l = [];
      this.onStart = void 0,
        this.onLoad = t,
        this.onProgress = e,
        this.onError = i,
        this.itemStart = function (t) {
          a++,
            !1 === o && void 0 !== n.onStart && n.onStart(t, s, a),
            o = !0
        }
        ,
        this.itemEnd = function (t) {
          s++,
            void 0 !== n.onProgress && n.onProgress(t, s, a),
            s === a && (o = !1,
              void 0 !== n.onLoad && n.onLoad())
        }
        ,
        this.itemError = function (t) {
          void 0 !== n.onError && n.onError(t)
        }
        ,
        this.resolveURL = function (t) {
          return r ? r(t) : t
        }
        ,
        this.setURLModifier = function (t) {
          return r = t,
            this
        }
        ,
        this.addHandler = function (t, e) {
          return l.push(t, e),
            this
        }
        ,
        this.removeHandler = function (t) {
          const e = l.indexOf(t);
          return -1 !== e && l.splice(e, 2),
            this
        }
        ,
        this.getHandler = function (t) {
          for (let e = 0, i = l.length; e < i; e += 2) {
            const i = l[e]
              , n = l[e + 1];
            if (i.global && (i.lastIndex = 0),
              i.test(t))
              return n
          }
          return null
        }
    }
  }
  const gc = new fc;
  class mc {
    constructor(t) {
      this.manager = void 0 !== t ? t : gc,
        this.crossOrigin = "anonymous",
        this.withCredentials = !1,
        this.path = "",
        this.resourcePath = "",
        this.requestHeader = {}
    }
    load() { }
    loadAsync(t, e) {
      const i = this;
      return new Promise((function (n, r) {
        i.load(t, n, e, r)
      }
      ))
    }
    parse() { }
    setCrossOrigin(t) {
      return this.crossOrigin = t,
        this
    }
    setWithCredentials(t) {
      return this.withCredentials = t,
        this
    }
    setPath(t) {
      return this.path = t,
        this
    }
    setResourcePath(t) {
      return this.resourcePath = t,
        this
    }
    setRequestHeader(t) {
      return this.requestHeader = t,
        this
    }
  }
  const yc = {};
  class vc extends mc {
    constructor(t) {
      super(t)
    }
    load(t, e, i, n) {
      void 0 === t && (t = ""),
        void 0 !== this.path && (t = this.path + t),
        t = this.manager.resolveURL(t);
      const r = dc.get(t);
      if (void 0 !== r)
        return this.manager.itemStart(t),
          setTimeout((() => {
            e && e(r),
              this.manager.itemEnd(t)
          }
          ), 0),
          r;
      if (void 0 !== yc[t])
        return void yc[t].push({
          onLoad: e,
          onProgress: i,
          onError: n
        });
      yc[t] = [],
        yc[t].push({
          onLoad: e,
          onProgress: i,
          onError: n
        });
      const o = new Request(t, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? "include" : "same-origin"
      })
        , s = this.mimeType
        , a = this.responseType;
      fetch(o).then((e => {
        if (200 === e.status || 0 === e.status) {
          if (0 === e.status && console.warn("THREE.FileLoader: HTTP Status 0 received."),
            "undefined" == typeof ReadableStream || void 0 === e.body || void 0 === e.body.getReader)
            return e;
          const i = yc[t]
            , n = e.body.getReader()
            , r = e.headers.get("Content-Length")
            , o = r ? parseInt(r) : 0
            , s = 0 !== o;
          let a = 0;
          const l = new ReadableStream({
            start(t) {
              !function e() {
                n.read().then((({ done: n, value: r }) => {
                  if (n)
                    t.close();
                  else {
                    a += r.byteLength;
                    const n = new ProgressEvent("progress", {
                      lengthComputable: s,
                      loaded: a,
                      total: o
                    });
                    for (let t = 0, e = i.length; t < e; t++) {
                      const e = i[t];
                      e.onProgress && e.onProgress(n)
                    }
                    t.enqueue(r),
                      e()
                  }
                }
                ))
              }()
            }
          });
          return new Response(l)
        }
        throw Error(`fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`)
      }
      )).then((t => {
        switch (a) {
          case "arraybuffer":
            return t.arrayBuffer();
          case "blob":
            return t.blob();
          case "document":
            return t.text().then((t => (new DOMParser).parseFromString(t, s)));
          case "json":
            return t.json();
          default:
            if (void 0 === s)
              return t.text();
            {
              const e = /charset="?([^;"\s]*)"?/i.exec(s)
                , i = e && e[1] ? e[1].toLowerCase() : void 0
                , n = new TextDecoder(i);
              return t.arrayBuffer().then((t => n.decode(t)))
            }
        }
      }
      )).then((e => {
        dc.add(t, e);
        const i = yc[t];
        delete yc[t];
        for (let t = 0, n = i.length; t < n; t++) {
          const n = i[t];
          n.onLoad && n.onLoad(e)
        }
      }
      )).catch((e => {
        const i = yc[t];
        if (void 0 === i)
          throw this.manager.itemError(t),
          e;
        delete yc[t];
        for (let t = 0, n = i.length; t < n; t++) {
          const n = i[t];
          n.onError && n.onError(e)
        }
        this.manager.itemError(t)
      }
      )).finally((() => {
        this.manager.itemEnd(t)
      }
      )),
        this.manager.itemStart(t)
    }
    setResponseType(t) {
      return this.responseType = t,
        this
    }
    setMimeType(t) {
      return this.mimeType = t,
        this
    }
  }
  class Ac extends mc {
    constructor(t) {
      super(t)
    }
    load(t, e, i, n) {
      void 0 !== this.path && (t = this.path + t),
        t = this.manager.resolveURL(t);
      const r = this
        , o = dc.get(t);
      if (void 0 !== o)
        return r.manager.itemStart(t),
          setTimeout((function () {
            e && e(o),
              r.manager.itemEnd(t)
          }
          ), 0),
          o;
      const s = We("img");
      function a() {
        h(),
          dc.add(t, this),
          e && e(this),
          r.manager.itemEnd(t)
      }
      function l(e) {
        h(),
          n && n(e),
          r.manager.itemError(t),
          r.manager.itemEnd(t)
      }
      function h() {
        s.removeEventListener("load", a, !1),
          s.removeEventListener("error", l, !1)
      }
      return s.addEventListener("load", a, !1),
        s.addEventListener("error", l, !1),
        "data:" !== t.slice(0, 5) && void 0 !== this.crossOrigin && (s.crossOrigin = this.crossOrigin),
        r.manager.itemStart(t),
        s.src = t,
        s
    }
  }
  class bc extends mc {
    constructor(t) {
      super(t)
    }
    load(t, e, i, n) {
      const r = new ai
        , o = new Ac(this.manager);
      return o.setCrossOrigin(this.crossOrigin),
        o.setPath(this.path),
        o.load(t, (function (t) {
          r.image = t,
            r.needsUpdate = !0,
            void 0 !== e && e(r)
        }
        ), i, n),
        r
    }
  }
  class xc extends mn {
    constructor(t, e = 1) {
      super(),
        this.isLight = !0,
        this.type = "Light",
        this.color = new ei(t),
        this.intensity = e
    }
    dispose() { }
    copy(t, e) {
      return super.copy(t, e),
        this.color.copy(t.color),
        this.intensity = t.intensity,
        this
    }
    toJSON(t) {
      const e = super.toJSON(t);
      return e.object.color = this.color.getHex(),
        e.object.intensity = this.intensity,
        void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()),
        void 0 !== this.distance && (e.object.distance = this.distance),
        void 0 !== this.angle && (e.object.angle = this.angle),
        void 0 !== this.decay && (e.object.decay = this.decay),
        void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
        void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
        e
    }
  }
  class Ic extends xc {
    constructor(t, e, i) {
      super(t, i),
        this.isHemisphereLight = !0,
        this.type = "HemisphereLight",
        this.position.copy(mn.DefaultUp),
        this.updateMatrix(),
        this.groundColor = new ei(e)
    }
    copy(t, e) {
      return super.copy(t, e),
        this.groundColor.copy(t.groundColor),
        this
    }
  }
  const Cc = new Wi
    , wc = new di
    , _c = new di;
  class Sc {
    constructor(t) {
      this.camera = t,
        this.bias = 0,
        this.normalBias = 0,
        this.radius = 1,
        this.blurSamples = 8,
        this.mapSize = new Fe(512, 512),
        this.map = null,
        this.mapPass = null,
        this.matrix = new Wi,
        this.autoUpdate = !0,
        this.needsUpdate = !1,
        this._frustum = new Mr,
        this._frameExtents = new Fe(1, 1),
        this._viewportCount = 1,
        this._viewports = [new li(0, 0, 1, 1)]
    }
    getViewportCount() {
      return this._viewportCount
    }
    getFrustum() {
      return this._frustum
    }
    updateMatrices(t) {
      const e = this.camera
        , i = this.matrix;
      wc.setFromMatrixPosition(t.matrixWorld),
        e.position.copy(wc),
        _c.setFromMatrixPosition(t.target.matrixWorld),
        e.lookAt(_c),
        e.updateMatrixWorld(),
        Cc.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(Cc),
        i.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
        i.multiply(e.projectionMatrix),
        i.multiply(e.matrixWorldInverse)
    }
    getViewport(t) {
      return this._viewports[t]
    }
    getFrameExtents() {
      return this._frameExtents
    }
    dispose() {
      this.map && this.map.dispose(),
        this.mapPass && this.mapPass.dispose()
    }
    copy(t) {
      return this.camera = t.camera.clone(),
        this.bias = t.bias,
        this.radius = t.radius,
        this.mapSize.copy(t.mapSize),
        this
    }
    clone() {
      return (new this.constructor).copy(this)
    }
    toJSON() {
      const t = {};
      return 0 !== this.bias && (t.bias = this.bias),
        0 !== this.normalBias && (t.normalBias = this.normalBias),
        1 !== this.radius && (t.radius = this.radius),
        512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()),
        t.camera = this.camera.toJSON(!1).object,
        delete t.camera.matrix,
        t
    }
  }
  class Mc extends Sc {
    constructor() {
      super(new mr(50, 1, .5, 500)),
        this.isSpotLightShadow = !0,
        this.focus = 1
    }
    updateMatrices(t) {
      const e = this.camera
        , i = 2 * ke * t.angle * this.focus
        , n = this.mapSize.width / this.mapSize.height
        , r = t.distance || e.far;
      i === e.fov && n === e.aspect && r === e.far || (e.fov = i,
        e.aspect = n,
        e.far = r,
        e.updateProjectionMatrix()),
        super.updateMatrices(t)
    }
    copy(t) {
      return super.copy(t),
        this.focus = t.focus,
        this
    }
  }
  class Tc extends xc {
    constructor(t, e, i = 0, n = Math.PI / 3, r = 0, o = 1) {
      super(t, e),
        this.isSpotLight = !0,
        this.type = "SpotLight",
        this.position.copy(mn.DefaultUp),
        this.updateMatrix(),
        this.target = new mn,
        this.distance = i,
        this.angle = n,
        this.penumbra = r,
        this.decay = o,
        this.shadow = new Mc
    }
    get power() {
      return this.intensity * Math.PI
    }
    set power(t) {
      this.intensity = t / Math.PI
    }
    dispose() {
      this.shadow.dispose()
    }
    copy(t, e) {
      return super.copy(t, e),
        this.distance = t.distance,
        this.angle = t.angle,
        this.penumbra = t.penumbra,
        this.decay = t.decay,
        this.target = t.target.clone(),
        this.shadow = t.shadow.clone(),
        this
    }
  }
  const Ec = new Wi
    , kc = new di
    , Rc = new di;
  class Lc extends Sc {
    constructor() {
      super(new mr(90, 1, .5, 500)),
        this.isPointLightShadow = !0,
        this._frameExtents = new Fe(4, 2),
        this._viewportCount = 6,
        this._viewports = [new li(2, 1, 1, 1), new li(0, 1, 1, 1), new li(3, 1, 1, 1), new li(1, 1, 1, 1), new li(3, 0, 1, 1), new li(1, 0, 1, 1)],
        this._cubeDirections = [new di(1, 0, 0), new di(-1, 0, 0), new di(0, 0, 1), new di(0, 0, -1), new di(0, 1, 0), new di(0, -1, 0)],
        this._cubeUps = [new di(0, 1, 0), new di(0, 1, 0), new di(0, 1, 0), new di(0, 1, 0), new di(0, 0, 1), new di(0, 0, -1)]
    }
    updateMatrices(t, e = 0) {
      const i = this.camera
        , n = this.matrix
        , r = t.distance || i.far;
      r !== i.far && (i.far = r,
        i.updateProjectionMatrix()),
        kc.setFromMatrixPosition(t.matrixWorld),
        i.position.copy(kc),
        Rc.copy(i.position),
        Rc.add(this._cubeDirections[e]),
        i.up.copy(this._cubeUps[e]),
        i.lookAt(Rc),
        i.updateMatrixWorld(),
        n.makeTranslation(-kc.x, -kc.y, -kc.z),
        Ec.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(Ec)
    }
  }
  class Pc extends xc {
    constructor(t, e, i = 0, n = 1) {
      super(t, e),
        this.isPointLight = !0,
        this.type = "PointLight",
        this.distance = i,
        this.decay = n,
        this.shadow = new Lc
    }
    get power() {
      return 4 * this.intensity * Math.PI
    }
    set power(t) {
      this.intensity = t / (4 * Math.PI)
    }
    dispose() {
      this.shadow.dispose()
    }
    copy(t, e) {
      return super.copy(t, e),
        this.distance = t.distance,
        this.decay = t.decay,
        this.shadow = t.shadow.clone(),
        this
    }
  }
  class zc extends Sc {
    constructor() {
      super(new Br(-5, 5, 5, -5, .5, 500)),
        this.isDirectionalLightShadow = !0
    }
  }
  class Oc extends xc {
    constructor(t, e) {
      super(t, e),
        this.isDirectionalLight = !0,
        this.type = "DirectionalLight",
        this.position.copy(mn.DefaultUp),
        this.updateMatrix(),
        this.target = new mn,
        this.shadow = new zc
    }
    dispose() {
      this.shadow.dispose()
    }
    copy(t) {
      return super.copy(t),
        this.target = t.target.clone(),
        this.shadow = t.shadow.clone(),
        this
    }
  }
  class Dc extends xc {
    constructor(t, e) {
      super(t, e),
        this.isAmbientLight = !0,
        this.type = "AmbientLight"
    }
  }
  class Uc extends xc {
    constructor(t, e, i = 10, n = 10) {
      super(t, e),
        this.isRectAreaLight = !0,
        this.type = "RectAreaLight",
        this.width = i,
        this.height = n
    }
    get power() {
      return this.intensity * this.width * this.height * Math.PI
    }
    set power(t) {
      this.intensity = t / (this.width * this.height * Math.PI)
    }
    copy(t) {
      return super.copy(t),
        this.width = t.width,
        this.height = t.height,
        this
    }
    toJSON(t) {
      const e = super.toJSON(t);
      return e.object.width = this.width,
        e.object.height = this.height,
        e
    }
  }
  class Nc {
    constructor() {
      this.isSphericalHarmonics3 = !0,
        this.coefficients = [];
      for (let t = 0; t < 9; t++)
        this.coefficients.push(new di)
    }
    set(t) {
      for (let e = 0; e < 9; e++)
        this.coefficients[e].copy(t[e]);
      return this
    }
    zero() {
      for (let t = 0; t < 9; t++)
        this.coefficients[t].set(0, 0, 0);
      return this
    }
    getAt(t, e) {
      const i = t.x
        , n = t.y
        , r = t.z
        , o = this.coefficients;
      return e.copy(o[0]).multiplyScalar(.282095),
        e.addScaledVector(o[1], .488603 * n),
        e.addScaledVector(o[2], .488603 * r),
        e.addScaledVector(o[3], .488603 * i),
        e.addScaledVector(o[4], i * n * 1.092548),
        e.addScaledVector(o[5], n * r * 1.092548),
        e.addScaledVector(o[6], .315392 * (3 * r * r - 1)),
        e.addScaledVector(o[7], i * r * 1.092548),
        e.addScaledVector(o[8], .546274 * (i * i - n * n)),
        e
    }
    getIrradianceAt(t, e) {
      const i = t.x
        , n = t.y
        , r = t.z
        , o = this.coefficients;
      return e.copy(o[0]).multiplyScalar(.886227),
        e.addScaledVector(o[1], 1.023328 * n),
        e.addScaledVector(o[2], 1.023328 * r),
        e.addScaledVector(o[3], 1.023328 * i),
        e.addScaledVector(o[4], .858086 * i * n),
        e.addScaledVector(o[5], .858086 * n * r),
        e.addScaledVector(o[6], .743125 * r * r - .247708),
        e.addScaledVector(o[7], .858086 * i * r),
        e.addScaledVector(o[8], .429043 * (i * i - n * n)),
        e
    }
    add(t) {
      for (let e = 0; e < 9; e++)
        this.coefficients[e].add(t.coefficients[e]);
      return this
    }
    addScaledSH(t, e) {
      for (let i = 0; i < 9; i++)
        this.coefficients[i].addScaledVector(t.coefficients[i], e);
      return this
    }
    scale(t) {
      for (let e = 0; e < 9; e++)
        this.coefficients[e].multiplyScalar(t);
      return this
    }
    lerp(t, e) {
      for (let i = 0; i < 9; i++)
        this.coefficients[i].lerp(t.coefficients[i], e);
      return this
    }
    equals(t) {
      for (let e = 0; e < 9; e++)
        if (!this.coefficients[e].equals(t.coefficients[e]))
          return !1;
      return !0
    }
    copy(t) {
      return this.set(t.coefficients)
    }
    clone() {
      return (new this.constructor).copy(this)
    }
    fromArray(t, e = 0) {
      const i = this.coefficients;
      for (let n = 0; n < 9; n++)
        i[n].fromArray(t, e + 3 * n);
      return this
    }
    toArray(t = [], e = 0) {
      const i = this.coefficients;
      for (let n = 0; n < 9; n++)
        i[n].toArray(t, e + 3 * n);
      return t
    }
    static getBasisAt(t, e) {
      const i = t.x
        , n = t.y
        , r = t.z;
      e[0] = .282095,
        e[1] = .488603 * n,
        e[2] = .488603 * r,
        e[3] = .488603 * i,
        e[4] = 1.092548 * i * n,
        e[5] = 1.092548 * n * r,
        e[6] = .315392 * (3 * r * r - 1),
        e[7] = 1.092548 * i * r,
        e[8] = .546274 * (i * i - n * n)
    }
  }
  class Fc extends xc {
    constructor(t = new Nc, e = 1) {
      super(void 0, e),
        this.isLightProbe = !0,
        this.sh = t
    }
    copy(t) {
      return super.copy(t),
        this.sh.copy(t.sh),
        this
    }
    fromJSON(t) {
      return this.intensity = t.intensity,
        this.sh.fromArray(t.sh),
        this
    }
    toJSON(t) {
      const e = super.toJSON(t);
      return e.object.sh = this.sh.toArray(),
        e
    }
  }
  class Bc extends mc {
    constructor(t) {
      super(t),
        this.textures = {}
    }
    load(t, e, i, n) {
      const r = this
        , o = new vc(r.manager);
      o.setPath(r.path),
        o.setRequestHeader(r.requestHeader),
        o.setWithCredentials(r.withCredentials),
        o.load(t, (function (i) {
          try {
            e(r.parse(JSON.parse(i)))
          } catch (e) {
            n ? n(e) : console.error(e),
              r.manager.itemError(t)
          }
        }
        ), i, n)
    }
    parse(t) {
      const e = this.textures;
      function i(t) {
        return void 0 === e[t] && console.warn("THREE.MaterialLoader: Undefined texture", t),
          e[t]
      }
      const n = Bc.createMaterialFromType(t.type);
      if (void 0 !== t.uuid && (n.uuid = t.uuid),
        void 0 !== t.name && (n.name = t.name),
        void 0 !== t.color && void 0 !== n.color && n.color.setHex(t.color),
        void 0 !== t.roughness && (n.roughness = t.roughness),
        void 0 !== t.metalness && (n.metalness = t.metalness),
        void 0 !== t.sheen && (n.sheen = t.sheen),
        void 0 !== t.sheenColor && (n.sheenColor = (new ei).setHex(t.sheenColor)),
        void 0 !== t.sheenRoughness && (n.sheenRoughness = t.sheenRoughness),
        void 0 !== t.emissive && void 0 !== n.emissive && n.emissive.setHex(t.emissive),
        void 0 !== t.specular && void 0 !== n.specular && n.specular.setHex(t.specular),
        void 0 !== t.specularIntensity && (n.specularIntensity = t.specularIntensity),
        void 0 !== t.specularColor && void 0 !== n.specularColor && n.specularColor.setHex(t.specularColor),
        void 0 !== t.shininess && (n.shininess = t.shininess),
        void 0 !== t.clearcoat && (n.clearcoat = t.clearcoat),
        void 0 !== t.clearcoatRoughness && (n.clearcoatRoughness = t.clearcoatRoughness),
        void 0 !== t.iridescence && (n.iridescence = t.iridescence),
        void 0 !== t.iridescenceIOR && (n.iridescenceIOR = t.iridescenceIOR),
        void 0 !== t.iridescenceThicknessRange && (n.iridescenceThicknessRange = t.iridescenceThicknessRange),
        void 0 !== t.transmission && (n.transmission = t.transmission),
        void 0 !== t.thickness && (n.thickness = t.thickness),
        void 0 !== t.attenuationDistance && (n.attenuationDistance = t.attenuationDistance),
        void 0 !== t.attenuationColor && void 0 !== n.attenuationColor && n.attenuationColor.setHex(t.attenuationColor),
        void 0 !== t.fog && (n.fog = t.fog),
        void 0 !== t.flatShading && (n.flatShading = t.flatShading),
        void 0 !== t.blending && (n.blending = t.blending),
        void 0 !== t.combine && (n.combine = t.combine),
        void 0 !== t.side && (n.side = t.side),
        void 0 !== t.shadowSide && (n.shadowSide = t.shadowSide),
        void 0 !== t.opacity && (n.opacity = t.opacity),
        void 0 !== t.transparent && (n.transparent = t.transparent),
        void 0 !== t.alphaTest && (n.alphaTest = t.alphaTest),
        void 0 !== t.depthTest && (n.depthTest = t.depthTest),
        void 0 !== t.depthWrite && (n.depthWrite = t.depthWrite),
        void 0 !== t.colorWrite && (n.colorWrite = t.colorWrite),
        void 0 !== t.stencilWrite && (n.stencilWrite = t.stencilWrite),
        void 0 !== t.stencilWriteMask && (n.stencilWriteMask = t.stencilWriteMask),
        void 0 !== t.stencilFunc && (n.stencilFunc = t.stencilFunc),
        void 0 !== t.stencilRef && (n.stencilRef = t.stencilRef),
        void 0 !== t.stencilFuncMask && (n.stencilFuncMask = t.stencilFuncMask),
        void 0 !== t.stencilFail && (n.stencilFail = t.stencilFail),
        void 0 !== t.stencilZFail && (n.stencilZFail = t.stencilZFail),
        void 0 !== t.stencilZPass && (n.stencilZPass = t.stencilZPass),
        void 0 !== t.wireframe && (n.wireframe = t.wireframe),
        void 0 !== t.wireframeLinewidth && (n.wireframeLinewidth = t.wireframeLinewidth),
        void 0 !== t.wireframeLinecap && (n.wireframeLinecap = t.wireframeLinecap),
        void 0 !== t.wireframeLinejoin && (n.wireframeLinejoin = t.wireframeLinejoin),
        void 0 !== t.rotation && (n.rotation = t.rotation),
        1 !== t.linewidth && (n.linewidth = t.linewidth),
        void 0 !== t.dashSize && (n.dashSize = t.dashSize),
        void 0 !== t.gapSize && (n.gapSize = t.gapSize),
        void 0 !== t.scale && (n.scale = t.scale),
        void 0 !== t.polygonOffset && (n.polygonOffset = t.polygonOffset),
        void 0 !== t.polygonOffsetFactor && (n.polygonOffsetFactor = t.polygonOffsetFactor),
        void 0 !== t.polygonOffsetUnits && (n.polygonOffsetUnits = t.polygonOffsetUnits),
        void 0 !== t.dithering && (n.dithering = t.dithering),
        void 0 !== t.alphaToCoverage && (n.alphaToCoverage = t.alphaToCoverage),
        void 0 !== t.premultipliedAlpha && (n.premultipliedAlpha = t.premultipliedAlpha),
        void 0 !== t.visible && (n.visible = t.visible),
        void 0 !== t.toneMapped && (n.toneMapped = t.toneMapped),
        void 0 !== t.userData && (n.userData = t.userData),
        void 0 !== t.vertexColors && ("number" == typeof t.vertexColors ? n.vertexColors = t.vertexColors > 0 : n.vertexColors = t.vertexColors),
        void 0 !== t.uniforms)
        for (const e in t.uniforms) {
          const r = t.uniforms[e];
          switch (n.uniforms[e] = {},
          r.type) {
            case "t":
              n.uniforms[e].value = i(r.value);
              break;
            case "c":
              n.uniforms[e].value = (new ei).setHex(r.value);
              break;
            case "v2":
              n.uniforms[e].value = (new Fe).fromArray(r.value);
              break;
            case "v3":
              n.uniforms[e].value = (new di).fromArray(r.value);
              break;
            case "v4":
              n.uniforms[e].value = (new li).fromArray(r.value);
              break;
            case "m3":
              n.uniforms[e].value = (new Be).fromArray(r.value);
              break;
            case "m4":
              n.uniforms[e].value = (new Wi).fromArray(r.value);
              break;
            default:
              n.uniforms[e].value = r.value
          }
        }
      if (void 0 !== t.defines && (n.defines = t.defines),
        void 0 !== t.vertexShader && (n.vertexShader = t.vertexShader),
        void 0 !== t.fragmentShader && (n.fragmentShader = t.fragmentShader),
        void 0 !== t.extensions)
        for (const e in t.extensions)
          n.extensions[e] = t.extensions[e];
      if (void 0 !== t.shading && (n.flatShading = 1 === t.shading),
        void 0 !== t.size && (n.size = t.size),
        void 0 !== t.sizeAttenuation && (n.sizeAttenuation = t.sizeAttenuation),
        void 0 !== t.map && (n.map = i(t.map)),
        void 0 !== t.matcap && (n.matcap = i(t.matcap)),
        void 0 !== t.alphaMap && (n.alphaMap = i(t.alphaMap)),
        void 0 !== t.bumpMap && (n.bumpMap = i(t.bumpMap)),
        void 0 !== t.bumpScale && (n.bumpScale = t.bumpScale),
        void 0 !== t.normalMap && (n.normalMap = i(t.normalMap)),
        void 0 !== t.normalMapType && (n.normalMapType = t.normalMapType),
        void 0 !== t.normalScale) {
        let e = t.normalScale;
        !1 === Array.isArray(e) && (e = [e, e]),
          n.normalScale = (new Fe).fromArray(e)
      }
      return void 0 !== t.displacementMap && (n.displacementMap = i(t.displacementMap)),
        void 0 !== t.displacementScale && (n.displacementScale = t.displacementScale),
        void 0 !== t.displacementBias && (n.displacementBias = t.displacementBias),
        void 0 !== t.roughnessMap && (n.roughnessMap = i(t.roughnessMap)),
        void 0 !== t.metalnessMap && (n.metalnessMap = i(t.metalnessMap)),
        void 0 !== t.emissiveMap && (n.emissiveMap = i(t.emissiveMap)),
        void 0 !== t.emissiveIntensity && (n.emissiveIntensity = t.emissiveIntensity),
        void 0 !== t.specularMap && (n.specularMap = i(t.specularMap)),
        void 0 !== t.specularIntensityMap && (n.specularIntensityMap = i(t.specularIntensityMap)),
        void 0 !== t.specularColorMap && (n.specularColorMap = i(t.specularColorMap)),
        void 0 !== t.envMap && (n.envMap = i(t.envMap)),
        void 0 !== t.envMapIntensity && (n.envMapIntensity = t.envMapIntensity),
        void 0 !== t.reflectivity && (n.reflectivity = t.reflectivity),
        void 0 !== t.refractionRatio && (n.refractionRatio = t.refractionRatio),
        void 0 !== t.lightMap && (n.lightMap = i(t.lightMap)),
        void 0 !== t.lightMapIntensity && (n.lightMapIntensity = t.lightMapIntensity),
        void 0 !== t.aoMap && (n.aoMap = i(t.aoMap)),
        void 0 !== t.aoMapIntensity && (n.aoMapIntensity = t.aoMapIntensity),
        void 0 !== t.gradientMap && (n.gradientMap = i(t.gradientMap)),
        void 0 !== t.clearcoatMap && (n.clearcoatMap = i(t.clearcoatMap)),
        void 0 !== t.clearcoatRoughnessMap && (n.clearcoatRoughnessMap = i(t.clearcoatRoughnessMap)),
        void 0 !== t.clearcoatNormalMap && (n.clearcoatNormalMap = i(t.clearcoatNormalMap)),
        void 0 !== t.clearcoatNormalScale && (n.clearcoatNormalScale = (new Fe).fromArray(t.clearcoatNormalScale)),
        void 0 !== t.iridescenceMap && (n.iridescenceMap = i(t.iridescenceMap)),
        void 0 !== t.iridescenceThicknessMap && (n.iridescenceThicknessMap = i(t.iridescenceThicknessMap)),
        void 0 !== t.transmissionMap && (n.transmissionMap = i(t.transmissionMap)),
        void 0 !== t.thicknessMap && (n.thicknessMap = i(t.thicknessMap)),
        void 0 !== t.sheenColorMap && (n.sheenColorMap = i(t.sheenColorMap)),
        void 0 !== t.sheenRoughnessMap && (n.sheenRoughnessMap = i(t.sheenRoughnessMap)),
        n
    }
    setTextures(t) {
      return this.textures = t,
        this
    }
    static createMaterialFromType(t) {
      return new {
        ShadowMaterial: Vh,
        SpriteMaterial: va,
        RawShaderMaterial: Gh,
        ShaderMaterial: fr,
        PointsMaterial: ul,
        MeshPhysicalMaterial: Jh,
        MeshStandardMaterial: Wh,
        MeshPhongMaterial: Hh,
        MeshToonMaterial: Zh,
        MeshNormalMaterial: Qh,
        MeshLambertMaterial: Kh,
        MeshDepthMaterial: Ks,
        MeshDistanceMaterial: Ys,
        MeshBasicMaterial: kn,
        MeshMatcapMaterial: Yh,
        LineDashedMaterial: qh,
        LineBasicMaterial: tl,
        Material: En
      }[t]
    }
  }
  class jc {
    static decodeText(t) {
      if ("undefined" != typeof TextDecoder)
        return (new TextDecoder).decode(t);
      let e = "";
      for (let i = 0, n = t.length; i < n; i++)
        e += String.fromCharCode(t[i]);
      try {
        return decodeURIComponent(escape(e))
      } catch (t) {
        return e
      }
    }
    static extractUrlBase(t) {
      const e = t.lastIndexOf("/");
      return -1 === e ? "./" : t.slice(0, e + 1)
    }
    static resolveURL(t, e) {
      return "string" != typeof t || "" === t ? "" : (/^https?:\/\//i.test(e) && /^\//.test(t) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : e + t)
    }
  }
  class Vc extends Wn {
    constructor() {
      super(),
        this.isInstancedBufferGeometry = !0,
        this.type = "InstancedBufferGeometry",
        this.instanceCount = 1 / 0
    }
    copy(t) {
      return super.copy(t),
        this.instanceCount = t.instanceCount,
        this
    }
    clone() {
      return (new this.constructor).copy(this)
    }
    toJSON() {
      const t = super.toJSON(this);
      return t.instanceCount = this.instanceCount,
        t.isInstancedBufferGeometry = !0,
        t
    }
  }
  class Gc extends mc {
    constructor(t) {
      super(t)
    }
    load(t, e, i, n) {
      const r = this
        , o = new vc(r.manager);
      o.setPath(r.path),
        o.setRequestHeader(r.requestHeader),
        o.setWithCredentials(r.withCredentials),
        o.load(t, (function (i) {
          try {
            e(r.parse(JSON.parse(i)))
          } catch (e) {
            n ? n(e) : console.error(e),
              r.manager.itemError(t)
          }
        }
        ), i, n)
    }
    parse(t) {
      const e = {}
        , i = {};
      function n(t, n) {
        if (void 0 !== e[n])
          return e[n];
        const r = t.interleavedBuffers[n]
          , o = function (t, e) {
            if (void 0 !== i[e])
              return i[e];
            const n = t.arrayBuffers
              , r = n[e]
              , o = new Uint32Array(r).buffer;
            return i[e] = o,
              o
          }(t, r.buffer)
          , s = Ge(r.type, o)
          , a = new ga(s, r.stride);
        return a.uuid = r.uuid,
          e[n] = a,
          a
      }
      const r = t.isInstancedBufferGeometry ? new Vc : new Wn
        , o = t.data.index;
      if (void 0 !== o) {
        const t = Ge(o.type, o.array);
        r.setIndex(new Pn(t, 1))
      }
      const s = t.data.attributes;
      for (const e in s) {
        const i = s[e];
        let o;
        if (i.isInterleavedBufferAttribute) {
          const e = n(t.data, i.data);
          o = new ya(e, i.itemSize, i.offset, i.normalized)
        } else {
          const t = Ge(i.type, i.array);
          o = new (i.isInstancedBufferAttribute ? Qa : Pn)(t, i.itemSize, i.normalized)
        }
        void 0 !== i.name && (o.name = i.name),
          void 0 !== i.usage && o.setUsage(i.usage),
          void 0 !== i.updateRange && (o.updateRange.offset = i.updateRange.offset,
            o.updateRange.count = i.updateRange.count),
          r.setAttribute(e, o)
      }
      const a = t.data.morphAttributes;
      if (a)
        for (const e in a) {
          const i = a[e]
            , o = [];
          for (let e = 0, r = i.length; e < r; e++) {
            const r = i[e];
            let s;
            if (r.isInterleavedBufferAttribute) {
              const e = n(t.data, r.data);
              s = new ya(e, r.itemSize, r.offset, r.normalized)
            } else {
              const t = Ge(r.type, r.array);
              s = new Pn(t, r.itemSize, r.normalized)
            }
            void 0 !== r.name && (s.name = r.name),
              o.push(s)
          }
          r.morphAttributes[e] = o
        }
      t.data.morphTargetsRelative && (r.morphTargetsRelative = !0);
      const l = t.data.groups || t.data.drawcalls || t.data.offsets;
      if (void 0 !== l)
        for (let t = 0, e = l.length; t !== e; ++t) {
          const e = l[t];
          r.addGroup(e.start, e.count, e.materialIndex)
        }
      const h = t.data.boundingSphere;
      if (void 0 !== h) {
        const t = new di;
        void 0 !== h.center && t.fromArray(h.center),
          r.boundingSphere = new Oi(t, h.radius)
      }
      return t.name && (r.name = t.name),
        t.userData && (r.userData = t.userData),
        r
    }
  }
  const Wc = {
    UVMapping: Y,
    CubeReflectionMapping: q,
    CubeRefractionMapping: X,
    EquirectangularReflectionMapping: $,
    EquirectangularRefractionMapping: tt,
    CubeUVReflectionMapping: et
  }
    , Jc = {
      RepeatWrapping: it,
      ClampToEdgeWrapping: nt,
      MirroredRepeatWrapping: rt
    }
    , Hc = {
      NearestFilter: ot,
      NearestMipmapNearestFilter: st,
      NearestMipmapLinearFilter: at,
      LinearFilter: lt,
      LinearMipmapNearestFilter: ht,
      LinearMipmapLinearFilter: ct
    };
  class Zc extends mc {
    constructor(t) {
      super(t),
        this.isImageBitmapLoader = !0,
        "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
        "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
        this.options = {
          premultiplyAlpha: "none"
        }
    }
    setOptions(t) {
      return this.options = t,
        this
    }
    load(t, e, i, n) {
      void 0 === t && (t = ""),
        void 0 !== this.path && (t = this.path + t),
        t = this.manager.resolveURL(t);
      const r = this
        , o = dc.get(t);
      if (void 0 !== o)
        return r.manager.itemStart(t),
          setTimeout((function () {
            e && e(o),
              r.manager.itemEnd(t)
          }
          ), 0),
          o;
      const s = {};
      s.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include",
        s.headers = this.requestHeader,
        fetch(t, s).then((function (t) {
          return t.blob()
        }
        )).then((function (t) {
          return createImageBitmap(t, Object.assign(r.options, {
            colorSpaceConversion: "none"
          }))
        }
        )).then((function (i) {
          dc.add(t, i),
            e && e(i),
            r.manager.itemEnd(t)
        }
        )).catch((function (e) {
          n && n(e),
            r.manager.itemError(t),
            r.manager.itemEnd(t)
        }
        )),
        r.manager.itemStart(t)
    }
  }
  let Qc;
  const Kc = {
    getContext: function () {
      return void 0 === Qc && (Qc = new (window.AudioContext || window.webkitAudioContext)),
        Qc
    },
    setContext: function (t) {
      Qc = t
    }
  };
  const Yc = new Wi
    , qc = new Wi
    , Xc = new Wi;
  class $c {
    constructor(t = !0) {
      this.autoStart = t,
        this.startTime = 0,
        this.oldTime = 0,
        this.elapsedTime = 0,
        this.running = !1
    }
    start() {
      this.startTime = tu(),
        this.oldTime = this.startTime,
        this.elapsedTime = 0,
        this.running = !0
    }
    stop() {
      this.getElapsedTime(),
        this.running = !1,
        this.autoStart = !1
    }
    getElapsedTime() {
      return this.getDelta(),
        this.elapsedTime
    }
    getDelta() {
      let t = 0;
      if (this.autoStart && !this.running)
        return this.start(),
          0;
      if (this.running) {
        const e = tu();
        t = (e - this.oldTime) / 1e3,
          this.oldTime = e,
          this.elapsedTime += t
      }
      return t
    }
  }
  function tu() {
    return ("undefined" == typeof performance ? Date : performance).now()
  }
  const eu = new di
    , iu = new pi
    , nu = new di
    , ru = new di;
  let ou = class extends mn {
    constructor(t) {
      super(),
        this.type = "Audio",
        this.listener = t,
        this.context = t.context,
        this.gain = this.context.createGain(),
        this.gain.connect(t.getInput()),
        this.autoplay = !1,
        this.buffer = null,
        this.detune = 0,
        this.loop = !1,
        this.loopStart = 0,
        this.loopEnd = 0,
        this.offset = 0,
        this.duration = void 0,
        this.playbackRate = 1,
        this.isPlaying = !1,
        this.hasPlaybackControl = !0,
        this.source = null,
        this.sourceType = "empty",
        this._startedAt = 0,
        this._progress = 0,
        this._connected = !1,
        this.filters = []
    }
    getOutput() {
      return this.gain
    }
    setNodeSource(t) {
      return this.hasPlaybackControl = !1,
        this.sourceType = "audioNode",
        this.source = t,
        this.connect(),
        this
    }
    setMediaElementSource(t) {
      return this.hasPlaybackControl = !1,
        this.sourceType = "mediaNode",
        this.source = this.context.createMediaElementSource(t),
        this.connect(),
        this
    }
    setMediaStreamSource(t) {
      return this.hasPlaybackControl = !1,
        this.sourceType = "mediaStreamNode",
        this.source = this.context.createMediaStreamSource(t),
        this.connect(),
        this
    }
    setBuffer(t) {
      return this.buffer = t,
        this.sourceType = "buffer",
        this.autoplay && this.play(),
        this
    }
    play(t = 0) {
      if (!0 === this.isPlaying)
        return void console.warn("THREE.Audio: Audio is already playing.");
      if (!1 === this.hasPlaybackControl)
        return void console.warn("THREE.Audio: this Audio has no playback control.");
      this._startedAt = this.context.currentTime + t;
      const e = this.context.createBufferSource();
      return e.buffer = this.buffer,
        e.loop = this.loop,
        e.loopStart = this.loopStart,
        e.loopEnd = this.loopEnd,
        e.onended = this.onEnded.bind(this),
        e.start(this._startedAt, this._progress + this.offset, this.duration),
        this.isPlaying = !0,
        this.source = e,
        this.setDetune(this.detune),
        this.setPlaybackRate(this.playbackRate),
        this.connect()
    }
    pause() {
      if (!1 !== this.hasPlaybackControl)
        return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate,
          !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)),
          this.source.stop(),
          this.source.onended = null,
          this.isPlaying = !1),
          this;
      console.warn("THREE.Audio: this Audio has no playback control.")
    }
    stop() {
      if (!1 !== this.hasPlaybackControl)
        return this._progress = 0,
          this.source.stop(),
          this.source.onended = null,
          this.isPlaying = !1,
          this;
      console.warn("THREE.Audio: this Audio has no playback control.")
    }
    connect() {
      if (this.filters.length > 0) {
        this.source.connect(this.filters[0]);
        for (let t = 1, e = this.filters.length; t < e; t++)
          this.filters[t - 1].connect(this.filters[t]);
        this.filters[this.filters.length - 1].connect(this.getOutput())
      } else
        this.source.connect(this.getOutput());
      return this._connected = !0,
        this
    }
    disconnect() {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let t = 1, e = this.filters.length; t < e; t++)
          this.filters[t - 1].disconnect(this.filters[t]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput())
      } else
        this.source.disconnect(this.getOutput());
      return this._connected = !1,
        this
    }
    getFilters() {
      return this.filters
    }
    setFilters(t) {
      return t || (t = []),
        !0 === this._connected ? (this.disconnect(),
          this.filters = t.slice(),
          this.connect()) : this.filters = t.slice(),
        this
    }
    setDetune(t) {
      if (this.detune = t,
        void 0 !== this.source.detune)
        return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01),
          this
    }
    getDetune() {
      return this.detune
    }
    getFilter() {
      return this.getFilters()[0]
    }
    setFilter(t) {
      return this.setFilters(t ? [t] : [])
    }
    setPlaybackRate(t) {
      if (!1 !== this.hasPlaybackControl)
        return this.playbackRate = t,
          !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01),
          this;
      console.warn("THREE.Audio: this Audio has no playback control.")
    }
    getPlaybackRate() {
      return this.playbackRate
    }
    onEnded() {
      this.isPlaying = !1
    }
    getLoop() {
      return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."),
        !1) : this.loop
    }
    setLoop(t) {
      if (!1 !== this.hasPlaybackControl)
        return this.loop = t,
          !0 === this.isPlaying && (this.source.loop = this.loop),
          this;
      console.warn("THREE.Audio: this Audio has no playback control.")
    }
    setLoopStart(t) {
      return this.loopStart = t,
        this
    }
    setLoopEnd(t) {
      return this.loopEnd = t,
        this
    }
    getVolume() {
      return this.gain.gain.value
    }
    setVolume(t) {
      return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01),
        this
    }
  }
    ;
  const su = new di
    , au = new pi
    , lu = new di
    , hu = new di;
  class cu {
    constructor(t, e, i) {
      let n, r, o;
      switch (this.binding = t,
      this.valueSize = i,
      e) {
        case "quaternion":
          n = this._slerp,
            r = this._slerpAdditive,
            o = this._setAdditiveIdentityQuaternion,
            this.buffer = new Float64Array(6 * i),
            this._workIndex = 5;
          break;
        case "string":
        case "bool":
          n = this._select,
            r = this._select,
            o = this._setAdditiveIdentityOther,
            this.buffer = new Array(5 * i);
          break;
        default:
          n = this._lerp,
            r = this._lerpAdditive,
            o = this._setAdditiveIdentityNumeric,
            this.buffer = new Float64Array(5 * i)
      }
      this._mixBufferRegion = n,
        this._mixBufferRegionAdditive = r,
        this._setIdentity = o,
        this._origIndex = 3,
        this._addIndex = 4,
        this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0,
        this.useCount = 0,
        this.referenceCount = 0
    }
    accumulate(t, e) {
      const i = this.buffer
        , n = this.valueSize
        , r = t * n + n;
      let o = this.cumulativeWeight;
      if (0 === o) {
        for (let t = 0; t !== n; ++t)
          i[r + t] = i[t];
        o = e
      } else {
        o += e;
        const t = e / o;
        this._mixBufferRegion(i, r, 0, t, n)
      }
      this.cumulativeWeight = o
    }
    accumulateAdditive(t) {
      const e = this.buffer
        , i = this.valueSize
        , n = i * this._addIndex;
      0 === this.cumulativeWeightAdditive && this._setIdentity(),
        this._mixBufferRegionAdditive(e, n, 0, t, i),
        this.cumulativeWeightAdditive += t
    }
    apply(t) {
      const e = this.valueSize
        , i = this.buffer
        , n = t * e + e
        , r = this.cumulativeWeight
        , o = this.cumulativeWeightAdditive
        , s = this.binding;
      if (this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0,
        r < 1) {
        const t = e * this._origIndex;
        this._mixBufferRegion(i, n, t, 1 - r, e)
      }
      o > 0 && this._mixBufferRegionAdditive(i, n, this._addIndex * e, 1, e);
      for (let t = e, r = e + e; t !== r; ++t)
        if (i[t] !== i[t + e]) {
          s.setValue(i, n);
          break
        }
    }
    saveOriginalState() {
      const t = this.binding
        , e = this.buffer
        , i = this.valueSize
        , n = i * this._origIndex;
      t.getValue(e, n);
      for (let t = i, r = n; t !== r; ++t)
        e[t] = e[n + t % i];
      this._setIdentity(),
        this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0
    }
    restoreOriginalState() {
      const t = 3 * this.valueSize;
      this.binding.setValue(this.buffer, t)
    }
    _setAdditiveIdentityNumeric() {
      const t = this._addIndex * this.valueSize
        , e = t + this.valueSize;
      for (let i = t; i < e; i++)
        this.buffer[i] = 0
    }
    _setAdditiveIdentityQuaternion() {
      this._setAdditiveIdentityNumeric(),
        this.buffer[this._addIndex * this.valueSize + 3] = 1
    }
    _setAdditiveIdentityOther() {
      const t = this._origIndex * this.valueSize
        , e = this._addIndex * this.valueSize;
      for (let i = 0; i < this.valueSize; i++)
        this.buffer[e + i] = this.buffer[t + i]
    }
    _select(t, e, i, n, r) {
      if (n >= .5)
        for (let n = 0; n !== r; ++n)
          t[e + n] = t[i + n]
    }
    _slerp(t, e, i, n) {
      pi.slerpFlat(t, e, t, e, t, i, n)
    }
    _slerpAdditive(t, e, i, n, r) {
      const o = this._workIndex * r;
      pi.multiplyQuaternionsFlat(t, o, t, e, t, i),
        pi.slerpFlat(t, e, t, e, t, o, n)
    }
    _lerp(t, e, i, n, r) {
      const o = 1 - n;
      for (let s = 0; s !== r; ++s) {
        const r = e + s;
        t[r] = t[r] * o + t[i + s] * n
      }
    }
    _lerpAdditive(t, e, i, n, r) {
      for (let o = 0; o !== r; ++o) {
        const r = e + o;
        t[r] = t[r] + t[i + o] * n
      }
    }
  }
  const uu = "\\[\\]\\.:\\/"
    , pu = new RegExp("[" + uu + "]", "g")
    , du = "[^" + uu + "]"
    , fu = "[^" + uu.replace("\\.", "") + "]"
    , gu = new RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", du) + /(WCOD+)?/.source.replace("WCOD", fu) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", du) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", du) + "$")
    , mu = ["material", "materials", "bones"];
  class yu {
    constructor(t, e, i) {
      this.path = e,
        this.parsedPath = i || yu.parseTrackName(e),
        this.node = yu.findNode(t, this.parsedPath.nodeName) || t,
        this.rootNode = t,
        this.getValue = this._getValue_unbound,
        this.setValue = this._setValue_unbound
    }
    static create(t, e, i) {
      return t && t.isAnimationObjectGroup ? new yu.Composite(t, e, i) : new yu(t, e, i)
    }
    static sanitizeNodeName(t) {
      return t.replace(/\s/g, "_").replace(pu, "")
    }
    static parseTrackName(t) {
      const e = gu.exec(t);
      if (null === e)
        throw new Error("PropertyBinding: Cannot parse trackName: " + t);
      const i = {
        nodeName: e[2],
        objectName: e[3],
        objectIndex: e[4],
        propertyName: e[5],
        propertyIndex: e[6]
      }
        , n = i.nodeName && i.nodeName.lastIndexOf(".");
      if (void 0 !== n && -1 !== n) {
        const t = i.nodeName.substring(n + 1);
        -1 !== mu.indexOf(t) && (i.nodeName = i.nodeName.substring(0, n),
          i.objectName = t)
      }
      if (null === i.propertyName || 0 === i.propertyName.length)
        throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
      return i
    }
    static findNode(t, e) {
      if (void 0 === e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid)
        return t;
      if (t.skeleton) {
        const i = t.skeleton.getBoneByName(e);
        if (void 0 !== i)
          return i
      }
      if (t.children) {
        const i = function (t) {
          for (let n = 0; n < t.length; n++) {
            const r = t[n];
            if (r.name === e || r.uuid === e)
              return r;
            const o = i(r.children);
            if (o)
              return o
          }
          return null
        }
          , n = i(t.children);
        if (n)
          return n
      }
      return null
    }
    _getValue_unavailable() { }
    _setValue_unavailable() { }
    _getValue_direct(t, e) {
      t[e] = this.targetObject[this.propertyName]
    }
    _getValue_array(t, e) {
      const i = this.resolvedProperty;
      for (let n = 0, r = i.length; n !== r; ++n)
        t[e++] = i[n]
    }
    _getValue_arrayElement(t, e) {
      t[e] = this.resolvedProperty[this.propertyIndex]
    }
    _getValue_toArray(t, e) {
      this.resolvedProperty.toArray(t, e)
    }
    _setValue_direct(t, e) {
      this.targetObject[this.propertyName] = t[e]
    }
    _setValue_direct_setNeedsUpdate(t, e) {
      this.targetObject[this.propertyName] = t[e],
        this.targetObject.needsUpdate = !0
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
      this.targetObject[this.propertyName] = t[e],
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_array(t, e) {
      const i = this.resolvedProperty;
      for (let n = 0, r = i.length; n !== r; ++n)
        i[n] = t[e++]
    }
    _setValue_array_setNeedsUpdate(t, e) {
      const i = this.resolvedProperty;
      for (let n = 0, r = i.length; n !== r; ++n)
        i[n] = t[e++];
      this.targetObject.needsUpdate = !0
    }
    _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
      const i = this.resolvedProperty;
      for (let n = 0, r = i.length; n !== r; ++n)
        i[n] = t[e++];
      this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_arrayElement(t, e) {
      this.resolvedProperty[this.propertyIndex] = t[e]
    }
    _setValue_arrayElement_setNeedsUpdate(t, e) {
      this.resolvedProperty[this.propertyIndex] = t[e],
        this.targetObject.needsUpdate = !0
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
      this.resolvedProperty[this.propertyIndex] = t[e],
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_fromArray(t, e) {
      this.resolvedProperty.fromArray(t, e)
    }
    _setValue_fromArray_setNeedsUpdate(t, e) {
      this.resolvedProperty.fromArray(t, e),
        this.targetObject.needsUpdate = !0
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
      this.resolvedProperty.fromArray(t, e),
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _getValue_unbound(t, e) {
      this.bind(),
        this.getValue(t, e)
    }
    _setValue_unbound(t, e) {
      this.bind(),
        this.setValue(t, e)
    }
    bind() {
      let t = this.node;
      const e = this.parsedPath
        , i = e.objectName
        , n = e.propertyName;
      let r = e.propertyIndex;
      if (t || (t = yu.findNode(this.rootNode, e.nodeName) || this.rootNode,
        this.node = t),
        this.getValue = this._getValue_unavailable,
        this.setValue = this._setValue_unavailable,
        !t)
        return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
      if (i) {
        let n = e.objectIndex;
        switch (i) {
          case "materials":
            if (!t.material)
              return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            if (!t.material.materials)
              return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            t = t.material.materials;
            break;
          case "bones":
            if (!t.skeleton)
              return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            t = t.skeleton.bones;
            for (let e = 0; e < t.length; e++)
              if (t[e].name === n) {
                n = e;
                break
              }
            break;
          default:
            if (void 0 === t[i])
              return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            t = t[i]
        }
        if (void 0 !== n) {
          if (void 0 === t[n])
            return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
          t = t[n]
        }
      }
      const o = t[n];
      if (void 0 === o) {
        const i = e.nodeName;
        return void console.error("THREE.PropertyBinding: Trying to update property for track: " + i + "." + n + " but it wasn't found.", t)
      }
      let s = this.Versioning.None;
      this.targetObject = t,
        void 0 !== t.needsUpdate ? s = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (s = this.Versioning.MatrixWorldNeedsUpdate);
      let a = this.BindingType.Direct;
      if (void 0 !== r) {
        if ("morphTargetInfluences" === n) {
          if (!t.geometry)
            return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          if (!t.geometry.morphAttributes)
            return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          void 0 !== t.morphTargetDictionary[r] && (r = t.morphTargetDictionary[r])
        }
        a = this.BindingType.ArrayElement,
          this.resolvedProperty = o,
          this.propertyIndex = r
      } else
        void 0 !== o.fromArray && void 0 !== o.toArray ? (a = this.BindingType.HasFromToArray,
          this.resolvedProperty = o) : Array.isArray(o) ? (a = this.BindingType.EntireArray,
            this.resolvedProperty = o) : this.propertyName = n;
      this.getValue = this.GetterByBindingType[a],
        this.setValue = this.SetterByBindingTypeAndVersioning[a][s]
    }
    unbind() {
      this.node = null,
        this.getValue = this._getValue_unbound,
        this.setValue = this._setValue_unbound
    }
  }
  yu.Composite = class {
    constructor(t, e, i) {
      const n = i || yu.parseTrackName(e);
      this._targetGroup = t,
        this._bindings = t.subscribe_(e, n)
    }
    getValue(t, e) {
      this.bind();
      const i = this._targetGroup.nCachedObjects_
        , n = this._bindings[i];
      void 0 !== n && n.getValue(t, e)
    }
    setValue(t, e) {
      const i = this._bindings;
      for (let n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n)
        i[n].setValue(t, e)
    }
    bind() {
      const t = this._bindings;
      for (let e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e)
        t[e].bind()
    }
    unbind() {
      const t = this._bindings;
      for (let e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e)
        t[e].unbind()
    }
  }
    ,
    yu.prototype.BindingType = {
      Direct: 0,
      EntireArray: 1,
      ArrayElement: 2,
      HasFromToArray: 3
    },
    yu.prototype.Versioning = {
      None: 0,
      NeedsUpdate: 1,
      MatrixWorldNeedsUpdate: 2
    },
    yu.prototype.GetterByBindingType = [yu.prototype._getValue_direct, yu.prototype._getValue_array, yu.prototype._getValue_arrayElement, yu.prototype._getValue_toArray],
    yu.prototype.SetterByBindingTypeAndVersioning = [[yu.prototype._setValue_direct, yu.prototype._setValue_direct_setNeedsUpdate, yu.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [yu.prototype._setValue_array, yu.prototype._setValue_array_setNeedsUpdate, yu.prototype._setValue_array_setMatrixWorldNeedsUpdate], [yu.prototype._setValue_arrayElement, yu.prototype._setValue_arrayElement_setNeedsUpdate, yu.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [yu.prototype._setValue_fromArray, yu.prototype._setValue_fromArray_setNeedsUpdate, yu.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
  class vu {
    constructor(t, e, i = null, n = e.blendMode) {
      this._mixer = t,
        this._clip = e,
        this._localRoot = i,
        this.blendMode = n;
      const r = e.tracks
        , o = r.length
        , s = new Array(o)
        , a = {
          endingStart: he,
          endingEnd: he
        };
      for (let t = 0; t !== o; ++t) {
        const e = r[t].createInterpolant(null);
        s[t] = e,
          e.settings = a
      }
      this._interpolantSettings = a,
        this._interpolants = s,
        this._propertyBindings = new Array(o),
        this._cacheIndex = null,
        this._byClipCacheIndex = null,
        this._timeScaleInterpolant = null,
        this._weightInterpolant = null,
        this.loop = 2201,
        this._loopCount = -1,
        this._startTime = null,
        this.time = 0,
        this.timeScale = 1,
        this._effectiveTimeScale = 1,
        this.weight = 1,
        this._effectiveWeight = 1,
        this.repetitions = 1 / 0,
        this.paused = !1,
        this.enabled = !0,
        this.clampWhenFinished = !1,
        this.zeroSlopeAtStart = !0,
        this.zeroSlopeAtEnd = !0
    }
    play() {
      return this._mixer._activateAction(this),
        this
    }
    stop() {
      return this._mixer._deactivateAction(this),
        this.reset()
    }
    reset() {
      return this.paused = !1,
        this.enabled = !0,
        this.time = 0,
        this._loopCount = -1,
        this._startTime = null,
        this.stopFading().stopWarping()
    }
    isRunning() {
      return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
    }
    isScheduled() {
      return this._mixer._isActiveAction(this)
    }
    startAt(t) {
      return this._startTime = t,
        this
    }
    setLoop(t, e) {
      return this.loop = t,
        this.repetitions = e,
        this
    }
    setEffectiveWeight(t) {
      return this.weight = t,
        this._effectiveWeight = this.enabled ? t : 0,
        this.stopFading()
    }
    getEffectiveWeight() {
      return this._effectiveWeight
    }
    fadeIn(t) {
      return this._scheduleFading(t, 0, 1)
    }
    fadeOut(t) {
      return this._scheduleFading(t, 1, 0)
    }
    crossFadeFrom(t, e, i) {
      if (t.fadeOut(e),
        this.fadeIn(e),
        i) {
        const i = this._clip.duration
          , n = t._clip.duration
          , r = n / i
          , o = i / n;
        t.warp(1, r, e),
          this.warp(o, 1, e)
      }
      return this
    }
    crossFadeTo(t, e, i) {
      return t.crossFadeFrom(this, e, i)
    }
    stopFading() {
      const t = this._weightInterpolant;
      return null !== t && (this._weightInterpolant = null,
        this._mixer._takeBackControlInterpolant(t)),
        this
    }
    setEffectiveTimeScale(t) {
      return this.timeScale = t,
        this._effectiveTimeScale = this.paused ? 0 : t,
        this.stopWarping()
    }
    getEffectiveTimeScale() {
      return this._effectiveTimeScale
    }
    setDuration(t) {
      return this.timeScale = this._clip.duration / t,
        this.stopWarping()
    }
    syncWith(t) {
      return this.time = t.time,
        this.timeScale = t.timeScale,
        this.stopWarping()
    }
    halt(t) {
      return this.warp(this._effectiveTimeScale, 0, t)
    }
    warp(t, e, i) {
      const n = this._mixer
        , r = n.time
        , o = this.timeScale;
      let s = this._timeScaleInterpolant;
      null === s && (s = n._lendControlInterpolant(),
        this._timeScaleInterpolant = s);
      const a = s.parameterPositions
        , l = s.sampleValues;
      return a[0] = r,
        a[1] = r + i,
        l[0] = t / o,
        l[1] = e / o,
        this
    }
    stopWarping() {
      const t = this._timeScaleInterpolant;
      return null !== t && (this._timeScaleInterpolant = null,
        this._mixer._takeBackControlInterpolant(t)),
        this
    }
    getMixer() {
      return this._mixer
    }
    getClip() {
      return this._clip
    }
    getRoot() {
      return this._localRoot || this._mixer._root
    }
    _update(t, e, i, n) {
      if (!this.enabled)
        return void this._updateWeight(t);
      const r = this._startTime;
      if (null !== r) {
        const n = (t - r) * i;
        if (n < 0 || 0 === i)
          return;
        this._startTime = null,
          e = i * n
      }
      e *= this._updateTimeScale(t);
      const o = this._updateTime(e)
        , s = this._updateWeight(t);
      if (s > 0) {
        const t = this._interpolants
          , e = this._propertyBindings;
        if (this.blendMode === de)
          for (let i = 0, n = t.length; i !== n; ++i)
            t[i].evaluate(o),
              e[i].accumulateAdditive(s);
        else
          for (let i = 0, r = t.length; i !== r; ++i)
            t[i].evaluate(o),
              e[i].accumulate(n, s)
      }
    }
    _updateWeight(t) {
      let e = 0;
      if (this.enabled) {
        e = this.weight;
        const i = this._weightInterpolant;
        if (null !== i) {
          const n = i.evaluate(t)[0];
          e *= n,
            t > i.parameterPositions[1] && (this.stopFading(),
              0 === n && (this.enabled = !1))
        }
      }
      return this._effectiveWeight = e,
        e
    }
    _updateTimeScale(t) {
      let e = 0;
      if (!this.paused) {
        e = this.timeScale;
        const i = this._timeScaleInterpolant;
        if (null !== i) {
          e *= i.evaluate(t)[0],
            t > i.parameterPositions[1] && (this.stopWarping(),
              0 === e ? this.paused = !0 : this.timeScale = e)
        }
      }
      return this._effectiveTimeScale = e,
        e
    }
    _updateTime(t) {
      const e = this._clip.duration
        , i = this.loop;
      let n = this.time + t
        , r = this._loopCount;
      const o = 2202 === i;
      if (0 === t)
        return -1 === r ? n : o && 1 == (1 & r) ? e - n : n;
      if (2200 === i) {
        -1 === r && (this._loopCount = 0,
          this._setEndings(!0, !0, !1));
        t: {
          if (n >= e)
            n = e;
          else {
            if (!(n < 0)) {
              this.time = n;
              break t
            }
            n = 0
          }
          this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
            this.time = n,
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: t < 0 ? -1 : 1
            })
        }
      } else {
        if (-1 === r && (t >= 0 ? (r = 0,
          this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)),
          n >= e || n < 0) {
          const i = Math.floor(n / e);
          n -= e * i,
            r += Math.abs(i);
          const s = this.repetitions - r;
          if (s <= 0)
            this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
              n = t > 0 ? e : 0,
              this.time = n,
              this._mixer.dispatchEvent({
                type: "finished",
                action: this,
                direction: t > 0 ? 1 : -1
              });
          else {
            if (1 === s) {
              const e = t < 0;
              this._setEndings(e, !e, o)
            } else
              this._setEndings(!1, !1, o);
            this._loopCount = r,
              this.time = n,
              this._mixer.dispatchEvent({
                type: "loop",
                action: this,
                loopDelta: i
              })
          }
        } else
          this.time = n;
        if (o && 1 == (1 & r))
          return e - n
      }
      return n
    }
    _setEndings(t, e, i) {
      const n = this._interpolantSettings;
      i ? (n.endingStart = ce,
        n.endingEnd = ce) : (n.endingStart = t ? this.zeroSlopeAtStart ? ce : he : ue,
          n.endingEnd = e ? this.zeroSlopeAtEnd ? ce : he : ue)
    }
    _scheduleFading(t, e, i) {
      const n = this._mixer
        , r = n.time;
      let o = this._weightInterpolant;
      null === o && (o = n._lendControlInterpolant(),
        this._weightInterpolant = o);
      const s = o.parameterPositions
        , a = o.sampleValues;
      return s[0] = r,
        a[0] = e,
        s[1] = r + t,
        a[1] = i,
        this
    }
  }
  const Au = new Float32Array(1);
  class bu extends Se {
    constructor(t) {
      super(),
        this._root = t,
        this._initMemoryManager(),
        this._accuIndex = 0,
        this.time = 0,
        this.timeScale = 1
    }
    _bindAction(t, e) {
      const i = t._localRoot || this._root
        , n = t._clip.tracks
        , r = n.length
        , o = t._propertyBindings
        , s = t._interpolants
        , a = i.uuid
        , l = this._bindingsByRootAndName;
      let h = l[a];
      void 0 === h && (h = {},
        l[a] = h);
      for (let t = 0; t !== r; ++t) {
        const r = n[t]
          , l = r.name;
        let c = h[l];
        if (void 0 !== c)
          ++c.referenceCount,
            o[t] = c;
        else {
          if (c = o[t],
            void 0 !== c) {
            null === c._cacheIndex && (++c.referenceCount,
              this._addInactiveBinding(c, a, l));
            continue
          }
          const n = e && e._propertyBindings[t].binding.parsedPath;
          c = new cu(yu.create(i, l, n), r.ValueTypeName, r.getValueSize()),
            ++c.referenceCount,
            this._addInactiveBinding(c, a, l),
            o[t] = c
        }
        s[t].resultBuffer = c.buffer
      }
    }
    _activateAction(t) {
      if (!this._isActiveAction(t)) {
        if (null === t._cacheIndex) {
          const e = (t._localRoot || this._root).uuid
            , i = t._clip.uuid
            , n = this._actionsByClip[i];
          this._bindAction(t, n && n.knownActions[0]),
            this._addInactiveAction(t, i, e)
        }
        const e = t._propertyBindings;
        for (let t = 0, i = e.length; t !== i; ++t) {
          const i = e[t];
          0 == i.useCount++ && (this._lendBinding(i),
            i.saveOriginalState())
        }
        this._lendAction(t)
      }
    }
    _deactivateAction(t) {
      if (this._isActiveAction(t)) {
        const e = t._propertyBindings;
        for (let t = 0, i = e.length; t !== i; ++t) {
          const i = e[t];
          0 == --i.useCount && (i.restoreOriginalState(),
            this._takeBackBinding(i))
        }
        this._takeBackAction(t)
      }
    }
    _initMemoryManager() {
      this._actions = [],
        this._nActiveActions = 0,
        this._actionsByClip = {},
        this._bindings = [],
        this._nActiveBindings = 0,
        this._bindingsByRootAndName = {},
        this._controlInterpolants = [],
        this._nActiveControlInterpolants = 0;
      const t = this;
      this.stats = {
        actions: {
          get total() {
            return t._actions.length
          },
          get inUse() {
            return t._nActiveActions
          }
        },
        bindings: {
          get total() {
            return t._bindings.length
          },
          get inUse() {
            return t._nActiveBindings
          }
        },
        controlInterpolants: {
          get total() {
            return t._controlInterpolants.length
          },
          get inUse() {
            return t._nActiveControlInterpolants
          }
        }
      }
    }
    _isActiveAction(t) {
      const e = t._cacheIndex;
      return null !== e && e < this._nActiveActions
    }
    _addInactiveAction(t, e, i) {
      const n = this._actions
        , r = this._actionsByClip;
      let o = r[e];
      if (void 0 === o)
        o = {
          knownActions: [t],
          actionByRoot: {}
        },
          t._byClipCacheIndex = 0,
          r[e] = o;
      else {
        const e = o.knownActions;
        t._byClipCacheIndex = e.length,
          e.push(t)
      }
      t._cacheIndex = n.length,
        n.push(t),
        o.actionByRoot[i] = t
    }
    _removeInactiveAction(t) {
      const e = this._actions
        , i = e[e.length - 1]
        , n = t._cacheIndex;
      i._cacheIndex = n,
        e[n] = i,
        e.pop(),
        t._cacheIndex = null;
      const r = t._clip.uuid
        , o = this._actionsByClip
        , s = o[r]
        , a = s.knownActions
        , l = a[a.length - 1]
        , h = t._byClipCacheIndex;
      l._byClipCacheIndex = h,
        a[h] = l,
        a.pop(),
        t._byClipCacheIndex = null;
      delete s.actionByRoot[(t._localRoot || this._root).uuid],
        0 === a.length && delete o[r],
        this._removeInactiveBindingsForAction(t)
    }
    _removeInactiveBindingsForAction(t) {
      const e = t._propertyBindings;
      for (let t = 0, i = e.length; t !== i; ++t) {
        const i = e[t];
        0 == --i.referenceCount && this._removeInactiveBinding(i)
      }
    }
    _lendAction(t) {
      const e = this._actions
        , i = t._cacheIndex
        , n = this._nActiveActions++
        , r = e[n];
      t._cacheIndex = n,
        e[n] = t,
        r._cacheIndex = i,
        e[i] = r
    }
    _takeBackAction(t) {
      const e = this._actions
        , i = t._cacheIndex
        , n = --this._nActiveActions
        , r = e[n];
      t._cacheIndex = n,
        e[n] = t,
        r._cacheIndex = i,
        e[i] = r
    }
    _addInactiveBinding(t, e, i) {
      const n = this._bindingsByRootAndName
        , r = this._bindings;
      let o = n[e];
      void 0 === o && (o = {},
        n[e] = o),
        o[i] = t,
        t._cacheIndex = r.length,
        r.push(t)
    }
    _removeInactiveBinding(t) {
      const e = this._bindings
        , i = t.binding
        , n = i.rootNode.uuid
        , r = i.path
        , o = this._bindingsByRootAndName
        , s = o[n]
        , a = e[e.length - 1]
        , l = t._cacheIndex;
      a._cacheIndex = l,
        e[l] = a,
        e.pop(),
        delete s[r],
        0 === Object.keys(s).length && delete o[n]
    }
    _lendBinding(t) {
      const e = this._bindings
        , i = t._cacheIndex
        , n = this._nActiveBindings++
        , r = e[n];
      t._cacheIndex = n,
        e[n] = t,
        r._cacheIndex = i,
        e[i] = r
    }
    _takeBackBinding(t) {
      const e = this._bindings
        , i = t._cacheIndex
        , n = --this._nActiveBindings
        , r = e[n];
      t._cacheIndex = n,
        e[n] = t,
        r._cacheIndex = i,
        e[i] = r
    }
    _lendControlInterpolant() {
      const t = this._controlInterpolants
        , e = this._nActiveControlInterpolants++;
      let i = t[e];
      return void 0 === i && (i = new ec(new Float32Array(2), new Float32Array(2), 1, Au),
        i.__cacheIndex = e,
        t[e] = i),
        i
    }
    _takeBackControlInterpolant(t) {
      const e = this._controlInterpolants
        , i = t.__cacheIndex
        , n = --this._nActiveControlInterpolants
        , r = e[n];
      t.__cacheIndex = n,
        e[n] = t,
        r.__cacheIndex = i,
        e[i] = r
    }
    clipAction(t, e, i) {
      const n = e || this._root
        , r = n.uuid;
      let o = "string" == typeof t ? uc.findByName(n, t) : t;
      const s = null !== o ? o.uuid : t
        , a = this._actionsByClip[s];
      let l = null;
      if (void 0 === i && (i = null !== o ? o.blendMode : pe),
        void 0 !== a) {
        const t = a.actionByRoot[r];
        if (void 0 !== t && t.blendMode === i)
          return t;
        l = a.knownActions[0],
          null === o && (o = l._clip)
      }
      if (null === o)
        return null;
      const h = new vu(this, o, e, i);
      return this._bindAction(h, l),
        this._addInactiveAction(h, s, r),
        h
    }
    existingAction(t, e) {
      const i = e || this._root
        , n = i.uuid
        , r = "string" == typeof t ? uc.findByName(i, t) : t
        , o = r ? r.uuid : t
        , s = this._actionsByClip[o];
      return void 0 !== s && s.actionByRoot[n] || null
    }
    stopAllAction() {
      const t = this._actions;
      for (let e = this._nActiveActions - 1; e >= 0; --e)
        t[e].stop();
      return this
    }
    update(t) {
      t *= this.timeScale;
      const e = this._actions
        , i = this._nActiveActions
        , n = this.time += t
        , r = Math.sign(t)
        , o = this._accuIndex ^= 1;
      for (let s = 0; s !== i; ++s) {
        e[s]._update(n, t, r, o)
      }
      const s = this._bindings
        , a = this._nActiveBindings;
      for (let t = 0; t !== a; ++t)
        s[t].apply(o);
      return this
    }
    setTime(t) {
      this.time = 0;
      for (let t = 0; t < this._actions.length; t++)
        this._actions[t].time = 0;
      return this.update(t)
    }
    getRoot() {
      return this._root
    }
    uncacheClip(t) {
      const e = this._actions
        , i = t.uuid
        , n = this._actionsByClip
        , r = n[i];
      if (void 0 !== r) {
        const t = r.knownActions;
        for (let i = 0, n = t.length; i !== n; ++i) {
          const n = t[i];
          this._deactivateAction(n);
          const r = n._cacheIndex
            , o = e[e.length - 1];
          n._cacheIndex = null,
            n._byClipCacheIndex = null,
            o._cacheIndex = r,
            e[r] = o,
            e.pop(),
            this._removeInactiveBindingsForAction(n)
        }
        delete n[i]
      }
    }
    uncacheRoot(t) {
      const e = t.uuid
        , i = this._actionsByClip;
      for (const t in i) {
        const n = i[t].actionByRoot[e];
        void 0 !== n && (this._deactivateAction(n),
          this._removeInactiveAction(n))
      }
      const n = this._bindingsByRootAndName[e];
      if (void 0 !== n)
        for (const t in n) {
          const e = n[t];
          e.restoreOriginalState(),
            this._removeInactiveBinding(e)
        }
    }
    uncacheAction(t, e) {
      const i = this.existingAction(t, e);
      null !== i && (this._deactivateAction(i),
        this._removeInactiveAction(i))
    }
  }
  class xu {
    constructor(t) {
      "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."),
        t = arguments[1]),
        this.value = t
    }
    clone() {
      return new xu(void 0 === this.value.clone ? this.value : this.value.clone())
    }
  }
  class Iu extends ga {
    constructor(t, e, i = 1) {
      super(t, e),
        this.isInstancedInterleavedBuffer = !0,
        this.meshPerAttribute = i
    }
    copy(t) {
      return super.copy(t),
        this.meshPerAttribute = t.meshPerAttribute,
        this
    }
    clone(t) {
      const e = super.clone(t);
      return e.meshPerAttribute = this.meshPerAttribute,
        e
    }
    toJSON(t) {
      const e = super.toJSON(t);
      return e.isInstancedInterleavedBuffer = !0,
        e.meshPerAttribute = this.meshPerAttribute,
        e
    }
  }
  class Cu {
    constructor(t, e, i = 0, n = 1 / 0) {
      this.ray = new Gi(t, e),
        this.near = i,
        this.far = n,
        this.camera = null,
        this.layers = new en,
        this.params = {
          Mesh: {},
          Line: {
            threshold: 1
          },
          LOD: {},
          Points: {
            threshold: 1
          },
          Sprite: {}
        }
    }
    set(t, e) {
      this.ray.set(t, e)
    }
    setFromCamera(t, e) {
      e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
        this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize(),
        this.camera = e) : e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e),
          this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld),
          this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type: " + e.type)
    }
    intersectObject(t, e = !0, i = []) {
      return _u(t, this, i, e),
        i.sort(wu),
        i
    }
    intersectObjects(t, e = !0, i = []) {
      for (let n = 0, r = t.length; n < r; n++)
        _u(t[n], this, i, e);
      return i.sort(wu),
        i
    }
  }
  function wu(t, e) {
    return t.distance - e.distance
  }
  function _u(t, e, i, n) {
    if (t.layers.test(e.layers) && t.raycast(e, i),
      !0 === n) {
      const n = t.children;
      for (let t = 0, r = n.length; t < r; t++)
        _u(n[t], e, i, !0)
    }
  }
  const Su = new Fe;
  class Mu {
    constructor(t = new Fe(1 / 0, 1 / 0), e = new Fe(-1 / 0, -1 / 0)) {
      this.isBox2 = !0,
        this.min = t,
        this.max = e
    }
    set(t, e) {
      return this.min.copy(t),
        this.max.copy(e),
        this
    }
    setFromPoints(t) {
      this.makeEmpty();
      for (let e = 0, i = t.length; e < i; e++)
        this.expandByPoint(t[e]);
      return this
    }
    setFromCenterAndSize(t, e) {
      const i = Su.copy(e).multiplyScalar(.5);
      return this.min.copy(t).sub(i),
        this.max.copy(t).add(i),
        this
    }
    clone() {
      return (new this.constructor).copy(this)
    }
    copy(t) {
      return this.min.copy(t.min),
        this.max.copy(t.max),
        this
    }
    makeEmpty() {
      return this.min.x = this.min.y = 1 / 0,
        this.max.x = this.max.y = -1 / 0,
        this
    }
    isEmpty() {
      return this.max.x < this.min.x || this.max.y < this.min.y
    }
    getCenter(t) {
      return this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(t) {
      return this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
    }
    expandByPoint(t) {
      return this.min.min(t),
        this.max.max(t),
        this
    }
    expandByVector(t) {
      return this.min.sub(t),
        this.max.add(t),
        this
    }
    expandByScalar(t) {
      return this.min.addScalar(-t),
        this.max.addScalar(t),
        this
    }
    containsPoint(t) {
      return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
    }
    containsBox(t) {
      return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
    }
    getParameter(t, e) {
      return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
    }
    intersectsBox(t) {
      return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
    }
    clampPoint(t, e) {
      return e.copy(t).clamp(this.min, this.max)
    }
    distanceToPoint(t) {
      return Su.copy(t).clamp(this.min, this.max).sub(t).length()
    }
    intersect(t) {
      return this.min.max(t.min),
        this.max.min(t.max),
        this
    }
    union(t) {
      return this.min.min(t.min),
        this.max.max(t.max),
        this
    }
    translate(t) {
      return this.min.add(t),
        this.max.add(t),
        this
    }
    equals(t) {
      return t.min.equals(this.min) && t.max.equals(this.max)
    }
  }
  const Tu = new di
    , Eu = new di;
  class ku {
    constructor(t = new di, e = new di) {
      this.start = t,
        this.end = e
    }
    set(t, e) {
      return this.start.copy(t),
        this.end.copy(e),
        this
    }
    copy(t) {
      return this.start.copy(t.start),
        this.end.copy(t.end),
        this
    }
    getCenter(t) {
      return t.addVectors(this.start, this.end).multiplyScalar(.5)
    }
    delta(t) {
      return t.subVectors(this.end, this.start)
    }
    distanceSq() {
      return this.start.distanceToSquared(this.end)
    }
    distance() {
      return this.start.distanceTo(this.end)
    }
    at(t, e) {
      return this.delta(e).multiplyScalar(t).add(this.start)
    }
    closestPointToPointParameter(t, e) {
      Tu.subVectors(t, this.start),
        Eu.subVectors(this.end, this.start);
      const i = Eu.dot(Eu);
      let n = Eu.dot(Tu) / i;
      return e && (n = Le(n, 0, 1)),
        n
    }
    closestPointToPoint(t, e, i) {
      const n = this.closestPointToPointParameter(t, e);
      return this.delta(i).multiplyScalar(n).add(this.start)
    }
    applyMatrix4(t) {
      return this.start.applyMatrix4(t),
        this.end.applyMatrix4(t),
        this
    }
    equals(t) {
      return t.start.equals(this.start) && t.end.equals(this.end)
    }
    clone() {
      return (new this.constructor).copy(this)
    }
  }
  const Ru = new di;
  const Lu = new di
    , Pu = new Wi
    , zu = new Wi;
  function Ou(t) {
    const e = [];
    !0 === t.isBone && e.push(t);
    for (let i = 0; i < t.children.length; i++)
      e.push.apply(e, Ou(t.children[i]));
    return e
  }
  const Du = new di
    , Uu = new ei
    , Nu = new ei;
  const Fu = new di
    , Bu = new di
    , ju = new di;
  const Vu = new di
    , Gu = new gr;
  function Wu(t, e, i, n, r, o, s) {
    Vu.set(r, o, s).unproject(n);
    const a = e[t];
    if (void 0 !== a) {
      const t = i.getAttribute("position");
      for (let e = 0, i = a.length; e < i; e++)
        t.setXYZ(a[e], Vu.x, Vu.y, Vu.z)
    }
  }
  const Ju = new mi;
  const Hu = new di;
  let Zu, Qu;
  class Ku extends hl {
    constructor(t = 1) {
      const e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t]
        , i = new Wn;
      i.setAttribute("position", new Dn(e, 3)),
        i.setAttribute("color", new Dn([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3));
      super(i, new tl({
        vertexColors: !0,
        toneMapped: !1
      })),
        this.type = "AxesHelper"
    }
    setColors(t, e, i) {
      const n = new ei
        , r = this.geometry.attributes.color.array;
      return n.set(t),
        n.toArray(r, 0),
        n.toArray(r, 3),
        n.set(e),
        n.toArray(r, 6),
        n.toArray(r, 9),
        n.set(i),
        n.toArray(r, 12),
        n.toArray(r, 15),
        this.geometry.attributes.color.needsUpdate = !0,
        this
    }
    dispose() {
      this.geometry.dispose(),
        this.material.dispose()
    }
  }
  const { floatView: Yu, uint32View: qu, baseTable: Xu, shiftTable: $u, mantissaTable: tp, exponentTable: ep, offsetTable: ip } = np();
  function np() {
    const t = new ArrayBuffer(4)
      , e = new Float32Array(t)
      , i = new Uint32Array(t)
      , n = new Uint32Array(512)
      , r = new Uint32Array(512);
    for (let t = 0; t < 256; ++t) {
      const e = t - 127;
      e < -27 ? (n[t] = 0,
        n[256 | t] = 32768,
        r[t] = 24,
        r[256 | t] = 24) : e < -14 ? (n[t] = 1024 >> -e - 14,
          n[256 | t] = 1024 >> -e - 14 | 32768,
          r[t] = -e - 1,
          r[256 | t] = -e - 1) : e <= 15 ? (n[t] = e + 15 << 10,
            n[256 | t] = e + 15 << 10 | 32768,
            r[t] = 13,
            r[256 | t] = 13) : e < 128 ? (n[t] = 31744,
              n[256 | t] = 64512,
              r[t] = 24,
              r[256 | t] = 24) : (n[t] = 31744,
                n[256 | t] = 64512,
                r[t] = 13,
                r[256 | t] = 13)
    }
    const o = new Uint32Array(2048)
      , s = new Uint32Array(64)
      , a = new Uint32Array(64);
    for (let t = 1; t < 1024; ++t) {
      let e = t << 13
        , i = 0;
      for (; 0 == (8388608 & e);)
        e <<= 1,
          i -= 8388608;
      e &= -8388609,
        i += 947912704,
        o[t] = e | i
    }
    for (let t = 1024; t < 2048; ++t)
      o[t] = 939524096 + (t - 1024 << 13);
    for (let t = 1; t < 31; ++t)
      s[t] = t << 23;
    s[31] = 1199570944,
      s[32] = 2147483648;
    for (let t = 33; t < 63; ++t)
      s[t] = 2147483648 + (t - 32 << 23);
    s[63] = 3347054592;
    for (let t = 1; t < 64; ++t)
      32 !== t && (a[t] = 1024);
    return {
      floatView: e,
      uint32View: i,
      baseTable: n,
      shiftTable: r,
      mantissaTable: o,
      exponentTable: s,
      offsetTable: a
    }
  }
  var rp = Object.freeze({
    __proto__: null,
    toHalfFloat: function (t) {
      Math.abs(t) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
        t = Le(t, -65504, 65504),
        Yu[0] = t;
      const e = qu[0]
        , i = e >> 23 & 511;
      return Xu[i] + ((8388607 & e) >> $u[i])
    },
    fromHalfFloat: function (t) {
      const e = t >> 10;
      return qu[0] = tp[ip[e] + (1023 & t)] + ep[e],
        Yu[0]
    }
  });
  "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
    detail: {
      revision: e
    }
  })),
    "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = e);
  var op = Object.freeze({
    __proto__: null,
    ACESFilmicToneMapping: Q,
    AddEquation: y,
    AddOperation: G,
    AdditiveAnimationBlendMode: de,
    AdditiveBlending: d,
    AlphaFormat: It,
    AlwaysDepth: z,
    AlwaysStencilFunc: 519,
    AmbientLight: Dc,
    AmbientLightProbe: class extends Fc {
      constructor(t, e = 1) {
        super(void 0, e),
          this.isAmbientLightProbe = !0;
        const i = (new ei).set(t);
        this.sh.coefficients[0].set(i.r, i.g, i.b).multiplyScalar(2 * Math.sqrt(Math.PI))
      }
    }
    ,
    AnimationClip: uc,
    AnimationLoader: class extends mc {
      constructor(t) {
        super(t)
      }
      load(t, e, i, n) {
        const r = this
          , o = new vc(this.manager);
        o.setPath(this.path),
          o.setRequestHeader(this.requestHeader),
          o.setWithCredentials(this.withCredentials),
          o.load(t, (function (i) {
            try {
              e(r.parse(JSON.parse(i)))
            } catch (e) {
              n ? n(e) : console.error(e),
                r.manager.itemError(t)
            }
          }
          ), i, n)
      }
      parse(t) {
        const e = [];
        for (let i = 0; i < t.length; i++) {
          const n = uc.parse(t[i]);
          e.push(n)
        }
        return e
      }
    }
    ,
    AnimationMixer: bu,
    AnimationObjectGroup: class {
      constructor() {
        this.isAnimationObjectGroup = !0,
          this.uuid = Re(),
          this._objects = Array.prototype.slice.call(arguments),
          this.nCachedObjects_ = 0;
        const t = {};
        this._indicesByUUID = t;
        for (let e = 0, i = arguments.length; e !== i; ++e)
          t[arguments[e].uuid] = e;
        this._paths = [],
          this._parsedPaths = [],
          this._bindings = [],
          this._bindingsIndicesByPath = {};
        const e = this;
        this.stats = {
          objects: {
            get total() {
              return e._objects.length
            },
            get inUse() {
              return this.total - e.nCachedObjects_
            }
          },
          get bindingsPerObject() {
            return e._bindings.length
          }
        }
      }
      add() {
        const t = this._objects
          , e = this._indicesByUUID
          , i = this._paths
          , n = this._parsedPaths
          , r = this._bindings
          , o = r.length;
        let s, a = t.length, l = this.nCachedObjects_;
        for (let h = 0, c = arguments.length; h !== c; ++h) {
          const c = arguments[h]
            , u = c.uuid;
          let p = e[u];
          if (void 0 === p) {
            p = a++,
              e[u] = p,
              t.push(c);
            for (let t = 0, e = o; t !== e; ++t)
              r[t].push(new yu(c, i[t], n[t]))
          } else if (p < l) {
            s = t[p];
            const a = --l
              , h = t[a];
            e[h.uuid] = p,
              t[p] = h,
              e[u] = a,
              t[a] = c;
            for (let t = 0, e = o; t !== e; ++t) {
              const e = r[t]
                , o = e[a];
              let s = e[p];
              e[p] = o,
                void 0 === s && (s = new yu(c, i[t], n[t])),
                e[a] = s
            }
          } else
            t[p] !== s && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
        }
        this.nCachedObjects_ = l
      }
      remove() {
        const t = this._objects
          , e = this._indicesByUUID
          , i = this._bindings
          , n = i.length;
        let r = this.nCachedObjects_;
        for (let o = 0, s = arguments.length; o !== s; ++o) {
          const s = arguments[o]
            , a = s.uuid
            , l = e[a];
          if (void 0 !== l && l >= r) {
            const o = r++
              , h = t[o];
            e[h.uuid] = l,
              t[l] = h,
              e[a] = o,
              t[o] = s;
            for (let t = 0, e = n; t !== e; ++t) {
              const e = i[t]
                , n = e[o]
                , r = e[l];
              e[l] = n,
                e[o] = r
            }
          }
        }
        this.nCachedObjects_ = r
      }
      uncache() {
        const t = this._objects
          , e = this._indicesByUUID
          , i = this._bindings
          , n = i.length;
        let r = this.nCachedObjects_
          , o = t.length;
        for (let s = 0, a = arguments.length; s !== a; ++s) {
          const a = arguments[s].uuid
            , l = e[a];
          if (void 0 !== l)
            if (delete e[a],
              l < r) {
              const s = --r
                , a = t[s]
                , h = --o
                , c = t[h];
              e[a.uuid] = l,
                t[l] = a,
                e[c.uuid] = s,
                t[s] = c,
                t.pop();
              for (let t = 0, e = n; t !== e; ++t) {
                const e = i[t]
                  , n = e[s]
                  , r = e[h];
                e[l] = n,
                  e[s] = r,
                  e.pop()
              }
            } else {
              const r = --o
                , s = t[r];
              r > 0 && (e[s.uuid] = l),
                t[l] = s,
                t.pop();
              for (let t = 0, e = n; t !== e; ++t) {
                const e = i[t];
                e[l] = e[r],
                  e.pop()
              }
            }
        }
        this.nCachedObjects_ = r
      }
      subscribe_(t, e) {
        const i = this._bindingsIndicesByPath;
        let n = i[t];
        const r = this._bindings;
        if (void 0 !== n)
          return r[n];
        const o = this._paths
          , s = this._parsedPaths
          , a = this._objects
          , l = a.length
          , h = this.nCachedObjects_
          , c = new Array(l);
        n = r.length,
          i[t] = n,
          o.push(t),
          s.push(e),
          r.push(c);
        for (let i = h, n = a.length; i !== n; ++i) {
          const n = a[i];
          c[i] = new yu(n, t, e)
        }
        return c
      }
      unsubscribe_(t) {
        const e = this._bindingsIndicesByPath
          , i = e[t];
        if (void 0 !== i) {
          const n = this._paths
            , r = this._parsedPaths
            , o = this._bindings
            , s = o.length - 1
            , a = o[s];
          e[t[s]] = i,
            o[i] = a,
            o.pop(),
            r[i] = r[s],
            r.pop(),
            n[i] = n[s],
            n.pop()
        }
      }
    }
    ,
    AnimationUtils: Xh,
    ArcCurve: xl,
    ArrayCamera: na,
    ArrowHelper: class extends mn {
      constructor(t = new di(0, 0, 1), e = new di(0, 0, 0), i = 1, n = 16776960, r = .2 * i, o = .2 * r) {
        super(),
          this.type = "ArrowHelper",
          void 0 === Zu && (Zu = new Wn,
            Zu.setAttribute("position", new Dn([0, 0, 0, 0, 1, 0], 3)),
            Qu = new Wl(0, .5, 1, 5, 1),
            Qu.translate(0, -.5, 0)),
          this.position.copy(e),
          this.line = new sl(Zu, new tl({
            color: n,
            toneMapped: !1
          })),
          this.line.matrixAutoUpdate = !1,
          this.add(this.line),
          this.cone = new lr(Qu, new kn({
            color: n,
            toneMapped: !1
          })),
          this.cone.matrixAutoUpdate = !1,
          this.add(this.cone),
          this.setDirection(t),
          this.setLength(i, r, o)
      }
      setDirection(t) {
        if (t.y > .99999)
          this.quaternion.set(0, 0, 0, 1);
        else if (t.y < -.99999)
          this.quaternion.set(1, 0, 0, 0);
        else {
          Hu.set(t.z, 0, -t.x).normalize();
          const e = Math.acos(t.y);
          this.quaternion.setFromAxisAngle(Hu, e)
        }
      }
      setLength(t, e = .2 * t, i = .2 * e) {
        this.line.scale.set(1, Math.max(1e-4, t - e), 1),
          this.line.updateMatrix(),
          this.cone.scale.set(i, e, i),
          this.cone.position.y = t,
          this.cone.updateMatrix()
      }
      setColor(t) {
        this.line.material.color.set(t),
          this.cone.material.color.set(t)
      }
      copy(t) {
        return super.copy(t, !1),
          this.line.copy(t.line),
          this.cone.copy(t.cone),
          this
      }
    }
    ,
    Audio: ou,
    AudioAnalyser: class {
      constructor(t, e = 2048) {
        this.analyser = t.context.createAnalyser(),
          this.analyser.fftSize = e,
          this.data = new Uint8Array(this.analyser.frequencyBinCount),
          t.getOutput().connect(this.analyser)
      }
      getFrequencyData() {
        return this.analyser.getByteFrequencyData(this.data),
          this.data
      }
      getAverageFrequency() {
        let t = 0;
        const e = this.getFrequencyData();
        for (let i = 0; i < e.length; i++)
          t += e[i];
        return t / e.length
      }
    }
    ,
    AudioContext: Kc,
    AudioListener: class extends mn {
      constructor() {
        super(),
          this.type = "AudioListener",
          this.context = Kc.getContext(),
          this.gain = this.context.createGain(),
          this.gain.connect(this.context.destination),
          this.filter = null,
          this.timeDelta = 0,
          this._clock = new $c
      }
      getInput() {
        return this.gain
      }
      removeFilter() {
        return null !== this.filter && (this.gain.disconnect(this.filter),
          this.filter.disconnect(this.context.destination),
          this.gain.connect(this.context.destination),
          this.filter = null),
          this
      }
      getFilter() {
        return this.filter
      }
      setFilter(t) {
        return null !== this.filter ? (this.gain.disconnect(this.filter),
          this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination),
          this.filter = t,
          this.gain.connect(this.filter),
          this.filter.connect(this.context.destination),
          this
      }
      getMasterVolume() {
        return this.gain.gain.value
      }
      setMasterVolume(t) {
        return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01),
          this
      }
      updateMatrixWorld(t) {
        super.updateMatrixWorld(t);
        const e = this.context.listener
          , i = this.up;
        if (this.timeDelta = this._clock.getDelta(),
          this.matrixWorld.decompose(eu, iu, nu),
          ru.set(0, 0, -1).applyQuaternion(iu),
          e.positionX) {
          const t = this.context.currentTime + this.timeDelta;
          e.positionX.linearRampToValueAtTime(eu.x, t),
            e.positionY.linearRampToValueAtTime(eu.y, t),
            e.positionZ.linearRampToValueAtTime(eu.z, t),
            e.forwardX.linearRampToValueAtTime(ru.x, t),
            e.forwardY.linearRampToValueAtTime(ru.y, t),
            e.forwardZ.linearRampToValueAtTime(ru.z, t),
            e.upX.linearRampToValueAtTime(i.x, t),
            e.upY.linearRampToValueAtTime(i.y, t),
            e.upZ.linearRampToValueAtTime(i.z, t)
        } else
          e.setPosition(eu.x, eu.y, eu.z),
            e.setOrientation(ru.x, ru.y, ru.z, i.x, i.y, i.z)
      }
    }
    ,
    AudioLoader: class extends mc {
      constructor(t) {
        super(t)
      }
      load(t, e, i, n) {
        const r = this
          , o = new vc(this.manager);
        o.setResponseType("arraybuffer"),
          o.setPath(this.path),
          o.setRequestHeader(this.requestHeader),
          o.setWithCredentials(this.withCredentials),
          o.load(t, (function (i) {
            try {
              const t = i.slice(0);
              Kc.getContext().decodeAudioData(t, (function (t) {
                e(t)
              }
              ))
            } catch (e) {
              n ? n(e) : console.error(e),
                r.manager.itemError(t)
            }
          }
          ), i, n)
      }
    }
    ,
    AxesHelper: Ku,
    BackSide: h,
    BasicDepthPacking: 3200,
    BasicShadowMap: 0,
    Bone: Ga,
    BooleanKeyframeTrack: rc,
    Box2: Mu,
    Box3: mi,
    Box3Helper: class extends hl {
      constructor(t, e = 16776960) {
        const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
          , n = new Wn;
        n.setIndex(new Pn(i, 1)),
          n.setAttribute("position", new Dn([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)),
          super(n, new tl({
            color: e,
            toneMapped: !1
          })),
          this.box = t,
          this.type = "Box3Helper",
          this.geometry.computeBoundingSphere()
      }
      updateMatrixWorld(t) {
        const e = this.box;
        e.isEmpty() || (e.getCenter(this.position),
          e.getSize(this.scale),
          this.scale.multiplyScalar(.5),
          super.updateMatrixWorld(t))
      }
    }
    ,
    BoxBufferGeometry: cr,
    BoxGeometry: cr,
    BoxHelper: class extends hl {
      constructor(t, e = 16776960) {
        const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
          , n = new Float32Array(24)
          , r = new Wn;
        r.setIndex(new Pn(i, 1)),
          r.setAttribute("position", new Pn(n, 3)),
          super(r, new tl({
            color: e,
            toneMapped: !1
          })),
          this.object = t,
          this.type = "BoxHelper",
          this.matrixAutoUpdate = !1,
          this.update()
      }
      update(t) {
        if (void 0 !== t && console.warn("THREE.BoxHelper: .update() has no longer arguments."),
          void 0 !== this.object && Ju.setFromObject(this.object),
          Ju.isEmpty())
          return;
        const e = Ju.min
          , i = Ju.max
          , n = this.geometry.attributes.position
          , r = n.array;
        r[0] = i.x,
          r[1] = i.y,
          r[2] = i.z,
          r[3] = e.x,
          r[4] = i.y,
          r[5] = i.z,
          r[6] = e.x,
          r[7] = e.y,
          r[8] = i.z,
          r[9] = i.x,
          r[10] = e.y,
          r[11] = i.z,
          r[12] = i.x,
          r[13] = i.y,
          r[14] = e.z,
          r[15] = e.x,
          r[16] = i.y,
          r[17] = e.z,
          r[18] = e.x,
          r[19] = e.y,
          r[20] = e.z,
          r[21] = i.x,
          r[22] = e.y,
          r[23] = e.z,
          n.needsUpdate = !0,
          this.geometry.computeBoundingSphere()
      }
      setFromObject(t) {
        return this.object = t,
          this.update(),
          this
      }
      copy(t, e) {
        return super.copy(t, e),
          this.object = t.object,
          this
      }
    }
    ,
    BufferAttribute: Pn,
    BufferGeometry: Wn,
    BufferGeometryLoader: Gc,
    ByteType: pt,
    Cache: dc,
    Camera: gr,
    CameraHelper: class extends hl {
      constructor(t) {
        const e = new Wn
          , i = new tl({
            color: 16777215,
            vertexColors: !0,
            toneMapped: !1
          })
          , n = []
          , r = []
          , o = {};
        function s(t, e) {
          a(t),
            a(e)
        }
        function a(t) {
          n.push(0, 0, 0),
            r.push(0, 0, 0),
            void 0 === o[t] && (o[t] = []),
            o[t].push(n.length / 3 - 1)
        }
        s("n1", "n2"),
          s("n2", "n4"),
          s("n4", "n3"),
          s("n3", "n1"),
          s("f1", "f2"),
          s("f2", "f4"),
          s("f4", "f3"),
          s("f3", "f1"),
          s("n1", "f1"),
          s("n2", "f2"),
          s("n3", "f3"),
          s("n4", "f4"),
          s("p", "n1"),
          s("p", "n2"),
          s("p", "n3"),
          s("p", "n4"),
          s("u1", "u2"),
          s("u2", "u3"),
          s("u3", "u1"),
          s("c", "t"),
          s("p", "c"),
          s("cn1", "cn2"),
          s("cn3", "cn4"),
          s("cf1", "cf2"),
          s("cf3", "cf4"),
          e.setAttribute("position", new Dn(n, 3)),
          e.setAttribute("color", new Dn(r, 3)),
          super(e, i),
          this.type = "CameraHelper",
          this.camera = t,
          this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(),
          this.matrix = t.matrixWorld,
          this.matrixAutoUpdate = !1,
          this.pointMap = o,
          this.update();
        const l = new ei(16755200)
          , h = new ei(16711680)
          , c = new ei(43775)
          , u = new ei(16777215)
          , p = new ei(3355443);
        this.setColors(l, h, c, u, p)
      }
      setColors(t, e, i, n, r) {
        const o = this.geometry.getAttribute("color");
        o.setXYZ(0, t.r, t.g, t.b),
          o.setXYZ(1, t.r, t.g, t.b),
          o.setXYZ(2, t.r, t.g, t.b),
          o.setXYZ(3, t.r, t.g, t.b),
          o.setXYZ(4, t.r, t.g, t.b),
          o.setXYZ(5, t.r, t.g, t.b),
          o.setXYZ(6, t.r, t.g, t.b),
          o.setXYZ(7, t.r, t.g, t.b),
          o.setXYZ(8, t.r, t.g, t.b),
          o.setXYZ(9, t.r, t.g, t.b),
          o.setXYZ(10, t.r, t.g, t.b),
          o.setXYZ(11, t.r, t.g, t.b),
          o.setXYZ(12, t.r, t.g, t.b),
          o.setXYZ(13, t.r, t.g, t.b),
          o.setXYZ(14, t.r, t.g, t.b),
          o.setXYZ(15, t.r, t.g, t.b),
          o.setXYZ(16, t.r, t.g, t.b),
          o.setXYZ(17, t.r, t.g, t.b),
          o.setXYZ(18, t.r, t.g, t.b),
          o.setXYZ(19, t.r, t.g, t.b),
          o.setXYZ(20, t.r, t.g, t.b),
          o.setXYZ(21, t.r, t.g, t.b),
          o.setXYZ(22, t.r, t.g, t.b),
          o.setXYZ(23, t.r, t.g, t.b),
          o.setXYZ(24, e.r, e.g, e.b),
          o.setXYZ(25, e.r, e.g, e.b),
          o.setXYZ(26, e.r, e.g, e.b),
          o.setXYZ(27, e.r, e.g, e.b),
          o.setXYZ(28, e.r, e.g, e.b),
          o.setXYZ(29, e.r, e.g, e.b),
          o.setXYZ(30, e.r, e.g, e.b),
          o.setXYZ(31, e.r, e.g, e.b),
          o.setXYZ(32, i.r, i.g, i.b),
          o.setXYZ(33, i.r, i.g, i.b),
          o.setXYZ(34, i.r, i.g, i.b),
          o.setXYZ(35, i.r, i.g, i.b),
          o.setXYZ(36, i.r, i.g, i.b),
          o.setXYZ(37, i.r, i.g, i.b),
          o.setXYZ(38, n.r, n.g, n.b),
          o.setXYZ(39, n.r, n.g, n.b),
          o.setXYZ(40, r.r, r.g, r.b),
          o.setXYZ(41, r.r, r.g, r.b),
          o.setXYZ(42, r.r, r.g, r.b),
          o.setXYZ(43, r.r, r.g, r.b),
          o.setXYZ(44, r.r, r.g, r.b),
          o.setXYZ(45, r.r, r.g, r.b),
          o.setXYZ(46, r.r, r.g, r.b),
          o.setXYZ(47, r.r, r.g, r.b),
          o.setXYZ(48, r.r, r.g, r.b),
          o.setXYZ(49, r.r, r.g, r.b),
          o.needsUpdate = !0
      }
      update() {
        const t = this.geometry
          , e = this.pointMap;
        Gu.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
          Wu("c", e, t, Gu, 0, 0, -1),
          Wu("t", e, t, Gu, 0, 0, 1),
          Wu("n1", e, t, Gu, -1, -1, -1),
          Wu("n2", e, t, Gu, 1, -1, -1),
          Wu("n3", e, t, Gu, -1, 1, -1),
          Wu("n4", e, t, Gu, 1, 1, -1),
          Wu("f1", e, t, Gu, -1, -1, 1),
          Wu("f2", e, t, Gu, 1, -1, 1),
          Wu("f3", e, t, Gu, -1, 1, 1),
          Wu("f4", e, t, Gu, 1, 1, 1),
          Wu("u1", e, t, Gu, .7, 1.1, -1),
          Wu("u2", e, t, Gu, -.7, 1.1, -1),
          Wu("u3", e, t, Gu, 0, 2, -1),
          Wu("cf1", e, t, Gu, -1, 0, 1),
          Wu("cf2", e, t, Gu, 1, 0, 1),
          Wu("cf3", e, t, Gu, 0, -1, 1),
          Wu("cf4", e, t, Gu, 0, 1, 1),
          Wu("cn1", e, t, Gu, -1, 0, -1),
          Wu("cn2", e, t, Gu, 1, 0, -1),
          Wu("cn3", e, t, Gu, 0, -1, -1),
          Wu("cn4", e, t, Gu, 0, 1, -1),
          t.getAttribute("position").needsUpdate = !0
      }
      dispose() {
        this.geometry.dispose(),
          this.material.dispose()
      }
    }
    ,
    CanvasTexture: class extends ai {
      constructor(t, e, i, n, r, o, s, a, l) {
        super(t, e, i, n, r, o, s, a, l),
          this.isCanvasTexture = !0,
          this.needsUpdate = !0
      }
    }
    ,
    CapsuleBufferGeometry: Vl,
    CapsuleGeometry: Vl,
    CatmullRomCurve3: Ml,
    CineonToneMapping: Z,
    CircleBufferGeometry: Gl,
    CircleGeometry: Gl,
    ClampToEdgeWrapping: nt,
    Clock: $c,
    Color: ei,
    ColorKeyframeTrack: oc,
    ColorManagement: Qe,
    CompressedTexture: vl,
    CompressedTextureLoader: class extends mc {
      constructor(t) {
        super(t)
      }
      load(t, e, i, n) {
        const r = this
          , o = []
          , s = new vl
          , a = new vc(this.manager);
        a.setPath(this.path),
          a.setResponseType("arraybuffer"),
          a.setRequestHeader(this.requestHeader),
          a.setWithCredentials(r.withCredentials);
        let l = 0;
        function h(h) {
          a.load(t[h], (function (t) {
            const i = r.parse(t, !0);
            o[h] = {
              width: i.width,
              height: i.height,
              format: i.format,
              mipmaps: i.mipmaps
            },
              l += 1,
              6 === l && (1 === i.mipmapCount && (s.minFilter = lt),
                s.image = o,
                s.format = i.format,
                s.needsUpdate = !0,
                e && e(s))
          }
          ), i, n)
        }
        if (Array.isArray(t))
          for (let e = 0, i = t.length; e < i; ++e)
            h(e);
        else
          a.load(t, (function (t) {
            const i = r.parse(t, !0);
            if (i.isCubemap) {
              const t = i.mipmaps.length / i.mipmapCount;
              for (let e = 0; e < t; e++) {
                o[e] = {
                  mipmaps: []
                };
                for (let t = 0; t < i.mipmapCount; t++)
                  o[e].mipmaps.push(i.mipmaps[e * i.mipmapCount + t]),
                    o[e].format = i.format,
                    o[e].width = i.width,
                    o[e].height = i.height
              }
              s.image = o
            } else
              s.image.width = i.width,
                s.image.height = i.height,
                s.mipmaps = i.mipmaps;
            1 === i.mipmapCount && (s.minFilter = lt),
              s.format = i.format,
              s.needsUpdate = !0,
              e && e(s)
          }
          ), i, n);
        return s
      }
    }
    ,
    ConeBufferGeometry: Jl,
    ConeGeometry: Jl,
    CubeCamera: vr,
    CubeReflectionMapping: q,
    CubeRefractionMapping: X,
    CubeTexture: Ar,
    CubeTextureLoader: class extends mc {
      constructor(t) {
        super(t)
      }
      load(t, e, i, n) {
        const r = new Ar
          , o = new Ac(this.manager);
        o.setCrossOrigin(this.crossOrigin),
          o.setPath(this.path);
        let s = 0;
        function a(i) {
          o.load(t[i], (function (t) {
            r.images[i] = t,
              s++,
              6 === s && (r.needsUpdate = !0,
                e && e(r))
          }
          ), void 0, n)
        }
        for (let e = 0; e < t.length; ++e)
          a(e);
        return r
      }
    }
    ,
    CubeUVReflectionMapping: et,
    CubicBezierCurve: Rl,
    CubicBezierCurve3: Ll,
    CubicInterpolant: tc,
    CullFaceBack: n,
    CullFaceFront: r,
    CullFaceFrontBack: 3,
    CullFaceNone: i,
    Curve: Al,
    CurvePath: Fl,
    CustomBlending: m,
    CustomToneMapping: K,
    CylinderBufferGeometry: Wl,
    CylinderGeometry: Wl,
    Cylindrical: class {
      constructor(t = 1, e = 0, i = 0) {
        return this.radius = t,
          this.theta = e,
          this.y = i,
          this
      }
      set(t, e, i) {
        return this.radius = t,
          this.theta = e,
          this.y = i,
          this
      }
      copy(t) {
        return this.radius = t.radius,
          this.theta = t.theta,
          this.y = t.y,
          this
      }
      setFromVector3(t) {
        return this.setFromCartesianCoords(t.x, t.y, t.z)
      }
      setFromCartesianCoords(t, e, i) {
        return this.radius = Math.sqrt(t * t + i * i),
          this.theta = Math.atan2(t, i),
          this.y = e,
          this
      }
      clone() {
        return (new this.constructor).copy(this)
      }
    }
    ,
    Data3DTexture: ui,
    DataArrayTexture: ci,
    DataTexture: Wa,
    DataTexture2DArray: class extends ci {
      constructor(t, e, i, n) {
        console.warn("THREE.DataTexture2DArray has been renamed to DataArrayTexture."),
          super(t, e, i, n)
      }
    }
    ,
    DataTexture3D: class extends ui {
      constructor(t, e, i, n) {
        console.warn("THREE.DataTexture3D has been renamed to Data3DTexture."),
          super(t, e, i, n)
      }
    }
    ,
    DataTextureLoader: class extends mc {
      constructor(t) {
        super(t)
      }
      load(t, e, i, n) {
        const r = this
          , o = new Wa
          , s = new vc(this.manager);
        return s.setResponseType("arraybuffer"),
          s.setRequestHeader(this.requestHeader),
          s.setPath(this.path),
          s.setWithCredentials(r.withCredentials),
          s.load(t, (function (t) {
            const i = r.parse(t);
            i && (void 0 !== i.image ? o.image = i.image : void 0 !== i.data && (o.image.width = i.width,
              o.image.height = i.height,
              o.image.data = i.data),
              o.wrapS = void 0 !== i.wrapS ? i.wrapS : nt,
              o.wrapT = void 0 !== i.wrapT ? i.wrapT : nt,
              o.magFilter = void 0 !== i.magFilter ? i.magFilter : lt,
              o.minFilter = void 0 !== i.minFilter ? i.minFilter : lt,
              o.anisotropy = void 0 !== i.anisotropy ? i.anisotropy : 1,
              void 0 !== i.encoding && (o.encoding = i.encoding),
              void 0 !== i.flipY && (o.flipY = i.flipY),
              void 0 !== i.format && (o.format = i.format),
              void 0 !== i.type && (o.type = i.type),
              void 0 !== i.mipmaps && (o.mipmaps = i.mipmaps,
                o.minFilter = ct),
              1 === i.mipmapCount && (o.minFilter = lt),
              void 0 !== i.generateMipmaps && (o.generateMipmaps = i.generateMipmaps),
              o.needsUpdate = !0,
              e && e(o, i))
          }
          ), i, n),
          o
      }
    }
    ,
    DataUtils: rp,
    DecrementStencilOp: 7683,
    DecrementWrapStencilOp: 34056,
    DefaultLoadingManager: gc,
    DepthFormat: Mt,
    DepthStencilFormat: Tt,
    DepthTexture: aa,
    DirectionalLight: Oc,
    DirectionalLightHelper: class extends mn {
      constructor(t, e, i) {
        super(),
          this.light = t,
          this.light.updateMatrixWorld(),
          this.matrix = t.matrixWorld,
          this.matrixAutoUpdate = !1,
          this.color = i,
          void 0 === e && (e = 1);
        let n = new Wn;
        n.setAttribute("position", new Dn([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3));
        const r = new tl({
          fog: !1,
          toneMapped: !1
        });
        this.lightPlane = new sl(n, r),
          this.add(this.lightPlane),
          n = new Wn,
          n.setAttribute("position", new Dn([0, 0, 0, 0, 0, 1], 3)),
          this.targetLine = new sl(n, r),
          this.add(this.targetLine),
          this.update()
      }
      dispose() {
        this.lightPlane.geometry.dispose(),
          this.lightPlane.material.dispose(),
          this.targetLine.geometry.dispose(),
          this.targetLine.material.dispose()
      }
      update() {
        Fu.setFromMatrixPosition(this.light.matrixWorld),
          Bu.setFromMatrixPosition(this.light.target.matrixWorld),
          ju.subVectors(Bu, Fu),
          this.lightPlane.lookAt(Bu),
          void 0 !== this.color ? (this.lightPlane.material.color.set(this.color),
            this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color),
              this.targetLine.material.color.copy(this.light.color)),
          this.targetLine.lookAt(Bu),
          this.targetLine.scale.z = ju.length()
      }
    }
    ,
    DiscreteInterpolant: ic,
    DodecahedronBufferGeometry: Zl,
    DodecahedronGeometry: Zl,
    DoubleSide: c,
    DstAlphaFactor: T,
    DstColorFactor: k,
    DynamicCopyUsage: 35050,
    DynamicDrawUsage: Ce,
    DynamicReadUsage: 35049,
    EdgesGeometry: Xl,
    EllipseCurve: bl,
    EqualDepth: U,
    EqualStencilFunc: 514,
    EquirectangularReflectionMapping: $,
    EquirectangularRefractionMapping: tt,
    Euler: tn,
    EventDispatcher: Se,
    ExtrudeBufferGeometry: Th,
    ExtrudeGeometry: Th,
    FileLoader: vc,
    FlatShading: 1,
    Float16BufferAttribute: class extends Pn {
      constructor(t, e, i) {
        super(new Uint16Array(t), e, i),
          this.isFloat16BufferAttribute = !0
      }
    }
    ,
    Float32BufferAttribute: Dn,
    Float64BufferAttribute: class extends Pn {
      constructor(t, e, i) {
        super(new Float64Array(t), e, i)
      }
    }
    ,
    FloatType: yt,
    Fog: da,
    FogExp2: pa,
    Font: function () {
      console.error("THREE.Font has been moved to /examples/jsm/loaders/FontLoader.js")
    },
    FontLoader: function () {
      console.error("THREE.FontLoader has been moved to /examples/jsm/loaders/FontLoader.js")
    },
    FramebufferTexture: class extends ai {
      constructor(t, e, i) {
        super({
          width: t,
          height: e
        }),
          this.isFramebufferTexture = !0,
          this.format = i,
          this.magFilter = ot,
          this.minFilter = ot,
          this.generateMipmaps = !1,
          this.needsUpdate = !0
      }
    }
    ,
    FrontSide: l,
    Frustum: Mr,
    GLBufferAttribute: class {
      constructor(t, e, i, n, r) {
        this.isGLBufferAttribute = !0,
          this.buffer = t,
          this.type = e,
          this.itemSize = i,
          this.elementSize = n,
          this.count = r,
          this.version = 0
      }
      set needsUpdate(t) {
        !0 === t && this.version++
      }
      setBuffer(t) {
        return this.buffer = t,
          this
      }
      setType(t, e) {
        return this.type = t,
          this.elementSize = e,
          this
      }
      setItemSize(t) {
        return this.itemSize = t,
          this
      }
      setCount(t) {
        return this.count = t,
          this
      }
    }
    ,
    GLSL1: "100",
    GLSL3: we,
    GreaterDepth: F,
    GreaterEqualDepth: N,
    GreaterEqualStencilFunc: 518,
    GreaterStencilFunc: 516,
    GridHelper: class extends hl {
      constructor(t = 10, e = 10, i = 4473924, n = 8947848) {
        i = new ei(i),
          n = new ei(n);
        const r = e / 2
          , o = t / e
          , s = t / 2
          , a = []
          , l = [];
        for (let t = 0, h = 0, c = -s; t <= e; t++,
          c += o) {
          a.push(-s, 0, c, s, 0, c),
            a.push(c, 0, -s, c, 0, s);
          const e = t === r ? i : n;
          e.toArray(l, h),
            h += 3,
            e.toArray(l, h),
            h += 3,
            e.toArray(l, h),
            h += 3,
            e.toArray(l, h),
            h += 3
        }
        const h = new Wn;
        h.setAttribute("position", new Dn(a, 3)),
          h.setAttribute("color", new Dn(l, 3));
        super(h, new tl({
          vertexColors: !0,
          toneMapped: !1
        })),
          this.type = "GridHelper"
      }
    }
    ,
    Group: ra,
    HalfFloatType: vt,
    HemisphereLight: Ic,
    HemisphereLightHelper: class extends mn {
      constructor(t, e, i) {
        super(),
          this.light = t,
          this.light.updateMatrixWorld(),
          this.matrix = t.matrixWorld,
          this.matrixAutoUpdate = !1,
          this.color = i;
        const n = new Rh(e);
        n.rotateY(.5 * Math.PI),
          this.material = new kn({
            wireframe: !0,
            fog: !1,
            toneMapped: !1
          }),
          void 0 === this.color && (this.material.vertexColors = !0);
        const r = n.getAttribute("position")
          , o = new Float32Array(3 * r.count);
        n.setAttribute("color", new Pn(o, 3)),
          this.add(new lr(n, this.material)),
          this.update()
      }
      dispose() {
        this.children[0].geometry.dispose(),
          this.children[0].material.dispose()
      }
      update() {
        const t = this.children[0];
        if (void 0 !== this.color)
          this.material.color.set(this.color);
        else {
          const e = t.geometry.getAttribute("color");
          Uu.copy(this.light.color),
            Nu.copy(this.light.groundColor);
          for (let t = 0, i = e.count; t < i; t++) {
            const n = t < i / 2 ? Uu : Nu;
            e.setXYZ(t, n.r, n.g, n.b)
          }
          e.needsUpdate = !0
        }
        t.lookAt(Du.setFromMatrixPosition(this.light.matrixWorld).negate())
      }
    }
    ,
    HemisphereLightProbe: class extends Fc {
      constructor(t, e, i = 1) {
        super(void 0, i),
          this.isHemisphereLightProbe = !0;
        const n = (new ei).set(t)
          , r = (new ei).set(e)
          , o = new di(n.r, n.g, n.b)
          , s = new di(r.r, r.g, r.b)
          , a = Math.sqrt(Math.PI)
          , l = a * Math.sqrt(.75);
        this.sh.coefficients[0].copy(o).add(s).multiplyScalar(a),
          this.sh.coefficients[1].copy(o).sub(s).multiplyScalar(l)
      }
    }
    ,
    IcosahedronBufferGeometry: kh,
    IcosahedronGeometry: kh,
    ImageBitmapLoader: Zc,
    ImageLoader: Ac,
    ImageUtils: ni,
    ImmediateRenderObject: function () {
      console.error("THREE.ImmediateRenderObject has been removed.")
    },
    IncrementStencilOp: 7682,
    IncrementWrapStencilOp: 34055,
    InstancedBufferAttribute: Qa,
    InstancedBufferGeometry: Vc,
    InstancedInterleavedBuffer: Iu,
    InstancedMesh: $a,
    Int16BufferAttribute: class extends Pn {
      constructor(t, e, i) {
        super(new Int16Array(t), e, i)
      }
    }
    ,
    Int32BufferAttribute: class extends Pn {
      constructor(t, e, i) {
        super(new Int32Array(t), e, i)
      }
    }
    ,
    Int8BufferAttribute: class extends Pn {
      constructor(t, e, i) {
        super(new Int8Array(t), e, i)
      }
    }
    ,
    IntType: gt,
    InterleavedBuffer: ga,
    InterleavedBufferAttribute: ya,
    Interpolant: $h,
    InterpolateDiscrete: se,
    InterpolateLinear: ae,
    InterpolateSmooth: le,
    InvertStencilOp: 5386,
    KeepStencilOp: xe,
    KeyframeTrack: nc,
    LOD: Da,
    LatheBufferGeometry: jl,
    LatheGeometry: jl,
    Layers: en,
    LessDepth: O,
    LessEqualDepth: D,
    LessEqualStencilFunc: 515,
    LessStencilFunc: 513,
    Light: xc,
    LightProbe: Fc,
    Line: sl,
    Line3: ku,
    LineBasicMaterial: tl,
    LineCurve: Pl,
    LineCurve3: zl,
    LineDashedMaterial: qh,
    LineLoop: cl,
    LineSegments: hl,
    LinearEncoding: fe,
    LinearFilter: lt,
    LinearInterpolant: ec,
    LinearMipMapLinearFilter: 1008,
    LinearMipMapNearestFilter: 1007,
    LinearMipmapLinearFilter: ct,
    LinearMipmapNearestFilter: ht,
    LinearSRGBColorSpace: be,
    LinearToneMapping: J,
    Loader: mc,
    LoaderUtils: jc,
    LoadingManager: fc,
    LoopOnce: 2200,
    LoopPingPong: 2202,
    LoopRepeat: 2201,
    LuminanceAlphaFormat: St,
    LuminanceFormat: _t,
    MOUSE: {
      LEFT: 0,
      MIDDLE: 1,
      RIGHT: 2,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2
    },
    Material: En,
    MaterialLoader: Bc,
    MathUtils: Ne,
    Matrix3: Be,
    Matrix4: Wi,
    MaxEquation: x,
    Mesh: lr,
    MeshBasicMaterial: kn,
    MeshDepthMaterial: Ks,
    MeshDistanceMaterial: Ys,
    MeshLambertMaterial: Kh,
    MeshMatcapMaterial: Yh,
    MeshNormalMaterial: Qh,
    MeshPhongMaterial: Hh,
    MeshPhysicalMaterial: Jh,
    MeshStandardMaterial: Wh,
    MeshToonMaterial: Zh,
    MinEquation: b,
    MirroredRepeatWrapping: rt,
    MixOperation: V,
    MultiplyBlending: g,
    MultiplyOperation: j,
    NearestFilter: ot,
    NearestMipMapLinearFilter: 1005,
    NearestMipMapNearestFilter: 1004,
    NearestMipmapLinearFilter: at,
    NearestMipmapNearestFilter: st,
    NeverDepth: P,
    NeverStencilFunc: 512,
    NoBlending: u,
    NoColorSpace: "",
    NoToneMapping: W,
    NormalAnimationBlendMode: pe,
    NormalBlending: p,
    NotEqualDepth: B,
    NotEqualStencilFunc: 517,
    NumberKeyframeTrack: sc,
    Object3D: mn,
    ObjectLoader: class extends mc {
      constructor(t) {
        super(t)
      }
      load(t, e, i, n) {
        const r = this
          , o = "" === this.path ? jc.extractUrlBase(t) : this.path;
        this.resourcePath = this.resourcePath || o;
        const s = new vc(this.manager);
        s.setPath(this.path),
          s.setRequestHeader(this.requestHeader),
          s.setWithCredentials(this.withCredentials),
          s.load(t, (function (i) {
            let o = null;
            try {
              o = JSON.parse(i)
            } catch (e) {
              return void 0 !== n && n(e),
                void console.error("THREE:ObjectLoader: Can't parse " + t + ".", e.message)
            }
            const s = o.metadata;
            void 0 !== s && void 0 !== s.type && "geometry" !== s.type.toLowerCase() ? r.parse(o, e) : console.error("THREE.ObjectLoader: Can't load " + t)
          }
          ), i, n)
      }
      async loadAsync(t, e) {
        const i = "" === this.path ? jc.extractUrlBase(t) : this.path;
        this.resourcePath = this.resourcePath || i;
        const n = new vc(this.manager);
        n.setPath(this.path),
          n.setRequestHeader(this.requestHeader),
          n.setWithCredentials(this.withCredentials);
        const r = await n.loadAsync(t, e)
          , o = JSON.parse(r)
          , s = o.metadata;
        if (void 0 === s || void 0 === s.type || "geometry" === s.type.toLowerCase())
          throw new Error("THREE.ObjectLoader: Can't load " + t);
        return await this.parseAsync(o)
      }
      parse(t, e) {
        const i = this.parseAnimations(t.animations)
          , n = this.parseShapes(t.shapes)
          , r = this.parseGeometries(t.geometries, n)
          , o = this.parseImages(t.images, (function () {
            void 0 !== e && e(l)
          }
          ))
          , s = this.parseTextures(t.textures, o)
          , a = this.parseMaterials(t.materials, s)
          , l = this.parseObject(t.object, r, a, s, i)
          , h = this.parseSkeletons(t.skeletons, l);
        if (this.bindSkeletons(l, h),
          void 0 !== e) {
          let t = !1;
          for (const e in o)
            if (o[e].data instanceof HTMLImageElement) {
              t = !0;
              break
            }
          !1 === t && e(l)
        }
        return l
      }
      async parseAsync(t) {
        const e = this.parseAnimations(t.animations)
          , i = this.parseShapes(t.shapes)
          , n = this.parseGeometries(t.geometries, i)
          , r = await this.parseImagesAsync(t.images)
          , o = this.parseTextures(t.textures, r)
          , s = this.parseMaterials(t.materials, o)
          , a = this.parseObject(t.object, n, s, o, e)
          , l = this.parseSkeletons(t.skeletons, a);
        return this.bindSkeletons(a, l),
          a
      }
      parseShapes(t) {
        const e = {};
        if (void 0 !== t)
          for (let i = 0, n = t.length; i < n; i++) {
            const n = (new $l).fromJSON(t[i]);
            e[n.uuid] = n
          }
        return e
      }
      parseSkeletons(t, e) {
        const i = {}
          , n = {};
        if (e.traverse((function (t) {
          t.isBone && (n[t.uuid] = t)
        }
        )),
          void 0 !== t)
          for (let e = 0, r = t.length; e < r; e++) {
            const r = (new Za).fromJSON(t[e], n);
            i[r.uuid] = r
          }
        return i
      }
      parseGeometries(t, e) {
        const i = {};
        if (void 0 !== t) {
          const n = new Gc;
          for (let r = 0, o = t.length; r < o; r++) {
            let o;
            const s = t[r];
            switch (s.type) {
              case "BufferGeometry":
              case "InstancedBufferGeometry":
                o = n.parse(s);
                break;
              case "Geometry":
                console.error("THREE.ObjectLoader: The legacy Geometry type is no longer supported.");
                break;
              default:
                s.type in jh ? o = jh[s.type].fromJSON(s, e) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${s.type}"`)
            }
            o.uuid = s.uuid,
              void 0 !== s.name && (o.name = s.name),
              !0 === o.isBufferGeometry && void 0 !== s.userData && (o.userData = s.userData),
              i[s.uuid] = o
          }
        }
        return i
      }
      parseMaterials(t, e) {
        const i = {}
          , n = {};
        if (void 0 !== t) {
          const r = new Bc;
          r.setTextures(e);
          for (let e = 0, o = t.length; e < o; e++) {
            const o = t[e];
            if ("MultiMaterial" === o.type) {
              const t = [];
              for (let e = 0; e < o.materials.length; e++) {
                const n = o.materials[e];
                void 0 === i[n.uuid] && (i[n.uuid] = r.parse(n)),
                  t.push(i[n.uuid])
              }
              n[o.uuid] = t
            } else
              void 0 === i[o.uuid] && (i[o.uuid] = r.parse(o)),
                n[o.uuid] = i[o.uuid]
          }
        }
        return n
      }
      parseAnimations(t) {
        const e = {};
        if (void 0 !== t)
          for (let i = 0; i < t.length; i++) {
            const n = t[i]
              , r = uc.parse(n);
            e[r.uuid] = r
          }
        return e
      }
      parseImages(t, e) {
        const i = this
          , n = {};
        let r;
        function o(t) {
          if ("string" == typeof t) {
            const e = t;
            return function (t) {
              return i.manager.itemStart(t),
                r.load(t, (function () {
                  i.manager.itemEnd(t)
                }
                ), void 0, (function () {
                  i.manager.itemError(t),
                    i.manager.itemEnd(t)
                }
                ))
            }(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(e) ? e : i.resourcePath + e)
          }
          return t.data ? {
            data: Ge(t.type, t.data),
            width: t.width,
            height: t.height
          } : null
        }
        if (void 0 !== t && t.length > 0) {
          const i = new fc(e);
          r = new Ac(i),
            r.setCrossOrigin(this.crossOrigin);
          for (let e = 0, i = t.length; e < i; e++) {
            const i = t[e]
              , r = i.url;
            if (Array.isArray(r)) {
              const t = [];
              for (let e = 0, i = r.length; e < i; e++) {
                const i = o(r[e]);
                null !== i && (i instanceof HTMLImageElement ? t.push(i) : t.push(new Wa(i.data, i.width, i.height)))
              }
              n[i.uuid] = new ri(t)
            } else {
              const t = o(i.url);
              n[i.uuid] = new ri(t)
            }
          }
        }
        return n
      }
      async parseImagesAsync(t) {
        const e = this
          , i = {};
        let n;
        async function r(t) {
          if ("string" == typeof t) {
            const i = t
              , r = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(i) ? i : e.resourcePath + i;
            return await n.loadAsync(r)
          }
          return t.data ? {
            data: Ge(t.type, t.data),
            width: t.width,
            height: t.height
          } : null
        }
        if (void 0 !== t && t.length > 0) {
          n = new Ac(this.manager),
            n.setCrossOrigin(this.crossOrigin);
          for (let e = 0, n = t.length; e < n; e++) {
            const n = t[e]
              , o = n.url;
            if (Array.isArray(o)) {
              const t = [];
              for (let e = 0, i = o.length; e < i; e++) {
                const i = o[e]
                  , n = await r(i);
                null !== n && (n instanceof HTMLImageElement ? t.push(n) : t.push(new Wa(n.data, n.width, n.height)))
              }
              i[n.uuid] = new ri(t)
            } else {
              const t = await r(n.url);
              i[n.uuid] = new ri(t)
            }
          }
        }
        return i
      }
      parseTextures(t, e) {
        function i(t, e) {
          return "number" == typeof t ? t : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t),
            e[t])
        }
        const n = {};
        if (void 0 !== t)
          for (let r = 0, o = t.length; r < o; r++) {
            const o = t[r];
            void 0 === o.image && console.warn('THREE.ObjectLoader: No "image" specified for', o.uuid),
              void 0 === e[o.image] && console.warn("THREE.ObjectLoader: Undefined image", o.image);
            const s = e[o.image]
              , a = s.data;
            let l;
            Array.isArray(a) ? (l = new Ar,
              6 === a.length && (l.needsUpdate = !0)) : (l = a && a.data ? new Wa : new ai,
                a && (l.needsUpdate = !0)),
              l.source = s,
              l.uuid = o.uuid,
              void 0 !== o.name && (l.name = o.name),
              void 0 !== o.mapping && (l.mapping = i(o.mapping, Wc)),
              void 0 !== o.offset && l.offset.fromArray(o.offset),
              void 0 !== o.repeat && l.repeat.fromArray(o.repeat),
              void 0 !== o.center && l.center.fromArray(o.center),
              void 0 !== o.rotation && (l.rotation = o.rotation),
              void 0 !== o.wrap && (l.wrapS = i(o.wrap[0], Jc),
                l.wrapT = i(o.wrap[1], Jc)),
              void 0 !== o.format && (l.format = o.format),
              void 0 !== o.type && (l.type = o.type),
              void 0 !== o.encoding && (l.encoding = o.encoding),
              void 0 !== o.minFilter && (l.minFilter = i(o.minFilter, Hc)),
              void 0 !== o.magFilter && (l.magFilter = i(o.magFilter, Hc)),
              void 0 !== o.anisotropy && (l.anisotropy = o.anisotropy),
              void 0 !== o.flipY && (l.flipY = o.flipY),
              void 0 !== o.premultiplyAlpha && (l.premultiplyAlpha = o.premultiplyAlpha),
              void 0 !== o.unpackAlignment && (l.unpackAlignment = o.unpackAlignment),
              void 0 !== o.userData && (l.userData = o.userData),
              n[o.uuid] = l
          }
        return n
      }
      parseObject(t, e, i, n, r) {
        let o, s, a;
        function l(t) {
          return void 0 === e[t] && console.warn("THREE.ObjectLoader: Undefined geometry", t),
            e[t]
        }
        function h(t) {
          if (void 0 !== t) {
            if (Array.isArray(t)) {
              const e = [];
              for (let n = 0, r = t.length; n < r; n++) {
                const r = t[n];
                void 0 === i[r] && console.warn("THREE.ObjectLoader: Undefined material", r),
                  e.push(i[r])
              }
              return e
            }
            return void 0 === i[t] && console.warn("THREE.ObjectLoader: Undefined material", t),
              i[t]
          }
        }
        function c(t) {
          return void 0 === n[t] && console.warn("THREE.ObjectLoader: Undefined texture", t),
            n[t]
        }
        switch (t.type) {
          case "Scene":
            o = new fa,
              void 0 !== t.background && (Number.isInteger(t.background) ? o.background = new ei(t.background) : o.background = c(t.background)),
              void 0 !== t.environment && (o.environment = c(t.environment)),
              void 0 !== t.fog && ("Fog" === t.fog.type ? o.fog = new da(t.fog.color, t.fog.near, t.fog.far) : "FogExp2" === t.fog.type && (o.fog = new pa(t.fog.color, t.fog.density)));
            break;
          case "PerspectiveCamera":
            o = new mr(t.fov, t.aspect, t.near, t.far),
              void 0 !== t.focus && (o.focus = t.focus),
              void 0 !== t.zoom && (o.zoom = t.zoom),
              void 0 !== t.filmGauge && (o.filmGauge = t.filmGauge),
              void 0 !== t.filmOffset && (o.filmOffset = t.filmOffset),
              void 0 !== t.view && (o.view = Object.assign({}, t.view));
            break;
          case "OrthographicCamera":
            o = new Br(t.left, t.right, t.top, t.bottom, t.near, t.far),
              void 0 !== t.zoom && (o.zoom = t.zoom),
              void 0 !== t.view && (o.view = Object.assign({}, t.view));
            break;
          case "AmbientLight":
            o = new Dc(t.color, t.intensity);
            break;
          case "DirectionalLight":
            o = new Oc(t.color, t.intensity);
            break;
          case "PointLight":
            o = new Pc(t.color, t.intensity, t.distance, t.decay);
            break;
          case "RectAreaLight":
            o = new Uc(t.color, t.intensity, t.width, t.height);
            break;
          case "SpotLight":
            o = new Tc(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay);
            break;
          case "HemisphereLight":
            o = new Ic(t.color, t.groundColor, t.intensity);
            break;
          case "LightProbe":
            o = (new Fc).fromJSON(t);
            break;
          case "SkinnedMesh":
            s = l(t.geometry),
              a = h(t.material),
              o = new Va(s, a),
              void 0 !== t.bindMode && (o.bindMode = t.bindMode),
              void 0 !== t.bindMatrix && o.bindMatrix.fromArray(t.bindMatrix),
              void 0 !== t.skeleton && (o.skeleton = t.skeleton);
            break;
          case "Mesh":
            s = l(t.geometry),
              a = h(t.material),
              o = new lr(s, a);
            break;
          case "InstancedMesh":
            s = l(t.geometry),
              a = h(t.material);
            const e = t.count
              , i = t.instanceMatrix
              , n = t.instanceColor;
            o = new $a(s, a, e),
              o.instanceMatrix = new Qa(new Float32Array(i.array), 16),
              void 0 !== n && (o.instanceColor = new Qa(new Float32Array(n.array), n.itemSize));
            break;
          case "LOD":
            o = new Da;
            break;
          case "Line":
            o = new sl(l(t.geometry), h(t.material));
            break;
          case "LineLoop":
            o = new cl(l(t.geometry), h(t.material));
            break;
          case "LineSegments":
            o = new hl(l(t.geometry), h(t.material));
            break;
          case "PointCloud":
          case "Points":
            o = new ml(l(t.geometry), h(t.material));
            break;
          case "Sprite":
            o = new La(h(t.material));
            break;
          case "Group":
            o = new ra;
            break;
          case "Bone":
            o = new Ga;
            break;
          default:
            o = new mn
        }
        if (o.uuid = t.uuid,
          void 0 !== t.name && (o.name = t.name),
          void 0 !== t.matrix ? (o.matrix.fromArray(t.matrix),
            void 0 !== t.matrixAutoUpdate && (o.matrixAutoUpdate = t.matrixAutoUpdate),
            o.matrixAutoUpdate && o.matrix.decompose(o.position, o.quaternion, o.scale)) : (void 0 !== t.position && o.position.fromArray(t.position),
              void 0 !== t.rotation && o.rotation.fromArray(t.rotation),
              void 0 !== t.quaternion && o.quaternion.fromArray(t.quaternion),
              void 0 !== t.scale && o.scale.fromArray(t.scale)),
          void 0 !== t.castShadow && (o.castShadow = t.castShadow),
          void 0 !== t.receiveShadow && (o.receiveShadow = t.receiveShadow),
          t.shadow && (void 0 !== t.shadow.bias && (o.shadow.bias = t.shadow.bias),
            void 0 !== t.shadow.normalBias && (o.shadow.normalBias = t.shadow.normalBias),
            void 0 !== t.shadow.radius && (o.shadow.radius = t.shadow.radius),
            void 0 !== t.shadow.mapSize && o.shadow.mapSize.fromArray(t.shadow.mapSize),
            void 0 !== t.shadow.camera && (o.shadow.camera = this.parseObject(t.shadow.camera))),
          void 0 !== t.visible && (o.visible = t.visible),
          void 0 !== t.frustumCulled && (o.frustumCulled = t.frustumCulled),
          void 0 !== t.renderOrder && (o.renderOrder = t.renderOrder),
          void 0 !== t.userData && (o.userData = t.userData),
          void 0 !== t.layers && (o.layers.mask = t.layers),
          void 0 !== t.children) {
          const s = t.children;
          for (let t = 0; t < s.length; t++)
            o.add(this.parseObject(s[t], e, i, n, r))
        }
        if (void 0 !== t.animations) {
          const e = t.animations;
          for (let t = 0; t < e.length; t++) {
            const i = e[t];
            o.animations.push(r[i])
          }
        }
        if ("LOD" === t.type) {
          void 0 !== t.autoUpdate && (o.autoUpdate = t.autoUpdate);
          const e = t.levels;
          for (let t = 0; t < e.length; t++) {
            const i = e[t]
              , n = o.getObjectByProperty("uuid", i.object);
            void 0 !== n && o.addLevel(n, i.distance)
          }
        }
        return o
      }
      bindSkeletons(t, e) {
        0 !== Object.keys(e).length && t.traverse((function (t) {
          if (!0 === t.isSkinnedMesh && void 0 !== t.skeleton) {
            const i = e[t.skeleton];
            void 0 === i ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", t.skeleton) : t.bind(i, t.bindMatrix)
          }
        }
        ))
      }
      setTexturePath(t) {
        return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."),
          this.setResourcePath(t)
      }
    }
    ,
    ObjectSpaceNormalMap: ve,
    OctahedronBufferGeometry: Rh,
    OctahedronGeometry: Rh,
    OneFactor: C,
    OneMinusDstAlphaFactor: E,
    OneMinusDstColorFactor: R,
    OneMinusSrcAlphaFactor: M,
    OneMinusSrcColorFactor: _,
    OrthographicCamera: Br,
    PCFShadowMap: o,
    PCFSoftShadowMap: s,
    PMREMGenerator: Kr,
    ParametricGeometry: class extends Wn {
      constructor() {
        console.error("THREE.ParametricGeometry has been moved to /examples/jsm/geometries/ParametricGeometry.js"),
          super()
      }
    }
    ,
    Path: Bl,
    PerspectiveCamera: mr,
    Plane: wr,
    PlaneBufferGeometry: kr,
    PlaneGeometry: kr,
    PlaneHelper: class extends sl {
      constructor(t, e = 1, i = 16776960) {
        const n = i
          , r = new Wn;
        r.setAttribute("position", new Dn([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)),
          r.computeBoundingSphere(),
          super(r, new tl({
            color: n,
            toneMapped: !1
          })),
          this.type = "PlaneHelper",
          this.plane = t,
          this.size = e;
        const o = new Wn;
        o.setAttribute("position", new Dn([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)),
          o.computeBoundingSphere(),
          this.add(new lr(o, new kn({
            color: n,
            opacity: .2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1
          })))
      }
      updateMatrixWorld(t) {
        let e = -this.plane.constant;
        Math.abs(e) < 1e-8 && (e = 1e-8),
          this.scale.set(.5 * this.size, .5 * this.size, e),
          this.children[0].material.side = e < 0 ? h : l,
          this.lookAt(this.plane.normal),
          super.updateMatrixWorld(t)
      }
    }
    ,
    PointLight: Pc,
    PointLightHelper: class extends lr {
      constructor(t, e, i) {
        super(new zh(e, 4, 2), new kn({
          wireframe: !0,
          fog: !1,
          toneMapped: !1
        })),
          this.light = t,
          this.light.updateMatrixWorld(),
          this.color = i,
          this.type = "PointLightHelper",
          this.matrix = this.light.matrixWorld,
          this.matrixAutoUpdate = !1,
          this.update()
      }
      dispose() {
        this.geometry.dispose(),
          this.material.dispose()
      }
      update() {
        void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
      }
    }
    ,
    Points: ml,
    PointsMaterial: ul,
    PolarGridHelper: class extends hl {
      constructor(t = 10, e = 16, i = 8, n = 64, r = 4473924, o = 8947848) {
        r = new ei(r),
          o = new ei(o);
        const s = []
          , a = [];
        for (let i = 0; i <= e; i++) {
          const n = i / e * (2 * Math.PI)
            , l = Math.sin(n) * t
            , h = Math.cos(n) * t;
          s.push(0, 0, 0),
            s.push(l, 0, h);
          const c = 1 & i ? r : o;
          a.push(c.r, c.g, c.b),
            a.push(c.r, c.g, c.b)
        }
        for (let e = 0; e <= i; e++) {
          const l = 1 & e ? r : o
            , h = t - t / i * e;
          for (let t = 0; t < n; t++) {
            let e = t / n * (2 * Math.PI)
              , i = Math.sin(e) * h
              , r = Math.cos(e) * h;
            s.push(i, 0, r),
              a.push(l.r, l.g, l.b),
              e = (t + 1) / n * (2 * Math.PI),
              i = Math.sin(e) * h,
              r = Math.cos(e) * h,
              s.push(i, 0, r),
              a.push(l.r, l.g, l.b)
          }
        }
        const l = new Wn;
        l.setAttribute("position", new Dn(s, 3)),
          l.setAttribute("color", new Dn(a, 3));
        super(l, new tl({
          vertexColors: !0,
          toneMapped: !1
        })),
          this.type = "PolarGridHelper"
      }
    }
    ,
    PolyhedronBufferGeometry: Hl,
    PolyhedronGeometry: Hl,
    PositionalAudio: class extends ou {
      constructor(t) {
        super(t),
          this.panner = this.context.createPanner(),
          this.panner.panningModel = "HRTF",
          this.panner.connect(this.gain)
      }
      disconnect() {
        super.disconnect(),
          this.panner.disconnect(this.gain)
      }
      getOutput() {
        return this.panner
      }
      getRefDistance() {
        return this.panner.refDistance
      }
      setRefDistance(t) {
        return this.panner.refDistance = t,
          this
      }
      getRolloffFactor() {
        return this.panner.rolloffFactor
      }
      setRolloffFactor(t) {
        return this.panner.rolloffFactor = t,
          this
      }
      getDistanceModel() {
        return this.panner.distanceModel
      }
      setDistanceModel(t) {
        return this.panner.distanceModel = t,
          this
      }
      getMaxDistance() {
        return this.panner.maxDistance
      }
      setMaxDistance(t) {
        return this.panner.maxDistance = t,
          this
      }
      setDirectionalCone(t, e, i) {
        return this.panner.coneInnerAngle = t,
          this.panner.coneOuterAngle = e,
          this.panner.coneOuterGain = i,
          this
      }
      updateMatrixWorld(t) {
        if (super.updateMatrixWorld(t),
          !0 === this.hasPlaybackControl && !1 === this.isPlaying)
          return;
        this.matrixWorld.decompose(su, au, lu),
          hu.set(0, 0, 1).applyQuaternion(au);
        const e = this.panner;
        if (e.positionX) {
          const t = this.context.currentTime + this.listener.timeDelta;
          e.positionX.linearRampToValueAtTime(su.x, t),
            e.positionY.linearRampToValueAtTime(su.y, t),
            e.positionZ.linearRampToValueAtTime(su.z, t),
            e.orientationX.linearRampToValueAtTime(hu.x, t),
            e.orientationY.linearRampToValueAtTime(hu.y, t),
            e.orientationZ.linearRampToValueAtTime(hu.z, t)
        } else
          e.setPosition(su.x, su.y, su.z),
            e.setOrientation(hu.x, hu.y, hu.z)
      }
    }
    ,
    PropertyBinding: yu,
    PropertyMixer: cu,
    QuadraticBezierCurve: Ol,
    QuadraticBezierCurve3: Dl,
    Quaternion: pi,
    QuaternionKeyframeTrack: lc,
    QuaternionLinearInterpolant: ac,
    REVISION: e,
    RGBADepthPacking: me,
    RGBAFormat: wt,
    RGBAIntegerFormat: Pt,
    RGBA_ASTC_10x10_Format: ie,
    RGBA_ASTC_10x5_Format: $t,
    RGBA_ASTC_10x6_Format: te,
    RGBA_ASTC_10x8_Format: ee,
    RGBA_ASTC_12x10_Format: ne,
    RGBA_ASTC_12x12_Format: re,
    RGBA_ASTC_4x4_Format: Jt,
    RGBA_ASTC_5x4_Format: Ht,
    RGBA_ASTC_5x5_Format: Zt,
    RGBA_ASTC_6x5_Format: Qt,
    RGBA_ASTC_6x6_Format: Kt,
    RGBA_ASTC_8x5_Format: Yt,
    RGBA_ASTC_8x6_Format: qt,
    RGBA_ASTC_8x8_Format: Xt,
    RGBA_BPTC_Format: oe,
    RGBA_ETC2_EAC_Format: Wt,
    RGBA_PVRTC_2BPPV1_Format: jt,
    RGBA_PVRTC_4BPPV1_Format: Bt,
    RGBA_S3TC_DXT1_Format: Ot,
    RGBA_S3TC_DXT3_Format: Dt,
    RGBA_S3TC_DXT5_Format: Ut,
    RGBFormat: Ct,
    RGB_ETC1_Format: Vt,
    RGB_ETC2_Format: Gt,
    RGB_PVRTC_2BPPV1_Format: Ft,
    RGB_PVRTC_4BPPV1_Format: Nt,
    RGB_S3TC_DXT1_Format: zt,
    RGFormat: Rt,
    RGIntegerFormat: Lt,
    RawShaderMaterial: Gh,
    Ray: Gi,
    Raycaster: Cu,
    RectAreaLight: Uc,
    RedFormat: Et,
    RedIntegerFormat: kt,
    ReinhardToneMapping: H,
    RepeatWrapping: it,
    ReplaceStencilOp: 7681,
    ReverseSubtractEquation: A,
    RingBufferGeometry: Lh,
    RingGeometry: Lh,
    SRGBColorSpace: Ae,
    Scene: fa,
    ShaderChunk: Rr,
    ShaderLib: Pr,
    ShaderMaterial: fr,
    ShadowMaterial: Vh,
    Shape: $l,
    ShapeBufferGeometry: Ph,
    ShapeGeometry: Ph,
    ShapePath: class {
      constructor() {
        this.type = "ShapePath",
          this.color = new ei,
          this.subPaths = [],
          this.currentPath = null
      }
      moveTo(t, e) {
        return this.currentPath = new Bl,
          this.subPaths.push(this.currentPath),
          this.currentPath.moveTo(t, e),
          this
      }
      lineTo(t, e) {
        return this.currentPath.lineTo(t, e),
          this
      }
      quadraticCurveTo(t, e, i, n) {
        return this.currentPath.quadraticCurveTo(t, e, i, n),
          this
      }
      bezierCurveTo(t, e, i, n, r, o) {
        return this.currentPath.bezierCurveTo(t, e, i, n, r, o),
          this
      }
      splineThru(t) {
        return this.currentPath.splineThru(t),
          this
      }
      toShapes(t, e) {
        function i(t) {
          const e = [];
          for (let i = 0, n = t.length; i < n; i++) {
            const n = t[i]
              , r = new $l;
            r.curves = n.curves,
              e.push(r)
          }
          return e
        }
        function n(t, e) {
          const i = e.length;
          let n = !1;
          for (let r = i - 1, o = 0; o < i; r = o++) {
            let i = e[r]
              , s = e[o]
              , a = s.x - i.x
              , l = s.y - i.y;
            if (Math.abs(l) > Number.EPSILON) {
              if (l < 0 && (i = e[o],
                a = -a,
                s = e[r],
                l = -l),
                t.y < i.y || t.y > s.y)
                continue;
              if (t.y === i.y) {
                if (t.x === i.x)
                  return !0
              } else {
                const e = l * (t.x - i.x) - a * (t.y - i.y);
                if (0 === e)
                  return !0;
                if (e < 0)
                  continue;
                n = !n
              }
            } else {
              if (t.y !== i.y)
                continue;
              if (s.x <= t.x && t.x <= i.x || i.x <= t.x && t.x <= s.x)
                return !0
            }
          }
          return n
        }
        const r = _h.isClockWise
          , o = this.subPaths;
        if (0 === o.length)
          return [];
        if (!0 === e)
          return i(o);
        let s, a, l;
        const h = [];
        if (1 === o.length)
          return a = o[0],
            l = new $l,
            l.curves = a.curves,
            h.push(l),
            h;
        let c = !r(o[0].getPoints());
        c = t ? !c : c;
        const u = []
          , p = [];
        let d, f, g = [], m = 0;
        p[m] = void 0,
          g[m] = [];
        for (let e = 0, i = o.length; e < i; e++)
          a = o[e],
            d = a.getPoints(),
            s = r(d),
            s = t ? !s : s,
            s ? (!c && p[m] && m++,
              p[m] = {
                s: new $l,
                p: d
              },
              p[m].s.curves = a.curves,
              c && m++,
              g[m] = []) : g[m].push({
                h: a,
                p: d[0]
              });
        if (!p[0])
          return i(o);
        if (p.length > 1) {
          let t = !1
            , e = 0;
          for (let t = 0, e = p.length; t < e; t++)
            u[t] = [];
          for (let i = 0, r = p.length; i < r; i++) {
            const r = g[i];
            for (let o = 0; o < r.length; o++) {
              const s = r[o];
              let a = !0;
              for (let r = 0; r < p.length; r++)
                n(s.p, p[r].p) && (i !== r && e++,
                  a ? (a = !1,
                    u[r].push(s)) : t = !0);
              a && u[i].push(s)
            }
          }
          e > 0 && !1 === t && (g = u)
        }
        for (let t = 0, e = p.length; t < e; t++) {
          l = p[t].s,
            h.push(l),
            f = g[t];
          for (let t = 0, e = f.length; t < e; t++)
            l.holes.push(f[t].h)
        }
        return h
      }
    }
    ,
    ShapeUtils: _h,
    ShortType: dt,
    Skeleton: Za,
    SkeletonHelper: class extends hl {
      constructor(t) {
        const e = Ou(t)
          , i = new Wn
          , n = []
          , r = []
          , o = new ei(0, 0, 1)
          , s = new ei(0, 1, 0);
        for (let t = 0; t < e.length; t++) {
          const i = e[t];
          i.parent && i.parent.isBone && (n.push(0, 0, 0),
            n.push(0, 0, 0),
            r.push(o.r, o.g, o.b),
            r.push(s.r, s.g, s.b))
        }
        i.setAttribute("position", new Dn(n, 3)),
          i.setAttribute("color", new Dn(r, 3));
        super(i, new tl({
          vertexColors: !0,
          depthTest: !1,
          depthWrite: !1,
          toneMapped: !1,
          transparent: !0
        })),
          this.isSkeletonHelper = !0,
          this.type = "SkeletonHelper",
          this.root = t,
          this.bones = e,
          this.matrix = t.matrixWorld,
          this.matrixAutoUpdate = !1
      }
      updateMatrixWorld(t) {
        const e = this.bones
          , i = this.geometry
          , n = i.getAttribute("position");
        zu.copy(this.root.matrixWorld).invert();
        for (let t = 0, i = 0; t < e.length; t++) {
          const r = e[t];
          r.parent && r.parent.isBone && (Pu.multiplyMatrices(zu, r.matrixWorld),
            Lu.setFromMatrixPosition(Pu),
            n.setXYZ(i, Lu.x, Lu.y, Lu.z),
            Pu.multiplyMatrices(zu, r.parent.matrixWorld),
            Lu.setFromMatrixPosition(Pu),
            n.setXYZ(i + 1, Lu.x, Lu.y, Lu.z),
            i += 2)
        }
        i.getAttribute("position").needsUpdate = !0,
          super.updateMatrixWorld(t)
      }
    }
    ,
    SkinnedMesh: Va,
    SmoothShading: 2,
    Source: ri,
    Sphere: Oi,
    SphereBufferGeometry: zh,
    SphereGeometry: zh,
    Spherical: class {
      constructor(t = 1, e = 0, i = 0) {
        return this.radius = t,
          this.phi = e,
          this.theta = i,
          this
      }
      set(t, e, i) {
        return this.radius = t,
          this.phi = e,
          this.theta = i,
          this
      }
      copy(t) {
        return this.radius = t.radius,
          this.phi = t.phi,
          this.theta = t.theta,
          this
      }
      makeSafe() {
        const t = 1e-6;
        return this.phi = Math.max(t, Math.min(Math.PI - t, this.phi)),
          this
      }
      setFromVector3(t) {
        return this.setFromCartesianCoords(t.x, t.y, t.z)
      }
      setFromCartesianCoords(t, e, i) {
        return this.radius = Math.sqrt(t * t + e * e + i * i),
          0 === this.radius ? (this.theta = 0,
            this.phi = 0) : (this.theta = Math.atan2(t, i),
              this.phi = Math.acos(Le(e / this.radius, -1, 1))),
          this
      }
      clone() {
        return (new this.constructor).copy(this)
      }
    }
    ,
    SphericalHarmonics3: Nc,
    SplineCurve: Ul,
    SpotLight: Tc,
    SpotLightHelper: class extends mn {
      constructor(t, e) {
        super(),
          this.light = t,
          this.light.updateMatrixWorld(),
          this.matrix = t.matrixWorld,
          this.matrixAutoUpdate = !1,
          this.color = e;
        const i = new Wn
          , n = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
        for (let t = 0, e = 1, i = 32; t < i; t++,
          e++) {
          const r = t / i * Math.PI * 2
            , o = e / i * Math.PI * 2;
          n.push(Math.cos(r), Math.sin(r), 1, Math.cos(o), Math.sin(o), 1)
        }
        i.setAttribute("position", new Dn(n, 3));
        const r = new tl({
          fog: !1,
          toneMapped: !1
        });
        this.cone = new hl(i, r),
          this.add(this.cone),
          this.update()
      }
      dispose() {
        this.cone.geometry.dispose(),
          this.cone.material.dispose()
      }
      update() {
        this.light.updateMatrixWorld();
        const t = this.light.distance ? this.light.distance : 1e3
          , e = t * Math.tan(this.light.angle);
        this.cone.scale.set(e, e, t),
          Ru.setFromMatrixPosition(this.light.target.matrixWorld),
          this.cone.lookAt(Ru),
          void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
      }
    }
    ,
    Sprite: La,
    SpriteMaterial: va,
    SrcAlphaFactor: S,
    SrcAlphaSaturateFactor: L,
    SrcColorFactor: w,
    StaticCopyUsage: 35046,
    StaticDrawUsage: Ie,
    StaticReadUsage: 35045,
    StereoCamera: class {
      constructor() {
        this.type = "StereoCamera",
          this.aspect = 1,
          this.eyeSep = .064,
          this.cameraL = new mr,
          this.cameraL.layers.enable(1),
          this.cameraL.matrixAutoUpdate = !1,
          this.cameraR = new mr,
          this.cameraR.layers.enable(2),
          this.cameraR.matrixAutoUpdate = !1,
          this._cache = {
            focus: null,
            fov: null,
            aspect: null,
            near: null,
            far: null,
            zoom: null,
            eyeSep: null
          }
      }
      update(t) {
        const e = this._cache;
        if (e.focus !== t.focus || e.fov !== t.fov || e.aspect !== t.aspect * this.aspect || e.near !== t.near || e.far !== t.far || e.zoom !== t.zoom || e.eyeSep !== this.eyeSep) {
          e.focus = t.focus,
            e.fov = t.fov,
            e.aspect = t.aspect * this.aspect,
            e.near = t.near,
            e.far = t.far,
            e.zoom = t.zoom,
            e.eyeSep = this.eyeSep,
            Xc.copy(t.projectionMatrix);
          const i = e.eyeSep / 2
            , n = i * e.near / e.focus
            , r = e.near * Math.tan(Ee * e.fov * .5) / e.zoom;
          let o, s;
          qc.elements[12] = -i,
            Yc.elements[12] = i,
            o = -r * e.aspect + n,
            s = r * e.aspect + n,
            Xc.elements[0] = 2 * e.near / (s - o),
            Xc.elements[8] = (s + o) / (s - o),
            this.cameraL.projectionMatrix.copy(Xc),
            o = -r * e.aspect - n,
            s = r * e.aspect - n,
            Xc.elements[0] = 2 * e.near / (s - o),
            Xc.elements[8] = (s + o) / (s - o),
            this.cameraR.projectionMatrix.copy(Xc)
        }
        this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(qc),
          this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(Yc)
      }
    }
    ,
    StreamCopyUsage: 35042,
    StreamDrawUsage: 35040,
    StreamReadUsage: 35041,
    StringKeyframeTrack: hc,
    SubtractEquation: v,
    SubtractiveBlending: f,
    TOUCH: {
      ROTATE: 0,
      PAN: 1,
      DOLLY_PAN: 2,
      DOLLY_ROTATE: 3
    },
    TangentSpaceNormalMap: ye,
    TetrahedronBufferGeometry: Oh,
    TetrahedronGeometry: Oh,
    TextGeometry: class extends Wn {
      constructor() {
        console.error("THREE.TextGeometry has been moved to /examples/jsm/geometries/TextGeometry.js"),
          super()
      }
    }
    ,
    Texture: ai,
    TextureLoader: bc,
    TorusBufferGeometry: Dh,
    TorusGeometry: Dh,
    TorusKnotBufferGeometry: Uh,
    TorusKnotGeometry: Uh,
    Triangle: Mn,
    TriangleFanDrawMode: 2,
    TriangleStripDrawMode: 1,
    TrianglesDrawMode: 0,
    TubeBufferGeometry: Nh,
    TubeGeometry: Nh,
    UVMapping: Y,
    Uint16BufferAttribute: zn,
    Uint32BufferAttribute: On,
    Uint8BufferAttribute: class extends Pn {
      constructor(t, e, i) {
        super(new Uint8Array(t), e, i)
      }
    }
    ,
    Uint8ClampedBufferAttribute: class extends Pn {
      constructor(t, e, i) {
        super(new Uint8ClampedArray(t), e, i)
      }
    }
    ,
    Uniform: xu,
    UniformsLib: Lr,
    UniformsUtils: dr,
    UnsignedByteType: ut,
    UnsignedInt248Type: xt,
    UnsignedIntType: mt,
    UnsignedShort4444Type: At,
    UnsignedShort5551Type: bt,
    UnsignedShortType: ft,
    VSMShadowMap: a,
    Vector2: Fe,
    Vector3: di,
    Vector4: li,
    VectorKeyframeTrack: cc,
    VideoTexture: class extends ai {
      constructor(t, e, i, n, r, o, s, a, l) {
        super(t, e, i, n, r, o, s, a, l),
          this.isVideoTexture = !0,
          this.minFilter = void 0 !== o ? o : lt,
          this.magFilter = void 0 !== r ? r : lt,
          this.generateMipmaps = !1;
        const h = this;
        "requestVideoFrameCallback" in t && t.requestVideoFrameCallback((function e() {
          h.needsUpdate = !0,
            t.requestVideoFrameCallback(e)
        }
        ))
      }
      clone() {
        return new this.constructor(this.image).copy(this)
      }
      update() {
        const t = this.image;
        !1 === "requestVideoFrameCallback" in t && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
      }
    }
    ,
    WebGL1Renderer: ua,
    WebGL3DRenderTarget: class extends hi {
      constructor(t, e, i) {
        super(t, e),
          this.isWebGL3DRenderTarget = !0,
          this.depth = i,
          this.texture = new ui(null, t, e, i),
          this.texture.isRenderTargetTexture = !0
      }
    }
    ,
    WebGLArrayRenderTarget: class extends hi {
      constructor(t, e, i) {
        super(t, e),
          this.isWebGLArrayRenderTarget = !0,
          this.depth = i,
          this.texture = new ci(null, t, e, i),
          this.texture.isRenderTargetTexture = !0
      }
    }
    ,
    WebGLCubeRenderTarget: br,
    WebGLMultipleRenderTargets: class extends hi {
      constructor(t, e, i, n = {}) {
        super(t, e, n),
          this.isWebGLMultipleRenderTargets = !0;
        const r = this.texture;
        this.texture = [];
        for (let t = 0; t < i; t++)
          this.texture[t] = r.clone(),
            this.texture[t].isRenderTargetTexture = !0
      }
      setSize(t, e, i = 1) {
        if (this.width !== t || this.height !== e || this.depth !== i) {
          this.width = t,
            this.height = e,
            this.depth = i;
          for (let n = 0, r = this.texture.length; n < r; n++)
            this.texture[n].image.width = t, i
          this.texture[n].image.height = e,
            this.texture[n].image.depth = i;
          this.dispose()
        }
        return this.viewport.set(0, 0, t, e),
          this.scissor.set(0, 0, t, e),
          this
      }
      copy(t) {
        this.dispose(),
          this.width = t.width,
          this.height = t.height,
          this.depth = t.depth,
          this.viewport.set(0, 0, this.width, this.height),
          this.scissor.set(0, 0, this.width, this.height),
          this.depthBuffer = t.depthBuffer,
          this.stencilBuffer = t.stencilBuffer,
          null !== t.depthTexture && (this.depthTexture = t.depthTexture.clone()),
          this.texture.length = 0;
        for (let e = 0, i = t.texture.length; e < i; e++)
          this.texture[e] = t.texture[e].clone(),
            this.texture[e].isRenderTargetTexture = !0;
        return this
      }
    }
    ,
    WebGLMultisampleRenderTarget: class extends hi {
      constructor(t, e, i) {
        console.error('THREE.WebGLMultisampleRenderTarget has been removed. Use a normal render target and set the "samples" property to greater 0 to enable multisampling.'),
          super(t, e, i),
          this.samples = 4
      }
    }
    ,
    WebGLRenderTarget: hi,
    WebGLRenderer: ca,
    WebGLUtils: ia,
    WireframeGeometry: Fh,
    WrapAroundEnding: ue,
    ZeroCurvatureEnding: he,
    ZeroFactor: I,
    ZeroSlopeEnding: ce,
    ZeroStencilOp: 0,
    _SRGBAFormat: _e,
    sRGBEncoding: ge
  });
  function sp(t, e, i, n) {
    return new (i || (i = Promise))((function (r, o) {
      function s(t) {
        try {
          l(n.next(t))
        } catch (t) {
          o(t)
        }
      }
      function a(t) {
        try {
          l(n.throw(t))
        } catch (t) {
          o(t)
        }
      }
      function l(t) {
        var e;
        t.done ? r(t.value) : (e = t.value,
          e instanceof i ? e : new i((function (t) {
            t(e)
          }
          ))).then(s, a)
      }
      l((n = n.apply(t, e || [])).next())
    }
    ))
  }
  mn.prototype.dispose = function () {
    this.parent && this.parent.remove(this),
      this.geometry && this.geometry.dispose(),
      this.material && (this.material instanceof Array ? this.material.forEach((t => {
        t.map && t.map.dispose(),
          t.dispose()
      }
      )) : (this.material.map && this.material.map.dispose(),
        this.material.dispose())),
      this.children.slice().forEach((t => t.dispose && t.dispose())),
      this.dispatchEvent({
        type: "dispose"
      })
  }
    ,
    Object.defineProperty(mn.prototype, "_inScene", {
      get() {
        var t, e;
        return "Scene" === this.type || "Scene" === (null === (t = this.parent) || void 0 === t ? void 0 : t.type) || (null === (e = this.parent) || void 0 === e ? void 0 : e._inScene)
      }
    }),
    Fe.prototype.angleTo = function (t) {
      var e = this.dot(t) / Math.sqrt(this.lengthSq() * t.lengthSq());
      return Math.acos(Ne.clamp(e, -1, 1))
    }
    ;
  var ap, lp = "data:image/png;base64,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", hp = "data:image/png;base64,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", cp = "data:image/png;base64,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";
  const up = {
    api: (null === (ap = window.$config) || void 0 === ap ? void 0 : ap.api) || "https://test.3dwxb.com/",
    texList: {
      "洗手间": lp,
      "卫生间": lp,
      "电梯": "data:image/png;base64,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",
      "扶梯": "data:image/png;base64,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",
      "楼梯": hp,
      "步梯": hp,
      "大门": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZIAAAHyCAYAAADBdkigAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyNpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQ4IDc5LjE2NDAzNiwgMjAxOS8wOC8xMy0wMTowNjo1NyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDIxLjAgKFdpbmRvd3MpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkQyRjQyMjU1RTIyMDExRUM4RDNCRUU0Qjg0RENBOTc1IiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkQyRjQyMjU2RTIyMDExRUM4RDNCRUU0Qjg0RENBOTc1Ij4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6RDJGNDIyNTNFMjIwMTFFQzhEM0JFRTRCODREQ0E5NzUiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6RDJGNDIyNTRFMjIwMTFFQzhEM0JFRTRCODREQ0E5NzUiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz5iZB1jAABjpElEQVR42ux9baxl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",
      "停车场": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZIAAAHyCAYAAADBdkigAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyNpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQ4IDc5LjE2NDAzNiwgMjAxOS8wOC8xMy0wMTowNjo1NyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDIxLjAgKFdpbmRvd3MpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkRBMzcwNTI0RTIyMDExRUM5OTJGODMxRTU3NTY1NzRCIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkRBMzcwNTI1RTIyMDExRUM5OTJGODMxRTU3NTY1NzRCIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6REEzNzA1MjJFMjIwMTFFQzk5MkY4MzFFNTc1NjU3NEIiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6REEzNzA1MjNFMjIwMTFFQzk5MkY4MzFFNTc1NjU3NEIiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz4sEbGGAABvrUlEQVR42uy9C7hl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",
      "安全出口": cp,
      "出入口": cp
    }
  }
    , pp = {
      stairs: 5,
      escalator: 6,
      elevator: 7,
      indoor: 8,
      motorway: 9
    };
  pp[pp.stairs] = {
    name: "楼梯",
    id: pp.stairs
  },
    pp[pp.escalator] = {
      name: "扶梯",
      id: pp.escalator
    },
    pp[pp.elevator] = {
      name: "电梯",
      id: pp.elevator
    },
    pp[pp.indoor] = {
      name: "出入口",
      id: pp.indoor
    },
    pp[pp.motorway] = {
      name: "机动车道",
      id: pp.motorway
    };
  const dp = {
    block: 0,
    manCar: 1,
    man: 2,
    car: 4
  };
  dp[dp.block] = {
    name: "不通",
    id: dp.block
  },
    dp[dp.manCar] = {
      name: "人车",
      id: dp.manCar
    },
    dp[dp.man] = {
      name: "人",
      id: dp.man
    },
    dp[dp.car] = {
      name: "车",
      id: dp.car
    };
  const fp = 1e3
    , gp = 1003
    , mp = 1009
    , yp = 1e4
    , vp = 999
    , Ap = 10101
    , bp = 1002;
  class xp extends Se {
    constructor() {
      super(...arguments),
        this.children = [],
        this.childrenPool = []
    }
    add(t) {
      t.parent && (t.parent.children,
        t.parent = null),
        this.children.indexOf(t) < 0 && (this.object3d.add(t.object3d),
          t.parent = this,
          this.children.push(t))
    }
    remove(t) {
      let e = this.children.indexOf(t);
      e > -1 && (this.children.splice(e, 1),
        t.object3d.removeFromParent(),
        this.childrenPool.push(t))
    }
    addFromChildrnPool(t) {
      let e, i = this.childrenPool.findIndex((e => e.data.id === t));
      return i > -1 && (e = this.childrenPool.splice(i, 1)[0],
        this.children.push(e),
        this.object3d.add(e.object3d)),
        e
    }
    removeFromParent() {
      var t;
      null === (t = this.parent) || void 0 === t || t.remove(this)
    }
    destory() {
      this.children.map((t => {
        t.parent = null
      }
      )),
        this.object3d.dispose()
    }
  }
  const Ip = new Set;
  Se.prototype.on = function (t, e) {
    if ("function" == typeof e) {
      if (this.addEventListener(t, e),
        !Ip.has(this) && this instanceof mn) {
        Ip.add(this);
        const t = () => {
          Ip.delete(this),
            this.removeEventListener("dispose", t)
        }
          ;
        this.addEventListener("dispose", t)
      }
      return this
    }
  }
    ,
    Se.prototype.off = function (t, e) {
      return this.removeEventListener(t, e),
        this
    }
    ,
    Se.prototype.emit = function (t, ...e) {
      if (void 0 === this._listeners || !this._listeners[t])
        return;
      const i = (this._listeners[t] || []).slice(0);
      for (let t = 0; t < i.length; t++)
        i[t].apply(this, e);
      return this
    }
    ;
  class Cp extends Se {
    constructor(t) {
      super(),
        this.intersectionList = [],
        this.plane = new lr(new kr(99999999, 99999999)),
        this.map = t,
        this.enterList = {},
        this.raycaster = new Cu,
        this.initListener(),
        this.initInteraction()
    }
    get camera() {
      return this.map.camera
    }
    get canvas() {
      return this.map.renderer.domElement
    }
    initInteraction() {
      this.canvas.addEventListener("pointermove", (t => {
        this.handleIntersect(t);
        const e = this.intersectionList[0];
        this.canvas.style.cursor = e && e.object.cursor || "default"
      }
      )),
        this.canvas.addEventListener("pointerdown", (t => {
          this.handleIntersect(t)
        }
        )),
        this.canvas.addEventListener("pointerup", (t => {
          this.handleIntersect(t)
        }
        ))
    }
    handleIntersect(t, e) {
      this.raycaster.setFromCamera(_p(t, this.canvas), this.camera),
        this.intersectionList = this.raycaster.intersectObjects(e || [...Ip], !0).filter((t => t.object._click || t.object.visible)).sort(((t, e) => e.object.renderOrder - t.object.renderOrder));
      let i = this.map;
      this.intersectionList.map((t => {
        Object.defineProperty(t, "lnglat", {
          get() {
            return i.coordsToLngLat(this.point)
          }
        })
      }
      ))
    }
    initListener() {
      let t;
      this.canvas.addEventListener("pointerdown", (e => {
        t = wp(e),
          this.handleEvent(e, "pointerdown")
      }
      )),
        this.canvas.addEventListener("pointerup", (e => {
          let i = wp(e);
          Math.abs(i.x - t.x) <= 3 && Math.abs(i.y - t.y) <= 3 && (this.handleEvent(e, "click"),
            this.emit("click", e),
            0 === e.button ? (this.handleEvent(e, "leftclick"),
              this.emit("leftclick", e)) : 2 === e.button && (this.handleEvent(e, "rightclick"),
                this.emit("rightclick", e))),
            this.handleEvent(e, "pointerup")
        }
        )),
        this.canvas.addEventListener("pointermove", (t => {
          this.emit("pointermove", t),
            this.handleEvent(t, "pointermove"),
            this.handEnterOut(t)
        }
        ))
    }
    handEnterOut(t) {
      this.intersectionList.map((e => {
        this.enterList[e.object.uuid] || (e.object.emit("pointerenter", Object.assign({
          event: t
        }, e)),
          this.enterList[e.object.uuid] = e.object)
      }
      ));
      for (const e in this.enterList) {
        const i = this.enterList[e];
        this.intersectionList.find((t => t.object.uuid === e)) || (delete this.enterList[e],
          i.emit("pointerout", {
            event: t,
            object: i
          }))
      }
    }
    hasEvent(t, e) {
      return t._listeners && t._listeners[e] && t._listeners[e].length
    }
    handleEvent(t, e) {
      let i = {}
        , n = (r, o) => {
          if (!r)
            return;
          this.hasEvent(r, e) && !i[r.id] && (i[r.id] = 1,
            o.event = t,
            r.emit(e, o)),
            n(r.parent, o)
        }
        , r = !1;
      this.intersectionList.map((i => {
        !r && this.hasEvent(i.object, e) && (i.event = t,
          i.object.emit(e, i),
          r = !0),
          n(i.object.parent, i)
      }
      ))
    }
    intersectObjectsByLine(t, e, i = []) {
      return this.raycaster.set(t, e),
        this.raycaster.intersectObjects(i, !0)
    }
    intersectObjectsBy2D(t, e = []) {
      return this.raycaster.setFromCamera(_p(t, this.canvas), this.camera),
        this.raycaster.intersectObjects(e, !0)
    }
  }
  function wp(t) {
    return "clientX" in t ? {
      x: t.clientX,
      y: t.clientY
    } : t.touches && t.touches[0] ? {
      x: t.touches[0].clientX,
      y: t.touches[0].clientY
    } : t.changedTouches && t.changedTouches[0] ? {
      x: t.changedTouches[0].clientX,
      y: t.changedTouches[0].clientY
    } : t
  }
  function _p(t, e) {
    const { x: i, y: n } = wp(t)
      , r = e.getBoundingClientRect()
      , o = (i - r.left) * e.clientWidth / r.width
      , s = (n - r.top) * e.clientHeight / r.height
      , a = new Fe;
    return a.x = o / e.clientWidth * 2 - 1,
      a.y = s / e.clientHeight * -2 + 1,
      a
  }
  function Sp() {
    let t = {};
    return {
      get: function (e) {
        return t[e]
      },
      add: function (e, i) {
        t[e] = i
      },
      remove: function (e) {
        delete t[e]
      },
      removeAll: function () {
        t = {}
      }
    }
  }
  const Mp = {
    KHR_BINARY_GLTF: "KHR_binary_glTF",
    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
    KHR_MATERIALS_IOR: "KHR_materials_ior",
    KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
    KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
    KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
    KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
    KHR_MATERIALS_VOLUME: "KHR_materials_volume",
    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
    KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
    EXT_TEXTURE_WEBP: "EXT_texture_webp",
    EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
  };
  class Tp {
    constructor(t) {
      this.parser = t,
        this.name = Mp.KHR_LIGHTS_PUNCTUAL,
        this.cache = {
          refs: {},
          uses: {}
        }
    }
    _markDefs() {
      const t = this.parser
        , e = this.parser.json.nodes || [];
      for (let i = 0, n = e.length; i < n; i++) {
        const n = e[i];
        n.extensions && n.extensions[this.name] && void 0 !== n.extensions[this.name].light && t._addNodeRef(this.cache, n.extensions[this.name].light)
      }
    }
    _loadLight(t) {
      const e = this.parser
        , i = "light:" + t;
      let n = e.cache.get(i);
      if (n)
        return n;
      const r = e.json
        , o = ((r.extensions && r.extensions[this.name] || {}).lights || [])[t];
      let s;
      const a = new ei(16777215);
      void 0 !== o.color && a.fromArray(o.color);
      const l = void 0 !== o.range ? o.range : 0;
      switch (o.type) {
        case "directional":
          s = new Oc(a),
            s.target.position.set(0, 0, -1),
            s.add(s.target);
          break;
        case "point":
          s = new Pc(a),
            s.distance = l;
          break;
        case "spot":
          s = new Tc(a),
            s.distance = l,
            o.spot = o.spot || {},
            o.spot.innerConeAngle = void 0 !== o.spot.innerConeAngle ? o.spot.innerConeAngle : 0,
            o.spot.outerConeAngle = void 0 !== o.spot.outerConeAngle ? o.spot.outerConeAngle : Math.PI / 4,
            s.angle = o.spot.outerConeAngle,
            s.penumbra = 1 - o.spot.innerConeAngle / o.spot.outerConeAngle,
            s.target.position.set(0, 0, -1),
            s.add(s.target);
          break;
        default:
          throw new Error("THREE.GLTFLoader: Unexpected light type: " + o.type)
      }
      return s.position.set(0, 0, 0),
        s.decay = 2,
        void 0 !== o.intensity && (s.intensity = o.intensity),
        s.name = e.createUniqueName(o.name || "light_" + t),
        n = Promise.resolve(s),
        e.cache.add(i, n),
        n
    }
    createNodeAttachment(t) {
      const e = this
        , i = this.parser
        , n = i.json.nodes[t]
        , r = (n.extensions && n.extensions[this.name] || {}).light;
      return void 0 === r ? null : this._loadLight(r).then((function (t) {
        return i._getNodeRef(e.cache, r, t)
      }
      ))
    }
  }
  class Ep {
    constructor() {
      this.name = Mp.KHR_MATERIALS_UNLIT
    }
    getMaterialType() {
      return kn
    }
    extendParams(t, e, i) {
      const n = [];
      t.color = new ei(1, 1, 1),
        t.opacity = 1;
      const r = e.pbrMetallicRoughness;
      if (r) {
        if (Array.isArray(r.baseColorFactor)) {
          const e = r.baseColorFactor;
          t.color.fromArray(e),
            t.opacity = e[3]
        }
        void 0 !== r.baseColorTexture && n.push(i.assignTexture(t, "map", r.baseColorTexture, ge))
      }
      return Promise.all(n)
    }
  }
  class kp {
    constructor(t) {
      this.parser = t,
        this.name = Mp.KHR_MATERIALS_EMISSIVE_STRENGTH
    }
    extendMaterialParams(t, e) {
      const i = this.parser.json.materials[t];
      if (!i.extensions || !i.extensions[this.name])
        return Promise.resolve();
      const n = i.extensions[this.name].emissiveStrength;
      return void 0 !== n && (e.emissiveIntensity = n),
        Promise.resolve()
    }
  }
  class Rp {
    constructor(t) {
      this.parser = t,
        this.name = Mp.KHR_MATERIALS_CLEARCOAT
    }
    getMaterialType(t) {
      const e = this.parser.json.materials[t];
      return e.extensions && e.extensions[this.name] ? Jh : null
    }
    extendMaterialParams(t, e) {
      const i = this.parser
        , n = i.json.materials[t];
      if (!n.extensions || !n.extensions[this.name])
        return Promise.resolve();
      const r = []
        , o = n.extensions[this.name];
      if (void 0 !== o.clearcoatFactor && (e.clearcoat = o.clearcoatFactor),
        void 0 !== o.clearcoatTexture && r.push(i.assignTexture(e, "clearcoatMap", o.clearcoatTexture)),
        void 0 !== o.clearcoatRoughnessFactor && (e.clearcoatRoughness = o.clearcoatRoughnessFactor),
        void 0 !== o.clearcoatRoughnessTexture && r.push(i.assignTexture(e, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)),
        void 0 !== o.clearcoatNormalTexture && (r.push(i.assignTexture(e, "clearcoatNormalMap", o.clearcoatNormalTexture)),
          void 0 !== o.clearcoatNormalTexture.scale)) {
        const t = o.clearcoatNormalTexture.scale;
        e.clearcoatNormalScale = new Fe(t, t)
      }
      return Promise.all(r)
    }
  }
  class Lp {
    constructor(t) {
      this.parser = t,
        this.name = Mp.KHR_MATERIALS_IRIDESCENCE
    }
    getMaterialType(t) {
      const e = this.parser.json.materials[t];
      return e.extensions && e.extensions[this.name] ? Jh : null
    }
    extendMaterialParams(t, e) {
      const i = this.parser
        , n = i.json.materials[t];
      if (!n.extensions || !n.extensions[this.name])
        return Promise.resolve();
      const r = []
        , o = n.extensions[this.name];
      return void 0 !== o.iridescenceFactor && (e.iridescence = o.iridescenceFactor),
        void 0 !== o.iridescenceTexture && r.push(i.assignTexture(e, "iridescenceMap", o.iridescenceTexture)),
        void 0 !== o.iridescenceIor && (e.iridescenceIOR = o.iridescenceIor),
        void 0 === e.iridescenceThicknessRange && (e.iridescenceThicknessRange = [100, 400]),
        void 0 !== o.iridescenceThicknessMinimum && (e.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum),
        void 0 !== o.iridescenceThicknessMaximum && (e.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum),
        void 0 !== o.iridescenceThicknessTexture && r.push(i.assignTexture(e, "iridescenceThicknessMap", o.iridescenceThicknessTexture)),
        Promise.all(r)
    }
  }
  class Pp {
    constructor(t) {
      this.parser = t,
        this.name = Mp.KHR_MATERIALS_SHEEN
    }
    getMaterialType(t) {
      const e = this.parser.json.materials[t];
      return e.extensions && e.extensions[this.name] ? Jh : null
    }
    extendMaterialParams(t, e) {
      const i = this.parser
        , n = i.json.materials[t];
      if (!n.extensions || !n.extensions[this.name])
        return Promise.resolve();
      const r = [];
      e.sheenColor = new ei(0, 0, 0),
        e.sheenRoughness = 0,
        e.sheen = 1;
      const o = n.extensions[this.name];
      return void 0 !== o.sheenColorFactor && e.sheenColor.fromArray(o.sheenColorFactor),
        void 0 !== o.sheenRoughnessFactor && (e.sheenRoughness = o.sheenRoughnessFactor),
        void 0 !== o.sheenColorTexture && r.push(i.assignTexture(e, "sheenColorMap", o.sheenColorTexture, ge)),
        void 0 !== o.sheenRoughnessTexture && r.push(i.assignTexture(e, "sheenRoughnessMap", o.sheenRoughnessTexture)),
        Promise.all(r)
    }
  }
  class zp {
    constructor(t) {
      this.parser = t,
        this.name = Mp.KHR_MATERIALS_TRANSMISSION
    }
    getMaterialType(t) {
      const e = this.parser.json.materials[t];
      return e.extensions && e.extensions[this.name] ? Jh : null
    }
    extendMaterialParams(t, e) {
      const i = this.parser
        , n = i.json.materials[t];
      if (!n.extensions || !n.extensions[this.name])
        return Promise.resolve();
      const r = []
        , o = n.extensions[this.name];
      return void 0 !== o.transmissionFactor && (e.transmission = o.transmissionFactor),
        void 0 !== o.transmissionTexture && r.push(i.assignTexture(e, "transmissionMap", o.transmissionTexture)),
        Promise.all(r)
    }
  }
  class Op {
    constructor(t) {
      this.parser = t,
        this.name = Mp.KHR_MATERIALS_VOLUME
    }
    getMaterialType(t) {
      const e = this.parser.json.materials[t];
      return e.extensions && e.extensions[this.name] ? Jh : null
    }
    extendMaterialParams(t, e) {
      const i = this.parser
        , n = i.json.materials[t];
      if (!n.extensions || !n.extensions[this.name])
        return Promise.resolve();
      const r = []
        , o = n.extensions[this.name];
      e.thickness = void 0 !== o.thicknessFactor ? o.thicknessFactor : 0,
        void 0 !== o.thicknessTexture && r.push(i.assignTexture(e, "thicknessMap", o.thicknessTexture)),
        e.attenuationDistance = o.attenuationDistance || 0;
      const s = o.attenuationColor || [1, 1, 1];
      return e.attenuationColor = new ei(s[0], s[1], s[2]),
        Promise.all(r)
    }
  }
  class Dp {
    constructor(t) {
      this.parser = t,
        this.name = Mp.KHR_MATERIALS_IOR
    }
    getMaterialType(t) {
      const e = this.parser.json.materials[t];
      return e.extensions && e.extensions[this.name] ? Jh : null
    }
    extendMaterialParams(t, e) {
      const i = this.parser.json.materials[t];
      if (!i.extensions || !i.extensions[this.name])
        return Promise.resolve();
      const n = i.extensions[this.name];
      return e.ior = void 0 !== n.ior ? n.ior : 1.5,
        Promise.resolve()
    }
  }
  class Up {
    constructor(t) {
      this.parser = t,
        this.name = Mp.KHR_MATERIALS_SPECULAR
    }
    getMaterialType(t) {
      const e = this.parser.json.materials[t];
      return e.extensions && e.extensions[this.name] ? Jh : null
    }
    extendMaterialParams(t, e) {
      const i = this.parser
        , n = i.json.materials[t];
      if (!n.extensions || !n.extensions[this.name])
        return Promise.resolve();
      const r = []
        , o = n.extensions[this.name];
      e.specularIntensity = void 0 !== o.specularFactor ? o.specularFactor : 1,
        void 0 !== o.specularTexture && r.push(i.assignTexture(e, "specularIntensityMap", o.specularTexture));
      const s = o.specularColorFactor || [1, 1, 1];
      return e.specularColor = new ei(s[0], s[1], s[2]),
        void 0 !== o.specularColorTexture && r.push(i.assignTexture(e, "specularColorMap", o.specularColorTexture, ge)),
        Promise.all(r)
    }
  }
  class Np {
    constructor(t) {
      this.parser = t,
        this.name = Mp.KHR_TEXTURE_BASISU
    }
    loadTexture(t) {
      const e = this.parser
        , i = e.json
        , n = i.textures[t];
      if (!n.extensions || !n.extensions[this.name])
        return null;
      const r = n.extensions[this.name]
        , o = e.options.ktx2Loader;
      if (!o) {
        if (i.extensionsRequired && i.extensionsRequired.indexOf(this.name) >= 0)
          throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
        return null
      }
      return e.loadTextureImage(t, r.source, o)
    }
  }
  class Fp {
    constructor(t) {
      this.parser = t,
        this.name = Mp.EXT_TEXTURE_WEBP,
        this.isSupported = null
    }
    loadTexture(t) {
      const e = this.name
        , i = this.parser
        , n = i.json
        , r = n.textures[t];
      if (!r.extensions || !r.extensions[e])
        return null;
      const o = r.extensions[e]
        , s = n.images[o.source];
      let a = i.textureLoader;
      if (s.uri) {
        const t = i.options.manager.getHandler(s.uri);
        null !== t && (a = t)
      }
      return this.detectSupport().then((function (r) {
        if (r)
          return i.loadTextureImage(t, o.source, a);
        if (n.extensionsRequired && n.extensionsRequired.indexOf(e) >= 0)
          throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
        return i.loadTexture(t)
      }
      ))
    }
    detectSupport() {
      return this.isSupported || (this.isSupported = new Promise((function (t) {
        const e = new Image;
        e.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",
          e.onload = e.onerror = function () {
            t(1 === e.height)
          }
      }
      ))),
        this.isSupported
    }
  }
  class Bp {
    constructor(t) {
      this.name = Mp.EXT_MESHOPT_COMPRESSION,
        this.parser = t
    }
    loadBufferView(t) {
      const e = this.parser.json
        , i = e.bufferViews[t];
      if (i.extensions && i.extensions[this.name]) {
        const t = i.extensions[this.name]
          , n = this.parser.getDependency("buffer", t.buffer)
          , r = this.parser.options.meshoptDecoder;
        if (!r || !r.supported) {
          if (e.extensionsRequired && e.extensionsRequired.indexOf(this.name) >= 0)
            throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
          return null
        }
        return Promise.all([n, r.ready]).then((function (e) {
          const i = t.byteOffset || 0
            , n = t.byteLength || 0
            , o = t.count
            , s = t.byteStride
            , a = new ArrayBuffer(o * s)
            , l = new Uint8Array(e[0], i, n);
          return r.decodeGltfBuffer(new Uint8Array(a), o, s, l, t.mode, t.filter),
            a
        }
        ))
      }
      return null
    }
  }
  const jp = "glTF"
    , Vp = 1313821514
    , Gp = 5130562;
  class Wp {
    constructor(t) {
      this.name = Mp.KHR_BINARY_GLTF,
        this.content = null,
        this.body = null;
      const e = new DataView(t, 0, 12);
      if (this.header = {
        magic: jc.decodeText(new Uint8Array(t.slice(0, 4))),
        version: e.getUint32(4, !0),
        length: e.getUint32(8, !0)
      },
        this.header.magic !== jp)
        throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
      if (this.header.version < 2)
        throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
      const i = this.header.length - 12
        , n = new DataView(t, 12);
      let r = 0;
      for (; r < i;) {
        const e = n.getUint32(r, !0);
        r += 4;
        const i = n.getUint32(r, !0);
        if (r += 4,
          i === Vp) {
          const i = new Uint8Array(t, 12 + r, e);
          this.content = jc.decodeText(i)
        } else if (i === Gp) {
          const i = 12 + r;
          this.body = t.slice(i, i + e)
        }
        r += e
      }
      if (null === this.content)
        throw new Error("THREE.GLTFLoader: JSON content not found.")
    }
  }
  class Jp {
    constructor(t, e) {
      if (!e)
        throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
      this.name = Mp.KHR_DRACO_MESH_COMPRESSION,
        this.json = t,
        this.dracoLoader = e,
        this.dracoLoader.preload()
    }
    decodePrimitive(t, e) {
      const i = this.json
        , n = this.dracoLoader
        , r = t.extensions[this.name].bufferView
        , o = t.extensions[this.name].attributes
        , s = {}
        , a = {}
        , l = {};
      for (const t in o) {
        const e = cd[t] || t.toLowerCase();
        s[e] = o[t]
      }
      for (const e in t.attributes) {
        const n = cd[e] || e.toLowerCase();
        if (void 0 !== o[e]) {
          const r = i.accessors[t.attributes[e]]
            , o = sd[r.componentType];
          l[n] = o,
            a[n] = !0 === r.normalized
        }
      }
      return e.getDependency("bufferView", r).then((function (t) {
        return new Promise((function (e) {
          n.decodeDracoFile(t, (function (t) {
            for (const e in t.attributes) {
              const i = t.attributes[e]
                , n = a[e];
              void 0 !== n && (i.normalized = n)
            }
            e(t)
          }
          ), s, l)
        }
        ))
      }
      ))
    }
  }
  class Hp {
    constructor() {
      this.name = Mp.KHR_TEXTURE_TRANSFORM
    }
    extendTexture(t, e) {
      return void 0 !== e.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'),
        void 0 === e.offset && void 0 === e.rotation && void 0 === e.scale || (t = t.clone(),
          void 0 !== e.offset && t.offset.fromArray(e.offset),
          void 0 !== e.rotation && (t.rotation = e.rotation),
          void 0 !== e.scale && t.repeat.fromArray(e.scale),
          t.needsUpdate = !0),
        t
    }
  }
  class Zp extends Wh {
    constructor(t) {
      super(),
        this.isGLTFSpecularGlossinessMaterial = !0;
      const e = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n")
        , i = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n")
        , n = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n")
        , r = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n")
        , o = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.roughness += geometryRoughness;", "material.roughness = min( material.roughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n")
        , s = {
          specular: {
            value: (new ei).setHex(16777215)
          },
          glossiness: {
            value: 1
          },
          specularMap: {
            value: null
          },
          glossinessMap: {
            value: null
          }
        };
      this._extraUniforms = s,
        this.onBeforeCompile = function (t) {
          for (const e in s)
            t.uniforms[e] = s[e];
          t.fragmentShader = t.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", e).replace("#include <metalnessmap_pars_fragment>", i).replace("#include <roughnessmap_fragment>", n).replace("#include <metalnessmap_fragment>", r).replace("#include <lights_physical_fragment>", o)
        }
        ,
        Object.defineProperties(this, {
          specular: {
            get: function () {
              return s.specular.value
            },
            set: function (t) {
              s.specular.value = t
            }
          },
          specularMap: {
            get: function () {
              return s.specularMap.value
            },
            set: function (t) {
              s.specularMap.value = t,
                t ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP
            }
          },
          glossiness: {
            get: function () {
              return s.glossiness.value
            },
            set: function (t) {
              s.glossiness.value = t
            }
          },
          glossinessMap: {
            get: function () {
              return s.glossinessMap.value
            },
            set: function (t) {
              s.glossinessMap.value = t,
                t ? (this.defines.USE_GLOSSINESSMAP = "",
                  this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP,
                    delete this.defines.USE_UV)
            }
          }
        }),
        delete this.metalness,
        delete this.roughness,
        delete this.metalnessMap,
        delete this.roughnessMap,
        this.setValues(t)
    }
    copy(t) {
      return super.copy(t),
        this.specularMap = t.specularMap,
        this.specular.copy(t.specular),
        this.glossinessMap = t.glossinessMap,
        this.glossiness = t.glossiness,
        delete this.metalness,
        delete this.roughness,
        delete this.metalnessMap,
        delete this.roughnessMap,
        this
    }
  }
  class Qp {
    constructor() {
      this.name = Mp.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,
        this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity"]
    }
    getMaterialType() {
      return Zp
    }
    extendParams(t, e, i) {
      const n = e.extensions[this.name];
      t.color = new ei(1, 1, 1),
        t.opacity = 1;
      const r = [];
      if (Array.isArray(n.diffuseFactor)) {
        const e = n.diffuseFactor;
        t.color.fromArray(e),
          t.opacity = e[3]
      }
      if (void 0 !== n.diffuseTexture && r.push(i.assignTexture(t, "map", n.diffuseTexture, ge)),
        t.emissive = new ei(0, 0, 0),
        t.glossiness = void 0 !== n.glossinessFactor ? n.glossinessFactor : 1,
        t.specular = new ei(1, 1, 1),
        Array.isArray(n.specularFactor) && t.specular.fromArray(n.specularFactor),
        void 0 !== n.specularGlossinessTexture) {
        const e = n.specularGlossinessTexture;
        r.push(i.assignTexture(t, "glossinessMap", e)),
          r.push(i.assignTexture(t, "specularMap", e, ge))
      }
      return Promise.all(r)
    }
    createMaterial(t) {
      const e = new Zp(t);
      return e.fog = !0,
        e.color = t.color,
        e.map = void 0 === t.map ? null : t.map,
        e.lightMap = null,
        e.lightMapIntensity = 1,
        e.aoMap = void 0 === t.aoMap ? null : t.aoMap,
        e.aoMapIntensity = 1,
        e.emissive = t.emissive,
        e.emissiveIntensity = void 0 === t.emissiveIntensity ? 1 : t.emissiveIntensity,
        e.emissiveMap = void 0 === t.emissiveMap ? null : t.emissiveMap,
        e.bumpMap = void 0 === t.bumpMap ? null : t.bumpMap,
        e.bumpScale = 1,
        e.normalMap = void 0 === t.normalMap ? null : t.normalMap,
        e.normalMapType = ye,
        t.normalScale && (e.normalScale = t.normalScale),
        e.displacementMap = null,
        e.displacementScale = 1,
        e.displacementBias = 0,
        e.specularMap = void 0 === t.specularMap ? null : t.specularMap,
        e.specular = t.specular,
        e.glossinessMap = void 0 === t.glossinessMap ? null : t.glossinessMap,
        e.glossiness = t.glossiness,
        e.alphaMap = null,
        e.envMap = void 0 === t.envMap ? null : t.envMap,
        e.envMapIntensity = 1,
        e
    }
  }
  class Kp {
    constructor() {
      this.name = Mp.KHR_MESH_QUANTIZATION
    }
  }
  class Yp extends $h {
    constructor(t, e, i, n) {
      super(t, e, i, n)
    }
    copySampleValue_(t) {
      const e = this.resultBuffer
        , i = this.sampleValues
        , n = this.valueSize
        , r = t * n * 3 + n;
      for (let t = 0; t !== n; t++)
        e[t] = i[r + t];
      return e
    }
    interpolate_(t, e, i, n) {
      const r = this.resultBuffer
        , o = this.sampleValues
        , s = this.valueSize
        , a = 2 * s
        , l = 3 * s
        , h = n - e
        , c = (i - e) / h
        , u = c * c
        , p = u * c
        , d = t * l
        , f = d - l
        , g = -2 * p + 3 * u
        , m = p - u
        , y = 1 - g
        , v = m - u + c;
      for (let t = 0; t !== s; t++) {
        const e = o[f + t + s]
          , i = o[f + t + a] * h
          , n = o[d + t + s]
          , l = o[d + t] * h;
        r[t] = y * e + v * i + g * n + m * l
      }
      return r
    }
  }
  const qp = new pi;
  class Xp extends Yp {
    interpolate_(t, e, i, n) {
      const r = super.interpolate_(t, e, i, n);
      return qp.fromArray(r).normalize().toArray(r),
        r
    }
  }
  const $p = 0
    , td = 1
    , ed = 2
    , id = 3
    , nd = 4
    , rd = 5
    , od = 6
    , sd = {
      5120: Int8Array,
      5121: Uint8Array,
      5122: Int16Array,
      5123: Uint16Array,
      5125: Uint32Array,
      5126: Float32Array
    }
    , ad = {
      9728: ot,
      9729: lt,
      9984: st,
      9985: ht,
      9986: at,
      9987: ct
    }
    , ld = {
      33071: nt,
      33648: rt,
      10497: it
    }
    , hd = {
      SCALAR: 1,
      VEC2: 2,
      VEC3: 3,
      VEC4: 4,
      MAT2: 4,
      MAT3: 9,
      MAT4: 16
    }
    , cd = {
      POSITION: "position",
      NORMAL: "normal",
      TANGENT: "tangent",
      TEXCOORD_0: "uv",
      TEXCOORD_1: "uv2",
      COLOR_0: "color",
      WEIGHTS_0: "skinWeight",
      JOINTS_0: "skinIndex"
    }
    , ud = {
      scale: "scale",
      translation: "position",
      rotation: "quaternion",
      weights: "morphTargetInfluences"
    }
    , pd = {
      CUBICSPLINE: void 0,
      LINEAR: ae,
      STEP: se
    }
    , dd = "OPAQUE"
    , fd = "MASK"
    , gd = "BLEND";
  function md(t, e, i) {
    for (const n in i.extensions)
      void 0 === t[n] && (e.userData.gltfExtensions = e.userData.gltfExtensions || {},
        e.userData.gltfExtensions[n] = i.extensions[n])
  }
  function yd(t, e) {
    void 0 !== e.extras && ("object" == typeof e.extras ? Object.assign(t.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras))
  }
  function vd(t, e) {
    if (t.updateMorphTargets(),
      void 0 !== e.weights)
      for (let i = 0, n = e.weights.length; i < n; i++)
        t.morphTargetInfluences[i] = e.weights[i];
    if (e.extras && Array.isArray(e.extras.targetNames)) {
      const i = e.extras.targetNames;
      if (t.morphTargetInfluences.length === i.length) {
        t.morphTargetDictionary = {};
        for (let e = 0, n = i.length; e < n; e++)
          t.morphTargetDictionary[i[e]] = e
      } else
        console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
    }
  }
  function Ad(t) {
    const e = t.extensions && t.extensions[Mp.KHR_DRACO_MESH_COMPRESSION];
    let i;
    return i = e ? "draco:" + e.bufferView + ":" + e.indices + ":" + bd(e.attributes) : t.indices + ":" + bd(t.attributes) + ":" + t.mode,
      i
  }
  function bd(t) {
    let e = "";
    const i = Object.keys(t).sort();
    for (let n = 0, r = i.length; n < r; n++)
      e += i[n] + ":" + t[i[n]] + ";";
    return e
  }
  function xd(t) {
    switch (t) {
      case Int8Array:
        return 1 / 127;
      case Uint8Array:
        return 1 / 255;
      case Int16Array:
        return 1 / 32767;
      case Uint16Array:
        return 1 / 65535;
      default:
        throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
    }
  }
  class Id {
    constructor(t = {}, e = {}) {
      this.json = t,
        this.extensions = {},
        this.plugins = {},
        this.options = e,
        this.cache = new Sp,
        this.associations = new Map,
        this.primitiveCache = {},
        this.meshCache = {
          refs: {},
          uses: {}
        },
        this.cameraCache = {
          refs: {},
          uses: {}
        },
        this.lightCache = {
          refs: {},
          uses: {}
        },
        this.sourceCache = {},
        this.textureCache = {},
        this.nodeNamesUsed = {};
      const i = !0 === /^((?!chrome|android).)*safari/i.test(navigator.userAgent)
        , n = navigator.userAgent.indexOf("Firefox") > -1
        , r = n ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1;
      "undefined" == typeof createImageBitmap || i || n && r < 98 ? this.textureLoader = new bc(this.options.manager) : this.textureLoader = new Zc(this.options.manager),
        this.textureLoader.setCrossOrigin(this.options.crossOrigin),
        this.textureLoader.setRequestHeader(this.options.requestHeader),
        this.fileLoader = new vc(this.options.manager),
        this.fileLoader.setResponseType("arraybuffer"),
        "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
    }
    setExtensions(t) {
      this.extensions = t
    }
    setPlugins(t) {
      this.plugins = t
    }
    parse(t, e) {
      const i = this
        , n = this.json
        , r = this.extensions;
      this.cache.removeAll(),
        this._invokeAll((function (t) {
          return t._markDefs && t._markDefs()
        }
        )),
        Promise.all(this._invokeAll((function (t) {
          return t.beforeRoot && t.beforeRoot()
        }
        ))).then((function () {
          return Promise.all([i.getDependencies("scene"), i.getDependencies("animation"), i.getDependencies("camera")])
        }
        )).then((function (e) {
          const o = {
            scene: e[0][n.scene || 0],
            scenes: e[0],
            animations: e[1],
            cameras: e[2],
            asset: n.asset,
            parser: i,
            userData: {}
          };
          md(r, o, n),
            yd(o, n),
            Promise.all(i._invokeAll((function (t) {
              return t.afterRoot && t.afterRoot(o)
            }
            ))).then((function () {
              t(o)
            }
            ))
        }
        )).catch(e)
    }
    _markDefs() {
      const t = this.json.nodes || []
        , e = this.json.skins || []
        , i = this.json.meshes || [];
      for (let i = 0, n = e.length; i < n; i++) {
        const n = e[i].joints;
        for (let e = 0, i = n.length; e < i; e++)
          t[n[e]].isBone = !0
      }
      for (let e = 0, n = t.length; e < n; e++) {
        const n = t[e];
        void 0 !== n.mesh && (this._addNodeRef(this.meshCache, n.mesh),
          void 0 !== n.skin && (i[n.mesh].isSkinnedMesh = !0)),
          void 0 !== n.camera && this._addNodeRef(this.cameraCache, n.camera)
      }
    }
    _addNodeRef(t, e) {
      void 0 !== e && (void 0 === t.refs[e] && (t.refs[e] = t.uses[e] = 0),
        t.refs[e]++)
    }
    _getNodeRef(t, e, i) {
      if (t.refs[e] <= 1)
        return i;
      const n = i.clone()
        , r = (t, e) => {
          const i = this.associations.get(t);
          null != i && this.associations.set(e, i);
          for (const [i, n] of t.children.entries())
            r(n, e.children[i])
        }
        ;
      return r(i, n),
        n.name += "_instance_" + t.uses[e]++,
        n
    }
    _invokeOne(t) {
      const e = Object.values(this.plugins);
      e.push(this);
      for (let i = 0; i < e.length; i++) {
        const n = t(e[i]);
        if (n)
          return n
      }
      return null
    }
    _invokeAll(t) {
      const e = Object.values(this.plugins);
      e.unshift(this);
      const i = [];
      for (let n = 0; n < e.length; n++) {
        const r = t(e[n]);
        r && i.push(r)
      }
      return i
    }
    getDependency(t, e) {
      const i = t + ":" + e;
      let n = this.cache.get(i);
      if (!n) {
        switch (t) {
          case "scene":
            n = this.loadScene(e);
            break;
          case "node":
            n = this.loadNode(e);
            break;
          case "mesh":
            n = this._invokeOne((function (t) {
              return t.loadMesh && t.loadMesh(e)
            }
            ));
            break;
          case "accessor":
            n = this.loadAccessor(e);
            break;
          case "bufferView":
            n = this._invokeOne((function (t) {
              return t.loadBufferView && t.loadBufferView(e)
            }
            ));
            break;
          case "buffer":
            n = this.loadBuffer(e);
            break;
          case "material":
            n = this._invokeOne((function (t) {
              return t.loadMaterial && t.loadMaterial(e)
            }
            ));
            break;
          case "texture":
            n = this._invokeOne((function (t) {
              return t.loadTexture && t.loadTexture(e)
            }
            ));
            break;
          case "skin":
            n = this.loadSkin(e);
            break;
          case "animation":
            n = this._invokeOne((function (t) {
              return t.loadAnimation && t.loadAnimation(e)
            }
            ));
            break;
          case "camera":
            n = this.loadCamera(e);
            break;
          default:
            throw new Error("Unknown type: " + t)
        }
        this.cache.add(i, n)
      }
      return n
    }
    getDependencies(t) {
      let e = this.cache.get(t);
      if (!e) {
        const i = this
          , n = this.json[t + ("mesh" === t ? "es" : "s")] || [];
        e = Promise.all(n.map((function (e, n) {
          return i.getDependency(t, n)
        }
        ))),
          this.cache.add(t, e)
      }
      return e
    }
    loadBuffer(t) {
      const e = this.json.buffers[t]
        , i = this.fileLoader;
      if (e.type && "arraybuffer" !== e.type)
        throw new Error("THREE.GLTFLoader: " + e.type + " buffer type is not supported.");
      if (void 0 === e.uri && 0 === t)
        return Promise.resolve(this.extensions[Mp.KHR_BINARY_GLTF].body);
      const n = this.options;
      return new Promise((function (t, r) {
        i.load(jc.resolveURL(e.uri, n.path), t, void 0, (function () {
          r(new Error('THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".'))
        }
        ))
      }
      ))
    }
    loadBufferView(t) {
      const e = this.json.bufferViews[t];
      return this.getDependency("buffer", e.buffer).then((function (t) {
        const i = e.byteLength || 0
          , n = e.byteOffset || 0;
        return t.slice(n, n + i)
      }
      ))
    }
    loadAccessor(t) {
      const e = this
        , i = this.json
        , n = this.json.accessors[t];
      if (void 0 === n.bufferView && void 0 === n.sparse)
        return Promise.resolve(null);
      const r = [];
      return void 0 !== n.bufferView ? r.push(this.getDependency("bufferView", n.bufferView)) : r.push(null),
        void 0 !== n.sparse && (r.push(this.getDependency("bufferView", n.sparse.indices.bufferView)),
          r.push(this.getDependency("bufferView", n.sparse.values.bufferView))),
        Promise.all(r).then((function (t) {
          const r = t[0]
            , o = hd[n.type]
            , s = sd[n.componentType]
            , a = s.BYTES_PER_ELEMENT
            , l = a * o
            , h = n.byteOffset || 0
            , c = void 0 !== n.bufferView ? i.bufferViews[n.bufferView].byteStride : void 0
            , u = !0 === n.normalized;
          let p, d;
          if (c && c !== l) {
            const t = Math.floor(h / c)
              , i = "InterleavedBuffer:" + n.bufferView + ":" + n.componentType + ":" + t + ":" + n.count;
            let l = e.cache.get(i);
            l || (p = new s(r, t * c, n.count * c / a),
              l = new ga(p, c / a),
              e.cache.add(i, l)),
              d = new ya(l, o, h % c / a, u)
          } else
            p = null === r ? new s(n.count * o) : new s(r, h, n.count * o),
              d = new Pn(p, o, u);
          if (void 0 !== n.sparse) {
            const e = hd.SCALAR
              , i = sd[n.sparse.indices.componentType]
              , a = n.sparse.indices.byteOffset || 0
              , l = n.sparse.values.byteOffset || 0
              , h = new i(t[1], a, n.sparse.count * e)
              , c = new s(t[2], l, n.sparse.count * o);
            null !== r && (d = new Pn(d.array.slice(), d.itemSize, d.normalized));
            for (let t = 0, e = h.length; t < e; t++) {
              const e = h[t];
              if (d.setX(e, c[t * o]),
                o >= 2 && d.setY(e, c[t * o + 1]),
                o >= 3 && d.setZ(e, c[t * o + 2]),
                o >= 4 && d.setW(e, c[t * o + 3]),
                o >= 5)
                throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
            }
          }
          return d
        }
        ))
    }
    loadTexture(t) {
      const e = this.json
        , i = this.options
        , n = e.textures[t].source
        , r = e.images[n];
      let o = this.textureLoader;
      if (r.uri) {
        const t = i.manager.getHandler(r.uri);
        null !== t && (o = t)
      }
      return this.loadTextureImage(t, n, o)
    }
    loadTextureImage(t, e, i) {
      const n = this
        , r = this.json
        , o = r.textures[t]
        , s = r.images[e]
        , a = (s.uri || s.bufferView) + ":" + o.sampler;
      if (this.textureCache[a])
        return this.textureCache[a];
      const l = this.loadImageSource(e, i).then((function (e) {
        e.flipY = !1,
          o.name && (e.name = o.name);
        const i = (r.samplers || {})[o.sampler] || {};
        return e.magFilter = ad[i.magFilter] || lt,
          e.minFilter = ad[i.minFilter] || ct,
          e.wrapS = ld[i.wrapS] || it,
          e.wrapT = ld[i.wrapT] || it,
          n.associations.set(e, {
            textures: t
          }),
          e
      }
      )).catch((function () {
        return null
      }
      ));
      return this.textureCache[a] = l,
        l
    }
    loadImageSource(t, e) {
      const i = this
        , n = this.json
        , r = this.options;
      if (void 0 !== this.sourceCache[t])
        return this.sourceCache[t].then((t => t.clone()));
      const o = n.images[t]
        , s = self.URL || self.webkitURL;
      let a = o.uri || ""
        , l = !1;
      if (void 0 !== o.bufferView)
        a = i.getDependency("bufferView", o.bufferView).then((function (t) {
          l = !0;
          const e = new Blob([t], {
            type: o.mimeType
          });
          return a = s.createObjectURL(e),
            a
        }
        ));
      else if (void 0 === o.uri)
        throw new Error("THREE.GLTFLoader: Image " + t + " is missing URI and bufferView");
      const h = Promise.resolve(a).then((function (t) {
        return new Promise((function (i, n) {
          let o = i;
          !0 === e.isImageBitmapLoader && (o = function (t) {
            const e = new ai(t);
            e.needsUpdate = !0,
              i(e)
          }
          ),
            e.load(jc.resolveURL(t, r.path), o, void 0, n)
        }
        ))
      }
      )).then((function (t) {
        var e;
        return !0 === l && s.revokeObjectURL(a),
          t.userData.mimeType = o.mimeType || ((e = o.uri).search(/\.jpe?g($|\?)/i) > 0 || 0 === e.search(/^data\:image\/jpeg/) ? "image/jpeg" : e.search(/\.webp($|\?)/i) > 0 || 0 === e.search(/^data\:image\/webp/) ? "image/webp" : "image/png"),
          t
      }
      )).catch((function (t) {
        throw console.error("THREE.GLTFLoader: Couldn't load texture", a),
        t
      }
      ));
      return this.sourceCache[t] = h,
        h
    }
    assignTexture(t, e, i, n) {
      const r = this;
      return this.getDependency("texture", i.index).then((function (o) {
        if (void 0 === i.texCoord || 0 == i.texCoord || "aoMap" === e && 1 == i.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + i.texCoord + " for texture " + e + " not yet supported."),
          r.extensions[Mp.KHR_TEXTURE_TRANSFORM]) {
          const t = void 0 !== i.extensions ? i.extensions[Mp.KHR_TEXTURE_TRANSFORM] : void 0;
          if (t) {
            const e = r.associations.get(o);
            o = r.extensions[Mp.KHR_TEXTURE_TRANSFORM].extendTexture(o, t),
              r.associations.set(o, e)
          }
        }
        return void 0 !== n && (o.encoding = n),
          t[e] = o,
          o
      }
      ))
    }
    assignFinalMaterial(t) {
      const e = t.geometry;
      let i = t.material;
      const n = void 0 === e.attributes.tangent
        , r = void 0 !== e.attributes.color
        , o = void 0 === e.attributes.normal;
      if (t.isPoints) {
        const t = "PointsMaterial:" + i.uuid;
        let e = this.cache.get(t);
        e || (e = new ul,
          En.prototype.copy.call(e, i),
          e.color.copy(i.color),
          e.map = i.map,
          e.sizeAttenuation = !1,
          this.cache.add(t, e)),
          i = e
      } else if (t.isLine) {
        const t = "LineBasicMaterial:" + i.uuid;
        let e = this.cache.get(t);
        e || (e = new tl,
          En.prototype.copy.call(e, i),
          e.color.copy(i.color),
          this.cache.add(t, e)),
          i = e
      }
      if (n || r || o) {
        let t = "ClonedMaterial:" + i.uuid + ":";
        i.isGLTFSpecularGlossinessMaterial && (t += "specular-glossiness:"),
          n && (t += "derivative-tangents:"),
          r && (t += "vertex-colors:"),
          o && (t += "flat-shading:");
        let e = this.cache.get(t);
        e || (e = i.clone(),
          r && (e.vertexColors = !0),
          o && (e.flatShading = !0),
          n && (e.normalScale && (e.normalScale.y *= -1),
            e.clearcoatNormalScale && (e.clearcoatNormalScale.y *= -1)),
          this.cache.add(t, e),
          this.associations.set(e, this.associations.get(i))),
          i = e
      }
      i.aoMap && void 0 === e.attributes.uv2 && void 0 !== e.attributes.uv && e.setAttribute("uv2", e.attributes.uv),
        t.material = i
    }
    getMaterialType() {
      return Wh
    }
    loadMaterial(t) {
      const e = this
        , i = this.json
        , n = this.extensions
        , r = i.materials[t];
      let o;
      const s = {}
        , a = r.extensions || {}
        , l = [];
      if (a[Mp.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
        const t = n[Mp.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
        o = t.getMaterialType(),
          l.push(t.extendParams(s, r, e))
      } else if (a[Mp.KHR_MATERIALS_UNLIT]) {
        const t = n[Mp.KHR_MATERIALS_UNLIT];
        o = t.getMaterialType(),
          l.push(t.extendParams(s, r, e))
      } else {
        const i = r.pbrMetallicRoughness || {};
        if (s.color = new ei(1, 1, 1),
          s.opacity = 1,
          Array.isArray(i.baseColorFactor)) {
          const t = i.baseColorFactor;
          s.color.fromArray(t),
            s.opacity = t[3]
        }
        void 0 !== i.baseColorTexture && l.push(e.assignTexture(s, "map", i.baseColorTexture, ge)),
          s.metalness = void 0 !== i.metallicFactor ? i.metallicFactor : 1,
          s.roughness = void 0 !== i.roughnessFactor ? i.roughnessFactor : 1,
          void 0 !== i.metallicRoughnessTexture && (l.push(e.assignTexture(s, "metalnessMap", i.metallicRoughnessTexture)),
            l.push(e.assignTexture(s, "roughnessMap", i.metallicRoughnessTexture))),
          o = this._invokeOne((function (e) {
            return e.getMaterialType && e.getMaterialType(t)
          }
          )),
          l.push(Promise.all(this._invokeAll((function (e) {
            return e.extendMaterialParams && e.extendMaterialParams(t, s)
          }
          ))))
      }
      !0 === r.doubleSided && (s.side = c);
      const h = r.alphaMode || dd;
      if (h === gd ? (s.transparent = !0,
        s.depthWrite = !1) : (s.transparent = !1,
          h === fd && (s.alphaTest = void 0 !== r.alphaCutoff ? r.alphaCutoff : .5)),
        void 0 !== r.normalTexture && o !== kn && (l.push(e.assignTexture(s, "normalMap", r.normalTexture)),
          s.normalScale = new Fe(1, 1),
          void 0 !== r.normalTexture.scale)) {
        const t = r.normalTexture.scale;
        s.normalScale.set(t, t)
      }
      return void 0 !== r.occlusionTexture && o !== kn && (l.push(e.assignTexture(s, "aoMap", r.occlusionTexture)),
        void 0 !== r.occlusionTexture.strength && (s.aoMapIntensity = r.occlusionTexture.strength)),
        void 0 !== r.emissiveFactor && o !== kn && (s.emissive = (new ei).fromArray(r.emissiveFactor)),
        void 0 !== r.emissiveTexture && o !== kn && l.push(e.assignTexture(s, "emissiveMap", r.emissiveTexture, ge)),
        Promise.all(l).then((function () {
          let i;
          return i = o === Zp ? n[Mp.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(s) : new o(s),
            r.name && (i.name = r.name),
            yd(i, r),
            e.associations.set(i, {
              materials: t
            }),
            r.extensions && md(n, i, r),
            i
        }
        ))
    }
    createUniqueName(t) {
      const e = yu.sanitizeNodeName(t || "");
      let i = e;
      for (let t = 1; this.nodeNamesUsed[i]; ++t)
        i = e + "_" + t;
      return this.nodeNamesUsed[i] = !0,
        i
    }
    loadGeometries(t) {
      const e = this
        , i = this.extensions
        , n = this.primitiveCache;
      function r(t) {
        return i[Mp.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(t, e).then((function (i) {
          return wd(i, t, e)
        }
        ))
      }
      const o = [];
      for (let i = 0, s = t.length; i < s; i++) {
        const s = t[i]
          , a = Ad(s)
          , l = n[a];
        if (l)
          o.push(l.promise);
        else {
          let t;
          t = s.extensions && s.extensions[Mp.KHR_DRACO_MESH_COMPRESSION] ? r(s) : wd(new Wn, s, e),
            n[a] = {
              primitive: s,
              promise: t
            },
            o.push(t)
        }
      }
      return Promise.all(o)
    }
    loadMesh(t) {
      const e = this
        , i = this.json
        , n = this.extensions
        , r = i.meshes[t]
        , o = r.primitives
        , s = [];
      for (let t = 0, e = o.length; t < e; t++) {
        const e = void 0 === o[t].material ? (void 0 === (a = this.cache).DefaultMaterial && (a.DefaultMaterial = new Wh({
          color: 16777215,
          emissive: 0,
          metalness: 1,
          roughness: 1,
          transparent: !1,
          depthTest: !0,
          side: l
        })),
          a.DefaultMaterial) : this.getDependency("material", o[t].material);
        s.push(e)
      }
      var a;
      return s.push(e.loadGeometries(o)),
        Promise.all(s).then((function (i) {
          const s = i.slice(0, i.length - 1)
            , a = i[i.length - 1]
            , l = [];
          for (let i = 0, h = a.length; i < h; i++) {
            const h = a[i]
              , c = o[i];
            let u;
            const p = s[i];
            if (c.mode === nd || c.mode === rd || c.mode === od || void 0 === c.mode)
              u = !0 === r.isSkinnedMesh ? new Va(h, p) : new lr(h, p),
                !0 !== u.isSkinnedMesh || u.geometry.attributes.skinWeight.normalized || u.normalizeSkinWeights(),
                c.mode === rd ? u.geometry = _d(u.geometry, 1) : c.mode === od && (u.geometry = _d(u.geometry, 2));
            else if (c.mode === td)
              u = new hl(h, p);
            else if (c.mode === id)
              u = new sl(h, p);
            else if (c.mode === ed)
              u = new cl(h, p);
            else {
              if (c.mode !== $p)
                throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + c.mode);
              u = new ml(h, p)
            }
            Object.keys(u.geometry.morphAttributes).length > 0 && vd(u, r),
              u.name = e.createUniqueName(r.name || "mesh_" + t),
              yd(u, r),
              c.extensions && md(n, u, c),
              e.assignFinalMaterial(u),
              l.push(u)
          }
          for (let i = 0, n = l.length; i < n; i++)
            e.associations.set(l[i], {
              meshes: t,
              primitives: i
            });
          if (1 === l.length)
            return l[0];
          const h = new ra;
          e.associations.set(h, {
            meshes: t
          });
          for (let t = 0, e = l.length; t < e; t++)
            h.add(l[t]);
          return h
        }
        ))
    }
    loadCamera(t) {
      let e;
      const i = this.json.cameras[t]
        , n = i[i.type];
      if (n)
        return "perspective" === i.type ? e = new mr(Ne.radToDeg(n.yfov), n.aspectRatio || 1, n.znear || 1, n.zfar || 2e6) : "orthographic" === i.type && (e = new Br(-n.xmag, n.xmag, n.ymag, -n.ymag, n.znear, n.zfar)),
          i.name && (e.name = this.createUniqueName(i.name)),
          yd(e, i),
          Promise.resolve(e);
      console.warn("THREE.GLTFLoader: Missing camera parameters.")
    }
    loadSkin(t) {
      const e = this.json.skins[t]
        , i = {
          joints: e.joints
        };
      return void 0 === e.inverseBindMatrices ? Promise.resolve(i) : this.getDependency("accessor", e.inverseBindMatrices).then((function (t) {
        return i.inverseBindMatrices = t,
          i
      }
      ))
    }
    loadAnimation(t) {
      const e = this.json.animations[t]
        , i = []
        , n = []
        , r = []
        , o = []
        , s = [];
      for (let t = 0, a = e.channels.length; t < a; t++) {
        const a = e.channels[t]
          , l = e.samplers[a.sampler]
          , h = a.target
          , c = void 0 !== h.node ? h.node : h.id
          , u = void 0 !== e.parameters ? e.parameters[l.input] : l.input
          , p = void 0 !== e.parameters ? e.parameters[l.output] : l.output;
        i.push(this.getDependency("node", c)),
          n.push(this.getDependency("accessor", u)),
          r.push(this.getDependency("accessor", p)),
          o.push(l),
          s.push(h)
      }
      return Promise.all([Promise.all(i), Promise.all(n), Promise.all(r), Promise.all(o), Promise.all(s)]).then((function (i) {
        const n = i[0]
          , r = i[1]
          , o = i[2]
          , s = i[3]
          , a = i[4]
          , l = [];
        for (let t = 0, e = n.length; t < e; t++) {
          const e = n[t]
            , i = r[t]
            , h = o[t]
            , c = s[t]
            , u = a[t];
          if (void 0 === e)
            continue;
          let p;
          switch (e.updateMatrix(),
          e.matrixAutoUpdate = !0,
          ud[u.path]) {
            case ud.weights:
              p = sc;
              break;
            case ud.rotation:
              p = lc;
              break;
            default:
              p = cc
          }
          const d = e.name ? e.name : e.uuid
            , f = void 0 !== c.interpolation ? pd[c.interpolation] : ae
            , g = [];
          ud[u.path] === ud.weights ? e.traverse((function (t) {
            t.morphTargetInfluences && g.push(t.name ? t.name : t.uuid)
          }
          )) : g.push(d);
          let m = h.array;
          if (h.normalized) {
            const t = xd(m.constructor)
              , e = new Float32Array(m.length);
            for (let i = 0, n = m.length; i < n; i++)
              e[i] = m[i] * t;
            m = e
          }
          for (let t = 0, e = g.length; t < e; t++) {
            const e = new p(g[t] + "." + ud[u.path], i.array, m, f);
            "CUBICSPLINE" === c.interpolation && (e.createInterpolant = function (t) {
              return new (this instanceof lc ? Xp : Yp)(this.times, this.values, this.getValueSize() / 3, t)
            }
              ,
              e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0),
              l.push(e)
          }
        }
        const h = e.name ? e.name : "animation_" + t;
        return new uc(h, void 0, l)
      }
      ))
    }
    createNodeMesh(t) {
      const e = this.json
        , i = this
        , n = e.nodes[t];
      return void 0 === n.mesh ? null : i.getDependency("mesh", n.mesh).then((function (t) {
        const e = i._getNodeRef(i.meshCache, n.mesh, t);
        return void 0 !== n.weights && e.traverse((function (t) {
          if (t.isMesh)
            for (let e = 0, i = n.weights.length; e < i; e++)
              t.morphTargetInfluences[e] = n.weights[e]
        }
        )),
          e
      }
      ))
    }
    loadNode(t) {
      const e = this.json
        , i = this.extensions
        , n = this
        , r = e.nodes[t]
        , o = r.name ? n.createUniqueName(r.name) : "";
      return function () {
        const e = []
          , i = n._invokeOne((function (e) {
            return e.createNodeMesh && e.createNodeMesh(t)
          }
          ));
        return i && e.push(i),
          void 0 !== r.camera && e.push(n.getDependency("camera", r.camera).then((function (t) {
            return n._getNodeRef(n.cameraCache, r.camera, t)
          }
          ))),
          n._invokeAll((function (e) {
            return e.createNodeAttachment && e.createNodeAttachment(t)
          }
          )).forEach((function (t) {
            e.push(t)
          }
          )),
          Promise.all(e)
      }().then((function (e) {
        let s;
        if (s = !0 === r.isBone ? new Ga : e.length > 1 ? new ra : 1 === e.length ? e[0] : new mn,
          s !== e[0])
          for (let t = 0, i = e.length; t < i; t++)
            s.add(e[t]);
        if (r.name && (s.userData.name = r.name,
          s.name = o),
          yd(s, r),
          r.extensions && md(i, s, r),
          void 0 !== r.matrix) {
          const t = new Wi;
          t.fromArray(r.matrix),
            s.applyMatrix4(t)
        } else
          void 0 !== r.translation && s.position.fromArray(r.translation),
            void 0 !== r.rotation && s.quaternion.fromArray(r.rotation),
            void 0 !== r.scale && s.scale.fromArray(r.scale);
        return n.associations.has(s) || n.associations.set(s, {}),
          n.associations.get(s).nodes = t,
          s
      }
      ))
    }
    loadScene(t) {
      const e = this.json
        , i = this.extensions
        , n = this.json.scenes[t]
        , r = this
        , o = new ra;
      n.name && (o.name = r.createUniqueName(n.name)),
        yd(o, n),
        n.extensions && md(i, o, n);
      const s = n.nodes || []
        , a = [];
      for (let t = 0, i = s.length; t < i; t++)
        a.push(Cd(s[t], o, e, r));
      return Promise.all(a).then((function () {
        return r.associations = (t => {
          const e = new Map;
          for (const [t, i] of r.associations)
            (t instanceof En || t instanceof ai) && e.set(t, i);
          return t.traverse((t => {
            const i = r.associations.get(t);
            null != i && e.set(t, i)
          }
          )),
            e
        }
        )(o),
          o
      }
      ))
    }
  }
  function Cd(t, e, i, n) {
    const r = i.nodes[t];
    return n.getDependency("node", t).then((function (t) {
      if (void 0 === r.skin)
        return t;
      let e;
      return n.getDependency("skin", r.skin).then((function (t) {
        e = t;
        const i = [];
        for (let t = 0, r = e.joints.length; t < r; t++)
          i.push(n.getDependency("node", e.joints[t]));
        return Promise.all(i)
      }
      )).then((function (i) {
        return t.traverse((function (t) {
          if (!t.isMesh)
            return;
          const n = []
            , r = [];
          for (let t = 0, o = i.length; t < o; t++) {
            const o = i[t];
            if (o) {
              n.push(o);
              const i = new Wi;
              void 0 !== e.inverseBindMatrices && i.fromArray(e.inverseBindMatrices.array, 16 * t),
                r.push(i)
            } else
              console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', e.joints[t])
          }
          t.bind(new Za(n, r), t.matrixWorld)
        }
        )),
          t
      }
      ))
    }
    )).then((function (t) {
      e.add(t);
      const o = [];
      if (r.children) {
        const e = r.children;
        for (let r = 0, s = e.length; r < s; r++) {
          const s = e[r];
          o.push(Cd(s, t, i, n))
        }
      }
      return Promise.all(o)
    }
    ))
  }
  function wd(t, e, i) {
    const n = e.attributes
      , r = [];
    function o(e, n) {
      return i.getDependency("accessor", e).then((function (e) {
        t.setAttribute(n, e)
      }
      ))
    }
    for (const e in n) {
      const i = cd[e] || e.toLowerCase();
      i in t.attributes || r.push(o(n[e], i))
    }
    if (void 0 !== e.indices && !t.index) {
      const n = i.getDependency("accessor", e.indices).then((function (e) {
        t.setIndex(e)
      }
      ));
      r.push(n)
    }
    return yd(t, e),
      function (t, e, i) {
        const n = e.attributes
          , r = new mi;
        if (void 0 === n.POSITION)
          return;
        {
          const t = i.json.accessors[n.POSITION]
            , e = t.min
            , o = t.max;
          if (void 0 === e || void 0 === o)
            return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
          if (r.set(new di(e[0], e[1], e[2]), new di(o[0], o[1], o[2])),
            t.normalized) {
            const e = xd(sd[t.componentType]);
            r.min.multiplyScalar(e),
              r.max.multiplyScalar(e)
          }
        }
        const o = e.targets;
        if (void 0 !== o) {
          const t = new di
            , e = new di;
          for (let n = 0, r = o.length; n < r; n++) {
            const r = o[n];
            if (void 0 !== r.POSITION) {
              const n = i.json.accessors[r.POSITION]
                , o = n.min
                , s = n.max;
              if (void 0 !== o && void 0 !== s) {
                if (e.setX(Math.max(Math.abs(o[0]), Math.abs(s[0]))),
                  e.setY(Math.max(Math.abs(o[1]), Math.abs(s[1]))),
                  e.setZ(Math.max(Math.abs(o[2]), Math.abs(s[2]))),
                  n.normalized) {
                  const t = xd(sd[n.componentType]);
                  e.multiplyScalar(t)
                }
                t.max(e)
              } else
                console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
            }
          }
          r.expandByVector(t)
        }
        t.boundingBox = r;
        const s = new Oi;
        r.getCenter(s.center),
          s.radius = r.min.distanceTo(r.max) / 2,
          t.boundingSphere = s
      }(t, e, i),
      Promise.all(r).then((function () {
        return void 0 !== e.targets ? function (t, e, i) {
          let n = !1
            , r = !1
            , o = !1;
          for (let t = 0, i = e.length; t < i; t++) {
            const i = e[t];
            if (void 0 !== i.POSITION && (n = !0),
              void 0 !== i.NORMAL && (r = !0),
              void 0 !== i.COLOR_0 && (o = !0),
              n && r && o)
              break
          }
          if (!n && !r && !o)
            return Promise.resolve(t);
          const s = []
            , a = []
            , l = [];
          for (let h = 0, c = e.length; h < c; h++) {
            const c = e[h];
            if (n) {
              const e = void 0 !== c.POSITION ? i.getDependency("accessor", c.POSITION) : t.attributes.position;
              s.push(e)
            }
            if (r) {
              const e = void 0 !== c.NORMAL ? i.getDependency("accessor", c.NORMAL) : t.attributes.normal;
              a.push(e)
            }
            if (o) {
              const e = void 0 !== c.COLOR_0 ? i.getDependency("accessor", c.COLOR_0) : t.attributes.color;
              l.push(e)
            }
          }
          return Promise.all([Promise.all(s), Promise.all(a), Promise.all(l)]).then((function (e) {
            const i = e[0]
              , s = e[1]
              , a = e[2];
            return n && (t.morphAttributes.position = i),
              r && (t.morphAttributes.normal = s),
              o && (t.morphAttributes.color = a),
              t.morphTargetsRelative = !0,
              t
          }
          ))
        }(t, e.targets, i) : t
      }
      ))
  }
  function _d(t, e) {
    let i = t.getIndex();
    if (null === i) {
      const e = []
        , n = t.getAttribute("position");
      if (void 0 === n)
        return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),
          t;
      for (let t = 0; t < n.count; t++)
        e.push(t);
      t.setIndex(e),
        i = t.getIndex()
    }
    const n = i.count - 2
      , r = [];
    if (2 === e)
      for (let t = 1; t <= n; t++)
        r.push(i.getX(0)),
          r.push(i.getX(t)),
          r.push(i.getX(t + 1));
    else
      for (let t = 0; t < n; t++)
        t % 2 == 0 ? (r.push(i.getX(t)),
          r.push(i.getX(t + 1)),
          r.push(i.getX(t + 2))) : (r.push(i.getX(t + 2)),
            r.push(i.getX(t + 1)),
            r.push(i.getX(t)));
    r.length / 3 !== n && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    const o = t.clone();
    return o.setIndex(r),
      o
  }
  const Sd = AMap.Browser.windows || AMap.Browser.mac
    , Md = location.href.includes("log=")
    , Td = new bc
    , Ed = new class extends mc {
      constructor(t) {
        super(t),
          this.dracoLoader = null,
          this.ktx2Loader = null,
          this.meshoptDecoder = null,
          this.pluginCallbacks = [],
          this.register((function (t) {
            return new Rp(t)
          }
          )),
          this.register((function (t) {
            return new Np(t)
          }
          )),
          this.register((function (t) {
            return new Fp(t)
          }
          )),
          this.register((function (t) {
            return new Pp(t)
          }
          )),
          this.register((function (t) {
            return new zp(t)
          }
          )),
          this.register((function (t) {
            return new Op(t)
          }
          )),
          this.register((function (t) {
            return new Dp(t)
          }
          )),
          this.register((function (t) {
            return new kp(t)
          }
          )),
          this.register((function (t) {
            return new Up(t)
          }
          )),
          this.register((function (t) {
            return new Lp(t)
          }
          )),
          this.register((function (t) {
            return new Tp(t)
          }
          )),
          this.register((function (t) {
            return new Bp(t)
          }
          ))
      }
      load(t, e, i, n) {
        const r = this;
        let o;
        o = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : jc.extractUrlBase(t),
          this.manager.itemStart(t);
        const s = function (e) {
          n ? n(e) : console.error(e),
            r.manager.itemError(t),
            r.manager.itemEnd(t)
        }
          , a = new vc(this.manager);
        a.setPath(this.path),
          a.setResponseType("arraybuffer"),
          a.setRequestHeader(this.requestHeader),
          a.setWithCredentials(this.withCredentials),
          a.load(t, (function (i) {
            try {
              r.parse(i, o, (function (i) {
                e(i),
                  r.manager.itemEnd(t)
              }
              ), s)
            } catch (t) {
              s(t)
            }
          }
          ), i, s)
      }
      setDRACOLoader(t) {
        return this.dracoLoader = t,
          this
      }
      setDDSLoader() {
        throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
      }
      setKTX2Loader(t) {
        return this.ktx2Loader = t,
          this
      }
      setMeshoptDecoder(t) {
        return this.meshoptDecoder = t,
          this
      }
      register(t) {
        return -1 === this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.push(t),
          this
      }
      unregister(t) {
        return -1 !== this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1),
          this
      }
      parse(t, e, i, n) {
        let r;
        const o = {}
          , s = {};
        if ("string" == typeof t)
          r = t;
        else {
          if (jc.decodeText(new Uint8Array(t, 0, 4)) === jp) {
            try {
              o[Mp.KHR_BINARY_GLTF] = new Wp(t)
            } catch (t) {
              return void (n && n(t))
            }
            r = o[Mp.KHR_BINARY_GLTF].content
          } else
            r = jc.decodeText(new Uint8Array(t))
        }
        const a = JSON.parse(r);
        if (void 0 === a.asset || a.asset.version[0] < 2)
          return void (n && n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
        const l = new Id(a, {
          path: e || this.resourcePath || "",
          crossOrigin: this.crossOrigin,
          requestHeader: this.requestHeader,
          manager: this.manager,
          ktx2Loader: this.ktx2Loader,
          meshoptDecoder: this.meshoptDecoder
        });
        l.fileLoader.setRequestHeader(this.requestHeader);
        for (let t = 0; t < this.pluginCallbacks.length; t++) {
          const e = this.pluginCallbacks[t](l);
          s[e.name] = e,
            o[e.name] = !0
        }
        if (a.extensionsUsed)
          for (let t = 0; t < a.extensionsUsed.length; ++t) {
            const e = a.extensionsUsed[t]
              , i = a.extensionsRequired || [];
            switch (e) {
              case Mp.KHR_MATERIALS_UNLIT:
                o[e] = new Ep;
                break;
              case Mp.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                o[e] = new Qp;
                break;
              case Mp.KHR_DRACO_MESH_COMPRESSION:
                o[e] = new Jp(a, this.dracoLoader);
                break;
              case Mp.KHR_TEXTURE_TRANSFORM:
                o[e] = new Hp;
                break;
              case Mp.KHR_MESH_QUANTIZATION:
                o[e] = new Kp;
                break;
              default:
                i.indexOf(e) >= 0 && void 0 === s[e] && console.warn('THREE.GLTFLoader: Unknown extension "' + e + '".')
            }
          }
        l.setExtensions(o),
          l.setPlugins(s),
          l.parse(i, n)
      }
      parseAsync(t, e) {
        const i = this;
        return new Promise((function (n, r) {
          i.parse(t, e, n, r)
        }
        ))
      }
    }
    , kd = document.createElement("div");
  let Rd;
  function Ld(t) {
    Md && (clearTimeout(Rd),
      kd.style.position = "fixed",
      kd.style.top = "0",
      kd.style.right = "0",
      kd.style.maxWidth = "100vw",
      kd.style.whiteSpace = "pre-wrap",
      kd.style.color = "#ffffff",
      kd.style.opacity = "0.5",
      kd.style.pointerEvents = "none",
      kd.style.backgroundColor = "red",
      kd.style.borderRadius = "3px",
      kd.style.padding = "5px",
      kd.style.zIndex = "99999",
      kd.innerHTML = `${t}`,
      document.body.appendChild(kd),
      Rd = setTimeout((() => {
        document.body.removeChild(kd)
      }
      ), 1500))
  }
  function Pd(t, e, i) {
    if (e && (t._scale = e * ("_text" in t.material.map || Sd ? 1 : devicePixelRatio)),
      !t.material || !t.material.map.image)
      return;
    const { height: n, width: r } = t.material.map.image;
    let o = n / i;
    isNaN(o) && (o = 1),
      t.scale.set(o, o, 1).setX(t.scale.x * r / n).multiplyScalar(t._scale || 1)
  }
  class zd {
    constructor() {
      this.rects = []
    }
    clear() {
      this.rects.length = 0
    }
    push(t) {
      if (0 === this.rects.length)
        return this.rects.push(t),
          !1;
      for (var e in this.rects) {
        var i = this.rects[e];
        if (this.collision(i, t))
          return !0
      }
      return this.rects.push(t),
        !1
    }
    collision(t, e) {
      return t.x < e.x + e.w && t.x + t.w > e.x && t.y < e.y + e.h && t.h + t.y > e.y
    }
  }
  function Od(t, e, i) {
    let n = (new di).copy(t).project(e);
    const { clientWidth: r, clientHeight: o } = i;
    let s = (n.x + 1) / 2 * r
      , a = (1 - (n.y + 1) / 2) * o
      , l = s <= i.clientWidth && s >= 0 && a <= i.clientHeight && a >= 0;
    return {
      pos: new Fe(s, a),
      vector: n,
      trueSide: n.z < 1,
      inSight: l
    }
  }
  function Dd() {
    return (Math.random() + (new Date).getTime()).toString(36).replace(".", "")
  }
  function Ud(t, e) {
    let i = {};
    for (const n in t)
      Object.defineProperty(i, n, {
        get: () => t[n],
        set(i) {
          i !== t[n] && (t[n] = i,
            e(n, i))
        }
      });
    return i
  }
  const Nd = t => {
    let e = {};
    const i = new Worker(URL.createObjectURL(new Blob([`(${t.toString()})()`])));
    return i.onmessage = ({ data: t }) => {
      let { _id: i } = t
        , n = function (t, e) {
          var i = {};
          for (var n in t)
            Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (i[n] = t[n]);
          if (null != t && "function" == typeof Object.getOwnPropertySymbols) {
            var r = 0;
            for (n = Object.getOwnPropertySymbols(t); r < n.length; r++)
              e.indexOf(n[r]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[r]) && (i[n[r]] = t[n[r]])
          }
          return i
        }(t, ["_id"]);
      e[i](n),
        delete e[i]
    }
      ,
      t => new Promise((n => {
        let r = Math.random().toString();
        e[r] = n,
          i.postMessage(Object.assign({
            _id: r
          }, t))
      }
      ))
  }
    ;
  function Fd(t = location.href) {
    const e = {}
      , i = /([^?&=]+)=([^?&=]+)/g;
    let n = i.exec(t);
    for (; n;)
      e[n[1]] = n[2],
        n = i.exec(t);
    return e
  }
  const Bd = new mi
    , jd = new di;
  class Vd extends Vc {
    constructor() {
      super(),
        this.isLineSegmentsGeometry = !0,
        this.type = "LineSegmentsGeometry";
      this.setIndex([0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5]),
        this.setAttribute("position", new Dn([-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], 3)),
        this.setAttribute("uv", new Dn([-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], 2))
    }
    applyMatrix4(t) {
      const e = this.attributes.instanceStart
        , i = this.attributes.instanceEnd;
      return void 0 !== e && (e.applyMatrix4(t),
        i.applyMatrix4(t),
        e.needsUpdate = !0),
        null !== this.boundingBox && this.computeBoundingBox(),
        null !== this.boundingSphere && this.computeBoundingSphere(),
        this
    }
    setPositions(t) {
      let e;
      t instanceof Float32Array ? e = t : Array.isArray(t) && (e = new Float32Array(t));
      const i = new Iu(e, 6, 1);
      return this.setAttribute("instanceStart", new ya(i, 3, 0)),
        this.setAttribute("instanceEnd", new ya(i, 3, 3)),
        this.computeBoundingBox(),
        this.computeBoundingSphere(),
        this
    }
    setColors(t) {
      let e;
      t instanceof Float32Array ? e = t : Array.isArray(t) && (e = new Float32Array(t));
      const i = new Iu(e, 6, 1);
      return this.setAttribute("instanceColorStart", new ya(i, 3, 0)),
        this.setAttribute("instanceColorEnd", new ya(i, 3, 3)),
        this
    }
    fromWireframeGeometry(t) {
      return this.setPositions(t.attributes.position.array),
        this
    }
    fromEdgesGeometry(t) {
      return this.setPositions(t.attributes.position.array),
        this
    }
    fromMesh(t) {
      return this.fromWireframeGeometry(new Fh(t.geometry)),
        this
    }
    fromLineSegments(t) {
      const e = t.geometry;
      return this.setPositions(e.attributes.position.array),
        this
    }
    computeBoundingBox() {
      null === this.boundingBox && (this.boundingBox = new mi);
      const t = this.attributes.instanceStart
        , e = this.attributes.instanceEnd;
      void 0 !== t && void 0 !== e && (this.boundingBox.setFromBufferAttribute(t),
        Bd.setFromBufferAttribute(e),
        this.boundingBox.union(Bd))
    }
    computeBoundingSphere() {
      null === this.boundingSphere && (this.boundingSphere = new Oi),
        null === this.boundingBox && this.computeBoundingBox();
      const t = this.attributes.instanceStart
        , e = this.attributes.instanceEnd;
      if (void 0 !== t && void 0 !== e) {
        const i = this.boundingSphere.center;
        this.boundingBox.getCenter(i);
        let n = 0;
        for (let r = 0, o = t.count; r < o; r++)
          jd.fromBufferAttribute(t, r),
            n = Math.max(n, i.distanceToSquared(jd)),
            jd.fromBufferAttribute(e, r),
            n = Math.max(n, i.distanceToSquared(jd));
        this.boundingSphere.radius = Math.sqrt(n),
          isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this)
      }
    }
    toJSON() { }
    applyMatrix(t) {
      return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."),
        this.applyMatrix4(t)
    }
  }
  Lr.line = {
    worldUnits: {
      value: 1
    },
    linewidth: {
      value: 1
    },
    resolution: {
      value: new Fe(1, 1)
    },
    dashOffset: {
      value: 0
    },
    dashScale: {
      value: 1
    },
    dashSize: {
      value: 1
    },
    gapSize: {
      value: 1
    }
  },
    Pr.line = {
      uniforms: dr.merge([Lr.common, Lr.fog, Lr.line]),
      vertexShader: "\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\tworldStart = start.xyz;\n\t\t\t\tworldEnd = end.xyz;\n\n\t\t\t#else\n\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\n\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// get the offset direction as perpendicular to the view vector\n\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\n\t\t\t\tvec3 offset;\n\t\t\t\tif ( position.y < 0.5 ) {\n\n\t\t\t\t\toffset = normalize( cross( start.xyz, worldDir ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\toffset = normalize( cross( end.xyz, worldDir ) );\n\n\t\t\t\t}\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\tfloat forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );\n\n\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t// won't be rendering the endcaps\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t// extend the line bounds to encompass  endcaps\n\t\t\t\t\tstart.xyz += - worldDir * linewidth * 0.5;\n\t\t\t\t\tend.xyz += worldDir * linewidth * 0.5;\n\n\t\t\t\t\t// shift the position of the quad so it hugs the forward edge of the line\n\t\t\t\t\toffset.xy -= dir * forwardOffset;\n\t\t\t\t\toffset.z += 0.5;\n\n\t\t\t\t#endif\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\n\n\t\t\t\t\toffset.xy += dir * 2.0 * forwardOffset;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth * 0.5;\n\n\t\t\t\t// set the world position\n\t\t\t\tworldPos = ( position.y < 0.5 ) ? start : end;\n\t\t\t\tworldPos.xyz += offset;\n\n\t\t\t\t// project the worldpos\n\t\t\t\tvec4 clip = projectionMatrix * worldPos;\n\n\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t// segments overlap neatly\n\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n\t\t\t\tclip.z = clipPose.z * clip.w;\n\n\t\t\t#else\n\n\t\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\t\t\t\t// undo aspect ratio adjustment\n\t\t\t\tdir.x /= aspect;\n\t\t\t\toffset.x /= aspect;\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\t\toffset += - dir;\n\n\t\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\t\toffset += dir;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth;\n\n\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\t\toffset /= resolution.y;\n\n\t\t\t\t// select end\n\t\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t\t// back to clip space\n\t\t\t\toffset *= clip.w;\n\n\t\t\t\tclip.xy += offset;\n\n\t\t\t#endif\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t",
      fragmentShader: "\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\t\tuniform float linewidth;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n\t\t\tfloat mua;\n\t\t\tfloat mub;\n\n\t\t\tvec3 p13 = p1 - p3;\n\t\t\tvec3 p43 = p4 - p3;\n\n\t\t\tvec3 p21 = p2 - p1;\n\n\t\t\tfloat d1343 = dot( p13, p43 );\n\t\t\tfloat d4321 = dot( p43, p21 );\n\t\t\tfloat d1321 = dot( p13, p21 );\n\t\t\tfloat d4343 = dot( p43, p43 );\n\t\t\tfloat d2121 = dot( p21, p21 );\n\n\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\n\n\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\n\n\t\t\tmua = numer / denom;\n\t\t\tmua = clamp( mua, 0.0, 1.0 );\n\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\n\t\t\tmub = clamp( mub, 0.0, 1.0 );\n\n\t\t\treturn vec2( mua, mub );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tfloat alpha = opacity;\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n\t\t\t\tvec3 lineDir = worldEnd - worldStart;\n\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\n\t\t\t\tvec3 p2 = rayEnd * params.y;\n\t\t\t\tvec3 delta = p1 - p2;\n\t\t\t\tfloat len = length( delta );\n\t\t\t\tfloat norm = len / linewidth;\n\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\tfloat dnorm = fwidth( norm );\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tif ( norm > 0.5 ) {\n\n\t\t\t\t\t\t\tdiscard;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t#else\n\n\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\tfloat len2 = a * a + b * b;\n\t\t\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t#else\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t"
    };
  class Gd extends fr {
    constructor(t) {
      super({
        type: "LineMaterial",
        uniforms: dr.clone(Pr.line.uniforms),
        vertexShader: Pr.line.vertexShader,
        fragmentShader: Pr.line.fragmentShader,
        clipping: !0
      }),
        this.isLineMaterial = !0,
        Object.defineProperties(this, {
          color: {
            enumerable: !0,
            get: function () {
              return this.uniforms.diffuse.value
            },
            set: function (t) {
              this.uniforms.diffuse.value = t
            }
          },
          worldUnits: {
            enumerable: !0,
            get: function () {
              return "WORLD_UNITS" in this.defines
            },
            set: function (t) {
              !0 === t ? this.defines.WORLD_UNITS = "" : delete this.defines.WORLD_UNITS
            }
          },
          linewidth: {
            enumerable: !0,
            get: function () {
              return this.uniforms.linewidth.value
            },
            set: function (t) {
              this.uniforms.linewidth.value = t
            }
          },
          dashed: {
            enumerable: !0,
            get: function () {
              return Boolean("USE_DASH" in this.defines)
            },
            set(t) {
              Boolean(t) !== Boolean("USE_DASH" in this.defines) && (this.needsUpdate = !0),
                !0 === t ? this.defines.USE_DASH = "" : delete this.defines.USE_DASH
            }
          },
          dashScale: {
            enumerable: !0,
            get: function () {
              return this.uniforms.dashScale.value
            },
            set: function (t) {
              this.uniforms.dashScale.value = t
            }
          },
          dashSize: {
            enumerable: !0,
            get: function () {
              return this.uniforms.dashSize.value
            },
            set: function (t) {
              this.uniforms.dashSize.value = t
            }
          },
          dashOffset: {
            enumerable: !0,
            get: function () {
              return this.uniforms.dashOffset.value
            },
            set: function (t) {
              this.uniforms.dashOffset.value = t
            }
          },
          gapSize: {
            enumerable: !0,
            get: function () {
              return this.uniforms.gapSize.value
            },
            set: function (t) {
              this.uniforms.gapSize.value = t
            }
          },
          opacity: {
            enumerable: !0,
            get: function () {
              return this.uniforms.opacity.value
            },
            set: function (t) {
              this.uniforms.opacity.value = t
            }
          },
          resolution: {
            enumerable: !0,
            get: function () {
              return this.uniforms.resolution.value
            },
            set: function (t) {
              this.uniforms.resolution.value.copy(t)
            }
          },
          alphaToCoverage: {
            enumerable: !0,
            get: function () {
              return Boolean("USE_ALPHA_TO_COVERAGE" in this.defines)
            },
            set: function (t) {
              Boolean(t) !== Boolean("USE_ALPHA_TO_COVERAGE" in this.defines) && (this.needsUpdate = !0),
                !0 === t ? (this.defines.USE_ALPHA_TO_COVERAGE = "",
                  this.extensions.derivatives = !0) : (delete this.defines.USE_ALPHA_TO_COVERAGE,
                    this.extensions.derivatives = !1)
            }
          }
        }),
        this.setValues(t)
    }
  }
  const Wd = new di
    , Jd = new di
    , Hd = new li
    , Zd = new li
    , Qd = new li
    , Kd = new di
    , Yd = new Wi
    , qd = new ku
    , Xd = new di
    , $d = new mi
    , tf = new Oi
    , ef = new li;
  let nf, rf, of, sf;
  function af(t, e, i) {
    return ef.set(0, 0, -e, 1).applyMatrix4(t.projectionMatrix),
      ef.multiplyScalar(1 / ef.w),
      ef.x = sf / i.width,
      ef.y = sf / i.height,
      ef.applyMatrix4(t.projectionMatrixInverse),
      ef.multiplyScalar(1 / ef.w),
      Math.abs(Math.max(ef.x, ef.y))
  }
  class lf extends lr {
    constructor(t = new Vd, e = new Gd({
      color: 16777215 * Math.random()
    })) {
      super(t, e),
        this.isLineSegments2 = !0,
        this.type = "LineSegments2"
    }
    computeLineDistances() {
      const t = this.geometry
        , e = t.attributes.instanceStart
        , i = t.attributes.instanceEnd
        , n = new Float32Array(2 * e.count);
      for (let t = 0, r = 0, o = e.count; t < o; t++,
        r += 2)
        Wd.fromBufferAttribute(e, t),
          Jd.fromBufferAttribute(i, t),
          n[r] = 0 === r ? 0 : n[r - 1],
          n[r + 1] = n[r] + Wd.distanceTo(Jd);
      const r = new Iu(n, 2, 1);
      return t.setAttribute("instanceDistanceStart", new ya(r, 1, 0)),
        t.setAttribute("instanceDistanceEnd", new ya(r, 1, 1)),
        this
    }
    raycast(t, e) {
      const i = this.material.worldUnits
        , n = t.camera;
      null !== n || i || console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');
      const r = void 0 !== t.params.Line2 && t.params.Line2.threshold || 0;
      nf = t.ray;
      const o = this.matrixWorld
        , s = this.geometry
        , a = this.material;
      let l, h;
      if (sf = a.linewidth + r,
        rf = s.attributes.instanceStart,
        of = s.attributes.instanceEnd,
        null === s.boundingSphere && s.computeBoundingSphere(),
        tf.copy(s.boundingSphere).applyMatrix4(o),
        i)
        l = .5 * sf;
      else {
        l = af(n, Math.max(n.near, tf.distanceToPoint(nf.origin)), a.resolution)
      }
      if (tf.radius += l,
        !1 !== nf.intersectsSphere(tf)) {
        if (null === s.boundingBox && s.computeBoundingBox(),
          $d.copy(s.boundingBox).applyMatrix4(o),
          i)
          h = .5 * sf;
        else {
          h = af(n, Math.max(n.near, $d.distanceToPoint(nf.origin)), a.resolution)
        }
        $d.expandByScalar(h),
          !1 !== nf.intersectsBox($d) && (i ? function (t, e) {
            for (let i = 0, n = rf.count; i < n; i++) {
              qd.start.fromBufferAttribute(rf, i),
                qd.end.fromBufferAttribute(of, i);
              const n = new di
                , r = new di;
              nf.distanceSqToSegment(qd.start, qd.end, r, n),
                r.distanceTo(n) < .5 * sf && e.push({
                  point: r,
                  pointOnLine: n,
                  distance: nf.origin.distanceTo(r),
                  object: t,
                  face: null,
                  faceIndex: i,
                  uv: null,
                  uv2: null
                })
            }
          }(this, e) : function (t, e, i) {
            const n = e.projectionMatrix
              , r = t.material.resolution
              , o = t.matrixWorld
              , s = t.geometry
              , a = s.attributes.instanceStart
              , l = s.attributes.instanceEnd
              , h = -e.near;
            nf.at(1, Qd),
              Qd.w = 1,
              Qd.applyMatrix4(e.matrixWorldInverse),
              Qd.applyMatrix4(n),
              Qd.multiplyScalar(1 / Qd.w),
              Qd.x *= r.x / 2,
              Qd.y *= r.y / 2,
              Qd.z = 0,
              Kd.copy(Qd),
              Yd.multiplyMatrices(e.matrixWorldInverse, o);
            for (let e = 0, s = a.count; e < s; e++) {
              if (Hd.fromBufferAttribute(a, e),
                Zd.fromBufferAttribute(l, e),
                Hd.w = 1,
                Zd.w = 1,
                Hd.applyMatrix4(Yd),
                Zd.applyMatrix4(Yd),
                Hd.z > h && Zd.z > h)
                continue;
              if (Hd.z > h) {
                const t = Hd.z - Zd.z
                  , e = (Hd.z - h) / t;
                Hd.lerp(Zd, e)
              } else if (Zd.z > h) {
                const t = Zd.z - Hd.z
                  , e = (Zd.z - h) / t;
                Zd.lerp(Hd, e)
              }
              Hd.applyMatrix4(n),
                Zd.applyMatrix4(n),
                Hd.multiplyScalar(1 / Hd.w),
                Zd.multiplyScalar(1 / Zd.w),
                Hd.x *= r.x / 2,
                Hd.y *= r.y / 2,
                Zd.x *= r.x / 2,
                Zd.y *= r.y / 2,
                qd.start.copy(Hd),
                qd.start.z = 0,
                qd.end.copy(Zd),
                qd.end.z = 0;
              const s = qd.closestPointToPointParameter(Kd, !0);
              qd.at(s, Xd);
              const c = Ne.lerp(Hd.z, Zd.z, s)
                , u = c >= -1 && c <= 1
                , p = Kd.distanceTo(Xd) < .5 * sf;
              if (u && p) {
                qd.start.fromBufferAttribute(a, e),
                  qd.end.fromBufferAttribute(l, e),
                  qd.start.applyMatrix4(o),
                  qd.end.applyMatrix4(o);
                const n = new di
                  , r = new di;
                nf.distanceSqToSegment(qd.start, qd.end, r, n),
                  i.push({
                    point: r,
                    pointOnLine: n,
                    distance: nf.origin.distanceTo(r),
                    object: t,
                    face: null,
                    faceIndex: e,
                    uv: null,
                    uv2: null
                  })
              }
            }
          }(this, n, e))
      }
    }
  }
  class hf extends Vd {
    constructor() {
      super(),
        this.isLineGeometry = !0,
        this.type = "LineGeometry"
    }
    setPositions(t) {
      const e = t.length - 3
        , i = new Float32Array(2 * e);
      for (let n = 0; n < e; n += 3)
        i[2 * n] = t[n],
          i[2 * n + 1] = t[n + 1],
          i[2 * n + 2] = t[n + 2],
          i[2 * n + 3] = t[n + 3],
          i[2 * n + 4] = t[n + 4],
          i[2 * n + 5] = t[n + 5];
      return super.setPositions(i),
        this
    }
    setColors(t) {
      const e = t.length - 3
        , i = new Float32Array(2 * e);
      for (let n = 0; n < e; n += 3)
        i[2 * n] = t[n],
          i[2 * n + 1] = t[n + 1],
          i[2 * n + 2] = t[n + 2],
          i[2 * n + 3] = t[n + 3],
          i[2 * n + 4] = t[n + 4],
          i[2 * n + 5] = t[n + 5];
      return super.setColors(i),
        this
    }
    fromLine(t) {
      const e = t.geometry;
      return this.setPositions(e.attributes.position.array),
        this
    }
  }
  class cf extends lf {
    constructor(t = new hf, e = new Gd({
      color: 16777215 * Math.random()
    })) {
      super(t, e),
        this.isLine2 = !0,
        this.type = "Line2"
    }
  }
  class uf {
    constructor() {
      this.pos = new di,
        this.dir = new di,
        this.right = new di,
        this.up = new di,
        this.dist = 0,
        this.widthScale = 1,
        this.sharp = !1
    }
    lerpPathPoints(t, e, i) {
      this.pos.lerpVectors(t.pos, e.pos, i),
        this.dir.lerpVectors(t.dir, e.dir, i),
        this.up.lerpVectors(t.up, e.up, i),
        this.right.lerpVectors(t.right, e.right, i),
        this.dist = (e.dist - t.dist) * i + t.dist,
        this.widthScale = (e.widthScale - t.widthScale) * i + t.widthScale
    }
    copy(t) {
      this.pos.copy(t.pos),
        this.dir.copy(t.dir),
        this.up.copy(t.up),
        this.right.copy(t.right),
        this.dist = t.dist,
        this.widthScale = t.widthScale
    }
  }
  class pf extends Wn {
    constructor(t = 3e3, e = !1) {
      super(),
        isNaN(t) ? this._initByData(t.pathPointList, t.options, t.usage, e) : this._initByMaxVertex(t, e)
    }
    _initByMaxVertex(t, e) {
      this.setAttribute("position", new Pn(new Float32Array(3 * t), 3).setUsage(Ce)),
        this.setAttribute("normal", new Pn(new Float32Array(3 * t), 3).setUsage(Ce)),
        this.setAttribute("uv", new Pn(new Float32Array(2 * t), 2).setUsage(Ce)),
        e && this.setAttribute("uv2", new Pn(new Float32Array(2 * t), 2).setUsage(Ce)),
        this.drawRange.start = 0,
        this.drawRange.count = 0,
        this.setIndex(t > 65536 ? new On(3 * t, 1) : new zn(3 * t, 1))
    }
    _initByData(t, e = {}, i, n) {
      const r = df(t, e, n);
      r && 0 !== r.count ? (this.setAttribute("position", new Pn(new Float32Array(r.position), 3).setUsage(i || Ie)),
        this.setAttribute("normal", new Pn(new Float32Array(r.normal), 3).setUsage(i || Ie)),
        this.setAttribute("uv", new Pn(new Float32Array(r.uv), 2).setUsage(i || Ie)),
        n && this.setAttribute("uv2", new Pn(new Float32Array(r.uv2), 2).setUsage(i || Ie)),
        this.setIndex(r.position.length / 3 > 65536 ? new On(r.indices, 1) : new zn(r.indices, 1))) : this._initByMaxVertex(2, n)
    }
    update(t, e = {}) {
      const i = !!this.getAttribute("uv2")
        , n = df(t, e, i);
      n ? (this._updateAttributes(n.position, n.normal, n.uv, i ? n.uv2 : null, n.indices),
        this.drawRange.count = n.count) : this.drawRange.count = 0
    }
    _resizeAttribute(t, e) {
      let i = this.getAttribute(t);
      for (; i.array.length < e;) {
        const e = i.array.length
          , n = new Pn(new Float32Array(2 * e), i.itemSize, i.normalized);
        n.name = i.name,
          n.usage = i.usage,
          this.setAttribute(t, n),
          i = n
      }
    }
    _resizeIndex(t) {
      let e = this.getIndex();
      for (; e.array.length < t;) {
        const t = e.array.length
          , i = new Pn(2 * t > 65535 ? new Uint32Array(2 * t) : new Uint16Array(2 * t), 1);
        i.name = e.name,
          i.usage = e.usage,
          this.setIndex(i),
          e = i
      }
    }
    _updateAttributes(t, e, i, n, r) {
      this._resizeAttribute("position", t.length);
      const o = this.getAttribute("position");
      o.array.set(t, 0),
        o.updateRange.count = t.length,
        o.needsUpdate = !0,
        this._resizeAttribute("normal", e.length);
      const s = this.getAttribute("normal");
      s.array.set(e, 0),
        s.updateRange.count = e.length,
        s.needsUpdate = !0,
        this._resizeAttribute("uv", i.length);
      const a = this.getAttribute("uv");
      if (a.array.set(i, 0),
        a.updateRange.count = i.length,
        a.needsUpdate = !0,
        n) {
        this._resizeAttribute("uv2", n.length);
        const t = this.getAttribute("uv2");
        t.array.set(n, 0),
          t.updateRange.count = n.length,
          t.needsUpdate = !0
      }
      this._resizeIndex(r.length);
      const l = this.getIndex();
      l.set(r, 0),
        l.updateRange.count = r.length,
        l.needsUpdate = !0
    }
  }
  function df(t, e, i = !1) {
    const n = e.width || .1
      , r = void 0 !== e.progress ? e.progress : 1
      , o = void 0 === e.arrow || e.arrow
      , s = void 0 !== e.side ? e.side : "both"
      , a = n / 2
      , l = "both" !== s ? n / 2 : n
      , h = t.distance()
      , c = r * h;
    if (0 === h)
      return null;
    const u = a / l
      , p = a / h;
    let d = 0;
    const f = []
      , g = []
      , m = []
      , y = []
      , v = [];
    let A = 0;
    const b = new di
      , x = new di
      , I = new di
      , C = new di
      , w = new di
      , _ = new di;
    function S(t) {
      const e = 0 === f.length
        , n = t.sharp && !e
        , r = t.dist / l
        , o = t.dist / h
        , c = t.dir
        , S = t.up
        , M = t.right;
      if ("left" !== s ? b.copy(M).multiplyScalar(a * t.widthScale) : b.set(0, 0, 0),
        "right" !== s ? x.copy(M).multiplyScalar(-a * t.widthScale) : x.set(0, 0, 0),
        b.add(t.pos),
        x.add(t.pos),
        n) {
        I.fromArray(f, f.length - 6).sub(x),
          C.fromArray(f, f.length - 3).sub(b);
        const t = I.length() - C.length();
        let e, n;
        t > 0 ? (e = I,
          n = x) : (e = C,
            n = b),
          w.copy(e).setLength(Math.abs(t)).add(n);
        let s = _.copy(n).sub(w).normalize().dot(c) * _.copy(n).sub(w).length() * 2;
        _.copy(c).setLength(s).add(w),
          t > 0 ? (f.push(w.x, w.y, w.z, b.x, b.y, b.z, x.x, x.y, x.z, b.x, b.y, b.z, _.x, _.y, _.z, b.x, b.y, b.z),
            A += 6,
            v.push(A - 6, A - 8, A - 7, A - 6, A - 7, A - 5, A - 4, A - 6, A - 5, A - 2, A - 4, A - 1),
            d += 12) : (f.push(x.x, x.y, x.z, w.x, w.y, w.z, x.x, x.y, x.z, b.x, b.y, b.z, x.x, x.y, x.z, _.x, _.y, _.z),
              A += 6,
              v.push(A - 6, A - 8, A - 7, A - 6, A - 7, A - 5, A - 6, A - 5, A - 3, A - 2, A - 3, A - 1),
              d += 12),
          g.push(S.x, S.y, S.z, S.x, S.y, S.z, S.x, S.y, S.z, S.x, S.y, S.z, S.x, S.y, S.z, S.x, S.y, S.z),
          m.push(r - u, 0, r - u, 1, r, 0, r, 1, r + u, 0, r + u, 1),
          i && y.push(o - p, 0, o - p, 1, o, 0, o, 1, o + p, 0, o + p, 1)
      } else
        f.push(x.x, x.y, x.z, b.x, b.y, b.z),
          g.push(S.x, S.y, S.z, S.x, S.y, S.z),
          m.push(r, 0, r, 1),
          i && y.push(o, 0, o, 1),
          A += 2,
          e || (v.push(A - 2, A - 4, A - 3, A - 2, A - 3, A - 1),
            d += 6)
    }
    const M = new di;
    let T;
    if (c > 0)
      for (let e = 0; e < t.count; e++) {
        const i = t.array[e];
        if (i.dist > c) {
          const n = t.array[e - 1];
          T = new uf;
          const r = (c - n.dist) / (i.dist - n.dist);
          T.lerpPathPoints(n, i, r),
            S(T);
          break
        }
        S(i)
      }
    else
      T = t.array[0];
    return o && (T = T || t.array[t.count - 1],
      function (t) {
        const e = t.dir
          , r = t.up
          , o = t.right
          , c = t.dist / l
          , u = t.dist / h;
        "left" !== s ? b.copy(o).multiplyScalar(2 * a) : b.set(0, 0, 0),
          "right" !== s ? x.copy(o).multiplyScalar(2 * -a) : x.set(0, 0, 0),
          M.copy(e).setLength(3 * a),
          b.add(t.pos),
          x.add(t.pos),
          M.add(t.pos),
          f.push(x.x, x.y, x.z, b.x, b.y, b.z, M.x, M.y, M.z),
          g.push(r.x, r.y, r.z, r.x, r.y, r.z, r.x, r.y, r.z),
          m.push(c, "both" !== s ? "right" !== s ? -2 : 0 : -.5, c, "both" !== s ? "left" !== s ? 2 : 0 : 1.5, c + 1.5, "both" !== s ? 0 : .5),
          i && y.push(u, "both" !== s ? "right" !== s ? -2 : 0 : -.5, u, "both" !== s ? "left" !== s ? 2 : 0 : 1.5, u + 1.5 * n / h, "both" !== s ? 0 : .5),
          A += 3,
          v.push(A - 1, A - 3, A - 2),
          d += 3
      }(T)),
    {
      position: f,
      normal: g,
      uv: m,
      uv2: y,
      indices: v,
      count: d
    }
  }
  const ff = new di
    , gf = new di
    , mf = new di
    , yf = new Wi
    , vf = new Dl;
  class Af {
    constructor() {
      this.array = [],
        this.count = 0
    }
    set(t, e = .1, i = 10, n = null, r = !1) {
      if ((t = t.slice(0)).length < 2)
        return console.warn("PathPointList: points length less than 2."),
          void (this.count = 0);
      r && !t[0].equals(t[t.length - 1]) && t.push((new di).copy(t[0]));
      for (let o = 0, s = t.length; o < s; o++)
        if (0 === o)
          this._start(t[o], t[o + 1], n);
        else if (o === s - 1)
          if (r) {
            this._corner(t[o], t[1], e, i, n);
            const r = this.array[0].dist;
            this.array[0].copy(this.array[this.count - 1]),
              this.array[0].dist = r
          } else
            this._end(t[o]);
        else
          this._corner(t[o], t[o + 1], e, i, n)
    }
    distance() {
      return this.count > 0 ? this.array[this.count - 1].dist : 0
    }
    _getByIndex(t) {
      return this.array[t] || (this.array[t] = new uf),
        this.array[t]
    }
    _start(t, e, i) {
      this.count = 0;
      const n = this._getByIndex(this.count);
      if (n.pos.copy(t),
        n.dir.subVectors(e, t),
        i)
        n.up.copy(i);
      else {
        let t = Number.MAX_VALUE;
        const e = Math.abs(n.dir.x)
          , i = Math.abs(n.dir.y)
          , r = Math.abs(n.dir.z);
        e < t && (t = e,
          n.up.set(1, 0, 0)),
          i < t && (t = i,
            n.up.set(0, 1, 0)),
          r < t && n.up.set(0, 0, 1)
      }
      n.right.crossVectors(n.dir, n.up).normalize(),
        n.up.crossVectors(n.right, n.dir).normalize(),
        n.dist = 0,
        n.widthScale = 1,
        n.sharp = !1,
        n.dir.normalize(),
        this.count++
    }
    _end(t) {
      const e = this.array[this.count - 1]
        , i = this._getByIndex(this.count);
      i.pos.copy(t),
        i.dir.subVectors(t, e.pos);
      const n = i.dir.length();
      i.dir.normalize(),
        i.up.copy(e.up);
      const r = ff.crossVectors(e.dir, i.dir);
      if (r.length() > Number.EPSILON) {
        r.normalize();
        const t = Math.acos(Math.min(Math.max(e.dir.dot(i.dir), -1), 1));
        i.up.applyMatrix4(yf.makeRotationAxis(r, t))
      }
      i.right.crossVectors(i.dir, i.up).normalize(),
        i.dist = e.dist + n,
        i.widthScale = 1,
        i.sharp = !1,
        this.count++
    }
    _corner(t, e, i, n, r) {
      if (i > 0 && n > 0) {
        const o = function (t, e, i, n, r, o) {
          const s = ff.subVectors(e, t)
            , a = gf.subVectors(i, e)
            , l = s.length()
            , h = a.length();
          s.normalize(),
            a.normalize();
          const c = Math.min(.999999 * (r ? l / 2 : l), n);
          o.v0.copy(e).sub(s.multiplyScalar(c)),
            o.v1.copy(e);
          const u = Math.min(h / 2 * .999999, n);
          return o.v2.copy(e).add(a.multiplyScalar(u)),
            o
        }(this.array[this.count - 1].pos, t, e, i, this.count - 1 == 0, vf)
          , s = o.getPoints(n);
        for (let t = 0; t < n; t++)
          this._sharpCorner(s[t], s[t + 1], r, 0 === t ? 1 : 0);
        s[n].equals(e) || this._sharpCorner(s[n], e, r, 2)
      } else
        this._sharpCorner(t, e, r, 0, !0)
    }
    _sharpCorner(t, e, i, n = 0, r = !1) {
      const o = this.array[this.count - 1]
        , s = this._getByIndex(this.count)
        , a = ff.subVectors(t, o.pos)
        , l = gf.subVectors(e, t)
        , h = a.length();
      if (a.normalize(),
        l.normalize(),
        s.pos.copy(t),
        1 === n ? s.dir.copy(a) : 2 === n ? s.dir.copy(l) : (s.dir.addVectors(a, l),
          s.dir.normalize()),
        i)
        1 === s.dir.dot(i) ? s.right.crossVectors(l, i).normalize() : s.right.crossVectors(s.dir, i).normalize(),
          s.up.crossVectors(s.right, s.dir).normalize();
      else {
        s.up.copy(o.up);
        const t = mf.crossVectors(o.dir, s.dir);
        if (t.length() > Number.EPSILON) {
          t.normalize();
          const e = Math.acos(Math.min(Math.max(o.dir.dot(s.dir), -1), 1));
          s.up.applyMatrix4(yf.makeRotationAxis(t, e))
        }
        s.right.crossVectors(s.dir, s.up).normalize()
      }
      s.dist = o.dist + h;
      const c = a.dot(l);
      s.widthScale = Math.min(1 / Math.sqrt((1 + c) / 2), 1.415) || 1,
        s.sharp = Math.abs(c - 1) > .05 && r,
        this.count++
    }
  }
  class bf extends lr {
    constructor(t, e = {}, i) {
      super();
      const { bgc: n, color: r, width: o } = e;
      this.map = i,
        this.points = t,
        this.width = o || this.map.options.roadLineWidth || .6,
        this.up = new di(0, 0, 1);
      const s = new ai(document.createElement("canvas"));
      s.minFilter = lt,
        s.wrapS = s.wrapT = it,
        s.repeat.x = .3,
        this.material = new kn({
          transparent: !0,
          opacity: 1,
          depthTest: !1,
          depthWrite: !1,
          map: s
        }),
        this.renderOrder = fp,
        this.setTexture(n, r),
        this.update(),
        this.animate()
    }
    setTexture(t = "blue", e = "red") {
      let i = this.material.map.image
        , n = i.getContext("2d");
      i.width = 768,
        i.height = 256,
        n.clearRect(0, 0, i.width, i.height),
        n.fillStyle = "#999",
        n.fillRect(0, 0, i.width, i.height),
        n.fillStyle = t,
        n.fillRect(0, 30, i.width, i.height - 60),
        n.beginPath(),
        n.moveTo(0, 30),
        n.lineTo(70, 30),
        n.lineTo(170, 128),
        n.lineTo(70, 226),
        n.lineTo(0, 226),
        n.lineTo(100, 128),
        n.closePath(),
        n.fillStyle = e,
        n.fill(),
        this.material.map.needsUpdate = !0
    }
    update(t) {
      t && (this.points = t),
        this.geometry && this.geometry.dispose();
      var e = new Af;
      e.set(this.points, .5, 10, this.up, !1);
      var i = new pf;
      i.update(e, {
        width: this._width,
        arrow: !1
      }),
        this.geometry = i
    }
    animate() {
      this.RAFID = requestAnimationFrame((() => this.animate())),
        this.material.map.offset.x -= .03;
      let t = this.map.amap.getResolution() * this.width * 15;
      t = +t.toFixed(1),
        this._width !== t && (this._width = t,
          this.update())
    }
    dispose() {
      cancelAnimationFrame(this.RAFID),
        super.dispose()
    }
  }
  class xf extends cf {
    constructor(t, e = {}, i) {
      let n = new Gd(Object.assign({
        color: "blue",
        linewidth: 1,
        opacity: 1,
        transparent: !0,
        resolution: new Fe
      }, e));
      super(new hf, n),
        this.map = i,
        this.points = t,
        this.update(),
        this.handleResize = () => {
          n.resolution.set(i.renderer.domElement.clientWidth, i.renderer.domElement.clientHeight),
            e.keepDashSize && (n.gapSize = n.dashSize = 20 * i.amap.getResolution())
        }
        ,
        this.handleResize(),
        i.amap.on("viewchange", this.handleResize)
    }
    update(t) {
      this.points = t || this.points;
      const e = this.points.reduce(((t, e) => (t.push(e.x, e.y, e.z),
        t)), []);
      this.geometry.setPositions(e),
        this.computeLineDistances()
    }
    dispose() {
      super.dispose(),
        this.map.amap.off("viewchange", this.handleResize)
    }
  }
  let If = {};
  class Cf extends xp {
    constructor(t, e) {
      super();
      let i = (new di).copy(t.points[0])
        , n = "";
      this.data = t,
        this.map = e,
        t.points.map((t => {
          let e = (new di).copy(t).sub(i);
          e.x = +e.x.toFixed(3),
            e.y = +e.y.toFixed(3),
            e.z = +e.z.toFixed(3),
            n += e.toArray().toString()
        }
        )),
        "line" === t.polygonType ? this.object3d = this.createLine(t) : this.object3d = this.createPolygon(t, n),
        this.object3d.userData.mapObject = this
    }
    createPolygonGeometry(t) {
      const e = new $l;
      e.setFromPoints(t.points);
      const i = {
        curveSegments: 1,
        steps: 1,
        depth: t.height,
        bevelEnabled: !1
      };
      return new Th(e, i)
    }
    createLine(t) {
      let e = new xf(t.points, {
        linewidth: t.linewidth,
        color: t.color,
        dashed: t.dashed,
        dashScale: t.dashScale,
        worldUnits: t.worldUnits,
        depthTest: !1,
        keepDashSize: t.keepDashSize
      }, this.map);
      return e.userData.polygonData = t,
        e.renderOrder = t.parent.floorHeight || 0,
        e.position.z = t.bottom || 0,
        e.visible = !t.hidePolygon,
        e
    }
    createPolygon(t, e) {
      let i, n = t.hidePolygon ? 0 : t.opacity;
      t.topMap && (i = Td.load(t.topMap),
        i.wrapS = i.wrapT = it,
        t.topMapSize && t.topMapSize > 0 ? i.repeat.set(t.topMapSize, t.topMapSize) : i.repeat.set(.3, .3),
        i.rotation = t.topMapRotation || 0);
      let r = [new (i ? kn : Kh)({
        color: i ? "" : t.themeColor || t.color,
        transparent: !0,
        map: i,
        opacity: n
      }), new Kh({
        color: new ei(t.themeColor || t.color || "#fff").multiplyScalar(.9),
        map: Td.load("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAABACAIAAABdtOgoAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsQAAA7EAZUrDhsAAD9caVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjYtYzEzOCA3OS4xNTk4MjQsIDIwMTYvMDkvMTQtMDE6MDk6MDEgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgMjAxNyAoV2luZG93cyk8L3htcDpDcmVhdG9yVG9vbD4KICAgICAgICAgPHhtcDpDcmVhdGVEYXRlPjIwMTctMDYtMjNUMDk6MzI6MTErMDg6MDA8L3htcDpDcmVhdGVEYXRlPgogICAgICAgICA8eG1wOk1ldGFkYXRhRGF0ZT4yMDE3LTA2LTIzVDA5OjMyOjQ1KzA4OjAwPC94bXA6TWV0YWRhdGFEYXRlPgogICAgICAgICA8eG1wOk1vZGlmeURhdGU+MjAxNy0wNi0yM1QwOTozMjo0NSswODowMDwveG1wOk1vZGlmeURhdGU+CiAgICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2UvcG5nPC9kYzpmb3JtYXQ+CiAgICAgICAgIDx4bXBNTTpJbnN0YW5jZUlEPnhtcC5paWQ6YTZkM2Y3NWQtYmRiYy1mZTRkLTgxMTAtYTFiY2U2ZGVjMGNmPC94bXBNTTpJbnN0YW5jZUlEPgogICAgICAgICA8eG1wTU06RG9jdW1lbnRJRD5hZG9iZTpkb2NpZDpwaG90b3Nob3A6ZDMyMTlmODMtNTdiMy0xMWU3LWI2Y2EtZWIxNmIyMzU4OTNmPC94bXBNTTpEb2N1bWVudElEPgogICAgICAgICA8eG1wTU06T3JpZ2luYWxEb2N1bWVudElEPnhtcC5kaWQ6YTAwMTMzM2ItODkxMy1jYzRjLTk5ZmUtYzk1ZmEwNDBjNWJkPC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpIaXN0b3J5PgogICAgICAgICAgICA8cmRmOlNlcT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+Y3JlYXRlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOmEwMDEzMzNiLTg5MTMtY2M0Yy05OWZlLWM5NWZhMDQwYzViZDwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNy0wNi0yM1QwOTozMjoxMSswODowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIDIwMTcgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDplMmM5Zjc4Yi1hMGExLTNkNDQtODIxZi1hYjQyZjBkNWJiY2I8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTctMDYtMjNUMDk6MzI6NDUrMDg6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE3IChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmNvbnZlcnRlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6cGFyYW1ldGVycz5mcm9tIGFwcGxpY2F0aW9uL3ZuZC5hZG9iZS5waG90b3Nob3AgdG8gaW1hZ2UvcG5nPC9zdEV2dDpwYXJhbWV0ZXJzPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+ZGVyaXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6cGFyYW1ldGVycz5jb252ZXJ0ZWQgZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZzwvc3RFdnQ6cGFyYW1ldGVycz4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6YTZkM2Y3NWQtYmRiYy1mZTRkLTgxMTAtYTFiY2U2ZGVjMGNmPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE3LTA2LTIzVDA5OjMyOjQ1KzA4OjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ0MgMjAxNyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICA8L3JkZjpTZXE+CiAgICAgICAgIDwveG1wTU06SGlzdG9yeT4KICAgICAgICAgPHhtcE1NOkRlcml2ZWRGcm9tIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgPHN0UmVmOmluc3RhbmNlSUQ+eG1wLmlpZDplMmM5Zjc4Yi1hMGExLTNkNDQtODIxZi1hYjQyZjBkNWJiY2I8L3N0UmVmOmluc3RhbmNlSUQ+CiAgICAgICAgICAgIDxzdFJlZjpkb2N1bWVudElEPmFkb2JlOmRvY2lkOnBob3Rvc2hvcDoyNmNjYzM3NS01N2IxLTExZTctYjZjYS1lYjE2YjIzNTg5M2Y8L3N0UmVmOmRvY3VtZW50SUQ+CiAgICAgICAgICAgIDxzdFJlZjpvcmlnaW5hbERvY3VtZW50SUQ+eG1wLmRpZDphMDAxMzMzYi04OTEzLWNjNGMtOTlmZS1jOTVmYTA0MGM1YmQ8L3N0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD4KICAgICAgICAgPC94bXBNTTpEZXJpdmVkRnJvbT4KICAgICAgICAgPHBob3Rvc2hvcDpDb2xvck1vZGU+MzwvcGhvdG9zaG9wOkNvbG9yTW9kZT4KICAgICAgICAgPHRpZmY6T3JpZW50YXRpb24+MTwvdGlmZjpPcmllbnRhdGlvbj4KICAgICAgICAgPHRpZmY6WFJlc29sdXRpb24+OTYwMTIwLzEwMDAwPC90aWZmOlhSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpZUmVzb2x1dGlvbj45NjAxMjAvMTAwMDA8L3RpZmY6WVJlc29sdXRpb24+CiAgICAgICAgIDx0aWZmOlJlc29sdXRpb25Vbml0PjI8L3RpZmY6UmVzb2x1dGlvblVuaXQ+CiAgICAgICAgIDxleGlmOkNvbG9yU3BhY2U+NjU1MzU8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjEyODwvZXhpZjpQaXhlbFhEaW1lbnNpb24+CiAgICAgICAgIDxleGlmOlBpeGVsWURpbWVuc2lvbj42NDwvZXhpZjpQaXhlbFlEaW1lbnNpb24+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgIAo8P3hwYWNrZXQgZW5kPSJ3Ij8+EMUGBgAAAYBJREFUeF7t0UVCAgAARFHm/vcRlFJCShAJpaQR6Q5joYu5w2zmrf7+I3RzEzAd3AWDTFNAOBRimgIit7dMU0A0HGaaAmKRCNMUEI9GmaaAh1iMaQpIxONMU0Dy/p5pCkglEkxTwGMyyTQFZFIppikgm04zTQG5TIZpCihks0xTwFMuxzQFFPN5pimgVCgwTQHlYpFpCngplZimgMrzM9MUUC2XmaaAeqXCNAW8VqtMU8BbrcY0BTTqdaYpoPX6xjQFtBsNpimg02wyTQHvrRbTFNBrt5mmgH6nwzQFDLpdpilg2OsxTQGjfp9pChgPBkxTwMdwyDQFTEcjpingczxmmgJmkwnTFDD/mDJNAYvpJ9MUsJzNmKaA1XzONAWs5wumKWCzWDJNAdulByhht1oxTQH79ZppCjhsNkxTwHG7ZZoCTrsd0xRw2u+ZpoCzB0jhcjgwTQHX45FpCrieTkxTwJcHSOH7fGaawv+AC9MU8HPxACX8XK9MU8CvBwgFAn9d8KS45S4slgAAAABJRU5ErkJggg=="),
        transparent: !0,
        opacity: n
      })];
      r.map((t => t.map && (t.map.minFilter = lt))),
        If[e] || (If[e] = {
          geo: this.createPolygonGeometry(t),
          v3: t.points[0]
        });
      let o = new lr(If[e].geo, r);
      return o.position.copy(t.points[0]).sub(If[e].v3),
        o.userData.polygonData = t,
        o.renderOrder = t.parent.floorHeight || 0,
        o.position.z = t.bottom || 0,
        o.visible = !t.hidePolygon,
        o._click = !0,
        o
    }
  }
  class wf extends xp {
    constructor(t, e) {
      super(),
        this.data = t,
        this.map = e,
        this.object3d = new ra,
        this.object3d.userData.mapObject = this,
        this.object3d.name = "polygonLayer",
        t.polygonData.map((t => {
          setTimeout((() => {
            this.add(new Cf(t, e))
          }
          ), 0)
        }
        ))
    }
    addPolygon(t) {
      if (this.children.find((e => e.data.id === t)))
        return;
      if (this.addFromChildrnPool(t))
        return;
      let e = this.data.polygonData.find((e => e.id === t));
      e && this.add(new Cf(e, this.map))
    }
  }
  const _f = {};
  function Sf(t, e, i, n, r) {
    return [i, n, r, e + "px", t].join(" ")
  }
  class Mf extends ai {
    constructor(t = {}) {
      super(document.createElement("canvas"), void 0, void 0, void 0, lt, ct),
        Object.assign(this, {
          _align: t.align || "center",
          _fillStyle: t.fillStyle || "#fff",
          _fontFamily: t.fontFamily || "sans-serif",
          _fontSize: (t.fontSize ? +t.fontSize : 16) * devicePixelRatio,
          _fontStyle: t.fontStyle || "normal",
          _fontVariant: t.fontVariant || "normal",
          _fontWeight: t.fontWeight || "normal",
          _lineGap: t.lineGap || .15,
          _padding: t.padding || .25,
          _strokeStyle: t.strokeStyle || "#000",
          _strokeWidth: t.strokeWidth || 0,
          _text: t.text || "",
          _src: t.src || null,
          _areaType: t.areaType,
          _bgColor: t.bgColor,
          needsRedraw: !0
        }),
        this.iconHeight = 36 * devicePixelRatio,
        this.redraw()
    }
    get lines() {
      return this.text ? this.text.split("\n") : []
    }
    get textWidth() {
      var t = this.fontFamily
        , e = this.fontStyle
        , i = this.fontVariant
        , n = this.fontWeight
        , r = this.lines;
      if (r.length) {
        var o = document.createElement("canvas").getContext("2d");
        return o.font = Sf(t, 1, e, i, n),
          r.map((function (t) {
            return o.measureText(t).width
          }
          )).reduce((function (t, e) {
            return Math.max(t, e)
          }
          ))
      }
      return 0
    }
    get textHeight() {
      var t = this.lines.length;
      return t ? t + this.lineGap * (t - 1) : 0
    }
    get width() {
      let { padding: t, strokeWidth: e, textWidth: i, text: n } = this;
      return n ? ((i / n.length ? i / n.length : 1) > 1.5 && (i /= 8),
        t += e / 2,
        2 * t + i) : 0
    }
    get height() {
      return 2 * (this.padding + this.strokeWidth / 2) + this.textHeight + (this.src ? this.iconHeight / (this.padding + this.strokeWidth + this.fontSize) : 0)
    }
    redraw() {
      if (this.needsRedraw) {
        var t = this.image;
        if (t) {
          let { fontSize: A, height: b, width: x } = this;
          var e = t.getContext("2d");
          if (e.clearRect(0, 0, t.width, t.height),
            b *= A,
            (x *= A) && b) {
            var i, n = this.align, r = this.fillStyle, o = this.fontFamily, s = this.fontStyle, a = this.fontVariant, l = this.fontWeight, h = this.lineGap, c = this.lines, u = this.padding, p = this.strokeStyle, d = this.strokeWidth, f = this.src, g = this.bgColor, m = 0;
            if (t.width = x,
              t.height = g ? 1.2 * b : b,
              f && !0) {
              m = this.iconHeight;
              var y = new Image;
              y.onload = () => {
                let t = y.width / y.height;
                e.drawImage(y, 0, 0, y.width, y.height, (this.image.width - (t > 1 ? m : m * t)) / 2, 0, t > 1 ? m : m * t, t > 1 ? m / t : m),
                  this.needsUpdate = !0,
                  m = Math.min(t * m, m / t)
              }
                ,
                y.crossOrigin = "anonymous",
                _f[f] ? y.src = _f[f] : _f[f] = y.src = f.includes("base64") ? f : f + "?t=" + Date.now()
            }
            switch (u += d / 2,
            d *= A,
            h *= A,
            u *= A,
            e.font = Sf(o, A, s, a, l),
            n) {
              case "left":
                e.textAlign = "left",
                  i = u;
                break;
              case "right":
                e.textAlign = "right",
                  i = x - u;
                break;
              case "center":
                e.textAlign = "center",
                  i = x / 2
            }
            e.textBaseline = "alphabetic";
            var v = u / 2 + A + m;
            g ? (e.fillStyle = g,
              e.roundRect && e.roundRect(0, 0, x, b, 8),
              e.globalAlpha = .7,
              e.fill()) : (e.fillStyle = "rgba(255,255,255,+0.005)",
                e.fillRect(0, 0, x, b)),
              e.globalAlpha = 1,
              e.fillStyle = r,
              e.miterLimit = 1,
              e.lineWidth = d,
              e.strokeStyle = p,
              c.forEach((function (t) {
                d && e.strokeText(t, i, v),
                  e.fillText(t, i, v),
                  v += A + h
              }
              ))
          } else
            t.width = t.height = 1;
          this.needsRedraw = !1,
            this.needsUpdate = !0
        }
      }
    }
  }
  let Tf;
  Object.entries({
    _align: "align",
    _fillStyle: "fillStyle",
    _fontFamily: "fontFamily",
    _fontSize: "fontSize",
    _fontStyle: "fontStyle",
    _fontVariant: "fontVariant",
    _fontWeight: "fontWeight",
    _lineGap: "lineGap",
    _padding: "padding",
    _strokeStyle: "strokeStyle",
    _strokeWidth: "strokeWidth",
    _text: "text",
    _src: "src",
    _bgColor: "bgColor",
    _areaType: "areaType"
  }).forEach((function (t) {
    var e = t[0]
      , i = t[1];
    Object.defineProperty(Mf.prototype, i, {
      get: function () {
        return this[e]
      },
      set: function (t) {
        this[e] !== t && (this[e] = t,
          this.needsRedraw = !0)
      }
    })
  }
  ));
  const Ef = new Map;
  class kf extends La {
    constructor(t) {
      let e = t.text + (t.src || "").slice(-10) + t.bgColor + t.fillStyle + t.fontSize + t.strokeStyle + t.strokeWidth
        , i = Ef.get(e);
      if (!i) {
        let n = new Mf(t);
        Sd ? (n.minFilter = lt,
          n.magFilter = lt,
          n.generateMipmaps = !1) : (n.minFilter = lt,
            n.magFilter = ot),
          i = new va({
            sizeAttenuation: !1,
            depthTest: !1,
            depthWrite: !1,
            map: n
          }),
          Ef.set(e, i)
      }
      super(i),
        this._hide = !1,
        this.worldPos = new di,
        this.option = t,
        this.center.set(.5, t.src ? .5 : 0),
        this.isCollision = void 0 === this.option.isCollision || this.option.isCollision,
        this.group = t.group || ".",
        Pd(this, 1, t.vmap.sizeRatio),
        this.option.vmap.markerPool.push(this),
        this.option.vmap.markerCollisionPool[this.group] || (this.option.vmap.markerCollisionPool[this.group] = new zd),
        clearTimeout(Tf),
        Tf = setTimeout((() => {
          this.option.vmap.markerPool.sort(((t, e) => e.option.zIndex - t.option.zIndex)),
            this.option.vmap.handleMarkerCollision()
        }
        ), 50),
        this.collision()
    }
    collision() {
      if (this._hide)
        return void (this.visible = !1);
      if (!this.isCollision)
        return;
      let t = Od(this.getWorldPosition(this.worldPos), this.option.vmap.camera, this.option.vmap.renderer.domElement)
        , { pos: e } = t;
      const { image: i } = this.material.map;
      let n = i.height
        , r = i.width
        , o = this.center.x
        , s = this.center.y
        , a = {
          w: r /= devicePixelRatio,
          h: n /= devicePixelRatio,
          x: e.x - r * o,
          y: e.y - n * (1 - s)
        }
        , l = this.option.vmap.markerCollisionPool[this.group].push(a);
      this.visible = !l
    }
    dispose() {
      this.option.vmap.markerPool.splice(this.option.vmap.markerPool.indexOf(this), 1),
        super.dispose()
    }
  }
  class Rf extends xp {
    constructor(t, e) {
      if (super(),
        this.data = t,
        this.map = e,
        !t.name)
        return;
      let i;
      for (const e in up.texList)
        if (t.name.includes(e)) {
          i = up.texList[e];
          break
        }
      let n = new kf({
        vmap: this.map,
        text: t.name,
        bgColor: "",
        strokeStyle: "#FFFFFF",
        src: i || t.fontIcon,
        zIndex: t.zIndex || 0,
        fontSize: t.fontSize,
        fontWeight: Sd ? t.fontWeight ? 700 : 500 : 700,
        lineGap: .25,
        fontFamily: "Microsoft Yahei ,微软雅黑,Tahoma,Arial",
        strokeWidth: Sd ? .2 : .15,
        group: this.data.parent.id,
        fillStyle: t.fontColor || "#555"
      });
      n.renderOrder = t.parent.floorHeight + 1,
        n.position.copy(t.center),
        n.position.z = t.height,
        n.userData.polygonData = t,
        this.object3d = n,
        this.object3d.userData.mapObject = this
    }
  }
  class Lf extends xp {
    constructor(t, e) {
      super(),
        this.data = t,
        this.map = e,
        this.object3d = new ra,
        this.object3d.userData.mapObject = this,
        this.object3d.name = "markerLayer",
        t.polygonData.map((t => {
          setTimeout((() => {
            t.name && this.add(new Rf(t, e))
          }
          ), 0)
        }
        ))
    }
    addMarker(t) {
      if (this.children.find((e => e.data.id === t)))
        return;
      if (this.addFromChildrnPool(t))
        return;
      let e = this.data.polygonData.find((e => e.id === t));
      e && this.add(new Rf(e, this.map))
    }
  }
  const Pf = {};
  let zf = new $c
    , Of = [];
  !function t() {
    requestAnimationFrame(t),
      Of.length && Of.map((t => t.update(zf.getDelta())))
  }();
  class Df extends xp {
    constructor(t, e, i) {
      super();
      let n = Pf[t.url];
      this.data = t,
        this.map = e,
        this.object3d = new mn,
        this.object3d.userData.mapObject = this;
      const r = e => {
        t.position && e.position.copy(t.position),
          t.scale && e.scale.copy(t.scale),
          t.rotation && e.rotation.copy(t.rotation),
          this.object3d.name = t.url,
          this.object3d.userData.modelData = t,
          this.object3d.add(e),
          i && i(this)
      }
        ;
      if (n)
        n = n.clone(),
          r(n);
      else {
        let e = "";
        e = t.url.includes("http") ? t.url : 0 !== up.api.indexOf("http") ? t.url.includes("general") ? `/${t.url}` : `./www.wxb3d.com/park-edit/model/${t.url}` : `//www.wxb3d.com/park-edit/model/${t.url}`,
          Ed.load(e, (e => {
            const { scene: i, animations: n } = e;
            i.traverse((t => {
              t.material && (t.material.metalness = 0,
                t.material.roughness = 1)
            }
            )),
              n.length && Of.push(function (t, e, i) {
                const n = new bu(t)
                  , r = uc.findByName(e, i);
                r && n.clipAction(r).play();
                return n
              }(i, n, n[0].name)),
              r(i),
              Pf[t.url] = i
          }
          ))
      }
    }
  }
  class Uf extends xp {
    constructor(t, e) {
      super(),
        this.data = t,
        this.map = e,
        this.object3d = new ra,
        this.object3d.userData.mapObject = this,
        this.object3d.name = "modelLayer";
      let i = t.modelData.length;
      t.modelData.map((n => {
        setTimeout((() => {
          this.add(new Df(n, e, (() => {
            i--,
              i <= 0 && e.emit("floorModelAllLoaded", t)
          }
          )))
        }
        ), 0)
      }
      ))
    }
    addModel(t) {
      if (this.children.find((e => e.data.id === t)))
        return;
      if (this.addFromChildrnPool(t))
        return;
      let e = this.data.modelData.find((e => e.id === t));
      e && this.add(new Df(e, this.map))
    }
  }
  class Nf extends xp {
    constructor(t, e) {
      super(),
        this.data = t,
        this.object3d = new ra,
        this.object3d.userData.mapObject = this,
        this.object3d.name = "floor",
        this.map = e,
        this.polygonLayer = new wf(t, e),
        this.markerLayer = new Lf(t, e),
        this.modelLayer = new Uf(t, e),
        this.add(this.polygonLayer),
        this.add(this.markerLayer),
        this.add(this.modelLayer),
        this.addBgi(),
        this.addBeacon(),
        Md && this.debugPath(),
        this.addNaviLine(),
        this.addCustomMarker(),
        this.addCustomNaviLine(),
        this.data.parent && this.addFloorTitle(),
        this.map.on("addNaviLine", (() => {
          "1716622714522963969" !== this.map.mapData.mapId && "1716622714522963968" !== this.map.mapData.mapId || (this.object3d.visible = !0),
            this.addNaviLine()
        }
        )),
        this.map.on("removeNaviLine", (() => {
          var t;
          "1716622714522963969" !== this.map.mapData.mapId && "1716622714522963968" !== this.map.mapData.mapId || (this.object3d.visible = !0),
            null === (t = this.naviLine) || void 0 === t || t.dispose()
        }
        )),
        this.map.on("addLocationPoint", (({ floorId: t, marker: e }) => {
          t === this.data.id && e.parent !== this.object3d && (this.object3d.add(e),
            e.renderOrder = this.data.floorHeight + 1)
        }
        )),
        this.map.on("addCustomNaviLine", (() => {
          this.addCustomNaviLine()
        }
        )),
        this.map.on("removeCustomNaviLine", (t => {
          this.removeCustomNaviLine(t)
        }
        )),
        this.map.on("removeAllCustomMarker", (() => {
          this.removeAllCustomMarker()
        }
        )),
        this.map.on("addCustomMarker", (() => {
          this.addCustomMarker()
        }
        )),
        this.map.on("removeCustomMarker", (t => {
          this.removeCustomMarker(t)
        }
        )),
        this.map.on("removeAllCustomMarker", (() => {
          this.removeAllCustomMarker()
        }
        ))
    }
    addBgi() {
      return sp(this, void 0, void 0, (function* () {
        const { bgi: t } = this.data;
        if (!t || !t.url || !t.show)
          return;
        let e = 100;
        const i = yield Td.loadAsync(t.url + "?t=" + this.data.id)
          , n = new kn({
            map: i
          });
        n.transparent = !0;
        const { image: r } = i;
        e = r.naturalHeight / r.naturalWidth * 100;
        const o = new kr(100, e)
          , s = new lr(o, n);
        this.object3d.add(s),
          t.position && s.position.copy(t.position),
          s.position.z = -1,
          s.rotation.z = t.rotation || 0,
          t.scale && s.scale.multiplyScalar(t.scale),
          s.renderOrder = -1
      }
      ))
    }
    addNaviLine() {
      var t, e;
      if ("1716622714522963969" === this.map.mapData.mapId || "1716622714522963968" === this.map.mapData.mapId) {
        let e = null === (t = this.map.navi) || void 0 === t ? void 0 : t.status.route;
        if (!(null == e ? void 0 : e.length))
          return void (this.object3d.visible = !0);
        if (this.data.build) {
          let t = [...new Set(e.map((t => this.data.build.indexOf(t.floor))))].sort();
          console.log("🚀 ~ arr:", t);
          let i = this.data.build.indexOf(this.data);
          this.data.parent && (this.object3d.visible = i >= t[0] && i <= t.at(-1))
        }
      }
      if (null === (e = this.naviLine) || void 0 === e || e.dispose(),
        this.data.naviLineData) {
        this.naviLine = new ra;
        let t = this.data.naviLineData
          , e = [[t[0]]];
        for (let i = 1; i < t.length; i++) {
          let n = t[i];
          e.at(-1).at(-1).point.ids[n.point.id] ? e.at(-1).push(n) : e.push([n])
        }
        e.map((t => {
          let e = new bf(t.map((t => new di(t.point.x, t.point.y, 0))), {
            bgc: this.data.id === this.map.mapData.id ? "#39b373" : "#477df5",
            color: "#fff"
          }, this.map);
          e.renderOrder = t[0].floor.floorHeight + 1,
            this.naviLine.add(e)
        }
        )),
          this.object3d.add(this.naviLine)
      }
    }
    addFloorTitle(t = !1) {
      var e;
      null === (e = this.floorTitle) || void 0 === e || e.dispose();
      let i = this.floorTitle = new kf(Object.assign({
        text: this.data.name,
        vmap: this.map,
        isCollision: !1,
        zIndex: 999,
        fontWeight: "700",
        lineGap: .25
      }, t ? {
        fontSize: 22,
        fillStyle: "#FFFFFF",
        strokeStyle: "#FFFFFF",
        bgColor: "#ff994a"
      } : {
        fontSize: 18,
        strokeWidth: .15,
        fillStyle: "blue",
        strokeStyle: "#FFFFFF"
      }));
      const { position: n } = this.map.getPointsFit(this.data.polygonData.map((t => t.points)).flat());
      n.z += 2,
        i.position.copy(n),
        i.renderOrder = this.data.floorHeight + 2,
        this.object3d.add(i)
    }
    removeFloorTitle() {
      var t;
      null === (t = this.floorTitle) || void 0 === t || t.dispose()
    }
    addCustomNaviLine() {
      this.data.customNaviLineData && (this.customNaviLine || (this.customNaviLine = new ra,
        this.object3d.add(this.customNaviLine)),
        this.data.customNaviLineData.map((t => {
          if (!this.customNaviLine.children.find((e => e.userData.data.id === t.id))) {
            let e = new bf(t.points.map((t => new di(t.x, t.y, 0))), {
              bgc: "#477df5",
              color: "#fff"
            }, this.map);
            e.renderOrder = t.options.renderOrder || this.data.floorHeight + 1,
              e.userData.data = t,
              this.customNaviLine.add(e)
          }
        }
        )))
    }
    removeCustomNaviLine(t) {
      var e, i;
      null === (i = null === (e = this.customNaviLine) || void 0 === e ? void 0 : e.children.find((e => e.userData.data.id === t))) || void 0 === i || i.dispose()
    }
    removeAllCustomNaviLine() {
      var t;
      null === (t = this.customNaviLine) || void 0 === t || t.dispose(),
        this.customNaviLine = void 0
    }
    addCustomMarker() {
      this.data.customMarkerData && (this.customMarker || (this.customMarker = new ra,
        this.object3d.add(this.customMarker)),
        this.data.customMarkerData.map((t => {
          if ((t.src || t.text) && !this.customMarker.children.find((e => e.userData.data.id === t.id))) {
            let e = Object.assign(Object.assign({
              group: this.data.id
            }, t), {
              vmap: this.map
            })
              , i = e.text ? new kf(e) : new La(new va({
                map: Td.load(e.src, (() => {
                  Pd(i, e.scale || 1, this.map.sizeRatio)
                }
                )),
                sizeAttenuation: !1,
                depthTest: !1,
                transparent: !0
              }));
            i.material.map && (i.material.map.minFilter = lt),
              i.center.set(.5, 0),
              e.scale && i.scale.multiplyScalar(e.scale),
              e.position && i.position.copy(e.position),
              i.renderOrder = e.renderOrder || 9999,
              i.userData.data = e,
              this.customMarker.add(i)
          }
        }
        )))
    }
    removeCustomMarker(t) {
      var e, i;
      null === (i = null === (e = this.customMarker) || void 0 === e ? void 0 : e.children.find((e => e.userData.data.id === t))) || void 0 === i || i.dispose()
    }
    removeAllCustomMarker() {
      var t;
      null === (t = this.customMarker) || void 0 === t || t.dispose(),
        this.customMarker = void 0
    }
    getModelById(t) {
      return this.modelLayer.children.find((e => e.data.id === t))
    }
    getPolygonById(t) {
      return this.polygonLayer.children.find((e => e.data.id === t))
    }
    getMarkerById(t) {
      return this.markerLayer.children.find((e => e.data.id === t))
    }
    addBeacon() {
      if (!Md)
        return;
      let t = this.map.mapData.beaconData.filter((t => t.floorId === this.data.id))
        , e = this.bc = this.bc || new mn;
      this.object3d.add(e),
        t.map((t => {
          let i = new kf({
            vmap: this.map,
            text: t.id,
            fillStyle: "blue",
            strokeStyle: "#FFFFFF",
            lineGap: .25,
            strokeWidth: .15,
            isCollision: !1,
            fontSize: 10
          });
          i.position.copy(t).setZ(0),
            e.add(i),
            i.renderOrder = vp
        }
        ))
    }
    debugPath() {
      if (this._debugPathGroup && this._debugPathGroup.dispose(),
        !Md)
        return;
      let t = this._debugPathGroup = new ra;
      function e(t, e) {
        return t > e ? `${t},${e}` : `${e},${t}`
      }
      t.position.z = .1;
      let i = this.map.mapData.path.filter((t => t.floorId === this.data.id))
        , n = {};
      i.map((r => {
        for (const o in r.ids) {
          if (pp[r.ids[o]])
            continue;
          let s = i.find((t => +o == +t.id));
          if (!s || n[e(r.id, s.id)])
            continue;
          n[e(r.id, s.id)] = 1;
          let a = new sl(new Wn, new tl({
            color: 1 == r.ids[o] ? "blue" : 2 === r.ids[o] ? "red" : "yellow",
            transparent: !0,
            depthTest: !1,
            depthWrite: !1
          }));
          a.renderOrder = 1111111,
            t.add(a),
            a.geometry.setFromPoints([r, s])
        }
      }
      )),
        this.object3d.add(t)
    }
  }
  var Ff, Bf = Object.freeze({
    Linear: Object.freeze({
      None: function (t) {
        return t
      },
      In: function (t) {
        return this.None(t)
      },
      Out: function (t) {
        return this.None(t)
      },
      InOut: function (t) {
        return this.None(t)
      }
    }),
    Quadratic: Object.freeze({
      In: function (t) {
        return t * t
      },
      Out: function (t) {
        return t * (2 - t)
      },
      InOut: function (t) {
        return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1)
      }
    }),
    Cubic: Object.freeze({
      In: function (t) {
        return t * t * t
      },
      Out: function (t) {
        return --t * t * t + 1
      },
      InOut: function (t) {
        return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2)
      }
    }),
    Quartic: Object.freeze({
      In: function (t) {
        return t * t * t * t
      },
      Out: function (t) {
        return 1 - --t * t * t * t
      },
      InOut: function (t) {
        return (t *= 2) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2)
      }
    }),
    Quintic: Object.freeze({
      In: function (t) {
        return t * t * t * t * t
      },
      Out: function (t) {
        return --t * t * t * t * t + 1
      },
      InOut: function (t) {
        return (t *= 2) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2)
      }
    }),
    Sinusoidal: Object.freeze({
      In: function (t) {
        return 1 - Math.sin((1 - t) * Math.PI / 2)
      },
      Out: function (t) {
        return Math.sin(t * Math.PI / 2)
      },
      InOut: function (t) {
        return .5 * (1 - Math.sin(Math.PI * (.5 - t)))
      }
    }),
    Exponential: Object.freeze({
      In: function (t) {
        return 0 === t ? 0 : Math.pow(1024, t - 1)
      },
      Out: function (t) {
        return 1 === t ? 1 : 1 - Math.pow(2, -10 * t)
      },
      InOut: function (t) {
        return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? .5 * Math.pow(1024, t - 1) : .5 * (2 - Math.pow(2, -10 * (t - 1)))
      }
    }),
    Circular: Object.freeze({
      In: function (t) {
        return 1 - Math.sqrt(1 - t * t)
      },
      Out: function (t) {
        return Math.sqrt(1 - --t * t)
      },
      InOut: function (t) {
        return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
      }
    }),
    Elastic: Object.freeze({
      In: function (t) {
        return 0 === t ? 0 : 1 === t ? 1 : -Math.pow(2, 10 * (t - 1)) * Math.sin(5 * (t - 1.1) * Math.PI)
      },
      Out: function (t) {
        return 0 === t ? 0 : 1 === t ? 1 : Math.pow(2, -10 * t) * Math.sin(5 * (t - .1) * Math.PI) + 1
      },
      InOut: function (t) {
        return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? -.5 * Math.pow(2, 10 * (t - 1)) * Math.sin(5 * (t - 1.1) * Math.PI) : .5 * Math.pow(2, -10 * (t - 1)) * Math.sin(5 * (t - 1.1) * Math.PI) + 1
      }
    }),
    Back: Object.freeze({
      In: function (t) {
        var e = 1.70158;
        return 1 === t ? 1 : t * t * ((e + 1) * t - e)
      },
      Out: function (t) {
        var e = 1.70158;
        return 0 === t ? 0 : --t * t * ((e + 1) * t + e) + 1
      },
      InOut: function (t) {
        var e = 2.5949095;
        return (t *= 2) < 1 ? t * t * ((e + 1) * t - e) * .5 : .5 * ((t -= 2) * t * ((e + 1) * t + e) + 2)
      }
    }),
    Bounce: Object.freeze({
      In: function (t) {
        return 1 - Bf.Bounce.Out(1 - t)
      },
      Out: function (t) {
        return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
      },
      InOut: function (t) {
        return t < .5 ? .5 * Bf.Bounce.In(2 * t) : .5 * Bf.Bounce.Out(2 * t - 1) + .5
      }
    }),
    generatePow: function (t) {
      return void 0 === t && (t = 4),
        t = (t = t < Number.EPSILON ? Number.EPSILON : t) > 1e4 ? 1e4 : t,
      {
        In: function (e) {
          return Math.pow(e, t)
        },
        Out: function (e) {
          return 1 - Math.pow(1 - e, t)
        },
        InOut: function (e) {
          return e < .5 ? Math.pow(2 * e, t) / 2 : (1 - Math.pow(2 - 2 * e, t)) / 2 + .5
        }
      }
    }
  }), jf = function () {
    return performance.now()
  }, Vf = function () {
    function t() {
      this._tweens = {},
        this._tweensAddedDuringUpdate = {}
    }
    return t.prototype.getAll = function () {
      var t = this;
      return Object.keys(this._tweens).map((function (e) {
        return t._tweens[e]
      }
      ))
    }
      ,
      t.prototype.removeAll = function () {
        this._tweens = {}
      }
      ,
      t.prototype.add = function (t) {
        this._tweens[t.getId()] = t,
          this._tweensAddedDuringUpdate[t.getId()] = t
      }
      ,
      t.prototype.remove = function (t) {
        delete this._tweens[t.getId()],
          delete this._tweensAddedDuringUpdate[t.getId()]
      }
      ,
      t.prototype.update = function (t, e) {
        void 0 === t && (t = jf()),
          void 0 === e && (e = !1);
        var i = Object.keys(this._tweens);
        if (0 === i.length)
          return !1;
        for (; i.length > 0;) {
          this._tweensAddedDuringUpdate = {};
          for (var n = 0; n < i.length; n++) {
            var r = this._tweens[i[n]]
              , o = !e;
            r && !1 === r.update(t, o) && !e && delete this._tweens[i[n]]
          }
          i = Object.keys(this._tweensAddedDuringUpdate)
        }
        return !0
      }
      ,
      t
  }(), Gf = {
    Linear: function (t, e) {
      var i = t.length - 1
        , n = i * e
        , r = Math.floor(n)
        , o = Gf.Utils.Linear;
      return e < 0 ? o(t[0], t[1], n) : e > 1 ? o(t[i], t[i - 1], i - n) : o(t[r], t[r + 1 > i ? i : r + 1], n - r)
    },
    Bezier: function (t, e) {
      for (var i = 0, n = t.length - 1, r = Math.pow, o = Gf.Utils.Bernstein, s = 0; s <= n; s++)
        i += r(1 - e, n - s) * r(e, s) * t[s] * o(n, s);
      return i
    },
    CatmullRom: function (t, e) {
      var i = t.length - 1
        , n = i * e
        , r = Math.floor(n)
        , o = Gf.Utils.CatmullRom;
      return t[0] === t[i] ? (e < 0 && (r = Math.floor(n = i * (1 + e))),
        o(t[(r - 1 + i) % i], t[r], t[(r + 1) % i], t[(r + 2) % i], n - r)) : e < 0 ? t[0] - (o(t[0], t[0], t[1], t[1], -n) - t[0]) : e > 1 ? t[i] - (o(t[i], t[i], t[i - 1], t[i - 1], n - i) - t[i]) : o(t[r ? r - 1 : 0], t[r], t[i < r + 1 ? i : r + 1], t[i < r + 2 ? i : r + 2], n - r)
    },
    Utils: {
      Linear: function (t, e, i) {
        return (e - t) * i + t
      },
      Bernstein: function (t, e) {
        var i = Gf.Utils.Factorial;
        return i(t) / i(e) / i(t - e)
      },
      Factorial: (Ff = [1],
        function (t) {
          var e = 1;
          if (Ff[t])
            return Ff[t];
          for (var i = t; i > 1; i--)
            e *= i;
          return Ff[t] = e,
            e
        }
      ),
      CatmullRom: function (t, e, i, n, r) {
        var o = .5 * (i - t)
          , s = .5 * (n - e)
          , a = r * r;
        return (2 * e - 2 * i + o + s) * (r * a) + (-3 * e + 3 * i - 2 * o - s) * a + o * r + e
      }
    }
  }, Wf = function () {
    function t() { }
    return t.nextId = function () {
      return t._nextId++
    }
      ,
      t._nextId = 0,
      t
  }(), Jf = new Vf, Hf = function () {
    function t(t, e) {
      void 0 === e && (e = Jf),
        this._object = t,
        this._group = e,
        this._isPaused = !1,
        this._pauseStart = 0,
        this._valuesStart = {},
        this._valuesEnd = {},
        this._valuesStartRepeat = {},
        this._duration = 1e3,
        this._isDynamic = !1,
        this._initialRepeat = 0,
        this._repeat = 0,
        this._yoyo = !1,
        this._isPlaying = !1,
        this._reversed = !1,
        this._delayTime = 0,
        this._startTime = 0,
        this._easingFunction = Bf.Linear.None,
        this._interpolationFunction = Gf.Linear,
        this._chainedTweens = [],
        this._onStartCallbackFired = !1,
        this._onEveryStartCallbackFired = !1,
        this._id = Wf.nextId(),
        this._isChainStopped = !1,
        this._propertiesAreSetUp = !1,
        this._goToEnd = !1
    }
    return t.prototype.getId = function () {
      return this._id
    }
      ,
      t.prototype.isPlaying = function () {
        return this._isPlaying
      }
      ,
      t.prototype.isPaused = function () {
        return this._isPaused
      }
      ,
      t.prototype.to = function (t, e) {
        if (void 0 === e && (e = 1e3),
          this._isPlaying)
          throw new Error("Can not call Tween.to() while Tween is already started or paused. Stop the Tween first.");
        return this._valuesEnd = t,
          this._propertiesAreSetUp = !1,
          this._duration = e,
          this
      }
      ,
      t.prototype.duration = function (t) {
        return void 0 === t && (t = 1e3),
          this._duration = t,
          this
      }
      ,
      t.prototype.dynamic = function (t) {
        return void 0 === t && (t = !1),
          this._isDynamic = t,
          this
      }
      ,
      t.prototype.start = function (t, e) {
        if (void 0 === t && (t = jf()),
          void 0 === e && (e = !1),
          this._isPlaying)
          return this;
        if (this._group && this._group.add(this),
          this._repeat = this._initialRepeat,
          this._reversed)
          for (var i in this._reversed = !1,
            this._valuesStartRepeat)
            this._swapEndStartRepeatValues(i),
              this._valuesStart[i] = this._valuesStartRepeat[i];
        if (this._isPlaying = !0,
          this._isPaused = !1,
          this._onStartCallbackFired = !1,
          this._onEveryStartCallbackFired = !1,
          this._isChainStopped = !1,
          this._startTime = t,
          this._startTime += this._delayTime,
          !this._propertiesAreSetUp || e) {
          if (this._propertiesAreSetUp = !0,
            !this._isDynamic) {
            var n = {};
            for (var r in this._valuesEnd)
              n[r] = this._valuesEnd[r];
            this._valuesEnd = n
          }
          this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat, e)
        }
        return this
      }
      ,
      t.prototype.startFromCurrentValues = function (t) {
        return this.start(t, !0)
      }
      ,
      t.prototype._setupProperties = function (t, e, i, n, r) {
        for (var o in i) {
          var s = t[o]
            , a = Array.isArray(s)
            , l = a ? "array" : typeof s
            , h = !a && Array.isArray(i[o]);
          if ("undefined" !== l && "function" !== l) {
            if (h) {
              if (0 === (m = i[o]).length)
                continue;
              for (var c = [s], u = 0, p = m.length; u < p; u += 1) {
                var d = this._handleRelativeValue(s, m[u]);
                if (isNaN(d)) {
                  h = !1,
                    console.warn("Found invalid interpolation list. Skipping.");
                  break
                }
                c.push(d)
              }
              h && (i[o] = c)
            }
            if ("object" !== l && !a || !s || h)
              (void 0 === e[o] || r) && (e[o] = s),
                a || (e[o] *= 1),
                n[o] = h ? i[o].slice().reverse() : e[o] || 0;
            else {
              e[o] = a ? [] : {};
              var f = s;
              for (var g in f)
                e[o][g] = f[g];
              n[o] = a ? [] : {};
              var m = i[o];
              if (!this._isDynamic) {
                var y = {};
                for (var g in m)
                  y[g] = m[g];
                i[o] = m = y
              }
              this._setupProperties(f, e[o], m, n[o], r)
            }
          }
        }
      }
      ,
      t.prototype.stop = function () {
        return this._isChainStopped || (this._isChainStopped = !0,
          this.stopChainedTweens()),
          this._isPlaying ? (this._group && this._group.remove(this),
            this._isPlaying = !1,
            this._isPaused = !1,
            this._onStopCallback && this._onStopCallback(this._object),
            this) : this
      }
      ,
      t.prototype.end = function () {
        return this._goToEnd = !0,
          this.update(1 / 0),
          this
      }
      ,
      t.prototype.pause = function (t) {
        return void 0 === t && (t = jf()),
          this._isPaused || !this._isPlaying || (this._isPaused = !0,
            this._pauseStart = t,
            this._group && this._group.remove(this)),
          this
      }
      ,
      t.prototype.resume = function (t) {
        return void 0 === t && (t = jf()),
          this._isPaused && this._isPlaying ? (this._isPaused = !1,
            this._startTime += t - this._pauseStart,
            this._pauseStart = 0,
            this._group && this._group.add(this),
            this) : this
      }
      ,
      t.prototype.stopChainedTweens = function () {
        for (var t = 0, e = this._chainedTweens.length; t < e; t++)
          this._chainedTweens[t].stop();
        return this
      }
      ,
      t.prototype.group = function (t) {
        return void 0 === t && (t = Jf),
          this._group = t,
          this
      }
      ,
      t.prototype.delay = function (t) {
        return void 0 === t && (t = 0),
          this._delayTime = t,
          this
      }
      ,
      t.prototype.repeat = function (t) {
        return void 0 === t && (t = 0),
          this._initialRepeat = t,
          this._repeat = t,
          this
      }
      ,
      t.prototype.repeatDelay = function (t) {
        return this._repeatDelayTime = t,
          this
      }
      ,
      t.prototype.yoyo = function (t) {
        return void 0 === t && (t = !1),
          this._yoyo = t,
          this
      }
      ,
      t.prototype.easing = function (t) {
        return void 0 === t && (t = Bf.Linear.None),
          this._easingFunction = t,
          this
      }
      ,
      t.prototype.interpolation = function (t) {
        return void 0 === t && (t = Gf.Linear),
          this._interpolationFunction = t,
          this
      }
      ,
      t.prototype.chain = function () {
        for (var t = [], e = 0; e < arguments.length; e++)
          t[e] = arguments[e];
        return this._chainedTweens = t,
          this
      }
      ,
      t.prototype.onStart = function (t) {
        return this._onStartCallback = t,
          this
      }
      ,
      t.prototype.onEveryStart = function (t) {
        return this._onEveryStartCallback = t,
          this
      }
      ,
      t.prototype.onUpdate = function (t) {
        return this._onUpdateCallback = t,
          this
      }
      ,
      t.prototype.onRepeat = function (t) {
        return this._onRepeatCallback = t,
          this
      }
      ,
      t.prototype.onComplete = function (t) {
        return this._onCompleteCallback = t,
          this
      }
      ,
      t.prototype.onStop = function (t) {
        return this._onStopCallback = t,
          this
      }
      ,
      t.prototype.update = function (t, e) {
        if (void 0 === t && (t = jf()),
          void 0 === e && (e = !0),
          this._isPaused)
          return !0;
        var i, n, r = this._startTime + this._duration;
        if (!this._goToEnd && !this._isPlaying) {
          if (t > r)
            return !1;
          e && this.start(t, !0)
        }
        if (this._goToEnd = !1,
          t < this._startTime)
          return !0;
        !1 === this._onStartCallbackFired && (this._onStartCallback && this._onStartCallback(this._object),
          this._onStartCallbackFired = !0),
          !1 === this._onEveryStartCallbackFired && (this._onEveryStartCallback && this._onEveryStartCallback(this._object),
            this._onEveryStartCallbackFired = !0),
          n = (t - this._startTime) / this._duration,
          n = 0 === this._duration || n > 1 ? 1 : n;
        var o = this._easingFunction(n);
        if (this._updateProperties(this._object, this._valuesStart, this._valuesEnd, o),
          this._onUpdateCallback && this._onUpdateCallback(this._object, n),
          1 === n) {
          if (this._repeat > 0) {
            for (i in isFinite(this._repeat) && this._repeat--,
              this._valuesStartRepeat)
              this._yoyo || "string" != typeof this._valuesEnd[i] || (this._valuesStartRepeat[i] = this._valuesStartRepeat[i] + parseFloat(this._valuesEnd[i])),
                this._yoyo && this._swapEndStartRepeatValues(i),
                this._valuesStart[i] = this._valuesStartRepeat[i];
            return this._yoyo && (this._reversed = !this._reversed),
              void 0 !== this._repeatDelayTime ? this._startTime = t + this._repeatDelayTime : this._startTime = t + this._delayTime,
              this._onRepeatCallback && this._onRepeatCallback(this._object),
              this._onEveryStartCallbackFired = !1,
              !0
          }
          this._onCompleteCallback && this._onCompleteCallback(this._object);
          for (var s = 0, a = this._chainedTweens.length; s < a; s++)
            this._chainedTweens[s].start(this._startTime + this._duration, !1);
          return this._isPlaying = !1,
            !1
        }
        return !0
      }
      ,
      t.prototype._updateProperties = function (t, e, i, n) {
        for (var r in i)
          if (void 0 !== e[r]) {
            var o = e[r] || 0
              , s = i[r]
              , a = Array.isArray(t[r])
              , l = Array.isArray(s);
            !a && l ? t[r] = this._interpolationFunction(s, n) : "object" == typeof s && s ? this._updateProperties(t[r], o, s, n) : "number" == typeof (s = this._handleRelativeValue(o, s)) && (t[r] = o + (s - o) * n)
          }
      }
      ,
      t.prototype._handleRelativeValue = function (t, e) {
        return "string" != typeof e ? e : "+" === e.charAt(0) || "-" === e.charAt(0) ? t + parseFloat(e) : parseFloat(e)
      }
      ,
      t.prototype._swapEndStartRepeatValues = function (t) {
        var e = this._valuesStartRepeat[t]
          , i = this._valuesEnd[t];
        this._valuesStartRepeat[t] = "string" == typeof i ? this._valuesStartRepeat[t] + parseFloat(i) : this._valuesEnd[t],
          this._valuesEnd[t] = e
      }
      ,
      t
  }(), Zf = "20.0.3", Qf = Wf.nextId, Kf = Jf, Yf = Kf.getAll.bind(Kf), qf = Kf.removeAll.bind(Kf), Xf = Kf.add.bind(Kf), $f = Kf.remove.bind(Kf), tg = Kf.update.bind(Kf), eg = {
    Easing: Bf,
    Group: Vf,
    Interpolation: Gf,
    now: jf,
    Sequence: Wf,
    nextId: Qf,
    Tween: Hf,
    VERSION: Zf,
    getAll: Yf,
    removeAll: qf,
    add: Xf,
    remove: $f,
    update: tg
  }, ig = Object.freeze({
    __proto__: null,
    Easing: Bf,
    Group: Vf,
    Interpolation: Gf,
    Sequence: Wf,
    Tween: Hf,
    VERSION: Zf,
    add: Xf,
    default: eg,
    getAll: Yf,
    nextId: Qf,
    now: jf,
    remove: $f,
    removeAll: qf,
    update: tg
  });
  class ng extends xp {
    constructor(t, e) {
      super(),
        this.manyFloorMode = !1,
        this.children = [],
        this.data = t,
        this.map = e,
        this.object3d = new ra,
        this.object3d.userData.mapObject = this,
        this.object3d.name = "build",
        this.addCrossFloorNaviLine(),
        this.map.on("addNaviLine", (() => {
          this.addCrossFloorNaviLine()
        }
        )),
        this.map.on("removeNaviLine", (() => {
          var t;
          null === (t = this.crossFloorLine) || void 0 === t || t.dispose()
        }
        ))
    }
    addDefaultFloor() {
      if (this.curentFloor)
        return void (this.map.status.floor = this.curentFloor);
      let t = this.data.floor.find((t => t.default)) || this.data.floor[0];
      t && this.addFloor(t.id)
    }
    addCrossFloorNaviLine() {
      var t;
      if (null === (t = this.crossFloorLine) || void 0 === t || t.dispose(),
        this.manyFloorMode && this.data.naviLineData) {
        this.crossFloorLine = new ra;
        let t = this.data.naviLineData;
        for (let e = 1; e < t.length; e++) {
          let i = t[e - 1].at(-1)
            , n = t[e][0]
            , r = new xf([new di(i.point.x, i.point.y, i.floor.floorHeight - this.manyFloorStartFloor.data.floorHeight), new di(n.point.x, n.point.y, n.floor.floorHeight - this.manyFloorStartFloor.data.floorHeight)], {
              dashed: !0,
              dashScale: 2,
              depthTest: !1,
              transparent: !0,
              opacity: .5,
              worldUnits: !1,
              keepDashSize: !0,
              color: "#477df5",
              linewidth: 5
            }, this.map);
          r.renderOrder = bp,
            this.crossFloorLine.add(r)
        }
        this.object3d.add(this.crossFloorLine)
      }
    }
    addFloor(t) {
      if (this.children.find((e => e.data.id === t)))
        return;
      let e = this.addFromChildrnPool(t);
      if (!e) {
        let i = this.data.floor.find((e => e.id === t));
        i && (e = new Nf(i, this.map),
          this.add(e))
      }
      this.manyFloorMode ? new Hf(e.object3d.position).to({
        z: e.data.floorHeight - this.manyFloorStartFloor.data.floorHeight
      }, 300).start() : e.object3d.position.setZ(0),
        this.manyFloorMode || (this.map.status.floor = this.curentFloor = e),
        this.manyFloorMode && this.children.map((t => t.addFloorTitle && t.addFloorTitle(this.curentFloor === t)))
    }
    remoeFloor(t) {
      let e = this.children.find((e => e.data.id === t));
      e && this.remove(e)
    }
    switchFloor(t) {
      if (this.manyFloorMode) {
        let e = this.children.find((e => e.data.id === t));
        if (!e)
          return console.error(`switchFloor: 找不到 id:${t} 的楼层`),
            e;
        this.map.status.floor = this.curentFloor = e,
          new Hf(this.object3d.position).to({
            z: this.manyFloorStartFloor.data.floorHeight - e.data.floorHeight
          }, 300).easing(Bf.Quadratic.Out).start()
      } else
        this.curentFloor && this.remoeFloor(this.curentFloor.data.id),
          this.addFloor(t);
      return setTimeout((() => {
        this.map.handleMarkerCollision()
      }
      ), 0),
        this.manyFloorMode && this.children.map((t => t.addFloorTitle && t.addFloorTitle(this.curentFloor === t))),
        this.map.status.floor = this.curentFloor
    }
    setManyFloorMode() {
      var t;
      this.manyFloorMode || (this.manyFloorStartFloor = this.curentFloor,
        this.map.status.manyFloorMode = !0,
        this.map.removeAmapFeatures(),
        null === (t = this.map.outerFloor) || void 0 === t || t.removeFromParent(),
        this.manyFloorMode = !0,
        this.data.floor.map((t => {
          this.addFloor(t.id)
        }
        )),
        this.addCrossFloorNaviLine(),
        "1716622714522963969" !== this.map.mapData.mapId && "1716622714522963968" !== this.map.mapData.mapId || this.children.map((t => {
          var e, i;
          t.object3d.visible = !this.map.navi.status.route.length || !!(null === (e = t.data.naviLineData) || void 0 === e ? void 0 : e.length);
          let n = null === (i = this.map.navi) || void 0 === i ? void 0 : i.status.route;
          if (!(null == n ? void 0 : n.length))
            return;
          let r = [...new Set(n.map((t => this.data.floor.indexOf(t.floor))))].sort()
            , o = this.data.floor.indexOf(t.data);
          console.log("🚀 ~ arr:", r, o),
            t.object3d.visible = o >= r[0] && o <= r.at(-1)
        }
        )))
    }
    setOneFloorMode() {
      var t;
      "1716622714522963969" !== this.map.mapData.mapId && "1716622714522963968" !== this.map.mapData.mapId || this.children.map((t => t.object3d.visible = !0)),
        this.manyFloorMode && (this.object3d.position.setZ(0),
          this.map.status.manyFloorMode = !1,
          this.map.recoverAmapFeatures(),
          this.map.outerFloor && this.map.add(this.map.outerFloor),
          this.manyFloorMode = !1,
          this.children.slice().map((t => {
            t.object3d.position.setZ(0),
              t.data.id !== this.curentFloor.data.id && t.removeFromParent()
          }
          )),
          null === (t = this.crossFloorLine) || void 0 === t || t.dispose(),
          this.children.map((t => t.addFloorTitle && t.addFloorTitle())))
    }
    getFloorById(t) {
      return this.children.find((e => e.data.id === t))
    }
  }
  var rg = Object.prototype.hasOwnProperty
    , og = Object.keys || function (t) {
      var e, i = [];
      for (e in t)
        rg.call(t, e) && i.push(e);
      return i
    }
    ;
  function sg(t) {
    var e = {}
      , i = 0;
    function n(t) {
      return 0 === t.length ? [] : 0 === t[0] || "number" != typeof t[0] ? function (t) {
        for (var e = t.length, i = [], n = 0 === t[0] ? 1 : 0; n < e; n++) {
          var o = t[n]
            , s = r(o);
          ag(o) && Array.isArray(s) ? i = i.concat(s) : i.push(s)
        }
        return i
      }(t) : function (t) {
        var i, n = e[t[0]], o = n.length, s = (t.length - 1) / o;
        if (s > 1) {
          i = [];
          for (var a = 0; a < s; a++) {
            var l = {};
            for (let e, i = 0; e = n[i++];)
              l[e] = r(t[a * o + i]);
            i.push(l)
          }
        } else {
          i = {};
          for (let e, o = 0; e = n[o++];)
            i[e] = r(t[o])
        }
        return i
      }(t)
    }
    function r(t) {
      return "object" == typeof t && t ? Array.isArray(t) ? n(t) : function (t) {
        var n = og(t).sort();
        if (0 === n.length)
          return {};
        e[++i] = n;
        for (var o, s = {}, a = 0; o = n[a++];)
          s[o] = r(t[o]);
        return s
      }(t) : t
    }
    return r(t)
  }
  function ag(t) {
    return Array.isArray(t) && "number" == typeof t[0] && 0 !== t[0]
  }
  let lg, hg, cg = {
    UNCERTAIN: 0,
    STATIC: 1,
    WALKING: 2,
    RUN: 3,
    DRIVING: 4
  }, ug = {
    HOLD: 0,
    OTHER: 1
  }, pg = cg.UNCERTAIN, dg = ug.HOLD, fg = 0, gg = {
    t: fg,
    stepDetected: !1,
    step: null,
    phonePlacement: dg,
    motionState: pg,
    turnDetected: !1,
    turnAngle: 0
  }, mg = 25, yg = new Array(mg), vg = 0, Ag = [], bg = 4e3, xg = 5e3, Ig = 0, Cg = 0, wg = 0, _g = [], Sg = 0, Mg = 100, Tg = 0, Eg = 100, kg = {
    peak: 0,
    valley: 100,
    pvDiff: 0
  }, Rg = 4, Lg = !1, Pg = 0, zg = 0, Og = 10.5, Dg = 2, Ug = 330, Ng = 200, Fg = 1500, Bg = (new Date).getTime(), jg = 0, Vg = .65, Gg = null, Wg = [], Jg = [];
  function Hg(t) {
    if (t.gravity && t.accelerationIncludingGravity) {
      var e = t.gravity;
      AMap.Browser.ios && e && (e.x = -e.x,
        e.y = -e.y,
        e.z = -e.z),
        i = t.timestamp,
        n = t.accelerationIncludingGravity,
        r = function (t, e, i, n) {
          if (0 === e.x && 0 === e.y && 0 === e.z)
            return gg;
          var r = Math.sqrt(e.x * e.x + e.y * e.y + e.z * e.z)
            , o = yg[(vg - 1 + mg) % mg];
          (function (t, e, i) {
            if (e) {
              e.t = t;
              var n = Math.sqrt(e.x * e.x + e.y * e.y + e.z * e.z)
                , r = Math.sqrt(e.x * e.x + e.y * e.y);
              for (e.norm = n,
                e.gxy_norm = r,
                Ag.push(e); Ag.length > 0 && t - Ag[0].t > xg;)
                Ag.shift();
              var o = Ag.length;
              o > 250 && (Ag = Ag.slice(o - 250, o)),
                yg[vg] = i,
                vg = (vg + 1) % mg
            }
          }
          )(t, i, r),
            t - fg >= 5e3 && function (t) {
              var e = Ag.filter((e => e.t >= t - Fg))
                , i = dg
                , n = dg;
              if (e.length > 0) {
                var r = e.length
                  , o = (e.map((function (t) {
                    return t.y
                  }
                  )).reduce((function (t, e) {
                    return t + e
                  }
                  ), 0),
                    e.map((function (t) {
                      return t.z
                    }
                    )).reduce((function (t, e) {
                      return t + e
                    }
                    ), 0) / r);
                o = Math.abs(o);
                var s = e.map((function (t) {
                  return t.norm
                }
                )).reduce((function (t, e) {
                  return t + e
                }
                ), 0) / r
                  , a = Qg(e.map((function (t) {
                    return t.gxy_norm
                  }
                  )));
                i === ug.HOLD ? (o < 5.886 && a > 3 || a > 4) && (n = ug.OTHER) : i === ug.OTHER && a < 2.5 && s > 8.81 && s < 10.81 && o > 4.4145 && (n = ug.HOLD)
              }
              dg = n
            }(t);
          var s, a = function (t, e, i, n) {
            var r = !1;
            return Og = null === n ? 11.1 : 10.7,
              0 !== wg && kg.pvDiff > Dg && t - wg > Ng && wg - Ig > Ug && (Ig = wg,
                r = !0),
              e < Mg && (Mg = e,
                Tg = t),
              Eg = t - Sg < 2 * Ug && Sg > Ig && hg < Mg ? hg : Mg,
              0 !== i && 1 === function (t, e, i) {
                var n = Lg
                  , r = 0;
                return e > i ? (Lg = !0,
                  Pg++) : e < i && (zg = Pg,
                    Pg = 0,
                    Lg = !1),
                  i > Og && !Lg && n && (zg >= 1 || i >= 12) && (r = 1),
                  r
              }(0, e, i) && i - Eg > 1.3 && (t - wg > Ng && (Dg = function (t) {
                var e = Dg;
                return _g.length >= Rg && _g.shift(),
                  _g.push(t),
                  _g.length === Rg && (e = function (t) {
                    var e = t.reduce((function (t, e) {
                      return t + e
                    }
                    ), 0) / Rg;
                    return e >= 8 ? 4.3 : e >= 7 && e < 8 ? 3.3 : e >= 4 && e < 7 ? 2.3 : e >= 3 && e < 4 ? 2 : 1.7
                  }(_g)),
                  e
              }(i - Eg),
                hg = Mg,
                Sg = Tg,
                Mg = 100,
                wg = t,
                kg = {
                  peak: i,
                  valley: Eg,
                  pvDiff: i - Eg
                }),
                t - wg <= Ng && i > kg.peak && (wg = t,
                  Eg = Eg < kg.valley ? Eg : kg.valley,
                  kg = {
                    peak: i,
                    valley: Eg,
                    pvDiff: i - Eg
                  })),
              r
          }(t, r, o, n), l = {
            turnDetected: !1,
            turnAngle: 0
          };
          if (a) {
            for (s = {
              t: t,
              stepLen: Vg,
              heading: Gg
            },
              Wg.push(s),
              Jg.push(s); Jg.length > 0 && t - Jg[0].t > 4e3 || Jg.length > 6;)
              Jg.shift();
            (l = function (t) {
              var e = {
                turnDetected: !1,
                turnAngle: 0
              };
              if (t.length <= 1)
                return e;
              for (var i = t[t.length - 1], n = 0, r = t.length - 2; r >= 0; r--) {
                var o = Zg(i, t[r]);
                Math.abs(o) > Math.abs(n) && (n = o)
              }
              return Math.abs(n) >= 45 && Math.abs(i - t[t.length - 2]) < 15 && (e = {
                turnDetected: !0,
                turnAngle: n
              }),
                e
            }(Jg.map((function (t) {
              return t.heading
            }
            )))).turnDetected && Jg.length > 2 && (Jg = Jg.slice(Jg.length - 2, Jg.length))
          }
          for (; Wg.length > 0 && t - Wg[0].t > bg;)
            Wg.shift();
          return pg = function (t, e, i) {
            if (t - Bg >= 500) {
              Bg = t;
              var n = pg;
              Cg = e.length / bg * 1e3;
              var r = Qg(i);
              n === cg.UNCERTAIN || n === cg.STATIC ? Cg >= 1 && r > 1 && (pg = cg.WALKING) : n === cg.WALKING && Cg <= .75 && r < .7 && (pg = cg.STATIC)
            }
            return pg
          }(t, Wg, yg),
            gg = Object.assign({
              t: t,
              stepDetected: a,
              step: s,
              phonePlacement: dg,
              motionState: pg
            }, l),
            gg
        }(i, n, e, lg),
        r && (pg = r.motionState,
          r.step && (r.t,
            jg += 1),
          void 0 !== (o = r.phonePlacement) && (dg = o))
    }
    var i, n, r, o;
    return gg
  }
  function Zg(t, e) {
    var i = t - e;
    return i >= 180 && (i -= 360),
      i <= -180 && (i += 360),
      i
  }
  function Qg(t) {
    var e = function (t, e) {
      return t + e
    }
      , i = t.reduce(e, 0) / t.length
      , n = t.map((function (t) {
        return t - i
      }
      ));
    return Math.sqrt(n.map((function (t) {
      return t * t
    }
    )).reduce(e, 0) / (t.length - 1))
  }
  let Kg = {
    x: 0,
    y: 0,
    z: 0
  };
  let Yg = [];
  function qg() {
    return /(Android)/i.test(navigator.userAgent) ? 1 : /(iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent) ? 2 : 3
  }
  function Xg(t, e) {
    var i = {};
    return t instanceof Array ? (i.x = t[0],
      i.y = t[1]) : t instanceof Object ? i = t : (i.x = t,
        i.y = e),
      i
  }
  window.$testDataArr = Yg;
  var $g = Math.PI / 180
    , tm = 180 / Math.PI
    , em = 20037508.342789244;
  function im(t, e) {
    var i = [t, e];
    t instanceof Array ? i = t : t instanceof Object && (i = [t.x, t.y]);
    var n = i[0] / em * 180
      , r = i[1] / em * 180;
    return {
      lng: n,
      lat: r = tm * (2 * Math.atan(Math.exp(r * $g)) - Math.PI / 2)
    }
  }
  class nm {
    constructor(t) {
      this.app = t,
        this.beaconCacheTime = 2e3,
        1 === qg() && (this.beaconCacheTime = 5e3),
        this.locFloor = null,
        this.__PRIORITY_FLOOR__ = null,
        this.__CACHE_POOL__ = [],
        this.__FLOOR_CHANGE__ = []
    }
    filterBeacon(t) {
      var e = +new Date;
      for (var i in this.__CACHE_POOL__) {
        var n = this.__CACHE_POOL__[i];
        Math.abs(e - n.time) > this.beaconCacheTime && delete this.__CACHE_POOL__[i]
      }
      t.forEach((t => {
        this.__CACHE_POOL__[t.major + "_" + t.minor] = Object.assign({
          time: e
        }, t)
      }
      ));
      var r = [];
      for (var o in this.__CACHE_POOL__)
        r.push(this.__CACHE_POOL__[o]);
      return this.filterFloor(r)
    }
    filterFloor(t) {
      t.sort((function (t, e) {
        return e.rssi - t.rssi
      }
      ));
      for (var e = {
        beacons: [],
        floor: null
      }, i = {
        beacons: [],
        floor: null
      }, n = 0, r = 0; r < t.length; r++) {
        var o = t[r]
          , s = o.floor;
        if (this.locFloor = this.locFloor || s,
          0 === n)
          s === this.locFloor ? (e.beacons.push(o),
            e.floor = s) : (i.beacons.push(o),
              i.floor = s);
        else if (s === this.locFloor) {
          if (i.floor) {
            if (i.beacons[0].rssi - o.rssi > 8)
              continue;
            i.beacons = [],
              i.floor = null
          }
          e.beacons.push(o),
            e.floor = s
        } else
          s === i.floor && i.beacons.push(o);
        n++
      }
      return i.floor ? this._changeFloorCount++ : (this._changeFloorCount--,
        this._changeFloorCount < 0 && (this._changeFloorCount = 0)),
        this._changeFloorCount >= this.app.floorDelay / 1e3 && (e = i,
          this._changeFloorCount = 0),
        this.locFloor = e.floor,
        e.beacons
    }
    calcPos(t) {
      if (0 === t.length)
        return null;
      for (var e, i, n, r = Math.min(t.length, 6), o = [], s = 0, a = 0, l = 0, h = 0; h < r; h++)
        e = t[h],
          s += i = 1 / Math.pow(e.accuracy, 2),
          o.push(i);
      for (let e = 0; e < o.length; e++)
        a += (n = t[e]).x * o[e],
          l += n.y * o[e];
      return {
        x: a / s,
        y: l / s,
        floor: this.locFloor
      }
    }
    analyze(t) {
      return this.calcPos(this.filterBeacon(t))
    }
    reset() {
      this.__CACHE_POOL__ = [],
        this.locFloor = null
    }
  }
  function rm(t) {
    function e(e) {
      if (t.deviceOrientation = e,
        "number" == typeof e.alpha) {
        var n = (i ? e.webkitCompassHeading : 360 - e.alpha) - t.initAngle - t.arOffsetAngle;
        t._compass = i ? e.webkitCompassHeading : 360 - e.alpha,
          t.emit("__compass__", n),
          t.compassData = {
            alpha: n,
            beta: e.beta,
            gamma: e.gamma
          }
      }
    }
    this.$beaconsHeading = 0;
    var i = 2 === qg();
    let n = i ? "deviceorientation" : "deviceorientationabsolute";
    window.addEventListener(n, e, !1),
      this.reset = function () {
        window.removeEventListener(n, e, !1),
          window.addEventListener(n, e, !1)
      }
  }
  function om(t) {
    var e, i = this, n = 0, r = 0, o = !1;
    function s(i) {
      var o, s, a, l;
      let h = function (t) {
        "x" in t && (t = {
          accelerationIncludingGravity: t
        });
        let e, i = Date.now(), n = t.acceleration, r = t.acceleration;
        if (n && n.x && n.y && n.z)
          t.accelerationIncludingGravity && t.accelerationIncludingGravity.x && t.accelerationIncludingGravity.y && t.accelerationIncludingGravity.z && (e = {
            x: t.accelerationIncludingGravity.x - n.x,
            y: t.accelerationIncludingGravity.y - n.y,
            z: t.accelerationIncludingGravity.z - n.z
          });
        else {
          if (!(t.accelerationIncludingGravity && t.accelerationIncludingGravity.x && t.accelerationIncludingGravity.y && t.accelerationIncludingGravity.z))
            return;
          r = t.accelerationIncludingGravity,
            Kg.x = .9 * Kg.x + .1 * t.accelerationIncludingGravity.x,
            Kg.y = .9 * Kg.y + .1 * t.accelerationIncludingGravity.y,
            Kg.z = .9 * Kg.z + .1 * t.accelerationIncludingGravity.z,
            e = Kg,
            (n = {
              x: 0,
              y: 0,
              z: 0
            }).x = t.accelerationIncludingGravity.x - Kg.x,
            n.y = t.accelerationIncludingGravity.y - Kg.y,
            n.z = t.accelerationIncludingGravity.z - Kg.z
        }
        let o = t.accelerationIncludingGravity;
        return t.accelerationIncludingGravity && t.accelerationIncludingGravity.x && t.accelerationIncludingGravity.y && t.accelerationIncludingGravity.z || (o = {
          x: 0,
          y: 0,
          z: 0
        }),
        {
          timestamp: i,
          acc: r,
          linearAcc: n,
          gravity: e,
          accelerationIncludingGravity: o
        }
      }(i)
        , c = h && Hg(h);
      (null == c ? void 0 : c.stepDetected) && c.step && (console.log(c.motionState, c.phonePlacement),
        r++);
      let u = null === (s = t.map.getMapDataById(null === (o = t._lastLocatePoint) || void 0 === o ? void 0 : o.floor)) || void 0 === s ? void 0 : s.name;
      Md && window.$testMsg && window.$testMsg(0, "最强Rssi: " + t.lastBeaconBestRssi + "-蓝牙(20:弱-20:强):" + t.lt_78Count + "\n, 最强Gps: " + (null === (a = t.gpsAccuracy) || void 0 === a ? void 0 : a.toFixed(2)) + "-楼层: " + u + "-" + t.beaconsLength + "\n, 定位距离:" + (null === (l = t.locOffset.dis) || void 0 === l ? void 0 : l.toFixed(2)) + "-步行倍速:" + t.stepSpeed + "-" + r),
        (e = +new Date) - n >= t.inertanceDelay && (n = e,
          t.emit("__step__", r),
          r = 0)
    }
    this.open = function () {
      o = !0,
        window.addEventListener("devicemotion", s, !1)
    }
      ,
      this.close = function () {
        o = !1,
          window.removeEventListener("devicemotion", s, !1)
      }
      ,
      this.reset = function () {
        o && (i.close(),
          i.open())
      }
  }
  function sm(t) {
    var e, i, n = 4;
    function r() {
      t.emit("rssi", n),
        n = n - 1 < 0 ? 0 : n--,
        e = setTimeout(r, 3e3)
    }
    this.analyze = function (t) {
      e && clearTimeout(e),
        (t = t.beacons || t).length <= 2 ? i ? Date.now() - i >= 3e3 && (i = null,
          n = t.length) : i = +Date.now() : (i = null,
            n = Math.min(4, t.length)),
        r()
    }
  }
  function am() {
    return new Promise((function (t, e) {
      DeviceMotionEvent.requestPermission().then((function (e) {
        "granted" === e && t(e)
      }
      )).catch((function (t) {
        e(t)
      }
      ))
    }
    ))
  }
  var lm = {
    PI: 3.141592653589793,
    x_pi: 52.35987755982988,
    rectify: function (t, e) {
      if (this.outOfChina(t, e))
        return {
          lat: t,
          lng: e
        };
      var i = this.delta(t, e);
      return {
        lat: t + i.lat,
        lng: e + i.lng
      }
    },
    delta: function (t, e) {
      var i = .006693421622965943
        , n = this.toLat(e - 105, t - 35)
        , r = this.toLng(e - 105, t - 35)
        , o = t / 180 * this.PI
        , s = 1 - i * (s = Math.sin(o)) * s
        , a = Math.sqrt(s);
      return {
        lat: n = 180 * n / (6378245 * (1 - i) / (s * a) * this.PI),
        lng: r = 180 * r / (6378245 / a * Math.cos(o) * this.PI)
      }
    },
    outOfChina: function (t, e) {
      return e < 72.004 || e > 137.8347 || t < .8293 || t > 55.8271
    },
    toLat: function (t, e) {
      var i = 2 * t - 100 + 3 * e + .2 * e * e + .1 * t * e + .2 * Math.sqrt(Math.abs(t));
      return i += 2 * (20 * Math.sin(6 * t * this.PI) + 20 * Math.sin(2 * t * this.PI)) / 3,
        (i += 2 * (20 * Math.sin(e * this.PI) + 40 * Math.sin(e / 3 * this.PI)) / 3) + 2 * (160 * Math.sin(e / 12 * this.PI) + 320 * Math.sin(e * this.PI / 30)) / 3
    },
    toLng: function (t, e) {
      var i = 300 + t + 2 * e + .1 * t * t + .1 * t * e + .1 * Math.sqrt(Math.abs(t));
      return i += 2 * (20 * Math.sin(6 * t * this.PI) + 20 * Math.sin(2 * t * this.PI)) / 3,
        (i += 2 * (20 * Math.sin(t * this.PI) + 40 * Math.sin(t / 3 * this.PI)) / 3) + 2 * (150 * Math.sin(t / 12 * this.PI) + 300 * Math.sin(t / 30 * this.PI)) / 3
    }
  };
  function hm(t) {
    var e, i = this, n = !0;
    this.connect = function () {
      return n = !0,
        navigator.geolocation ? e = navigator.geolocation.watchPosition((function (e) {
          var i;
          n && (i = {
            current: lm.rectify(e.coords.latitude, e.coords.longitude),
            originGps: {
              lng: e.coords.longitude,
              lat: e.coords.latitude,
              accuracy: e.coords.accuracy,
              speed: e.coords.speed
            }
          },
            t.emit("__GPS__", i))
        }
        ), (function (t) {
          console.debug(t)
        }
        ), {
          maximumAge: 0,
          timeout: 3e4,
          enableHighAccuracy: !0
        }) : console.debug("不支持获取GPS地理位置"),
        i
    }
      ,
      this.disconnect = function () {
        return n = !1,
          navigator.geolocation && e && (navigator.geolocation.clearWatch(e),
            e = null),
          i
      }
  }
  class cm extends Se {
    get signal() {
      return this.lastBeaconBestRssi > -78 ? "rssi" : this.gpsAccuracy < 6 ? "GPS" : void 0
    }
    constructor(t) {
      super(),
        this.debug = !1,
        this.isAuth = !0,
        this.gps = !1,
        this.gpsAccuracy = 30,
        this.inertance = !0,
        this.lastBeaconBestRssi = -99,
        this.lt_78Count = 3,
        this.minIndoorRssiLimit = -78,
        this.locOffset = {
          set pos(t) {
            this._pos.unshift(Object.assign({}, t)),
              this._pos.splice(5, 1)
          },
          get pos() {
            let t = this._pos.reduce(((t, e) => (t.x += e.x,
              t.y += e.y,
              t)), {
              x: 0,
              y: 0
            });
            return t.x /= this._pos.length,
              t.y /= this._pos.length,
              t
          },
          _pos: [],
          locPos: new Fe,
          dis: 0,
          type: "rssi"
        },
        this.stepSpeed = 1,
        this.minRssi = -78,
        this.maxRssi = -15,
        this.compassDelay = 200,
        this.inertanceDelay = 500,
        this.floorDelay = 2e3,
        this.initAngle = 0,
        this.arOffsetAngle = 0,
        this.GPSMinAccuracy = 1e4,
        this.rssiCount = 0,
        this.map = t.map,
        this.setOptions(t),
        this.handleHashChange(),
        setTimeout((() => {
          this.resetDevice(),
            setTimeout((() => {
              this.resetDevice()
            }
            ), 3e3)
        }
        ), 3e3)
    }
    init(t) {
      let e = [];
      for (var i = 0; i < t.length; i++) {
        let n = t[i];
        e[n.major + "_" + n.minor] = n
      }
      this.BEACON_DATA = [],
        this.BEACON_DATA = e,
        this.emit("ready"),
        this.$analyze = new nm(this),
        this.$compass = new rm(this),
        this.$acc = new om(this),
        this.bTFilter = new sm(this),
        this.$gps = new hm(this),
        this.gps && this.$gps.connect(),
        this.inertance && this.$acc.open(),
        this.CUR_COMPASS = 0,
        this.on("__compass__", (t => {
          this.emit("compass", this.CUR_COMPASS = t),
            Md && Yg.push({
              compass: t,
              time: Date.now()
            })
        }
        )),
        this.on("__step__", (t => {
          var e;
          if (Md && Yg.push({
            step: t,
            time: Date.now()
          }),
            !this._lastLocatePoint || !this.map.navi.status.isNavi)
            return;
          if (!t || this.enterStairLock)
            return Ld("进入梯锁住定位点"),
              this.emit("__location__", Object.assign({}, this._lastLocatePoint, {
                type: "step"
              }));
          let i = this._lastLocatePoint.x
            , n = this._lastLocatePoint.y
            , r = this.CUR_COMPASS
            , o = ("rssi" == this.locOffset.type ? .9 : 1) * t * this.stepSpeed
            , s = r * Math.PI / 180
            , a = {
              x: i += Math.sin(s) * o,
              y: n += Math.cos(s) * o
            };
          this._lastLocatePoint.x = a.x,
            this._lastLocatePoint.y = a.y,
            this.locOffset.dis > ("1" === (null === (e = this._lastLocatePoint) || void 0 === e ? void 0 : e.floor) ? 35 : 20) && (this._lastLocatePoint.x = this.locOffset.locPos.x,
              this._lastLocatePoint.y = this.locOffset.locPos.y),
            this.emit("__location__", Object.assign({}, this._lastLocatePoint, {
              type: "step"
            })),
            this.emit("pedometer", t)
        }
        )),
        this.on("__GPS__", (t => {
          if (this.gpsAccuracy = t.originGps.accuracy,
            this.lt_78Count < 0)
            return;
          if (this.lastBeaconBestRssi > this.minIndoorRssiLimit && this.gpsAccuracy > 10)
            return;
          if (this.hasBeacon && this.gpsAccuracy > 20)
            return;
          var e;
          let i = t.current || t;
          if (i instanceof Array ? e = i : i instanceof Object && (e = [i.lng, i.lat]),
            this._lastLocatePoint = this._lastLocatePoint || {},
            this.map.navi.status.isNavi) {
            if (t.originGps.accuracy < 10 && "1" == this._lastLocatePoint.floor) {
              let t = new Fe(e[0] * em / 180, Math.log(Math.tan((90 + e[1]) * $g / 2)) / $g * em / 180);
              this.locOffset.locPos.x || this.locOffset.locPos.copy(t);
              let i = t.distanceTo(this.locOffset.locPos) || 1
                , n = Math.min(1 / i, .5);
              this.locOffset.locPos.set(this.locOffset.locPos.x * (1 - n) + t.x * n, this.locOffset.locPos.y * (1 - n) + t.y * n),
                this.locOffset.dis = this.locOffset.locPos.distanceTo(this._lastLocatePoint),
                this.locOffset.type = "GPS";
              let r = t.sub(this._lastLocatePoint);
              this.locOffset.pos = r
            }
          } else
            this._lastLocatePoint.x = e[0] * em / 180,
              this._lastLocatePoint.y = Math.log(Math.tan((90 + e[1]) * $g / 2)) / $g * em / 180,
              this.locOffset.locPos.copy(this._lastLocatePoint);
          this._lastLocatePoint.floor = "1",
            this._lastLocatePoint.GPS = !0,
            this.emit("__location__", Object.assign({}, this._lastLocatePoint, {
              type: "GPS",
              originGps: t.originGps
            }))
        }
        )),
        this.on("__location__", (t => {
          var e, i, n;
          t && (e = "x" in t ? Object.assign({}, t, im(t.x, t.y)) : Object.assign({}, t, (i = t.lng,
            n = t.lat,
          {
            x: i * em / 180,
            y: Math.log(Math.tan((90 + n) * $g / 2)) / $g * em / 180
          })),
            this.emit("location", e),
            this.debug)
        }
        )),
        this.isAuth && new Promise((function (t, e) {
          var i, n, r, o = function (e) {
            t({
              message: "success",
              e: e
            })
          }, s = function (t) {
            e({
              message: "error",
              e: t
            })
          };
          2 === qg() ? window.__IOS_DEVICE_MOTION_AUTH_CALLBACK__ ? window.__IOS_DEVICE_MOTION_AUTH_CALLBACK__(t, e) : (window.__IOS_DEVICE_MOTION_AUTH_CALLBACK__ = function (i, n) {
            o = function (e) {
              var n = {
                message: "success",
                e: e
              };
              t(n),
                i(n),
                window.__IOS_DEVICE_MOTION_AUTH_CALLBACK__ = null
            }
              ,
              s = function (t) {
                var i = {
                  message: "error",
                  e: t
                };
                e(i),
                  n(i),
                  window.__IOS_DEVICE_MOTION_AUTH_CALLBACK__ = null
              }
          }
            ,
            i = function () {
              var t = document.createElement("div");
              t.innerHTML = '\n            <div style="position: fixed; left: 0; right: 0; top: 0; bottom: 0; z-index: 999999; background-color: rgba(0, 0, 0, .5); display: flex; flex-direction: column; align-items: center; justify-content: center;">\n                <div style="width: 60%; max-width: 360px; background-color: #ffffff; border-radius: 8px; overflow: hidden; padding: 20px; text-align: center;">\n                    <div style="font-size: 0;"><img height="50" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHEAAAB8CAYAAABe4F8OAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyVpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDYuMC1jMDAyIDc5LjE2NDQ2MCwgMjAyMC8wNS8xMi0xNjowNDoxNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDIxLjIgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NUM3RjcxOEY1NkREMTFFQkJGOTRCRkU0NDg3Q0U5ODYiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NUM3RjcxOTA1NkREMTFFQkJGOTRCRkU0NDg3Q0U5ODYiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo1QzdGNzE4RDU2REQxMUVCQkY5NEJGRTQ0ODdDRTk4NiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo1QzdGNzE4RTU2REQxMUVCQkY5NEJGRTQ0ODdDRTk4NiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pv4JStIAAAhJSURBVHja7J1p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" alt="" /></div>\n                    <div style="font-size: 16px; color: #666666; font-weight: bold; margin-top: 10px;">系统需开启权限</div>\n                    <div style="border-top: 1px solid #dddddd; margin-top: 20px; padding: 10px 0">\n                        <div style="font-size: 14px; color: #999999; padding: 10px 0">指南针数据<span style="font-size: 13px; color: #cccccc; margin-left: 10px;">(运动方向)</span></div>\n                    </div>\n                </div>\n            </div>\n        ';
              var e = document.createElement("div");
              return e.setAttribute("style", "margin: 0 auto; width: 100px; padding: 8px 0; border-radius: 30px; background-color: #0099FF; color: #ffffff; font-size: 14px;"),
                e.innerHTML = "开启",
                t.children[0].children[0].appendChild(e),
              {
                $dom: t,
                $button: e
              }
            }(),
            n = i.$dom,
            r = i.$button,
            window.DeviceMotionEvent && "function" == typeof DeviceMotionEvent.requestPermission ? am().then((function (t) {
              o(t)
            }
            )).catch((function () {
              document.body.appendChild(n),
                r.addEventListener("click", (function () {
                  document.body.removeChild(n),
                    am().then((function (t) {
                      o(t)
                    }
                    )).catch((function (t) {
                      s(t)
                    }
                    ))
                }
                ), !1)
            }
            )) : s({})) : o({})
        }
        )).then((t => {
          this.resetDevice()
        }
        ))
    }
    _calculate(t) {
      var e, i, n;
      if (0 === t.length)
        return;
      this.emit("beacons", t),
        this.GPSMinAccuracy = 30,
        this.bTFilter.analyze(t);
      const r = this.$analyze.analyze(t);
      if (this._lastLocatePoint = this._lastLocatePoint || r,
        r) {
        if (r.floor === this._lastLocatePoint.floor) {
          if (this._offsetScale || (this._offsetScale = .1),
            i = r,
            n = this._lastLocatePoint,
            i = Xg(i),
            n = Xg(n),
            Math.sqrt((i.x - n.x) * (i.x - n.x) + (i.y - n.y) * (i.y - n.y)) > 2) {
            if (this._offsetScale = Math.min(this._offsetScale, .5),
              n = this._lastLocatePoint,
              e = this._offsetScale,
              this.map.navi.status.isNavi) {
              this.locOffset.locPos.x || this.locOffset.locPos.copy(r);
              let t = .2;
              this.locOffset.locPos.set(this.locOffset.locPos.x * (1 - t) + r.x * t, this.locOffset.locPos.y * (1 - t) + r.y * t),
                this.locOffset.dis = this.locOffset.locPos.distanceTo(this._lastLocatePoint),
                this.locOffset.type = "rssi"
            } else
              this._lastLocatePoint = {
                x: n.x * (1 - e) + r.x * e,
                y: n.y * (1 - e) + r.y * e
              },
                this.locOffset.locPos.copy(this._lastLocatePoint);
            this._offsetScale += .05
          } else
            this._offsetScale = .1
        } else
          this.map.navi.status.isNavi ? "1" != this._lastLocatePoint.floor && r.floor : this._lastLocatePoint = r || this._lastLocatePoint || {};
        this._lastLocatePoint.floor = r.floor,
          this.emit("__location__", Object.assign({}, this._lastLocatePoint, {
            type: "rssi",
            beaconPoint: Object.assign({}, r, im(r.x, r.y))
          }))
      }
    }
    handleHashChange() {
      window.addEventListener("hashchange", (t => {
        let { appData: e } = Fd(location.href);
        e && (e = decodeURIComponent(e),
          e = JSON.parse(e),
          Date.now() - e.time > 2e3 || (e.beacon && (Md && Yg.push({
            beacon: e.beacon,
            time: Date.now()
          }),
            this.beaconAnalysis(e.beacon)),
            e.gps && (this.$gps.disconnect(),
              this.emit("__GPS__", {
                type: "GPS",
                GPS: !0,
                originGps: e.gps,
                lng: e.gps.gcjLon,
                lat: e.gps.gcjLat,
                floor: "1"
              })),
            history.back()))
      }
      ))
    }
    beaconAnalysis(t) {
      var e;
      t[0] && (this.beaconsLength = t.length,
        t = this.filterBeacons(t, this.BEACON_DATA, this.minRssi, this.maxRssi),
        this.beaconsLength = this.beaconsLength + "-" + t.length),
        t.length && !this.hasBeacon && (this.hasBeacon = !0),
        this.lastBeaconBestRssi = (null === (e = t[0]) || void 0 === e ? void 0 : e.rssi) || -97,
        this.lastBeaconBestRssi > this.minIndoorRssiLimit ? this.lt_78Count = Math.max(--this.lt_78Count, -20) : this.lt_78Count = Math.min(++this.lt_78Count, 20),
        clearTimeout(this.beaconAnalysisTimer),
        this.beaconAnalysisTimer = setTimeout((() => {
          this.lastBeaconBestRssi = -96,
            this.lt_78Count = 5
        }
        ), 8e3),
        this.lt_78Count > 0 || (this.emit("beaconFilterList", JSON.parse(JSON.stringify(t))),
          this._calculate(t || []))
    }
    filterBeacons(t, e, i, n) {
      (t = t.beacons || t || []).sort(((t, e) => e.rssi - t.rssi));
      for (var r = [], o = 0; o < t.length; o++) {
        var s = t[o]
          , a = s.major + "_" + s.minor;
        if (s.rssi = +s.rssi,
          s.accuracy = +s.accuracy,
          e[a] && !(s.accuracy <= 0 || s.rssi > n)) {
          if (s.rssi < i)
            break;
          var l = e[a];
          r.push({
            major: l.major,
            minor: l.minor,
            rssi: s.rssi,
            accuracy: s.accuracy,
            x: l.x,
            y: l.y,
            floor: l.floor
          })
        }
      }
      return r
    }
    reset() {
      this.$analyze.reset()
    }
    resetDevice() {
      this.$compass.reset(),
        this.$acc.reset()
    }
    setOptions(t) {
      for (var e in t)
        void 0 !== this[e] && void 0 !== t[e] && null !== t[e] && "" !== t[e] && (this[e] = t[e])
    }
  }
  var um = "data:image/png;base64,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";
  function pm() {
    let t, e;
    const i = {};
    let n;
    const r = {};
    let o;
    function s(i, n, r, o, s) {
      for (const a in n.ids) {
        let l = +n.ids[a];
        if (l === e.block)
          continue;
        let h = r.find((t => +t.id == +a));
        h && (l === +s || l === +t.indoor ? i[h.id] = 20 : l !== +o && l !== e.manCar || (i[h.id] = Math.sqrt(Math.pow(n.x - h.x, 2) + Math.pow(n.y - h.y, 2))))
      }
    }
    function a(t, e, i, n, r, o) {
      var s, a, l = r - i, h = o - n, c = l * l + h * h, u = -1;
      0 !== c && (u = ((t - i) * l + (e - n) * h) / c),
        u < 0 ? (s = i,
          a = n) : u > 1 ? (s = r,
            a = o) : (s = i + u * l,
              a = n + u * h);
      var p = t - s
        , d = e - a;
      return {
        v2: {
          x: s,
          y: a
        },
        distance: Math.sqrt(p * p + d * d)
      }
    }
    onmessage = ({ data: l }) => {
      "init" === l.fn ? function (a) {
        n = a.path,
          t = a.lineTypeData.EnterType,
          e = a.lineTypeData.CrossType,
          o = n.find((t => -1 == +t.id)),
          n.map((t => {
            void 0 !== t.floorId && (r[t.floorId] = r[t.floorId] || [],
              r[t.floorId].push(t))
          }
          )),
          function (n) {
            let r = Object.values(e).filter((t => "number" == typeof t && t !== e.block))
              , o = Object.values(t).filter((e => "number" == typeof e && e !== t.indoor));
            r.map((t => {
              o.map((e => {
                i[`${t},${e}`] = function (t, e, i) {
                  let n = {};
                  return i.forEach((r => {
                    n[r.id] = {},
                      s(n[r.id], r, i, t, e)
                  }
                  )),
                    n
                }(t, e, n)
              }
              ))
            }
            ))
          }(n),
          postMessage({
            _id: a._id
          })
      }(l) : "setLocationMyPosition" === l.fn ? function (t) {
        let r = t.myPositionPath;
        for (const t in r)
          o[t] = r[t];
        Object.keys(i).map((t => {
          const r = i[t]
            , [, a] = t.split(",");
          r[-1] = {},
            s(r[-1], o, n, e.manCar, a)
        }
        )),
          postMessage({
            _id: t._id
          })
      }(l) : "location2Path" === l.fn ? function ({ point: t, path: i, floorId: n, _id: o, location2PathType: s, remainDistance: l, routeDistance: h }) {
        let c = {
          distance: void 0,
          x: 0,
          y: 0,
          ids: {}
        };
        if (!(i = i || r[n]) || !i.length)
          return postMessage({
            _id: o,
            min: c
          });
        if ("myPos" == s) {
          let n = (t, e) => t > e ? `${e},${t}` : `${t},${e}`
            , r = {};
          i.forEach(((o, s) => {
            if (!(o.id < 0))
              for (const s in o.ids) {
                if (o.ids[s] <= 0)
                  continue;
                let l = n(s, o.id);
                if (r[l])
                  continue;
                let h = i.find((t => +t.id == +s));
                if (h) {
                  const { distance: i, v2: n } = a(t.x, t.y, o.x, o.y, h.x, h.y);
                  (void 0 === c.distance || i < c.distance) && (c.distance = i,
                    c.x = n.x,
                    c.y = n.y,
                    c.ids = {},
                    c.ids[o.id] = c.ids[s] = e.manCar)
                }
                r[l] = 1
              }
          }
          ))
        } else {
          let n = h - l
            , r = []
            , o = 0;
          i.forEach(((s, l) => {
            let h = i[l + 1];
            if (h) {
              const { distance: u, v2: p } = a(t.x, t.y, s.x, s.y, h.x, h.y);
              if ((void 0 === c.distance || u < c.distance) && (c.distance = u,
                c.x = p.x,
                c.y = p.y,
                c.ids = {},
                c.ids[s.id] = c.ids[h.id] = e.manCar),
                l) {
                let t = i[l - 1];
                o += Math.sqrt(Math.pow(t.x - s.x, 2) + Math.pow(t.y - s.y, 2))
              }
              let d = Math.sqrt(Math.pow(p.x - s.x, 2) + Math.pow(p.y - s.y, 2))
                , f = o + d;
              r.push(Object.assign(Object.assign({
                distance: u,
                passLength: f,
                disToLoction: n - f
              }, p), {
                ids: {
                  [s.id]: e.manCar,
                  [h.id]: e.manCar
                }
              }))
            }
          }
          ));
          let s = r.filter((t => t.passLength >= n - 3 && t.passLength <= n + 10)).sort(((t, e) => t.distance - e.distance))
            , u = s[0];
          console.log("🚀 ~ minPass:", u, r, r.filter((t => t.passLength >= n - 3 && t.passLength <= n + 10))),
            u ? (c.distance = u.distance,
              c.x = u.x,
              c.y = u.y,
              c.ids = u.ids) : c = {},
            c.arrMin = r
        }
        postMessage({
          _id: o,
          min: c
        })
      }(l) : "find" === l.fn && function ({ _id: e, startID: r, endID: o, enterType: s, crossType: a, disablePoints: l }) {
        let h = i[`${a},${s}`];
        l && l.length && (h = JSON.parse(JSON.stringify(h)),
          l.map((t => {
            delete h[t]
          }
          )));
        let c = function (t, e, i) {
          var n = function (t) {
            var e, i = [];
            for (e in t)
              Object.prototype.hasOwnProperty.call(t, e) && i.push(e);
            return i
          }
            , r = function (t, e) {
              return parseFloat(t) - parseFloat(e)
            };
          function o(t, e, i) {
            var o, s = {}, a = {
              0: [e]
            }, l = {}, h = function (t, e) {
              var i = "" + t;
              a[i] = a[i] || [],
                a[i].push(e)
            };
            for (s[e] = 0; a && (o = n(a)).length;) {
              o.sort(r);
              var c = o[0]
                , u = a[c]
                , p = u.shift()
                , d = parseFloat(c)
                , f = t[p] || {};
              for (var g in u.length || delete a[c],
                f)
                if (Object.prototype.hasOwnProperty.call(f, g)) {
                  var m = f[g] + d
                    , y = s[g];
                  (void 0 === y || y > m) && (s[g] = m,
                    h(m, g),
                    l[g] = p)
                }
            }
            return void 0 === s[i] ? null : l
          }
          var s = function (t, e) {
            for (var i = [], n = e; void 0 !== n;)
              i.push(n),
                n = t[n];
            return i.reverse(),
              i
          };
          return function (t, e) {
            for (var i, n, r, a = e.shift(), l = []; e.length;) {
              if (!(n = o(t, a, i = e.shift())))
                return null;
              if (r = s(n, i),
                !e.length)
                return l.concat(r);
              l.push.apply(l, r.slice(0, -1)),
                a = i
            }
          }(i, [t, e])
        }(r, o, h);
        if (!c)
          return void postMessage({
            _id: e
          });
        let u = 0
          , p = c.map(((e, i) => {
            let r, o = n.find((t => +t.id == +e)), s = c[i + 1];
            if (s) {
              let e = null == o ? void 0 : o.ids[s];
              r = !!t[e]
            }
            let a = h[e][s] || 0;
            if (r) {
              let t = n.find((t => +t.id == +s));
              a = t ? Math.sqrt(Math.pow(t.x - o.x, 2) + Math.pow(t.y - o.y, 2)) : 0
            }
            return u += a,
            {
              point: o,
              nextDistance: a
            }
          }
          ));
        postMessage({
          _id: e,
          distance: u,
          path: p
        })
      }(l)
    }
  }
  class dm {
    constructor(t) {
      this.worker = Nd(pm),
        this.map = t,
        this.worker({
          fn: "init",
          path: this.map.mapData.path,
          lineTypeData: {
            EnterType: pp,
            CrossType: dp
          }
        })
    }
    findRoute(t, e, i, n = dp.manCar) {
      return sp(this, void 0, void 0, (function* () {
        let r = []
          , o = [];
        return t.path.map((t => {
          e.path.map((e => sp(this, void 0, void 0, (function* () {
            let s = this.findRouteWorker(t, e, i, n);
            r.push(s);
            const a = yield s;
            a.path && a.path.length && (a.path.distance = a.distance,
              o.push(a.path))
          }
          ))))
        }
        )),
          yield Promise.all(r),
          o
      }
      ))
    }
    find(t, e, i, n) {
      var r, o;
      return sp(this, void 0, void 0, (function* () {
        if (!e || !t)
          return;
        if (!(null === (r = t.path) || void 0 === r ? void 0 : r.length) || !(null === (o = e.path) || void 0 === o ? void 0 : o.length))
          return void console.log("未找到路线, 请联系地图制作方!");
        let s = [pp.elevator, pp.escalator, pp.stairs];
        s.unshift(...s.splice(s.indexOf(i), 1));
        let a = () => sp(this, void 0, void 0, (function* () {
          let i = s.shift();
          if (null != i) {
            let r = yield this.findRoute(t, e, i, n);
            return r.length ? r : (console.log("找不到路线:", i),
              a())
          }
        }
        ))
          , l = yield a();
        if (!l)
          return;
        let h = l.sort(((t, e) => t.distance - e.distance))[0];
        return h[0].point.floorId === h[1].point.floorId && h[0].point.x === h[1].point.x && h[0].point.y === h[1].point.y && h.shift(),
          h.map((t => {
            t.floor = this.map.getMapDataById(t.point.floorId)
          }
          )),
          h
      }
      ))
    }
    planRoute(t, e, i, n) {
      return sp(this, void 0, void 0, (function* () {
        let r = yield this.find(t, e, i, n);
        if (null == r ? void 0 : r.length)
          return this.computeRouteInfo(r)
      }
      ))
    }
    computeRouteInfo(t) {
      for (let e = 0; e < t.length - 1; e++) {
        const i = t[e]
          , n = t[e + 1]
          , r = t[e + 2];
        if (i.enterTypeId = i.point.ids[n.point.id],
          i.point.floorId !== n.point.floorId) {
          r && (n.point.floorId !== r.point.floorId ? n.tip = pp[n.point.ids[r.point.id]].name : n.tip = "直行");
          continue
        }
        let o = (new Fe).copy(i.point)
          , s = (new Fe).copy(n.point)
          , a = o.sub(s)
          , l = new Fe(0, 1)
          , h = a.angleTo(l) * Ne.RAD2DEG;
        if (i.mapRotation = l.cross(a) > 0 ? h : 360 - h,
          r) {
          if (r.point.floorId !== n.point.floorId) {
            n.tip = pp[n.point.ids[r.point.id]].name,
              n.angle = 0;
            continue
          }
          let t = (new Fe).copy(r.point)
            , e = s.sub(t)
            , i = a.angleTo(e) * Ne.RAD2DEG;
          isNaN(i),
            i = a.clone().cross(e) > 0 ? i : 360 - i,
            isNaN(i),
            n.tip = this.angle2NaviText(i),
            n.angle = i
        } else
          n.isEnd = !0
      }
      let e = t.reduce(((t, e) => {
        let i = t.at(-1);
        if (!i)
          return t.push([e]),
            t;
        let n = i[0];
        return n && n.point.floorId === e.point.floorId ? i.push(e) : t.push([e]),
          t
      }
      ), []);
      return e.shift(),
        e.pop(),
        e.map((e => {
          1 === e.length && t.splice(t.indexOf(e[0]), 1)
        }
        )),
        t
    }
    findRouteWorker(t, e, i, n, r) {
      return this.worker({
        fn: "find",
        startID: t,
        endID: e,
        enterType: i,
        crossType: n,
        disablePoints: r
      })
    }
    angle2NaviText(t) {
      return [{
        text: "请保持直行",
        max: 20,
        min: 0
      }, {
        text: "向左前方",
        max: 45,
        min: 20
      }, {
        text: "即将左转",
        max: 135,
        min: 45
      }, {
        text: "向左后方",
        max: 180,
        min: 135
      }, {
        text: "向右后方",
        max: 225,
        min: 180
      }, {
        text: "即将右转",
        max: 315,
        min: 225
      }, {
        text: "向右前方",
        max: 340,
        min: 315
      }, {
        text: "请保持直行",
        max: 360,
        min: 340
      }].find((e => e.max >= t && e.min <= t)).text
    }
  }
  var fm = {
    0: [2200, 396],
    1: [3300, 251],
    2: [4399, 289],
    3: [5500, 360],
    4: [6600, 396],
    5: [7700, 216],
    6: [8800, 288],
    7: [9900, 396],
    8: [11e3, 255],
    9: [12100, 324],
    ",": [0, 128],
    "-": [1100, 360],
    A: [13200, 324],
    B: [14300, 283],
    C: [15400, 324],
    D: [16500, 250],
    E: [17600, 360],
    F: [18700, 396],
    G: [19800, 324],
    H: [20900, 324],
    I: [22e3, 267],
    J: [23100, 292],
    K: [24200, 347],
    L: [25300, 431],
    M: [26400, 334],
    N: [27499, 288],
    O: [28599, 288],
    P: [29700, 393],
    Q: [30800, 263],
    R: [31900, 288],
    S: [33e3, 252],
    T: [34100, 252],
    U: [35200, 324],
    V: [36300, 245],
    W: [37400, 476],
    X: [38500, 252],
    Y: [39600, 360],
    Z: [40700, 198],
    navDeviate: [41800, 394],
    "上层": [42900, 684],
    "上行": [44e3, 684],
    "下层": [45100, 729],
    "下行": [46200, 684],
    "中间方向": [47300, 972],
    "停车场": [48400, 792],
    "出入口": [49500, 835],
    "到达目的地": [50600, 1091],
    "前往": [52700, 622],
    "十": [53800, 468],
    "千": [54900, 360],
    "即将到达": [56e3, 1080],
    "即将": [56e3, 500],
    "到达": [56500, 540],
    "右侧": [58100, 658],
    "右前方": [59200, 792],
    "右后方": [60300, 756],
    "右转": [61400, 504],
    "后": [62500, 385],
    "向": [63600, 360],
    "坡道": [64700, 654],
    "夹层": [65800, 648],
    "导航开始": [66899, 1133],
    "导航结束": [68999, 1029],
    "左侧": [71100, 599],
    "左前方": [72199, 774],
    "左后方": [73299, 792],
    "左转": [74399, 612],
    "扶梯": [75499, 612],
    "检测到您处于步行状态": [76599, 2232],
    "检测到您处于驾车状态": [79699, 2340],
    "楼": [82799, 373],
    "楼梯": [83899, 504],
    "然后": [84999, 612],
    "电梯": [86099, 633],
    "百": [87199, 360],
    "目的地在您": [88299, 1044],
    "直行": [90399, 594],
    "米": [91499, 283],
    "继续": [92599, 540],
    "至": [93699, 288],
    "行走": [94799, 576],
    "行驶": [95899, 612],
    "请": [96999, 305],
    "请保持直行": [98099, 1332],
    "请减速": [100199, 828],
    "请掉头": [101299, 864],
    "请确认行进方向": [102399, 1728],
    "请走右侧车道": [104499, 1476],
    "请走左侧车道": [106599, 1548],
    "负": [108699, 360],
    "走": [109799, 270],
    "走中间车道": [110899, 1260],
    "进入": [112999, 540],
    "您已偏离路线": [114039, 2340]
  };
  let gm;
  var mm = new class {
    constructor() {
      this.init()
    }
    init() {
      return this._counter = 1e3,
        this._html5AudioPool = [],
        this.html5PoolSize = 10,
        this._codecs = {},
        this._howls = [],
        this._muted = !1,
        this._volume = 1,
        this._canPlayEvent = "canplaythrough",
        this._navigator = "undefined" != typeof window && window.navigator ? window.navigator : null,
        this.masterGain = null,
        this.noAudio = !1,
        this.usingWebAudio = !0,
        this.autoSuspend = !0,
        this.ctx = null,
        this.autoUnlock = !0,
        this._setup(),
        this
    }
    volume(t) {
      if (t = parseFloat(t),
        this.ctx || ym(),
        void 0 !== t && t >= 0 && t <= 1) {
        if (this._volume = t,
          this._muted)
          return this;
        this.usingWebAudio && this.masterGain.gain.setValueAtTime(t, mm.ctx.currentTime);
        for (var e = 0; e < this._howls.length; e++)
          if (!this._howls[e]._webAudio)
            for (var i = this._howls[e]._getSoundIds(), n = 0; n < i.length; n++) {
              var r = this._howls[e]._soundById(i[n]);
              r && r._node && (r._node.volume = r._volume * t)
            }
        return this
      }
      return this._volume
    }
    mute(t) {
      this.ctx || ym(),
        this._muted = t,
        this.usingWebAudio && this.masterGain.gain.setValueAtTime(t ? 0 : this._volume, mm.ctx.currentTime);
      for (var e = 0; e < this._howls.length; e++)
        if (!this._howls[e]._webAudio)
          for (var i = this._howls[e]._getSoundIds(), n = 0; n < i.length; n++) {
            var r = this._howls[e]._soundById(i[n]);
            r && r._node && (r._node.muted = !!t || r._muted)
          }
      return this
    }
    unload() {
      for (var t = this._howls.length - 1; t >= 0; t--)
        this._howls[t].unload();
      return this.usingWebAudio && this.ctx && void 0 !== this.ctx.close && (this.ctx.close(),
        this.ctx = null,
        ym()),
        this
    }
    codecs(t) {
      return (this || mm)._codecs[t.replace(/^x-/, "")]
    }
    _setup() {
      var t = this || mm;
      if (t.state = t.ctx && t.ctx.state || "suspended",
        t._autoSuspend(),
        !t.usingWebAudio)
        if ("undefined" != typeof Audio)
          try {
            void 0 === (new Audio).oncanplaythrough && (t._canPlayEvent = "canplay")
          } catch (e) {
            t.noAudio = !0
          }
        else
          t.noAudio = !0;
      try {
        (new Audio).muted && (t.noAudio = !0)
      } catch (t) { }
      return t.noAudio || t._setupCodecs(),
        t
    }
    _setupCodecs() {
      var t = this || mm
        , e = null;
      try {
        e = "undefined" != typeof Audio ? new Audio : null
      } catch (e) {
        return t
      }
      if (!e || "function" != typeof e.canPlayType)
        return t;
      var i = e.canPlayType("audio/mpeg;").replace(/^no$/, "")
        , n = t._navigator && t._navigator.userAgent.match(/OPR\/([0-6].)/g)
        , r = n && parseInt(n[0].split("/")[1], 10) < 33;
      return t._codecs = {
        mp3: !(r || !i && !e.canPlayType("audio/mp3;").replace(/^no$/, "")),
        mpeg: !!i,
        opus: !!e.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""),
        ogg: !!e.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
        oga: !!e.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
        wav: !!e.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ""),
        aac: !!e.canPlayType("audio/aac;").replace(/^no$/, ""),
        caf: !!e.canPlayType("audio/x-caf;").replace(/^no$/, ""),
        m4a: !!(e.canPlayType("audio/x-m4a;") || e.canPlayType("audio/m4a;") || e.canPlayType("audio/aac;")).replace(/^no$/, ""),
        mp4: !!(e.canPlayType("audio/x-mp4;") || e.canPlayType("audio/mp4;") || e.canPlayType("audio/aac;")).replace(/^no$/, ""),
        weba: !!e.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ""),
        webm: !!e.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ""),
        dolby: !!e.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""),
        flac: !!(e.canPlayType("audio/x-flac;") || e.canPlayType("audio/flac;")).replace(/^no$/, "")
      },
        t
    }
    _unlockAudio() {
      var t = this || mm;
      if (!t._audioUnlocked && t.ctx) {
        t._audioUnlocked = !1,
          t.autoUnlock = !1,
          t._mobileUnloaded || 44100 === t.ctx.sampleRate || (t._mobileUnloaded = !0,
            t.unload()),
          t._scratchBuffer = t.ctx.createBuffer(1, 1, 22050);
        var e = function e(i) {
          for (var n = 0; n < t.html5PoolSize; n++)
            try {
              var r = new Audio;
              r._unlocked = !0,
                t._releaseHtml5Audio(r)
            } catch (i) {
              t.noAudio = !0
            }
          for (n = 0; n < t._howls.length; n++)
            if (!t._howls[n]._webAudio)
              for (var o = t._howls[n]._getSoundIds(), s = 0; s < o.length; s++) {
                var a = t._howls[n]._soundById(o[s]);
                a && a._node && !a._node._unlocked && (a._node._unlocked = !0,
                  a._node.load())
              }
          t._autoResume();
          var l = t.ctx.createBufferSource();
          l.buffer = t._scratchBuffer,
            l.connect(t.ctx.destination),
            void 0 === l.start ? l.noteOn(0) : l.start(0),
            "function" == typeof t.ctx.resume && t.ctx.resume(),
            l.onended = function () {
              l.disconnect(0),
                t._audioUnlocked = !0,
                document.removeEventListener("touchstart", e, !0),
                document.removeEventListener("touchend", e, !0),
                document.removeEventListener("click", e, !0);
              for (var i = 0; i < t._howls.length; i++)
                t._howls[i]._emit("unlock")
            }
        };
        return document.addEventListener("touchstart", e, !0),
          document.addEventListener("touchend", e, !0),
          document.addEventListener("click", e, !0),
          t
      }
    }
    _obtainHtml5Audio() {
      var t = this || mm;
      if (t._html5AudioPool.length)
        return t._html5AudioPool.pop();
      var e = (new Audio).play();
      return e && void 0 !== Promise && (e instanceof Promise || e.then),
        new Audio
    }
    _releaseHtml5Audio(t) {
      var e = this || mm;
      return t._unlocked && e._html5AudioPool.push(t),
        e
    }
    _autoSuspend() {
      var t = this;
      if (t.autoSuspend && t.ctx && void 0 !== t.ctx.suspend && mm.usingWebAudio) {
        for (var e = 0; e < t._howls.length; e++)
          if (t._howls[e]._webAudio)
            for (var i = 0; i < t._howls[e]._sounds.length; i++)
              if (!t._howls[e]._sounds[i]._paused)
                return t;
        return t._suspendTimer && clearTimeout(t._suspendTimer),
          t._suspendTimer = setTimeout((function () {
            t.autoSuspend && (t._suspendTimer = null,
              t.state = "suspending",
              t.ctx.suspend().then((function () {
                t.state = "suspended",
                  t._resumeAfterSuspend && (delete t._resumeAfterSuspend,
                    t._autoResume())
              }
              )))
          }
          ), 3e4),
          t
      }
    }
    _autoResume() {
      var t = this;
      if (t.ctx && void 0 !== t.ctx.resume && mm.usingWebAudio)
        return "running" === t.state && t._suspendTimer ? (clearTimeout(t._suspendTimer),
          t._suspendTimer = null) : "suspended" === t.state || "running" !== t.ctx.state ? (t.ctx.resume().then((function () {
            t.state = "running";
            for (var e = 0; e < t._howls.length; e++)
              t._howls[e]._emit("resume")
          }
          )),
            t._suspendTimer && (clearTimeout(t._suspendTimer),
              t._suspendTimer = null)) : "suspending" === t.state && (t._resumeAfterSuspend = !0),
          t
    }
  }
    ;
  function ym() {
    if (mm.usingWebAudio) {
      try {
        "undefined" != typeof AudioContext ? mm.ctx = new AudioContext : "undefined" != typeof webkitAudioContext ? mm.ctx = new webkitAudioContext : mm.usingWebAudio = !1
      } catch (t) {
        mm.usingWebAudio = !1
      }
      mm.ctx || (mm.usingWebAudio = !1);
      var t = /iP(hone|od|ad)/.test(mm._navigator && mm._navigator.platform)
        , e = mm._navigator && mm._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/)
        , i = e ? parseInt(e[1], 10) : null;
      if (t && i && i < 9) {
        var n = /safari/.test(mm._navigator && mm._navigator.userAgent.toLowerCase());
        (mm._navigator && mm._navigator.standalone && !n || mm._navigator && !mm._navigator.standalone && !n) && (mm.usingWebAudio = !1)
      }
      mm.usingWebAudio && (mm.masterGain = void 0 === mm.ctx.createGain ? mm.ctx.createGainNode() : mm.ctx.createGain(),
        mm.masterGain.gain.setValueAtTime(mm._muted ? 0 : 1, mm.ctx.currentTime),
        mm.masterGain.connect(mm.ctx.destination)),
        mm._setup()
    }
  }
  class vm {
    constructor(t) {
      this.init(t)
    }
    init(t) {
      var e = this;
      return mm.ctx || ym(),
        e._autoplay = t.autoplay || !1,
        e._format = "string" != typeof t.format ? t.format : [t.format],
        e._html5 = t.html5 || !1,
        e._muted = t.mute || !1,
        e._loop = t.loop || !1,
        e._pool = t.pool || 5,
        e._preload = "boolean" != typeof t.preload || t.preload,
        e._rate = t.rate || 1,
        e._sprite = t.sprite || {},
        e._src = "string" != typeof t.src ? t.src : [t.src],
        e._volume = void 0 !== t.volume ? t.volume : 1,
        e._xhrWithCredentials = t.xhrWithCredentials || !1,
        e._duration = 0,
        e._state = "unloaded",
        e._sounds = [],
        e._endTimers = {},
        e._queue = [],
        e._playLock = !1,
        e._onend = t.onend ? [{
          fn: t.onend
        }] : [],
        e._onfade = t.onfade ? [{
          fn: t.onfade
        }] : [],
        e._onload = t.onload ? [{
          fn: t.onload
        }] : [],
        e._onloaderror = t.onloaderror ? [{
          fn: t.onloaderror
        }] : [],
        e._onplayerror = t.onplayerror ? [{
          fn: t.onplayerror
        }] : [],
        e._onpause = t.onpause ? [{
          fn: t.onpause
        }] : [],
        e._onplay = t.onplay ? [{
          fn: t.onplay
        }] : [],
        e._onstop = t.onstop ? [{
          fn: t.onstop
        }] : [],
        e._onmute = t.onmute ? [{
          fn: t.onmute
        }] : [],
        e._onvolume = t.onvolume ? [{
          fn: t.onvolume
        }] : [],
        e._onrate = t.onrate ? [{
          fn: t.onrate
        }] : [],
        e._onseek = t.onseek ? [{
          fn: t.onseek
        }] : [],
        e._onunlock = t.onunlock ? [{
          fn: t.onunlock
        }] : [],
        e._onresume = [],
        e._webAudio = mm.usingWebAudio && !e._html5,
        void 0 !== mm.ctx && mm.ctx && mm.autoUnlock && mm._unlockAudio(),
        mm._howls.push(e),
        e._autoplay && e._queue.push({
          event: "play",
          action: function () {
            e.play()
          }
        }),
        e._preload && e.load(),
        e
    }
    load() {
      var t = null;
      if (mm.noAudio)
        this._emit("loaderror", null, "No audio support.");
      else {
        "string" == typeof this._src && (this._src = [this._src]);
        for (var e = 0; e < this._src.length; e++) {
          var i, n;
          if (this._format && this._format[e])
            i = this._format[e];
          else {
            if ("string" != typeof (n = this._src[e]))
              continue;
            (i = /^data:audio\/([^;,]+);/i.exec(n)) || (i = /\.([^.]+)$/.exec(n.split("?", 1)[0])),
              i && (i = i[1].toLowerCase())
          }
          if (i && mm.codecs(i)) {
            t = this._src[e];
            break
          }
        }
        if (t)
          return this._src = t,
            this._state = "loading",
            "https:" === window.location.protocol && "http:" === t.slice(0, 5) && (this._html5 = !0,
              this._webAudio = !1),
            new xm(this),
            this._webAudio && function (t) {
              var e = t._src;
              if (wm[e])
                return t._duration = wm[e].duration,
                  void Im(t);
              if (/^data:[^;]+;base64,/.test(e)) {
                for (var i = atob(e.split(",")[1]), n = new Uint8Array(i.length), r = 0; r < i.length; ++r)
                  n[r] = i.charCodeAt(r);
                Cm(n.buffer, t)
              } else {
                var o = new XMLHttpRequest;
                o.open("GET", e, !0),
                  o.withCredentials = t._xhrWithCredentials,
                  o.responseType = "arraybuffer",
                  o.onload = function () {
                    var e = (o.status + "")[0];
                    "0" === e || "2" === e || "3" === e ? Cm(o.response, t) : t._emit("loaderror", null, "onload Failed loading audio file with status: " + o.status + ".")
                  }
                  ,
                  o.onerror = function () {
                    t._emit("loaderror", null, "onerror Failed loading audio file with status: " + o.status + ".")
                  }
                  ,
                  function (t) {
                    try {
                      t.send()
                    } catch (e) {
                      t.onerror()
                    }
                  }(o)
              }
            }(this),
            this;
        this._emit("loaderror", null, "No codec support for selected audio sources.")
      }
    }
    play(t, e) {
      var i = this
        , n = null;
      if ("number" == typeof t)
        n = t,
          t = null;
      else {
        if ("string" == typeof t && "loaded" === i._state && !i._sprite[t])
          return null;
        if (void 0 === t && (t = "__default",
          !i._playLock)) {
          for (var r = 0, o = 0; o < i._sounds.length; o++)
            i._sounds[o]._paused && !i._sounds[o]._ended && (r++,
              n = i._sounds[o]._id);
          1 === r ? t = null : n = null
        }
      }
      var s = n ? i._soundById(n) : i._inactiveSound();
      if (!s)
        return null;
      if (n && !t && (t = s._sprite || "__default"),
        "loaded" !== i._state) {
        s._sprite = t,
          s._ended = !1;
        var a = s._id;
        return i._queue.push({
          event: "play",
          action: function () {
            i.play(a)
          }
        }),
          a
      }
      if (n && !s._paused)
        return e || i._loadQueue("play"),
          s._id;
      i._webAudio && mm._autoResume();
      var l = Math.max(0, s._seek > 0 ? s._seek : i._sprite[t][0] / 1e3)
        , h = Math.max(0, (i._sprite[t][0] + i._sprite[t][1]) / 1e3 - l)
        , c = 1e3 * h / Math.abs(s._rate)
        , u = i._sprite[t][0] / 1e3
        , p = (i._sprite[t][0] + i._sprite[t][1]) / 1e3
        , d = !(!s._loop && !i._sprite[t][2]);
      s._sprite = t,
        s._ended = !1;
      var f = function () {
        s._paused = !1,
          s._seek = l,
          s._start = u,
          s._stop = p,
          s._loop = d
      };
      if (!(l >= p)) {
        var g = s._node;
        if (i._webAudio) {
          var m = function () {
            i._playLock = !1,
              f(),
              i._refreshBuffer(s);
            var t = s._muted || i._muted ? 0 : s._volume;
            g.gain.setValueAtTime(t, mm.ctx.currentTime),
              s._playStart = mm.ctx.currentTime,
              void 0 === g.bufferSource.start ? s._loop ? g.bufferSource.noteGrainOn(0, l, 86400) : g.bufferSource.noteGrainOn(0, l, h) : s._loop ? g.bufferSource.start(0, l, 86400) : g.bufferSource.start(0, l, h),
              c !== 1 / 0 && (i._endTimers[s._id] = setTimeout(i._ended.bind(i, s), c)),
              e || setTimeout((function () {
                i._emit("play", s._id),
                  i._loadQueue()
              }
              ), 0)
          };
          "running" === mm.state ? m() : (i._playLock = !0,
            i.once("resume", m),
            i._clearTimer(s._id))
        } else {
          var y = function () {
            g.currentTime = l,
              g.muted = s._muted || i._muted || mm._muted || g.muted,
              g.volume = s._volume * mm.volume(),
              g.playbackRate = s._rate;
            try {
              var n = g.play();
              if (n && void 0 !== Promise && (n instanceof Promise || "function" == typeof n.then) ? (i._playLock = !0,
                f(),
                n.then((function () {
                  i._playLock = !1,
                    g._unlocked = !0,
                    e || (i._emit("play", s._id),
                      i._loadQueue())
                }
                )).catch((function () {
                  i._playLock = !1,
                    i._emit("playerror", s._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."),
                    s._ended = !0,
                    s._paused = !0
                }
                ))) : e || (i._playLock = !1,
                  f(),
                  i._emit("play", s._id),
                  i._loadQueue()),
                g.playbackRate = s._rate,
                g.paused)
                return void i._emit("playerror", s._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
              "__default" !== t || s._loop ? i._endTimers[s._id] = setTimeout(i._ended.bind(i, s), c) : (i._endTimers[s._id] = function () {
                i._ended(s),
                  g.removeEventListener("ended", i._endTimers[s._id], !1)
              }
                ,
                g.addEventListener("ended", i._endTimers[s._id], !1))
            } catch (t) {
              i._emit("playerror", s._id, t)
            }
          };
          "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA" === g.src && (g.src = i._src,
            g.load());
          var v = window && window.ejecta || !g.readyState && mm._navigator.isCocoonJS;
          g.readyState >= 3 || v ? y() : (i._playLock = !0,
            g.addEventListener(mm._canPlayEvent, (function t() {
              y(),
                g.removeEventListener(mm._canPlayEvent, t, !1)
            }
            ), !1),
            i._clearTimer(s._id))
        }
        return s._id
      }
      i._ended(s)
    }
    pause(t) {
      var e = this;
      if ("loaded" !== e._state || e._playLock)
        return e._queue.push({
          event: "pause",
          action: function () {
            e.pause(t)
          }
        }),
          e;
      for (var i = e._getSoundIds(t), n = 0; n < i.length; n++) {
        e._clearTimer(i[n]);
        var r = e._soundById(i[n]);
        if (r && !r._paused && (r._seek = e.seek(i[n]),
          r._rateSeek = 0,
          r._paused = !0,
          e._stopFade(i[n]),
          r._node))
          if (e._webAudio) {
            if (!r._node.bufferSource)
              continue;
            void 0 === r._node.bufferSource.stop ? r._node.bufferSource.noteOff(0) : r._node.bufferSource.stop(0),
              e._cleanBuffer(r._node)
          } else
            isNaN(r._node.duration) && r._node.duration !== 1 / 0 || r._node.pause();
        arguments[1] || e._emit("pause", r ? r._id : null)
      }
      return e
    }
    stop(t, e) {
      var i = this;
      if ("loaded" !== i._state || i._playLock)
        return i._queue.push({
          event: "stop",
          action: function () {
            i.stop(t)
          }
        }),
          i;
      for (var n = i._getSoundIds(t), r = 0; r < n.length; r++) {
        i._clearTimer(n[r]);
        var o = i._soundById(n[r]);
        o && (o._seek = o._start || 0,
          o._rateSeek = 0,
          o._paused = !0,
          o._ended = !0,
          i._stopFade(n[r]),
          o._node && (i._webAudio ? o._node.bufferSource && (void 0 === o._node.bufferSource.stop ? o._node.bufferSource.noteOff(0) : o._node.bufferSource.stop(0),
            i._cleanBuffer(o._node)) : isNaN(o._node.duration) && o._node.duration !== 1 / 0 || (o._node.currentTime = o._start || 0,
              o._node.pause(),
              o._node.duration === 1 / 0 && i._clearSound(o._node))),
          e || i._emit("stop", o._id))
      }
      return i
    }
    mute(t, e) {
      var i = this;
      if ("loaded" !== i._state || i._playLock)
        return i._queue.push({
          event: "mute",
          action: function () {
            i.mute(t, e)
          }
        }),
          i;
      if (void 0 === e) {
        if ("boolean" != typeof t)
          return i._muted;
        i._muted = t
      }
      for (var n = i._getSoundIds(e), r = 0; r < n.length; r++) {
        var o = i._soundById(n[r]);
        o && (o._muted = t,
          o._interval && i._stopFade(o._id),
          i._webAudio && o._node ? o._node.gain.setValueAtTime(t ? 0 : o._volume, mm.ctx.currentTime) : o._node && (o._node.muted = !!mm._muted || t),
          i._emit("mute", o._id))
      }
      return i
    }
    volume() {
      var t, e, i, n = this, r = arguments;
      if (0 === r.length)
        return n._volume;
      if (1 === r.length || 2 === r.length && void 0 === r[1] ? n._getSoundIds().indexOf(r[0]) >= 0 ? e = parseInt(r[0], 10) : t = parseFloat(r[0]) : r.length >= 2 && (t = parseFloat(r[0]),
        e = parseInt(r[1], 10)),
        !(void 0 !== t && t >= 0 && t <= 1))
        return (i = e ? n._soundById(e) : n._sounds[0]) ? i._volume : 0;
      if ("loaded" !== n._state || n._playLock)
        return n._queue.push({
          event: "volume",
          action: function () {
            n.volume.apply(n, r)
          }
        }),
          n;
      void 0 === e && (n._volume = t),
        e = n._getSoundIds(e);
      for (var o = 0; o < e.length; o++)
        (i = n._soundById(e[o])) && (i._volume = t,
          r[2] || n._stopFade(e[o]),
          n._webAudio && i._node && !i._muted ? i._node.gain.setValueAtTime(t, mm.ctx.currentTime) : i._node && !i._muted && (i._node.volume = t * mm.volume()),
          n._emit("volume", i._id));
      return n
    }
    fade(t, e, i, n) {
      var r = this;
      if ("loaded" !== r._state || r._playLock)
        return r._queue.push({
          event: "fade",
          action: function () {
            r.fade(t, e, i, n)
          }
        }),
          r;
      t = parseFloat(t),
        e = parseFloat(e),
        i = parseFloat(i),
        r.volume(t, n);
      for (var o = r._getSoundIds(n), s = 0; s < o.length; s++) {
        var a = r._soundById(o[s]);
        if (a) {
          if (n || r._stopFade(o[s]),
            r._webAudio && !a._muted) {
            var l = mm.ctx.currentTime
              , h = l + i / 1e3;
            a._volume = t,
              a._node.gain.setValueAtTime(t, l),
              a._node.gain.linearRampToValueAtTime(e, h)
          }
          r._startFadeInterval(a, t, e, i, o[s], void 0 === n)
        }
      }
      return r
    }
    _startFadeInterval(t, e, i, n, r, o) {
      var s = this
        , a = e
        , l = i - e
        , h = Math.abs(l / .01)
        , c = Math.max(4, h > 0 ? n / h : n)
        , u = Date.now();
      t._fadeTo = i,
        t._interval = setInterval((function () {
          var r = (Date.now() - u) / n;
          u = Date.now(),
            a += l * r,
            a = Math.max(0, a),
            a = Math.min(1, a),
            a = Math.round(100 * a) / 100,
            s._webAudio ? t._volume = a : s.volume(a, t._id, !0),
            o && (s._volume = a),
            (i < e && a <= i || i > e && a >= i) && (clearInterval(t._interval),
              t._interval = null,
              t._fadeTo = null,
              s.volume(i, t._id),
              s._emit("fade", t._id))
        }
        ), c)
    }
    _stopFade(t) {
      var e = this._soundById(t);
      return e && e._interval && (this._webAudio && e._node.gain.cancelScheduledValues(mm.ctx.currentTime),
        clearInterval(e._interval),
        e._interval = null,
        this.volume(e._fadeTo, t),
        e._fadeTo = null,
        this._emit("fade", t)),
        this
    }
    loop() {
      var t, e, i, n = arguments;
      if (0 === n.length)
        return this._loop;
      if (1 === n.length) {
        if ("boolean" != typeof n[0])
          return !!(i = this._soundById(parseInt(n[0], 10))) && i._loop;
        t = n[0],
          this._loop = t
      } else
        2 === n.length && (t = n[0],
          e = parseInt(n[1], 10));
      for (var r = this._getSoundIds(e), o = 0; o < r.length; o++)
        (i = this._soundById(r[o])) && (i._loop = t,
          this._webAudio && i._node && i._node.bufferSource && (i._node.bufferSource.loop = t,
            t && (i._node.bufferSource.loopStart = i._start || 0,
              i._node.bufferSource.loopEnd = i._stop)));
      return this
    }
    rate() {
      var t, e, i, n = this, r = arguments;
      if (0 === r.length ? e = n._sounds[0]._id : 1 === r.length ? n._getSoundIds().indexOf(r[0]) >= 0 ? e = parseInt(r[0], 10) : t = parseFloat(r[0]) : 2 === r.length && (t = parseFloat(r[0]),
        e = parseInt(r[1], 10)),
        "number" != typeof t)
        return (i = n._soundById(e)) ? i._rate : n._rate;
      if ("loaded" !== n._state || n._playLock)
        return n._queue.push({
          event: "rate",
          action: function () {
            n.rate.apply(n, r)
          }
        }),
          n;
      void 0 === e && (n._rate = t),
        e = n._getSoundIds(e);
      for (var o = 0; o < e.length; o++)
        if (i = n._soundById(e[o])) {
          n.playing(e[o]) && (i._rateSeek = n.seek(e[o]),
            i._playStart = n._webAudio ? mm.ctx.currentTime : i._playStart),
            i._rate = t,
            n._webAudio && i._node && i._node.bufferSource ? i._node.bufferSource.playbackRate.setValueAtTime(t, mm.ctx.currentTime) : i._node && (i._node.playbackRate = t);
          var s = n.seek(e[o])
            , a = 1e3 * ((n._sprite[i._sprite][0] + n._sprite[i._sprite][1]) / 1e3 - s) / Math.abs(i._rate);
          !n._endTimers[e[o]] && i._paused || (n._clearTimer(e[o]),
            n._endTimers[e[o]] = setTimeout(n._ended.bind(n, i), a)),
            n._emit("rate", i._id)
        }
      return n
    }
    seek() {
      var t, e, i = this, n = arguments;
      if (0 === n.length ? e = i._sounds[0]._id : 1 === n.length ? i._getSoundIds().indexOf(n[0]) >= 0 ? e = parseInt(n[0], 10) : i._sounds.length && (e = i._sounds[0]._id,
        t = parseFloat(n[0])) : 2 === n.length && (t = parseFloat(n[0]),
          e = parseInt(n[1], 10)),
        void 0 === e)
        return i;
      if ("loaded" !== i._state || i._playLock)
        return i._queue.push({
          event: "seek",
          action: function () {
            i.seek.apply(i, n)
          }
        }),
          i;
      var r = i._soundById(e);
      if (r) {
        if (!("number" == typeof t && t >= 0)) {
          if (i._webAudio) {
            var o = i.playing(e) ? mm.ctx.currentTime - r._playStart : 0
              , s = r._rateSeek ? r._rateSeek - r._seek : 0;
            return r._seek + (s + o * Math.abs(r._rate))
          }
          return r._node.currentTime
        }
        var a = i.playing(e);
        a && i.pause(e, !0),
          r._seek = t,
          r._ended = !1,
          i._clearTimer(e),
          i._webAudio || !r._node || isNaN(r._node.duration) || (r._node.currentTime = t);
        var l = function () {
          i._emit("seek", e),
            a && i.play(e, !0)
        };
        a && !i._webAudio ? setTimeout((function t() {
          i._playLock ? setTimeout(t, 0) : l()
        }
        ), 0) : l()
      }
      return i
    }
    playing(t) {
      if ("number" == typeof t) {
        var e = this._soundById(t);
        return !!e && !e._paused
      }
      for (var i = 0; i < this._sounds.length; i++)
        if (!this._sounds[i]._paused)
          return !0;
      return !1
    }
    duration(t) {
      var e = this._duration
        , i = this._soundById(t);
      return i && (e = this._sprite[i._sprite][1] / 1e3),
        e
    }
    state() {
      return this._state
    }
    unload() {
      for (var t = this, e = t._sounds, i = 0; i < e.length; i++)
        e[i]._paused || t.stop(e[i]._id),
          t._webAudio || (t._clearSound(e[i]._node),
            e[i]._node.removeEventListener("error", e[i]._errorFn, !1),
            e[i]._node.removeEventListener(mm._canPlayEvent, e[i]._loadFn, !1),
            mm._releaseHtml5Audio(e[i]._node)),
          delete e[i]._node,
          t._clearTimer(e[i]._id);
      var n = mm._howls.indexOf(t);
      n >= 0 && mm._howls.splice(n, 1);
      var r = !0;
      for (i = 0; i < mm._howls.length; i++)
        if (mm._howls[i]._src === t._src || t._src.indexOf(mm._howls[i]._src) >= 0) {
          r = !1;
          break
        }
      return wm && r && delete wm[t._src],
        mm.noAudio = !1,
        t._state = "unloaded",
        t._sounds = [],
        t = null,
        null
    }
    on(t, e, i, n) {
      var r = this["_on" + t];
      return "function" == typeof e && r.push(n ? {
        id: i,
        fn: e,
        once: n
      } : {
        id: i,
        fn: e
      }),
        this
    }
    off(t, e, i) {
      var n = this["_on" + t]
        , r = 0;
      if ("number" == typeof e && (i = e,
        e = null),
        e || i)
        for (r = 0; r < n.length; r++) {
          var o = i === n[r].id;
          if (e === n[r].fn && o || !e && o) {
            n.splice(r, 1);
            break
          }
        }
      else if (t)
        this["_on" + t] = [];
      else {
        var s = Object.keys(this);
        for (r = 0; r < s.length; r++)
          0 === s[r].indexOf("_on") && Array.isArray(this[s[r]]) && (this[s[r]] = [])
      }
      return this
    }
    once(t, e, i) {
      return this.on(t, e, i, 1),
        this
    }
    _emit(t, e, i) {
      for (var n = this["_on" + t], r = n.length - 1; r >= 0; r--)
        n[r].id && n[r].id !== e && "load" !== t || (setTimeout(function (t) {
          t.call(this, e, i)
        }
          .bind(this, n[r].fn), 0),
          n[r].once && this.off(t, n[r].fn, n[r].id));
      return this._loadQueue(t),
        this
    }
    _loadQueue(t) {
      if (this._queue.length > 0) {
        var e = this._queue[0];
        e.event === t && (this._queue.shift(),
          this._loadQueue()),
          t || e.action()
      }
      return this
    }
    _ended(t) {
      var e = t._sprite;
      if (!this._webAudio && t._node && !t._node.paused && !t._node.ended && t._node.currentTime < t._stop)
        return setTimeout(this._ended.bind(this, t), 100),
          this;
      var i = !(!t._loop && !this._sprite[e][2]);
      if (this._emit("end", t._id),
        !this._webAudio && i && this.stop(t._id, !0).play(t._id),
        this._webAudio && i) {
        this._emit("play", t._id),
          t._seek = t._start || 0,
          t._rateSeek = 0,
          t._playStart = mm.ctx.currentTime;
        var n = 1e3 * (t._stop - t._start) / Math.abs(t._rate);
        this._endTimers[t._id] = setTimeout(this._ended.bind(this, t), n)
      }
      return this._webAudio && !i && (t._paused = !0,
        t._ended = !0,
        t._seek = t._start || 0,
        t._rateSeek = 0,
        this._clearTimer(t._id),
        this._cleanBuffer(t._node),
        mm._autoSuspend()),
        this._webAudio || i || this.stop(t._id, !0),
        this
    }
    _clearTimer(t) {
      if (this._endTimers[t]) {
        if ("function" != typeof this._endTimers[t])
          clearTimeout(this._endTimers[t]);
        else {
          var e = this._soundById(t);
          e && e._node && e._node.removeEventListener("ended", this._endTimers[t], !1)
        }
        delete this._endTimers[t]
      }
      return this
    }
    _soundById(t) {
      for (var e = 0; e < this._sounds.length; e++)
        if (t === this._sounds[e]._id)
          return this._sounds[e];
      return null
    }
    _inactiveSound() {
      this._drain();
      for (var t = 0; t < this._sounds.length; t++)
        if (this._sounds[t]._ended)
          return this._sounds[t].reset();
      return new xm(this)
    }
    _drain() {
      var t = this._pool
        , e = 0
        , i = 0;
      if (!(this._sounds.length < t)) {
        for (i = 0; i < this._sounds.length; i++)
          this._sounds[i]._ended && e++;
        for (i = this._sounds.length - 1; i >= 0; i--) {
          if (e <= t)
            return;
          this._sounds[i]._ended && (this._webAudio && this._sounds[i]._node && this._sounds[i]._node.disconnect(0),
            this._sounds.splice(i, 1),
            e--)
        }
      }
    }
    _getSoundIds(t) {
      if (void 0 === t) {
        for (var e = [], i = 0; i < this._sounds.length; i++)
          e.push(this._sounds[i]._id);
        return e
      }
      return [t]
    }
    _refreshBuffer(t) {
      return t._node.bufferSource = mm.ctx.createBufferSource(),
        t._node.bufferSource.buffer = wm[this._src],
        t._panner ? t._node.bufferSource.connect(t._panner) : t._node.bufferSource.connect(t._node),
        t._node.bufferSource.loop = t._loop,
        t._loop && (t._node.bufferSource.loopStart = t._start || 0,
          t._node.bufferSource.loopEnd = t._stop || 0),
        t._node.bufferSource.playbackRate.setValueAtTime(t._rate, mm.ctx.currentTime),
        this
    }
    _cleanBuffer(t) {
      var e = mm._navigator && mm._navigator.vendor.indexOf("Apple") >= 0;
      if (mm._scratchBuffer && t.bufferSource && (t.bufferSource.onended = null,
        t.bufferSource.disconnect(0),
        e))
        try {
          t.bufferSource.buffer = mm._scratchBuffer
        } catch (t) { }
      return t.bufferSource = null,
        this
    }
    _clearSound(t) {
      /MSIE |Trident\//.test(mm._navigator && mm._navigator.userAgent) || (t.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA")
    }
  }
  class Am extends Se {
    constructor(t) {
      super(),
        gm = this,
        this.sprite = t.sprite,
        this.src = t.src,
        this.sound = void 0,
        this.isLoaded = !1,
        this.playIndex = 0,
        this.playLength = -1,
        this.spriteArray = [],
        this.isPlaying = !1,
        this.canInterrupt = !0,
        this.reloadTimer = void 0;
      for (var e = Object.keys(this.sprite), i = e.length, n = void 0, r = 0; r < i; r++)
        for (var o = r + 1; o < i; o++)
          e[r].length < e[o].length && (n = e[r],
            e[r] = e[o],
            e[o] = n);
      return mm.autoSuspend = !1,
        this.spriteMaxToMin = e,
        this
    }
    visibleHandler() {
      "hidden" === document.visibilityState ? gm.suspendContext() : "visible" === document.visibilityState && gm.resumeContext()
    }
    suspendContext() {
      clearTimeout(this.reloadTimer),
        this.stop(),
        mm.state = "suspending",
        mm.ctx.suspend().then((function () {
          mm.state = "suspended"
        }
        ))
    }
    resumeContext() {
      this.reload(),
        mm.ctx.resume().then((function () {
          for (var t = 0; t < mm._howls.length; t++)
            mm._howls[t]._emit("resume");
          mm.state = "running"
        }
        ))
    }
    reload() {
      var t = this;
      this.isLoaded || (clearTimeout(this.reloadTimer),
        this.reloadTimer = setTimeout((function () {
          t.sound.load()
        }
        ), 2e3))
    }
    initAudio() {
      var t = this;
      this.destroy(),
        document.addEventListener("visibilitychange", this.visibleHandler),
        this.sound = new vm({
          src: this.src,
          sprite: this.sprite
        }),
        this.sound.on("loaderror", (function (e) {
          t.reload()
        }
        )),
        this.sound.once("load", (function () {
          clearTimeout(t.reloadTimer),
            t.isLoaded = !0,
            t.emit("load", {})
        }
        ))
    }
    destroy() {
      document.removeEventListener("visibilitychange", this.visibleHandler),
        clearTimeout(this.reloadTimer),
        this.stop(),
        this.isLoaded = !1,
        this.sound && (this.sound.off(),
          this.sound.unload(),
          mm.unload(),
          mm.autoUnlock = !0,
          mm._audioUnlocked = !1,
          this.sound = void 0)
    }
    endHandler() {
      gm.playIndex >= gm.playLength ? (gm.stop(),
        gm.emit("playEnd", {}),
        gm.canInterrupt = !0) : gm.sound.play(gm.spriteArray[gm.playIndex++])
    }
    playSprites(t) {
      0 !== t.length && this.isLoaded && (this.spriteArray = this.spriteArray.concat(t),
        this.playLength = this.spriteArray.length,
        this.isPlaying || (this.playIndex = 0,
          this.sound.on("end", this.endHandler),
          this.sound.play(this.spriteArray[this.playIndex++])),
        this.isPlaying = !0)
    }
    stop() {
      this.sound && (this.sound.stop(),
        this.sound.off("end", this.endHandler)),
        this.playIndex = 0,
        this.playLength = -1,
        this.spriteArray = [],
        this.isPlaying = !1
    }
    navDeviate() {
      this.stop(),
        this.playSprites(["navDeviate"])
    }
    playRange(t) { }
    setMute(t) {
      this.sound.mute(t)
    }
    setVolume(t) {
      this.sound.volume(t)
    }
    setRate(t) {
      this.sound.rate(t)
    }
  }
  class bm extends Am {
    constructor(t) {
      super(t = {
        sprite: fm,
        src: t.src
      })
    }
    playRange(t) {
      if (this.isLoaded) {
        var e, i, n, r, o = function (t) {
          for (var e = "", i = "", n = 0, r = (t = t.replace("，", ",")).length; n < r; n++) {
            var o = t[n];
            o >= "0" && o <= "9" ? e += o : (e && (i += e = a(e).join("")),
              e = "",
              i += o)
          }
          return e && (i += e = a(e).join("")),
            i
        }(t = t.replace(/([BFA])([0-9]+)([mM]?)/, (function (t, e, i, n, r, o) {
          var s;
          switch (e) {
            case "B":
              s = "负" + i + "楼";
              break;
            case "A":
            case "F":
              s = i + "楼"
          }
          return n && (s += "夹层"),
            s
        }
        ))), s = (e = o,
          i = this.spriteMaxToMin,
          n = [],
          r = [],
          i.forEach((function (t) {
            var i = e.indexOf(t)
              , r = t.length;
            if (i > -1) {
              for (; i > -1;)
                n[i] = t,
                  i = e.indexOf(t, i + r);
              for (var o = "", s = 0; s < r; s++)
                o += "/";
              var a = new RegExp(t, "g");
              e = e.replace(a, o)
            }
          }
          )),
          n.forEach((function (t) {
            t && r.push(t)
          }
          )),
          r);
        this.playSprites(s)
      }
      function a(t) {
        var e = []
          , i = 1e3;
        for (t = parseInt(t); 0 !== i;) {
          t %= 10 * i;
          var n = parseInt(t / i);
          if (n > 0) {
            e.push(n + "");
            var r = null;
            switch (i) {
              case 1e3:
                r = "千";
                break;
              case 100:
                r = "百";
                break;
              case 10:
                r = "十"
            }
            r && e.push(r)
          } else {
            var o = e.length;
            o > 0 && "0" !== e[o - 1] && e.push("0")
          }
          i /= 10
        }
        return "0" === e[e.length - 1] && e.pop(),
          "1" === e[0] && "十" === e[1] && e.shift(),
          e
      }
    }
  }
  class xm {
    constructor(t) {
      this._parent = t,
        this.init()
    }
    init() {
      var t = this._parent;
      return this._muted = t._muted,
        this._loop = t._loop,
        this._volume = t._volume,
        this._rate = t._rate,
        this._seek = 0,
        this._paused = !0,
        this._ended = !0,
        this._sprite = "__default",
        this._id = ++mm._counter,
        t._sounds.push(this),
        this.create(),
        this
    }
    create() {
      var t = this._parent
        , e = mm._muted || this._muted || this._parent._muted ? 0 : this._volume;
      return t._webAudio ? (this._node = void 0 === mm.ctx.createGain ? mm.ctx.createGainNode() : mm.ctx.createGain(),
        this._node.gain.setValueAtTime(e, mm.ctx.currentTime),
        this._node.paused = !0,
        this._node.connect(mm.masterGain)) : (this._node = mm._obtainHtml5Audio(),
          this._errorFn = this._errorListener.bind(this),
          this._node.addEventListener("error", this._errorFn, !1),
          this._loadFn = this._loadListener.bind(this),
          this._node.addEventListener(mm._canPlayEvent, this._loadFn, !1),
          this._node.src = t._src,
          this._node.preload = "auto",
          this._node.volume = e * mm.volume(),
          this._node.load()),
        this
    }
    reset() {
      var t = this._parent;
      return this._muted = t._muted,
        this._loop = t._loop,
        this._volume = t._volume,
        this._rate = t._rate,
        this._seek = 0,
        this._rateSeek = 0,
        this._paused = !0,
        this._ended = !0,
        this._sprite = "__default",
        this._id = ++mm._counter,
        this
    }
    _errorListener() {
      this._parent._emit("loaderror", this._id, this._node.error ? this._node.error.code : 0),
        this._node.removeEventListener("error", this._errorFn, !1)
    }
    _loadListener() {
      var t = this._parent;
      t._duration = Math.ceil(10 * this._node.duration) / 10,
        0 === Object.keys(t._sprite).length && (t._sprite = {
          __default: [0, 1e3 * t._duration]
        }),
        "loaded" !== t._state && (t._state = "loaded",
          t._emit("load"),
          t._loadQueue()),
        this._node.removeEventListener(mm._canPlayEvent, this._loadFn, !1)
    }
  }
  function Im(t, e) {
    e && !t._duration && (t._duration = e.duration),
      0 === Object.keys(t._sprite).length && (t._sprite = {
        __default: [0, 1e3 * t._duration]
      }),
      "loaded" !== t._state && (t._state = "loaded",
        t._emit("load"),
        t._loadQueue())
  }
  function Cm(t, e) {
    var i = function () {
      e._emit("loaderror", null, "Decoding audio data failed.")
    }
      , n = function (t) {
        t && e._sounds.length > 0 ? (wm[e._src] = t,
          Im(e, t)) : i()
      };
    void 0 !== Promise && 1 === mm.ctx.decodeAudioData.length ? mm.ctx.decodeAudioData(t).then(n).catch(i) : mm.ctx.decodeAudioData(t, n, i)
  }
  var wm = {};
  const { DEG2RAD: _m, RAD2DEG: Sm } = Ne;
  let Mm;
  addEventListener("pointerdown", (() => {
    clearTimeout(Mm),
      Mm = setTimeout((() => {
        Mm = void 0
      }
      ), 5e3)
  }
  ));
  class Tm extends Se {
    get mapData() {
      return this.map.mapData
    }
    constructor(t) {
      var e;
      let i;
      super(),
        this.status = Ud({
          route: [],
          enterType: pp.elevator,
          crossType: dp.manCar,
          end: null,
          start: null,
          isNavi: !1,
          isSimulate: !1,
          isSimulatePause: !1,
          simulateSpeed: 2.5,
          ar: !1,
          speed: 0,
          compass: 0,
          nextNaviTip: "",
          nextRoutePoint: null,
          nextNaviDistance: 0,
          remainDistance: 0,
          routeDistance: 0,
          locationFloor: null
        }, ((t, e) => {
          this.emit(t + "Change", e)
        }
        )),
        this.object3d = new ra,
        this.arrowHide = new mn,
        this.arrow = new La(new va({
          map: Td.load("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFEAAABPCAYAAACTUyndAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA3FpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDE0IDc5LjE1MTQ4MSwgMjAxMy8wMy8xMy0xMjowOToxNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDoxNzlhMGNiOS1mYTVmLTQ5MzEtOGIwZi02Y2Y0NWFkY2Y4NzIiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MjU5NzgwNzQxNDVEMTFFODg5ODc5M0FBN0Q3OUZCRUYiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MjU5NzgwNzMxNDVEMTFFODg5ODc5M0FBN0Q3OUZCRUYiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjE5MWIyZjEyLWI3YjgtYTY0Zi05NDYyLTZhMTNmZDM0NTZhZSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoxNzlhMGNiOS1mYTVmLTQ5MzEtOGIwZi02Y2Y0NWFkY2Y4NzIiLz4gPC9y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", (() => Pd(this.arrow, .4, this.map.sizeRatio))),
          transparent: !0,
          depthTest: !1,
          depthWrite: !1,
          sizeAttenuation: !1
        })),
        this.positionMarkerHide = new mn,
        this.positionMarker = new La(new va({
          map: Td.load("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='192' height='192' viewBox='0 0 192 192'%3e %3cdefs%3e %3cstyle%3e .cls-1 %7b fill: %233a72ed%3b fill-rule: evenodd%3b %7d %3c/style%3e %3c/defs%3e %3cpath id='%e5%9b%be%e5%b1%82_2' data-name='%e5%9b%be%e5%b1%82 2' class='cls-1' d='M62.4%2c129.04a48.149%2c48.149%2c0%2c0%2c0%2c67.81%2c0%2c47.569%2c47.569%2c0%2c0%2c0%2c0-67.463%2c48.16%2c48.16%2c0%2c0%2c0-67.81%2c0A47.568%2c47.568%2c0%2c0%2c0%2c62.4%2c129.04Z'/%3e %3cpath id='%e5%9b%be%e5%b1%82_3' data-name='%e5%9b%be%e5%b1%82 3' class='cls-1' d='M120.909%2c48.944L96.753%2c10.181%2c72.6%2c48.944A53.056%2c53.056%2c0%2c0%2c1%2c120.909%2c48.944Z'/%3e%3c/svg%3e", (() => Pd(this.positionMarker, .195, this.map.sizeRatio))),
          transparent: !0,
          depthTest: !1,
          sizeAttenuation: !1,
          depthWrite: !1
        })),
        this.audioPlayer = new bm({
          src: "./naviAudio.mp3"
        }),
        this.waypointsPolygonData = [],
        this.beaconCacheList = {},
        this.locResCache = [],
        this.isonceSetCompassOffset = !1,
        this.curPercent = 0,
        this.nextPercent = 0,
        this.waypointMarkList = [],
        this.map = t,
        this.positionMarker.renderOrder = mp,
        this.myPositionPath = {
          id: -1,
          ids: {},
          x: 0,
          y: 0,
          floorId: ""
        },
        this.mapData.path.push(this.myPositionPath),
        Md && (window.$testMsg = (...t) => this.map.testMsg(...t)),
        this.router = new dm(t),
        this.audioPlayer.initAudio(),
        t.object3d.add(this.object3d),
        this.arrow.renderOrder = gp,
        this.myPosition = {
          name: "我的位置",
          id: "0",
          isMyPosition: !0,
          path: [this.myPositionPath.id]
        },
        this.updateNaviTime = t => {
          var e;
          t !== i && (i = t,
            null === (e = this.naviTime) || void 0 === e || e.dispose(),
            this.naviTime = new kf({
              text: t,
              vmap: this.map,
              fillStyle: "#fff",
              align: "left",
              bgColor: "rgb(44,62,89)",
              lineGap: .25,
              isCollision: !1,
              fontSize: 12
            }),
            this.object3d.add(this.naviTime),
            this.naviTime.center.set(-.1, -.5),
            this.naviTime.renderOrder = 99999)
        }
        ,
        this.initMark(),
        (null === (e = this.mapData.options) || void 0 === e ? void 0 : e.closeWalk) && !Md || (this.initLoction(),
          this.onCompass(),
          this.onSocket()),
        (location.href.includes("gpsTest") || location.href.includes("testGps")) && this.clickTestLocation()
    }
    setStart(t) {
      this.setStartEnd(t, "start")
    }
    setEnd(t) {
      this.setStartEnd(t, "end")
    }
    setStartEnd(t, e) {
      if (!t)
        return;
      if (this.status.isNavi || this.status.isSimulate)
        return;
      this.removeNaviArrow(),
        this.removeNaviLine();
      let i, n = this.map.getPolygonDataById(t);
      if (n.parent.build)
        i = this.map.outerFloor;
      else {
        i = this.map.showIndoor(n.parent.parent.id, n.parent.id).curentFloor
      }
      let r = this[`${e}Mark`];
      this.status[e] = n,
        i.object3d.add(r),
        r.position.copy(n.center).setZ(n.height || 2)
    }
    setWaypoints(t) {
      if (!t)
        return;
      if (this.status.isNavi || this.status.isSimulate)
        return;
      this.removeNaviArrow(),
        this.removeNaviLine();
      const e = t => {
        let e, i = this.map.getPolygonDataById(t);
        if (!i)
          return console.log("找不到id:" + t);
        if (i.parent.build)
          e = this.map.outerFloor;
        else {
          e = this.map.showIndoor(i.parent.parent.id, i.parent.id).curentFloor
        }
        let n = this.createWaypointMark();
        n.userData.data = i,
          this.waypointsPolygonData.push(i),
          e.object3d.add(n),
          n.position.copy(i.center).setZ(i.height || 2)
      }
        ;
      Array.isArray(t) ? t.map(e) : e(t)
    }
    find() {
      return sp(this, void 0, void 0, (function* () {
        if (!this.status.start || !this.status.end)
          throw new Error("起点或终点为null");
        let t;
        if (this.waypointsPolygonData.length) {
          let e = []
            , i = [this.status.start, ...this.waypointsPolygonData, this.status.end];
          i.map(((t, n) => {
            i[n + 1] && e.push(this.router.find(t, i[n + 1], this.status.enterType, this.status.crossType))
          }
          ));
          let n = yield Promise.all(e);
          if (console.log("🚀 ~ lines:", n),
            n.find((t => !(null == t ? void 0 : t.length))))
            throw new Error("未找到路线,请联系地图制作方!");
          n.map(((t, e) => {
            e && (null == t || t.splice(0, 1))
          }
          )),
            t = n.flat(),
            t.distance = null == t ? void 0 : t.reduce(((e, i, n) => {
              let r = t[n + 1];
              return r && (i.nextDistance = Math.sqrt(Math.pow(i.point.x - r.point.x, 2) + Math.pow(i.point.y - r.point.y, 2)),
                e += i.nextDistance),
                e
            }
            ), 0),
            t = this.router.computeRouteInfo(t)
        } else
          t = yield this.router.planRoute(this.status.start, this.status.end, this.status.enterType, this.status.crossType);
        if (console.log("🚀 ~ line:", t),
          !(null == t ? void 0 : t.length))
          throw new Error("未找到路线,请联系地图制作方!");
        this.status.route = t,
          this.status.routeDistance = t.distance;
        let e = [];
        this.status.route.reduce(((t, i) => (t[i.point.floorId] = t[i.point.floorId] || [],
          t[i.point.floorId].push(i),
          e.at(-1) !== t[i.point.floorId] && e.push(t[i.point.floorId]),
          t)), {}),
          this.showRouteFloor(e),
          e.map((t => {
            t[0].floor.naviLineData = t,
              t[0].floor.parent && (t[0].floor.parent.naviLineData = t[0].floor.parent.naviLineData || [],
                t[0].floor.parent.naviLineData.push(t))
          }
          )),
          this.map.addNaviLine()
      }
      ))
    }
    showRouteFloor(t) {
      let e = {};
      t.map((t => {
        var i;
        let n = null === (i = t[0].floor.parent) || void 0 === i ? void 0 : i.id;
        n && !e[n] && (this.map.showIndoor(n, t[0].floor.id),
          e[n] = 1)
      }
      ))
    }
    clickTestLocation() {
      console.log("🚀 ~ clickTestLocation:"),
        this.map.on("click", (t => {
          var e, i;
          let n = null === (e = t.object) || void 0 === e ? void 0 : e.userData.polygonData
            , r = {
              x: 115.1590689362627,
              y: 13.020685724382645,
              floor: (null == n ? void 0 : n.parent.id) || this.mapData.id,
              type: (null == n ? void 0 : n.parent.build) ? "GPS" : "rssi",
              originGps: {
                lng: 110.31339088,
                lat: 25.33182552,
                accuracy: 4.54603910446167,
                speed: 0
              },
              lng: 115.1590689362627,
              lat: 13.020685724382645,
              angle: 348,
              time: 191
            }
            , o = this.map.lngLatToCoord(t.lnglat);
          r.lat = t.lnglat.lat,
            r.lng = t.lnglat.lng,
            r.x = o.x,
            r.y = o.y,
            this.status.isNavi && (r.type = "step"),
            null === (i = this.location) || void 0 === i || i.emit("location", r)
        }
        ))
    }
    onSocket() {
      let { socketId: t } = Fd();
      if (!t)
        return;
      let e, i = String.fromCharCode(30);
      const n = () => {
        this.socket = new WebSocket("wss://ws.3dwxb.com/ws"),
          this.socket.onopen = () => {
            var e;
            this.socket.send(`{"protocol":"json","version":1}${i}`),
              this.socket.send((e = t,
                `${JSON.stringify({
                  type: 1,
                  target: "SetId",
                  arguments: [e]
                })}${i}`))
          }
          ,
          this.socket.onclose = this.socket.onerror = () => {
            clearTimeout(e),
              console.log("close"),
              e = setTimeout((() => {
                n()
              }
              ), 1e3)
          }
          ;
        let r = t => {
          if (t.arguments && t.arguments[0]) {
            let { beaconList: e, gps: i } = JSON.parse(t.arguments[0]);
            e && e && this.location.beaconAnalysis(e),
              i && (this.location.$gps.disconnect(),
                this.location.emit("__GPS__", {
                  type: "GPS",
                  GPS: !0,
                  originGps: i,
                  lng: i.gcjLon,
                  lat: i.gcjLat,
                  floor: this.mapData.id
                }))
          }
        }
          ;
        this.socket.onmessage = t => {
          t.data.split(i).map((t => {
            t && r(JSON.parse(t))
          }
          ))
        }
      }
        ;
      n()
    }
    beaconCache(t) {
      let e = Date.now();
      return t.map((t => {
        t.time = e,
          this.beaconCacheList[`${t.major}_${t.minor}`] = t
      }
      )),
        Object.keys(this.beaconCacheList).map((t => {
          const i = this.beaconCacheList[t];
          e - i.time > 1e3 && delete this.beaconCacheList[t]
        }
        )),
        Object.values(this.beaconCacheList)
    }
    initLoction() {
      let t = [];
      this.mapData.beaconData && this.mapData.beaconData.map((e => {
        let i = e.id.split("-")
          , n = this.map.coordsToLngLat(e);
        t.push({
          floor: e.floorId,
          major: i[0],
          minor: i[1],
          x: n.pos[0],
          y: n.pos[1]
        })
      }
      )),
        this.location = new cm({
          debug: !0,
          gps: !Sd,
          GPS: !Sd,
          compassDelay: 100,
          minRssi: -78,
          initAngle: this.mapData.options.compassInitAngle || 0,
          floorDelay: 2e3,
          map: this.map
        }),
        this.location.init(t);
      let e = !0;
      this.location.on("location", (t => sp(this, void 0, void 0, (function* () {
        var i, n, r, o;
        console.log("🚀 ~ type:" + t.type, t);
        let s = im(this.location.locOffset.locPos);
        if (this.reallyPos = this.map.lngLatToCoord(s.lng, s.lat),
          this.location.locOffset.locPos.x || (this.reallyPos.x = t.x,
            this.reallyPos.y = t.y),
          Md && this.map.testPoint([this.reallyPos], "black", 3),
          this.status.isNavi && this.status.nextRoutePoint && (this.location.enterStairLock = !!(null === (i = this.status.nextRoutePoint.tip) || void 0 === i ? void 0 : i.includes("梯")) && this.status.nextNaviDistance <= 3 && this.status.nextRoutePoint.floor.id === t.floor),
          this.status.isNavi) {
          if ("rssi" === t.type || "GPS" === t.type)
            return
        } else if ("step" === t.type)
          return;
        let a = this.map.lngLatToCoord(t.lng, t.lat);
        t.x = a.x,
          t.y = a.y,
          "rssi" === t.type && this.onceSetCompassOffset(t, t.floor),
          this.locResCache.unshift(Object.assign({}, t));
        let l = this.locResCache.reduce(((t, e) => (t.x += e.x,
          t.y += e.y,
          t)), {
          x: 0,
          y: 0
        });
        t.x = l.x / this.locResCache.length,
          t.y = l.y / this.locResCache.length,
          this.locResCache.splice(5, 1),
          this.lastLocationResult = this.status.isNavi ? Object.assign(Object.assign({}, t), this.reallyPos) : t,
          this.status.isNavi || this.status.isSimulate || (yield this.setLocationMyPosition(t)),
          this.setMoveSpeed(t);
        let h = new di(t.x, t.y, 0);
        if (this.onLocationNavi && this.onLocationNavi(h),
          this.positionMarkerHide.position.copy(h),
          null === (n = this._positionMarkerShowTw) || void 0 === n || n.stop(),
          this._positionMarkerShowTw = new Hf(this.positionMarker.position).to(this.positionMarkerHide.position, 300).start(),
          this.positionMarker.visible = !this.status.isNavi || Md || location.href.includes("gpsTest"),
          this.map.lngLatToCoord(...this.mapData.center).distanceTo(h) < 2e4) {
          let i = t.floor;
          this.status.locationFloor = "1" === i ? this.map.mapData : this.map.getMapDataById(i),
            this.emit("location", {
              floor: this.status.locationFloor,
              x: t.x,
              y: t.y,
              lng: t.lng,
              lat: t.lat
            });
          let n = this.status.isSimulate || this.status.isNavi;
          if (n || !e && Mm || ((null === (r = this.status.locationFloor) || void 0 === r ? void 0 : r.parent) && this.status.locationFloor.id !== (null === (o = this.map.status.floor) || void 0 === o ? void 0 : o.data.id) && this.map.showIndoorFitscreen(this.status.locationFloor.parent.id, this.status.locationFloor.id, !1),
            e = !1),
            !Mm && !n) {
            let e = this.map.coordsToLngLat(t);
            this.map.amap.getCenter().distanceTo(e) > 5 && this.map.amap.setZoomAndCenter(this.mapData.showIndoorZoom + 3, e)
          }
        }
        this.map.emit("addLocationPoint", {
          floorId: t.floor,
          marker: this.positionMarker
        })
      }
      ))))
    }
    onceSetCompassOffset(t, e) {
      return sp(this, void 0, void 0, (function* () {
        if (this.isonceSetCompassOffset)
          return;
        this.isonceSetCompassOffset = !0;
        let i = (new Fe).copy(t)
          , n = yield this.map.request({
            url: `${up.api}api/MapExtra/${this.map.options.id}`
          })
          , r = JSON.parse(n.response.data);
        r && r.compassOffset.map((t => {
          if (t.floorId === e) {
            (new Fe).copy(t).distanceTo(i) <= t.radius && (console.log("setOffet", t.val),
              this.location.initAngle = t.val,
              Md && alert(`定位设置偏移: ${t.remark}-度:${t.val}-范围:${t.radius}`))
          }
        }
        ))
      }
      ))
    }
    setMoveSpeed(t) {
      var e;
      (null === (e = t.originGps) || void 0 === e ? void 0 : e.speed) && (this.status.speed = t.originGps.speed),
        this.status.speed = +Number(this.status.speed).toFixed(2)
    }
    stopNavi() {
      this.status.isNavi = !1,
        this.status.ar = !1,
        this.onLocationNavi = null
    }
    setNaviControlStatus(t) {
      !Sd && this.map.amap.setStatus({
        dragEnable: !t,
        rotateEnable: !t
      })
    }
    setNaviIconPosition(t) {
      t > this.nextPercent && (this.nextPercent = t);
      let e = new Bl(this.status.route.map((t => (new Fe).copy(t.point))))
        , i = 1 / e.getLength()
        , n = () => {
          if (this.setNaviIconPositionTw)
            return;
          if (this.curPercent >= this.nextPercent)
            return;
          this.nextPercent - this.curPercent < i ? this.curPercent = this.nextPercent : this.curPercent += i;
          let t = e.getPoint(this.curPercent);
          this.setNaviIconPositionTw = new Hf(this.arrow.position).to(new di(t.x, t.y, 0), 200).onComplete((() => {
            this.setNaviIconPositionTw = null,
              n()
          }
          )).start()
        }
        ;
      n()
    }
    startNavi(t = {}) {
      var e;
      if (this.status.isNavi && !t.isRePlanRoute)
        return;
      if (!this.status.end || !this.status.start)
        return;
      let i;
      this.status.isNavi = !0,
        this.object3d.add(this.arrow),
        null === (e = this.map.status.build) || void 0 === e || e.setOneFloorMode(),
        this.status.route[0].floor.parent && this.map.showIndoor(this.status.route[0].floor.parent.id, this.status.route[0].point.floorId),
        this.status.remainDistance = this.status.route.distance,
        t.isRePlanRoute ? this.audioPlayer.playRange("您已偏离路线") : this.audioPlayer.playRange("导航开始"),
        this.curPercent = 0,
        this.nextPercent = 0,
        this.setNaviIconPositionTw && (this.setNaviIconPositionTw.stop(),
          this.setNaviIconPositionTw = null),
        this.naviInfo = {
          isFirst: !0,
          nextId: 0,
          nextDis: 0,
          isEnd: !1,
          backCount: 0,
          nextIdx: 1,
          nextTipDis: 0
        },
        setTimeout((() => {
          this.map.amap.setZoom(21)
        }
        ), 500),
        setTimeout((() => {
          this.lastLocationResult.type = "step",
            this.location.emit("location", this.lastLocationResult)
        }
        ), 0);
      let n, r = 0;
      const o = () => sp(this, void 0, void 0, (function* () {
        let t = yield this.location2Path(this.reallyPos, "reallyPos");
        if (void 0 === t.distance || !i || void 0 === i.distance)
          return;
        let e = n && n !== this.lastLocationResult.floor;
        if (t.distance < ("1" === this.lastLocationResult.floor ? 15 : 5) && (!r || r - this.status.remainDistance >= 5) || this.naviInfo.isFirst || e) {
          let t = this.map.coordsToLngLat(i);
          this.location._lastLocatePoint.x = t.pos[0],
            this.location._lastLocatePoint.y = t.pos[1],
            Ld("归位"),
            r = this.status.remainDistance,
            this.locResCache = []
        }
        let o = Object.keys(t.ids)
          , s = this.status.route.findIndex((t => +t.point.id == +o[0]))
          , a = this.status.route.findIndex((t => +t.point.id == +o[1]))
          , l = Math.max(s, a)
          , h = this.status.route[l]
          , c = new Fe(t.x, t.y).distanceTo(h.point)
          , u = this.status.route.slice(l).reduce(((t, e) => t + e.nextDistance), 0) + c
          , p = this.status.remainDistance - u;
        this.location.stepSpeed = +Ne.clamp(1 + p / 10, .8, 2).toFixed(2),
          n = this.lastLocationResult.floor
      }
      ));
      this.onLocationNavi = t => sp(this, void 0, void 0, (function* () {
        let e = yield this.location2Path(t, "stepPos");
        if (void 0 === e.distance)
          return;
        i = e,
          e.floorData.parent && this.map.showIndoor(e.floorData.parent.id, e.floorData.id);
        let n = Object.keys(e.ids)
          , r = this.status.route.findIndex((t => +t.point.id == +n[0]))
          , s = this.status.route.findIndex((t => +t.point.id == +n[1]))
          , a = this.naviInfo.__nextIdx = Math.max(r, s);
        o();
        let l = this.status.route[a - 1]
          , h = this.status.route[a]
          , c = this.status.route[a + 1];
        if (this.arrowHide.position.copy(Object.assign(Object.assign({}, e), {
          z: 0
        })),
          this.naviInfo.isFirst && this.arrow.position.copy(this.arrowHide.position),
          this.naviInfo.nextIdx = a,
          this.rePlanRoute(),
          !h)
          return;
        let u = new Fe(e.x, e.y).distanceTo(h.point)
          , p = this.status.route.slice(a).reduce(((t, e) => t + e.nextDistance), 0)
          , d = p + u;
        if (this.setNaviIconPosition(1 - d / this.status.routeDistance),
          d > this.status.remainDistance && (this.naviInfo.backCount++,
            this.naviInfo.backCount < 20))
          return;
        this.naviInfo.backCount = 0,
          this.status.remainDistance = d,
          this.naviInfo.nextId = h.point.id,
          this.naviInfo.nextDis = u,
          this.emitPano(h, c);
        let f = this.status.route.slice(a).map((t => t.point));
        f.unshift(e);
        let g = this.status.route.slice(0, a - 1).map((t => t.point));
        g.push(e),
          this.emit("arRoute", {
            before: f,
            after: g
          });
        let m = this.map.getNaviRotation(l.point, h.point) * Sm
          , y = this.map.amap.getRotation();
        m - y > 180 ? this.map.amap.setRotation(360 + y, !0) : m - y < -180 && this.map.amap.setRotation(-360 + y, !0),
          this.map.amap.setRotation(m, !1, 500),
          !this.naviInfo.isEnd && this.status.remainDistance < 8 && (this.naviInfo.isEnd = !0,
            this._stopNaviTimer = setTimeout((() => {
              this.audioPlayer.playRange("到达目的地,导航结束"),
                this.stopNavi()
            }
            ), 1e4)),
          this.status.remainDistance <= .5 && (clearTimeout(this._stopNaviTimer),
            this.audioPlayer.playRange("到达目的地,导航结束"),
            this.stopNavi()),
          this.naviAudioTip(l, h);
        let v = this.map.coordsToLngLat(e)
          , A = this.map.lngLatToCoord(this.map.amap.getCenter()).distanceTo(this.arrowHide.position);
        Mm && !this.naviInfo.isFirst || (this.naviInfo.isFirst = !1,
          console.log("🚀 ~ disToCenter:", A),
          A > 5 && this.map.amap.setCenter(v))
      }
      ))
    }
    rePlanRoute() {
      return sp(this, void 0, void 0, (function* () {
        let t = this.reallyPos.distanceTo(this.arrowHide.position)
          , e = this.lastLocationResult.floor === this.mapData.id ? 40 : 20;
        if (console.log("🚀 ~ disToReplan:", e, t),
          t > e && t < 5e3 && !this._lockReplanRoute) {
          this._lockReplanRoute = !0,
            yield this.setLocationMyPosition(),
            this.status.start = this.myPosition,
            yield this.find();
          let t = this.myPositionPath.distance > 10;
          this.startNavi({
            isRePlanRoute: !0,
            notInLine: t
          }),
            setTimeout((() => {
              this._lockReplanRoute = !1
            }
            ), 5e3)
        }
      }
      ))
    }
    onCompass() {
      let t = 0;
      this.location.on("compass", (e => {
        let i = this.map.amap.getRotation() * _m;
        t = e * _m,
          this.positionMarker.material.rotation = 2 * Math.PI - t - i,
          this.status.isSimulate || (this.arrow.material.rotation = this.positionMarker.material.rotation,
            this.status.compass = +Number(e).toFixed(0))
      }
      )),
        this.map.amap.on("viewchange", (() => {
          if (this.status.isSimulate)
            return;
          let e = this.map.amap.getRotation() * _m;
          this.arrow.material.rotation = 2 * Math.PI - t - e,
            this.positionMarker.material.rotation = this.arrow.material.rotation
        }
        ))
    }
    stopSimulate() {
      this.status.isSimulate = !1,
        this.status.isSimulatePause = !1,
        this.animate && this.animate.stop(),
        this.setNaviControlStatus(!1)
    }
    removeNaviLine() {
      this.status.route.map((t => {
        delete t.floor.naviLineData,
          t.floor.parent && delete t.floor.parent.naviLineData
      }
      )),
        this.status.route = [],
        this.map.removeNaviLine()
    }
    removeNaviArrow() {
      var t;
      this.arrow.removeFromParent(),
        null === (t = this.naviTime) || void 0 === t || t.dispose()
    }
    removeStartEnd() {
      this.removeStart(),
        this.removeEnd()
    }
    removeEnd() {
      this.status.end = null,
        this.endMark.removeFromParent()
    }
    removeWaypoint(t) {
      var e;
      null === (e = this.waypointMarkList.find((e => e.userData.data.id === t))) || void 0 === e || e.dispose();
      let i = this.waypointsPolygonData.findIndex((e => e.id === t));
      i > -1 && this.waypointsPolygonData.splice(i, 1)
    }
    removeAllWaypoint() {
      this.waypointMarkList.map((t => t.dispose())),
        this.waypointsPolygonData.length = 0
    }
    removeStart() {
      this.status.start = null,
        this.startMark.removeFromParent()
    }
    pauseSimulate() {
      this.status.isSimulatePause = !0,
        this.animate && this.animate.pause(),
        this.setNaviControlStatus(!1)
    }
    resumeSimulate() {
      this.status.isSimulatePause = !1,
        this.animate && this.animate.resume(),
        this.setNaviControlStatus(!0)
    }
    setSimulateSpeed(t = this.status.simulateSpeed) {
      this.status.simulateSpeed = t,
        this.setSimulateSpeedAnimate && this.setSimulateSpeedAnimate()
    }
    simulate() {
      var t, e, i, n;
      return sp(this, void 0, void 0, (function* () {
        if (this.setSimulateSpeedAnimate = null,
          !(null === (t = this.status.route) || void 0 === t ? void 0 : t.length))
          return;
        let r = this.status.route[0];
        this.setNaviControlStatus(!0),
          this.animate && this.animate.stop(),
          this.status.simulateSpeed = 2.5,
          null === (e = this.map.status.build) || void 0 === e || e.setOneFloorMode();
        let o = 0;
        if ((null === (i = this.mapData.options) || void 0 === i ? void 0 : i.closeNaviDemoVoice) || this.audioPlayer.playRange("导航开始"),
          this.status.isSimulate = !0,
          this.status.isSimulatePause = !1,
          this.status.end && this.status.start && this.object3d.add(this.arrow),
          this.naviInfo = {
            nextIdx: 0,
            nextId: 0,
            nextDis: r.nextDistance,
            isEnd: !1,
            nextPanoId: -1,
            nextTipDis: 0
          },
          this.computeNaviInfo(r),
          !Sd || (null === (n = this.mapData.options) || void 0 === n ? void 0 : n.isSimulateRotate)) {
          let { zoom: t } = this.map.getPointsFit([this.status.nextRoutePoint.point, this.status.route[o].point]);
          this.map.amap.setZoomAndCenter(Math.min(22, t), this.map.coordsToLngLat(this.status.route[0].point))
        }
        let s = () => sp(this, void 0, void 0, (function* () {
          var t, e, i, n, r;
          let a = this.status.route[o]
            , l = this.status.route[o + 1]
            , h = this.status.route[o + 2]
            , c = 0;
          if (!l)
            return (null === (t = this.mapData.options) || void 0 === t ? void 0 : t.closeSimulateVoice) || this.audioPlayer.playRange("到达目的地,导航结束"),
              console.log("到达目的地,导航结束"),
              this.status.isSimulate = !1,
              this.stopSimulate(),
              this.status.isSimulatePause = !1,
              void (this.setSimulateSpeedAnimate = null);
          this.arrow.position.set(a.point.x, a.point.y, 0),
            this.naviInfo.nextId = l.point.id,
            this.naviInfo.nextIdx = o,
            l.floor.parent && (l.floor.id === a.floor.id && (null === (e = this.map.status.floor) || void 0 === e ? void 0 : e.data) === a.floor || (c += 500,
              this.map.showIndoor(l.floor.parent.id, l.floor.id))),
            Sd && !(null === (i = this.mapData.options) || void 0 === i ? void 0 : i.isSimulateRotate) || this.status.nextRoutePoint && (this.map.getPointsFit([this.status.nextRoutePoint.point, this.status.route[o].point]),
              this.map.amap.setZoom(Math.min(22, 23), !1, 1e3));
          let u = l.point.floorId !== a.point.floorId && ("1" == l.point.floorId || "1" == a.point.floorId)
            , p = this.map.getNaviRotation(a.point, u ? h.point : l.point)
            , d = p * Sm
            , f = this.map.amap.getRotation();
          d - f > 180 ? this.map.amap.setRotation(360 + f, !0) : d - f < -180 && this.map.amap.setRotation(-360 + f, !0);
          let g = 1e3 / 180 * Math.abs(d - this.map.amap.getRotation());
          (Math.abs(f - d) < 10 || !o) && (g = 0),
            Sd && !(null === (n = this.mapData.options) || void 0 === n ? void 0 : n.isSimulateRotate) || (null === (r = this.mapData.options) || void 0 === r ? void 0 : r.isPlane) || (g *= 2,
              this.map.amap.setRotation(d, !o, g / (Sd ? devicePixelRatio : 1)),
              c += g);
          let m = this.map.coordsToLngLat(a.point)
            , y = this.map.coordsToLngLat(l.point)
            , v = {
              x: a.point.x,
              y: a.point.y,
              lng: m.lng,
              lat: m.lat
            }
            , A = {
              x: l.point.x,
              y: l.point.y,
              lng: y.lng,
              lat: y.lat
            };
          l.point.url && Td.load(l.point.url),
            l.point.floorId === a.point.floorId || "1" === l.point.floorId || "1" === a.point.floorId ? (this.setSimulateSpeedAnimate = (t = 0) => {
              let e = this.naviInfo.nextDis || a.nextDistance;
              this.animate && this.animate.stop(),
                this.animate = new Hf(v).to(A, 1e3 * e / this.status.simulateSpeed).easing(Bf.Linear.None).delay(t).start().onUpdate((() => {
                  var t, e, i, n;
                  this.arrow.position.set(v.x, v.y, 0),
                    this.naviInfo.nextDis = new Fe(v.x, v.y).distanceTo(l.point);
                  let r = this.status.route.slice(o + 1).reduce(((t, e) => t + e.nextDistance), 0);
                  this.status.remainDistance = r + this.naviInfo.nextDis,
                    this.updateNaviTime(`剩余距离: ${this.status.remainDistance.toFixed(0)}米\n大约时长: ${function (t) {
                      lete = parseInt(t)
                        , i = 0
                        , n = 0;
                      e > 60 && (i = parseInt(e / 60),
                        e = parseInt(e % 60),
                        i > 60 && (n = parseInt(i / 60),
                          i = parseInt(i % 60)));
                      letr = parseInt(e) + "秒";
                      i > 0 && (r = parseInt(i) + "分" + r);
                      n > 0 && (r = parseInt(n) + "小时" + r);
                      return r
                    }(this.status.remainDistance)}`),
                    null === (t = this.naviTime) || void 0 === t || t.position.copy(this.arrow.position),
                    (null === (e = this.mapData.options) || void 0 === e ? void 0 : e.closeNaviDemoVoice) || this.naviAudioTip(a, l),
                    this.arrow.material.rotation = p - this.map.amap.getRotation() * _m,
                    this.emitPano(l, h),
                    Sd && !(null === (i = this.mapData.options) || void 0 === i ? void 0 : i.isSimulateRotate) || ((null === (n = this.mapData.options) || void 0 === n ? void 0 : n.isPlane) || this.map.amap.setRotation(d, !0),
                      this.map.amap.setCenter([v.lng, v.lat], !0))
                }
                )).onComplete((() => {
                  this.naviInfo.nextDis = l.nextDistance,
                    s(o++)
                }
                ))
            }
              ,
              this.setSimulateSpeedAnimate(c)) : s(o++)
        }
        ));
        s()
      }
      ))
    }
    emitPano(t, e) {
      if (e && t.point.url && this.naviInfo.nextDis < 8 && this.naviInfo.nextId !== this.naviInfo.nextPanoId) {
        this.naviInfo.nextPanoId = this.naviInfo.nextId;
        let i = (new Fe).copy(t.point).sub((new Fe).copy(e.point)).angle();
        this.emit("showPano", {
          point: t.point,
          angle: i + Math.PI / 2
        })
      }
    }
    computeNaviInfo(t) {
      let e = this.status.route.indexOf(t)
        , i = this.naviInfo.nextDis
        , n = this.status.route.slice(e + 1);
      for (let t = 0; t < n.length; t++) {
        const e = n[t];
        if (e.tip && (e.tip.includes("直行") || e.tip.includes("出入口")))
          i += e.nextDistance;
        else if (e.tip || e.isEnd) {
          e.isEnd ? this.status.nextNaviTip = "到达目的地" : e.tip.includes("电梯") ? this.status.nextNaviTip = "走电梯前往" + n[t + 1].floor.name : e.tip.includes("扶梯") ? this.status.nextNaviTip = "走扶梯前往" + n[t + 1].floor.name : e.tip.includes("楼梯") ? this.status.nextNaviTip = "走楼梯前往" + n[t + 1].floor.name : this.status.nextNaviTip = e.tip.replace("即将", ""),
            this.status.nextRoutePoint = e,
            this.status.nextNaviDistance = +(.9 * i).toFixed(0);
          break
        }
      }
    }
    naviAudioTip(t, e) {
      var i, n, r, o;
      this.computeNaviInfo(t),
        e && (this.status.nextNaviDistance < 6 && !this.naviInfo[null === (i = this.status.nextRoutePoint) || void 0 === i ? void 0 : i.point.id] && this.status.nextNaviTip && (this.naviInfo[null === (n = this.status.nextRoutePoint) || void 0 === n ? void 0 : n.point.id] = 1,
          this.audioPlayer.playRange((this.status.nextNaviTip.includes("梯") ? "请" : "即将") + this.status.nextNaviTip)),
          !this.naviInfo[(null === (r = this.status.nextRoutePoint) || void 0 === r ? void 0 : r.point.id) + "直行"] && this.status.nextNaviDistance > 10 && (this.naviInfo[(null === (o = this.status.nextRoutePoint) || void 0 === o ? void 0 : o.point.id) + "直行"] = 1,
            this.audioPlayer.playRange("直行" + this.status.nextNaviDistance + "米后" + this.status.nextNaviTip)))
    }
    setLocationMyPosition(t = this.lastLocationResult) {
      return sp(this, void 0, void 0, (function* () {
        const e = yield this.location2Path(new Fe(t.x, t.y), "myPos");
        console.log("🚀 ~ min.distance", e),
          void 0 === e.distance || e.distance > 500 || (this.myPositionPath.x = e.x,
            this.myPositionPath.y = e.y,
            this.myPositionPath.ids = e.ids,
            this.myPositionPath.floorId = e.floorData.id,
            yield this.router.worker({
              fn: "setLocationMyPosition",
              myPositionPath: this.myPositionPath
            }),
            this.myPosition.parent = e.floorData,
            Object.keys(this.myPositionPath.ids).length && !this.status.start && this.setStartMyPosition())
      }
      ))
    }
    location2Path(t, e) {
      return sp(this, void 0, void 0, (function* () {
        let i = this.lastLocationResult.floor === this.mapData.id ? this.mapData : this.map.getMapDataById(this.lastLocationResult.floor);
        i && i.id || Md && alert("定位归到路线上错误, 请联系开发者");
        let n, r = {
          floorData: i,
          distance: void 0,
          x: 0,
          y: 0,
          ids: {}
        }, o = [...new Set(this.status.route.map((t => t.floor.id)))], s = o.indexOf(i.id);
        s > -1 && (n = i.id === this.mapData.id ? [o[s - 1], o[s], o[s + 1]].filter((t => t)) : o[s - 1] === this.mapData.id || o[s + 1] === this.mapData.id ? [this.mapData.id, i.id] : [i.id]);
        let a = yield this.router.worker({
          fn: "location2Path",
          point: t,
          location2PathType: e,
          floorId: i.id,
          remainDistance: this.status.remainDistance,
          routeDistance: this.status.routeDistance,
          floorIds: n,
          path: "myPos" == e ? this.mapData.path.filter((t => t.floorId === i.id)) : this.status.route.map((t => t.point))
        });
        return "stepPos" === e && this.map.testPoint(a.min.arrMin),
          Object.assign(Object.assign({}, r), a.min)
      }
      ))
    }
    setStartMyPosition() {
      this.status.start = this.myPosition
    }
    initMark() {
      this.startMark = new La(new va({
        sizeAttenuation: !1,
        depthTest: !1
      })),
        this.endMark = new La(new va({
          sizeAttenuation: !1,
          depthTest: !1,
          map: Td.load(um)
        })),
        this.startMark.renderOrder = this.endMark.renderOrder = bp,
        this.endMark.center.set(.5, -.5),
        this.startMark.material.map = Td.load("data:image/png;base64,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", (() => {
          Pd(this.startMark, .2, this.map.sizeRatio)
        }
        )),
        this.endMark.material.map = Td.load(um, (() => {
          Pd(this.endMark, .2, this.map.sizeRatio)
        }
        )),
        this.startMark.center.copy(this.endMark.center)
    }
    createWaypointMark() {
      let t = new La(new va({
        sizeAttenuation: !1,
        depthTest: !1
      }));
      return t.renderOrder = bp,
        t.center.set(.5, -.5),
        t.material.map = Td.load("data:image/png;base64,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", (() => {
          Pd(t, .2, this.map.sizeRatio)
        }
        )),
        this.waypointMarkList.push(t),
        t
    }
  }
  var Em = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
  function km(t) {
    return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t
  }
  function Rm(t) {
    throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')
  }
  var Lm = {
    exports: {}
  };
  /*!

  JSZip v3.10.1 - A JavaScript class for generating and reading zip files
  <http://stuartk.com/jszip>

  (c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
  Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

  JSZip uses the library pako released under the MIT license :
  https://github.com/nodeca/pako/blob/main/LICENSE
  */
  !function (t, e) {
    t.exports = function t(e, i, n) {
      function r(s, a) {
        if (!i[s]) {
          if (!e[s]) {
            if (!a && Rm)
              return Rm(s);
            if (o)
              return o(s, !0);
            var l = new Error("Cannot find module '" + s + "'");
            throw l.code = "MODULE_NOT_FOUND",
            l
          }
          var h = i[s] = {
            exports: {}
          };
          e[s][0].call(h.exports, (function (t) {
            return r(e[s][1][t] || t)
          }
          ), h, h.exports, t, e, i, n)
        }
        return i[s].exports
      }
      for (var o = Rm, s = 0; s < n.length; s++)
        r(n[s]);
      return r
    }({
      1: [function (t, e, i) {
        var n = t("./utils")
          , r = t("./support")
          , o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        i.encode = function (t) {
          for (var e, i, r, s, a, l, h, c = [], u = 0, p = t.length, d = p, f = "string" !== n.getTypeOf(t); u < t.length;)
            d = p - u,
              r = f ? (e = t[u++],
                i = u < p ? t[u++] : 0,
                u < p ? t[u++] : 0) : (e = t.charCodeAt(u++),
                  i = u < p ? t.charCodeAt(u++) : 0,
                  u < p ? t.charCodeAt(u++) : 0),
              s = e >> 2,
              a = (3 & e) << 4 | i >> 4,
              l = 1 < d ? (15 & i) << 2 | r >> 6 : 64,
              h = 2 < d ? 63 & r : 64,
              c.push(o.charAt(s) + o.charAt(a) + o.charAt(l) + o.charAt(h));
          return c.join("")
        }
          ,
          i.decode = function (t) {
            var e, i, n, s, a, l, h = 0, c = 0, u = "data:";
            if (t.substr(0, u.length) === u)
              throw new Error("Invalid base64 input, it looks like a data url.");
            var p, d = 3 * (t = t.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
            if (t.charAt(t.length - 1) === o.charAt(64) && d--,
              t.charAt(t.length - 2) === o.charAt(64) && d--,
              d % 1 != 0)
              throw new Error("Invalid base64 input, bad content length.");
            for (p = r.uint8array ? new Uint8Array(0 | d) : new Array(0 | d); h < t.length;)
              e = o.indexOf(t.charAt(h++)) << 2 | (s = o.indexOf(t.charAt(h++))) >> 4,
                i = (15 & s) << 4 | (a = o.indexOf(t.charAt(h++))) >> 2,
                n = (3 & a) << 6 | (l = o.indexOf(t.charAt(h++))),
                p[c++] = e,
                64 !== a && (p[c++] = i),
                64 !== l && (p[c++] = n);
            return p
          }
      }
        , {
        "./support": 30,
        "./utils": 32
      }],
      2: [function (t, e, i) {
        var n = t("./external")
          , r = t("./stream/DataWorker")
          , o = t("./stream/Crc32Probe")
          , s = t("./stream/DataLengthProbe");
        function a(t, e, i, n, r) {
          this.compressedSize = t,
            this.uncompressedSize = e,
            this.crc32 = i,
            this.compression = n,
            this.compressedContent = r
        }
        a.prototype = {
          getContentWorker: function () {
            var t = new r(n.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new s("data_length"))
              , e = this;
            return t.on("end", (function () {
              if (this.streamInfo.data_length !== e.uncompressedSize)
                throw new Error("Bug : uncompressed data size mismatch")
            }
            )),
              t
          },
          getCompressedWorker: function () {
            return new r(n.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression)
          }
        },
          a.createWorkerFrom = function (t, e, i) {
            return t.pipe(new o).pipe(new s("uncompressedSize")).pipe(e.compressWorker(i)).pipe(new s("compressedSize")).withStreamInfo("compression", e)
          }
          ,
          e.exports = a
      }
        , {
        "./external": 6,
        "./stream/Crc32Probe": 25,
        "./stream/DataLengthProbe": 26,
        "./stream/DataWorker": 27
      }],
      3: [function (t, e, i) {
        var n = t("./stream/GenericWorker");
        i.STORE = {
          magic: "\0\0",
          compressWorker: function () {
            return new n("STORE compression")
          },
          uncompressWorker: function () {
            return new n("STORE decompression")
          }
        },
          i.DEFLATE = t("./flate")
      }
        , {
        "./flate": 7,
        "./stream/GenericWorker": 28
      }],
      4: [function (t, e, i) {
        var n = t("./utils")
          , r = function () {
            for (var t, e = [], i = 0; i < 256; i++) {
              t = i;
              for (var n = 0; n < 8; n++)
                t = 1 & t ? 3988292384 ^ t >>> 1 : t >>> 1;
              e[i] = t
            }
            return e
          }();
        e.exports = function (t, e) {
          return void 0 !== t && t.length ? "string" !== n.getTypeOf(t) ? function (t, e, i, n) {
            var o = r
              , s = n + i;
            t ^= -1;
            for (var a = n; a < s; a++)
              t = t >>> 8 ^ o[255 & (t ^ e[a])];
            return -1 ^ t
          }(0 | e, t, t.length, 0) : function (t, e, i, n) {
            var o = r
              , s = n + i;
            t ^= -1;
            for (var a = n; a < s; a++)
              t = t >>> 8 ^ o[255 & (t ^ e.charCodeAt(a))];
            return -1 ^ t
          }(0 | e, t, t.length, 0) : 0
        }
      }
        , {
        "./utils": 32
      }],
      5: [function (t, e, i) {
        i.base64 = !1,
          i.binary = !1,
          i.dir = !1,
          i.createFolders = !0,
          i.date = null,
          i.compression = null,
          i.compressionOptions = null,
          i.comment = null,
          i.unixPermissions = null,
          i.dosPermissions = null
      }
        , {}],
      6: [function (t, e, i) {
        var n = null;
        n = "undefined" != typeof Promise ? Promise : t("lie"),
          e.exports = {
            Promise: n
          }
      }
        , {
        lie: 37
      }],
      7: [function (t, e, i) {
        var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array
          , r = t("pako")
          , o = t("./utils")
          , s = t("./stream/GenericWorker")
          , a = n ? "uint8array" : "array";
        function l(t, e) {
          s.call(this, "FlateWorker/" + t),
            this._pako = null,
            this._pakoAction = t,
            this._pakoOptions = e,
            this.meta = {}
        }
        i.magic = "\b\0",
          o.inherits(l, s),
          l.prototype.processChunk = function (t) {
            this.meta = t.meta,
              null === this._pako && this._createPako(),
              this._pako.push(o.transformTo(a, t.data), !1)
          }
          ,
          l.prototype.flush = function () {
            s.prototype.flush.call(this),
              null === this._pako && this._createPako(),
              this._pako.push([], !0)
          }
          ,
          l.prototype.cleanUp = function () {
            s.prototype.cleanUp.call(this),
              this._pako = null
          }
          ,
          l.prototype._createPako = function () {
            this._pako = new r[this._pakoAction]({
              raw: !0,
              level: this._pakoOptions.level || -1
            });
            var t = this;
            this._pako.onData = function (e) {
              t.push({
                data: e,
                meta: t.meta
              })
            }
          }
          ,
          i.compressWorker = function (t) {
            return new l("Deflate", t)
          }
          ,
          i.uncompressWorker = function () {
            return new l("Inflate", {})
          }
      }
        , {
        "./stream/GenericWorker": 28,
        "./utils": 32,
        pako: 38
      }],
      8: [function (t, e, i) {
        function n(t, e) {
          var i, n = "";
          for (i = 0; i < e; i++)
            n += String.fromCharCode(255 & t),
              t >>>= 8;
          return n
        }
        function r(t, e, i, r, s, c) {
          var u, p, d = t.file, f = t.compression, g = c !== a.utf8encode, m = o.transformTo("string", c(d.name)), y = o.transformTo("string", a.utf8encode(d.name)), v = d.comment, A = o.transformTo("string", c(v)), b = o.transformTo("string", a.utf8encode(v)), x = y.length !== d.name.length, I = b.length !== v.length, C = "", w = "", _ = "", S = d.dir, M = d.date, T = {
            crc32: 0,
            compressedSize: 0,
            uncompressedSize: 0
          };
          e && !i || (T.crc32 = t.crc32,
            T.compressedSize = t.compressedSize,
            T.uncompressedSize = t.uncompressedSize);
          var E = 0;
          e && (E |= 8),
            g || !x && !I || (E |= 2048);
          var k = 0
            , R = 0;
          S && (k |= 16),
            "UNIX" === s ? (R = 798,
              k |= function (t, e) {
                var i = t;
                return t || (i = e ? 16893 : 33204),
                  (65535 & i) << 16
              }(d.unixPermissions, S)) : (R = 20,
                k |= function (t) {
                  return 63 & (t || 0)
                }(d.dosPermissions)),
            u = M.getUTCHours(),
            u <<= 6,
            u |= M.getUTCMinutes(),
            u <<= 5,
            u |= M.getUTCSeconds() / 2,
            p = M.getUTCFullYear() - 1980,
            p <<= 4,
            p |= M.getUTCMonth() + 1,
            p <<= 5,
            p |= M.getUTCDate(),
            x && (w = n(1, 1) + n(l(m), 4) + y,
              C += "up" + n(w.length, 2) + w),
            I && (_ = n(1, 1) + n(l(A), 4) + b,
              C += "uc" + n(_.length, 2) + _);
          var L = "";
          return L += "\n\0",
            L += n(E, 2),
            L += f.magic,
            L += n(u, 2),
            L += n(p, 2),
            L += n(T.crc32, 4),
            L += n(T.compressedSize, 4),
            L += n(T.uncompressedSize, 4),
            L += n(m.length, 2),
            L += n(C.length, 2),
          {
            fileRecord: h.LOCAL_FILE_HEADER + L + m + C,
            dirRecord: h.CENTRAL_FILE_HEADER + n(R, 2) + L + n(A.length, 2) + "\0\0\0\0" + n(k, 4) + n(r, 4) + m + C + A
          }
        }
        var o = t("../utils")
          , s = t("../stream/GenericWorker")
          , a = t("../utf8")
          , l = t("../crc32")
          , h = t("../signature");
        function c(t, e, i, n) {
          s.call(this, "ZipFileWorker"),
            this.bytesWritten = 0,
            this.zipComment = e,
            this.zipPlatform = i,
            this.encodeFileName = n,
            this.streamFiles = t,
            this.accumulate = !1,
            this.contentBuffer = [],
            this.dirRecords = [],
            this.currentSourceOffset = 0,
            this.entriesCount = 0,
            this.currentFile = null,
            this._sources = []
        }
        o.inherits(c, s),
          c.prototype.push = function (t) {
            var e = t.meta.percent || 0
              , i = this.entriesCount
              , n = this._sources.length;
            this.accumulate ? this.contentBuffer.push(t) : (this.bytesWritten += t.data.length,
              s.prototype.push.call(this, {
                data: t.data,
                meta: {
                  currentFile: this.currentFile,
                  percent: i ? (e + 100 * (i - n - 1)) / i : 100
                }
              }))
          }
          ,
          c.prototype.openedSource = function (t) {
            this.currentSourceOffset = this.bytesWritten,
              this.currentFile = t.file.name;
            var e = this.streamFiles && !t.file.dir;
            if (e) {
              var i = r(t, e, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
              this.push({
                data: i.fileRecord,
                meta: {
                  percent: 0
                }
              })
            } else
              this.accumulate = !0
          }
          ,
          c.prototype.closedSource = function (t) {
            this.accumulate = !1;
            var e = this.streamFiles && !t.file.dir
              , i = r(t, e, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
            if (this.dirRecords.push(i.dirRecord),
              e)
              this.push({
                data: function (t) {
                  return h.DATA_DESCRIPTOR + n(t.crc32, 4) + n(t.compressedSize, 4) + n(t.uncompressedSize, 4)
                }(t),
                meta: {
                  percent: 100
                }
              });
            else
              for (this.push({
                data: i.fileRecord,
                meta: {
                  percent: 0
                }
              }); this.contentBuffer.length;)
                this.push(this.contentBuffer.shift());
            this.currentFile = null
          }
          ,
          c.prototype.flush = function () {
            for (var t = this.bytesWritten, e = 0; e < this.dirRecords.length; e++)
              this.push({
                data: this.dirRecords[e],
                meta: {
                  percent: 100
                }
              });
            var i = this.bytesWritten - t
              , r = function (t, e, i, r, s) {
                var a = o.transformTo("string", s(r));
                return h.CENTRAL_DIRECTORY_END + "\0\0\0\0" + n(t, 2) + n(t, 2) + n(e, 4) + n(i, 4) + n(a.length, 2) + a
              }(this.dirRecords.length, i, t, this.zipComment, this.encodeFileName);
            this.push({
              data: r,
              meta: {
                percent: 100
              }
            })
          }
          ,
          c.prototype.prepareNextSource = function () {
            this.previous = this._sources.shift(),
              this.openedSource(this.previous.streamInfo),
              this.isPaused ? this.previous.pause() : this.previous.resume()
          }
          ,
          c.prototype.registerPrevious = function (t) {
            this._sources.push(t);
            var e = this;
            return t.on("data", (function (t) {
              e.processChunk(t)
            }
            )),
              t.on("end", (function () {
                e.closedSource(e.previous.streamInfo),
                  e._sources.length ? e.prepareNextSource() : e.end()
              }
              )),
              t.on("error", (function (t) {
                e.error(t)
              }
              )),
              this
          }
          ,
          c.prototype.resume = function () {
            return !!s.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(),
              !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(),
                !0))
          }
          ,
          c.prototype.error = function (t) {
            var e = this._sources;
            if (!s.prototype.error.call(this, t))
              return !1;
            for (var i = 0; i < e.length; i++)
              try {
                e[i].error(t)
              } catch (t) { }
            return !0
          }
          ,
          c.prototype.lock = function () {
            s.prototype.lock.call(this);
            for (var t = this._sources, e = 0; e < t.length; e++)
              t[e].lock()
          }
          ,
          e.exports = c
      }
        , {
        "../crc32": 4,
        "../signature": 23,
        "../stream/GenericWorker": 28,
        "../utf8": 31,
        "../utils": 32
      }],
      9: [function (t, e, i) {
        var n = t("../compressions")
          , r = t("./ZipFileWorker");
        i.generateWorker = function (t, e, i) {
          var o = new r(e.streamFiles, i, e.platform, e.encodeFileName)
            , s = 0;
          try {
            t.forEach((function (t, i) {
              s++;
              var r = function (t, e) {
                var i = t || e
                  , r = n[i];
                if (!r)
                  throw new Error(i + " is not a valid compression method !");
                return r
              }(i.options.compression, e.compression)
                , a = i.options.compressionOptions || e.compressionOptions || {}
                , l = i.dir
                , h = i.date;
              i._compressWorker(r, a).withStreamInfo("file", {
                name: t,
                dir: l,
                date: h,
                comment: i.comment || "",
                unixPermissions: i.unixPermissions,
                dosPermissions: i.dosPermissions
              }).pipe(o)
            }
            )),
              o.entriesCount = s
          } catch (t) {
            o.error(t)
          }
          return o
        }
      }
        , {
        "../compressions": 3,
        "./ZipFileWorker": 8
      }],
      10: [function (t, e, i) {
        function n() {
          if (!(this instanceof n))
            return new n;
          if (arguments.length)
            throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
          this.files = Object.create(null),
            this.comment = null,
            this.root = "",
            this.clone = function () {
              var t = new n;
              for (var e in this)
                "function" != typeof this[e] && (t[e] = this[e]);
              return t
            }
        }
        (n.prototype = t("./object")).loadAsync = t("./load"),
          n.support = t("./support"),
          n.defaults = t("./defaults"),
          n.version = "3.10.1",
          n.loadAsync = function (t, e) {
            return (new n).loadAsync(t, e)
          }
          ,
          n.external = t("./external"),
          e.exports = n
      }
        , {
        "./defaults": 5,
        "./external": 6,
        "./load": 11,
        "./object": 15,
        "./support": 30
      }],
      11: [function (t, e, i) {
        var n = t("./utils")
          , r = t("./external")
          , o = t("./utf8")
          , s = t("./zipEntries")
          , a = t("./stream/Crc32Probe")
          , l = t("./nodejsUtils");
        function h(t) {
          return new r.Promise((function (e, i) {
            var n = t.decompressed.getContentWorker().pipe(new a);
            n.on("error", (function (t) {
              i(t)
            }
            )).on("end", (function () {
              n.streamInfo.crc32 !== t.decompressed.crc32 ? i(new Error("Corrupted zip : CRC32 mismatch")) : e()
            }
            )).resume()
          }
          ))
        }
        e.exports = function (t, e) {
          var i = this;
          return e = n.extend(e || {}, {
            base64: !1,
            checkCRC32: !1,
            optimizedBinaryString: !1,
            createFolders: !1,
            decodeFileName: o.utf8decode
          }),
            l.isNode && l.isStream(t) ? r.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : n.prepareContent("the loaded zip file", t, !0, e.optimizedBinaryString, e.base64).then((function (t) {
              var i = new s(e);
              return i.load(t),
                i
            }
            )).then((function (t) {
              var i = [r.Promise.resolve(t)]
                , n = t.files;
              if (e.checkCRC32)
                for (var o = 0; o < n.length; o++)
                  i.push(h(n[o]));
              return r.Promise.all(i)
            }
            )).then((function (t) {
              for (var r = t.shift(), o = r.files, s = 0; s < o.length; s++) {
                var a = o[s]
                  , l = a.fileNameStr
                  , h = n.resolve(a.fileNameStr);
                i.file(h, a.decompressed, {
                  binary: !0,
                  optimizedBinaryString: !0,
                  date: a.date,
                  dir: a.dir,
                  comment: a.fileCommentStr.length ? a.fileCommentStr : null,
                  unixPermissions: a.unixPermissions,
                  dosPermissions: a.dosPermissions,
                  createFolders: e.createFolders
                }),
                  a.dir || (i.file(h).unsafeOriginalName = l)
              }
              return r.zipComment.length && (i.comment = r.zipComment),
                i
            }
            ))
        }
      }
        , {
        "./external": 6,
        "./nodejsUtils": 14,
        "./stream/Crc32Probe": 25,
        "./utf8": 31,
        "./utils": 32,
        "./zipEntries": 33
      }],
      12: [function (t, e, i) {
        var n = t("../utils")
          , r = t("../stream/GenericWorker");
        function o(t, e) {
          r.call(this, "Nodejs stream input adapter for " + t),
            this._upstreamEnded = !1,
            this._bindStream(e)
        }
        n.inherits(o, r),
          o.prototype._bindStream = function (t) {
            var e = this;
            (this._stream = t).pause(),
              t.on("data", (function (t) {
                e.push({
                  data: t,
                  meta: {
                    percent: 0
                  }
                })
              }
              )).on("error", (function (t) {
                e.isPaused ? this.generatedError = t : e.error(t)
              }
              )).on("end", (function () {
                e.isPaused ? e._upstreamEnded = !0 : e.end()
              }
              ))
          }
          ,
          o.prototype.pause = function () {
            return !!r.prototype.pause.call(this) && (this._stream.pause(),
              !0)
          }
          ,
          o.prototype.resume = function () {
            return !!r.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(),
              !0)
          }
          ,
          e.exports = o
      }
        , {
        "../stream/GenericWorker": 28,
        "../utils": 32
      }],
      13: [function (t, e, i) {
        var n = t("readable-stream").Readable;
        function r(t, e, i) {
          n.call(this, e),
            this._helper = t;
          var r = this;
          t.on("data", (function (t, e) {
            r.push(t) || r._helper.pause(),
              i && i(e)
          }
          )).on("error", (function (t) {
            r.emit("error", t)
          }
          )).on("end", (function () {
            r.push(null)
          }
          ))
        }
        t("../utils").inherits(r, n),
          r.prototype._read = function () {
            this._helper.resume()
          }
          ,
          e.exports = r
      }
        , {
        "../utils": 32,
        "readable-stream": 16
      }],
      14: [function (t, e, i) {
        e.exports = {
          isNode: "undefined" != typeof Buffer,
          newBufferFrom: function (t, e) {
            if (Buffer.from && Buffer.from !== Uint8Array.from)
              return Buffer.from(t, e);
            if ("number" == typeof t)
              throw new Error('The "data" argument must not be a number');
            return new Buffer(t, e)
          },
          allocBuffer: function (t) {
            if (Buffer.alloc)
              return Buffer.alloc(t);
            var e = new Buffer(t);
            return e.fill(0),
              e
          },
          isBuffer: function (t) {
            return Buffer.isBuffer(t)
          },
          isStream: function (t) {
            return t && "function" == typeof t.on && "function" == typeof t.pause && "function" == typeof t.resume
          }
        }
      }
        , {}],
      15: [function (t, e, i) {
        function n(t, e, i) {
          var n, r = o.getTypeOf(e), a = o.extend(i || {}, l);
          a.date = a.date || new Date,
            null !== a.compression && (a.compression = a.compression.toUpperCase()),
            "string" == typeof a.unixPermissions && (a.unixPermissions = parseInt(a.unixPermissions, 8)),
            a.unixPermissions && 16384 & a.unixPermissions && (a.dir = !0),
            a.dosPermissions && 16 & a.dosPermissions && (a.dir = !0),
            a.dir && (t = g(t)),
            a.createFolders && (n = f(t)) && m.call(this, n, !0);
          var u = "string" === r && !1 === a.binary && !1 === a.base64;
          i && void 0 !== i.binary || (a.binary = !u),
            (e instanceof h && 0 === e.uncompressedSize || a.dir || !e || 0 === e.length) && (a.base64 = !1,
              a.binary = !0,
              e = "",
              a.compression = "STORE",
              r = "string");
          var y = null;
          y = e instanceof h || e instanceof s ? e : p.isNode && p.isStream(e) ? new d(t, e) : o.prepareContent(t, e, a.binary, a.optimizedBinaryString, a.base64);
          var v = new c(t, y, a);
          this.files[t] = v
        }
        var r = t("./utf8")
          , o = t("./utils")
          , s = t("./stream/GenericWorker")
          , a = t("./stream/StreamHelper")
          , l = t("./defaults")
          , h = t("./compressedObject")
          , c = t("./zipObject")
          , u = t("./generate")
          , p = t("./nodejsUtils")
          , d = t("./nodejs/NodejsStreamInputAdapter")
          , f = function (t) {
            "/" === t.slice(-1) && (t = t.substring(0, t.length - 1));
            var e = t.lastIndexOf("/");
            return 0 < e ? t.substring(0, e) : ""
          }
          , g = function (t) {
            return "/" !== t.slice(-1) && (t += "/"),
              t
          }
          , m = function (t, e) {
            return e = void 0 !== e ? e : l.createFolders,
              t = g(t),
              this.files[t] || n.call(this, t, null, {
                dir: !0,
                createFolders: e
              }),
              this.files[t]
          };
        function y(t) {
          return "[object RegExp]" === Object.prototype.toString.call(t)
        }
        var v = {
          load: function () {
            throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")
          },
          forEach: function (t) {
            var e, i, n;
            for (e in this.files)
              n = this.files[e],
                (i = e.slice(this.root.length, e.length)) && e.slice(0, this.root.length) === this.root && t(i, n)
          },
          filter: function (t) {
            var e = [];
            return this.forEach((function (i, n) {
              t(i, n) && e.push(n)
            }
            )),
              e
          },
          file: function (t, e, i) {
            if (1 !== arguments.length)
              return t = this.root + t,
                n.call(this, t, e, i),
                this;
            if (y(t)) {
              var r = t;
              return this.filter((function (t, e) {
                return !e.dir && r.test(t)
              }
              ))
            }
            var o = this.files[this.root + t];
            return o && !o.dir ? o : null
          },
          folder: function (t) {
            if (!t)
              return this;
            if (y(t))
              return this.filter((function (e, i) {
                return i.dir && t.test(e)
              }
              ));
            var e = this.root + t
              , i = m.call(this, e)
              , n = this.clone();
            return n.root = i.name,
              n
          },
          remove: function (t) {
            t = this.root + t;
            var e = this.files[t];
            if (e || ("/" !== t.slice(-1) && (t += "/"),
              e = this.files[t]),
              e && !e.dir)
              delete this.files[t];
            else
              for (var i = this.filter((function (e, i) {
                return i.name.slice(0, t.length) === t
              }
              )), n = 0; n < i.length; n++)
                delete this.files[i[n].name];
            return this
          },
          generate: function () {
            throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")
          },
          generateInternalStream: function (t) {
            var e, i = {};
            try {
              if ((i = o.extend(t || {}, {
                streamFiles: !1,
                compression: "STORE",
                compressionOptions: null,
                type: "",
                platform: "DOS",
                comment: null,
                mimeType: "application/zip",
                encodeFileName: r.utf8encode
              })).type = i.type.toLowerCase(),
                i.compression = i.compression.toUpperCase(),
                "binarystring" === i.type && (i.type = "string"),
                !i.type)
                throw new Error("No output type specified.");
              o.checkSupport(i.type),
                "darwin" !== i.platform && "freebsd" !== i.platform && "linux" !== i.platform && "sunos" !== i.platform || (i.platform = "UNIX"),
                "win32" === i.platform && (i.platform = "DOS");
              var n = i.comment || this.comment || "";
              e = u.generateWorker(this, i, n)
            } catch (t) {
              (e = new s("error")).error(t)
            }
            return new a(e, i.type || "string", i.mimeType)
          },
          generateAsync: function (t, e) {
            return this.generateInternalStream(t).accumulate(e)
          },
          generateNodeStream: function (t, e) {
            return (t = t || {}).type || (t.type = "nodebuffer"),
              this.generateInternalStream(t).toNodejsStream(e)
          }
        };
        e.exports = v
      }
        , {
        "./compressedObject": 2,
        "./defaults": 5,
        "./generate": 9,
        "./nodejs/NodejsStreamInputAdapter": 12,
        "./nodejsUtils": 14,
        "./stream/GenericWorker": 28,
        "./stream/StreamHelper": 29,
        "./utf8": 31,
        "./utils": 32,
        "./zipObject": 35
      }],
      16: [function (t, e, i) {
        e.exports = t("stream")
      }
        , {
        stream: void 0
      }],
      17: [function (t, e, i) {
        var n = t("./DataReader");
        function r(t) {
          n.call(this, t);
          for (var e = 0; e < this.data.length; e++)
            t[e] = 255 & t[e]
        }
        t("../utils").inherits(r, n),
          r.prototype.byteAt = function (t) {
            return this.data[this.zero + t]
          }
          ,
          r.prototype.lastIndexOfSignature = function (t) {
            for (var e = t.charCodeAt(0), i = t.charCodeAt(1), n = t.charCodeAt(2), r = t.charCodeAt(3), o = this.length - 4; 0 <= o; --o)
              if (this.data[o] === e && this.data[o + 1] === i && this.data[o + 2] === n && this.data[o + 3] === r)
                return o - this.zero;
            return -1
          }
          ,
          r.prototype.readAndCheckSignature = function (t) {
            var e = t.charCodeAt(0)
              , i = t.charCodeAt(1)
              , n = t.charCodeAt(2)
              , r = t.charCodeAt(3)
              , o = this.readData(4);
            return e === o[0] && i === o[1] && n === o[2] && r === o[3]
          }
          ,
          r.prototype.readData = function (t) {
            if (this.checkOffset(t),
              0 === t)
              return [];
            var e = this.data.slice(this.zero + this.index, this.zero + this.index + t);
            return this.index += t,
              e
          }
          ,
          e.exports = r
      }
        , {
        "../utils": 32,
        "./DataReader": 18
      }],
      18: [function (t, e, i) {
        var n = t("../utils");
        function r(t) {
          this.data = t,
            this.length = t.length,
            this.index = 0,
            this.zero = 0
        }
        r.prototype = {
          checkOffset: function (t) {
            this.checkIndex(this.index + t)
          },
          checkIndex: function (t) {
            if (this.length < this.zero + t || t < 0)
              throw new Error("End of data reached (data length = " + this.length + ", asked index = " + t + "). Corrupted zip ?")
          },
          setIndex: function (t) {
            this.checkIndex(t),
              this.index = t
          },
          skip: function (t) {
            this.setIndex(this.index + t)
          },
          byteAt: function () { },
          readInt: function (t) {
            var e, i = 0;
            for (this.checkOffset(t),
              e = this.index + t - 1; e >= this.index; e--)
              i = (i << 8) + this.byteAt(e);
            return this.index += t,
              i
          },
          readString: function (t) {
            return n.transformTo("string", this.readData(t))
          },
          readData: function () { },
          lastIndexOfSignature: function () { },
          readAndCheckSignature: function () { },
          readDate: function () {
            var t = this.readInt(4);
            return new Date(Date.UTC(1980 + (t >> 25 & 127), (t >> 21 & 15) - 1, t >> 16 & 31, t >> 11 & 31, t >> 5 & 63, (31 & t) << 1))
          }
        },
          e.exports = r
      }
        , {
        "../utils": 32
      }],
      19: [function (t, e, i) {
        var n = t("./Uint8ArrayReader");
        function r(t) {
          n.call(this, t)
        }
        t("../utils").inherits(r, n),
          r.prototype.readData = function (t) {
            this.checkOffset(t);
            var e = this.data.slice(this.zero + this.index, this.zero + this.index + t);
            return this.index += t,
              e
          }
          ,
          e.exports = r
      }
        , {
        "../utils": 32,
        "./Uint8ArrayReader": 21
      }],
      20: [function (t, e, i) {
        var n = t("./DataReader");
        function r(t) {
          n.call(this, t)
        }
        t("../utils").inherits(r, n),
          r.prototype.byteAt = function (t) {
            return this.data.charCodeAt(this.zero + t)
          }
          ,
          r.prototype.lastIndexOfSignature = function (t) {
            return this.data.lastIndexOf(t) - this.zero
          }
          ,
          r.prototype.readAndCheckSignature = function (t) {
            return t === this.readData(4)
          }
          ,
          r.prototype.readData = function (t) {
            this.checkOffset(t);
            var e = this.data.slice(this.zero + this.index, this.zero + this.index + t);
            return this.index += t,
              e
          }
          ,
          e.exports = r
      }
        , {
        "../utils": 32,
        "./DataReader": 18
      }],
      21: [function (t, e, i) {
        var n = t("./ArrayReader");
        function r(t) {
          n.call(this, t)
        }
        t("../utils").inherits(r, n),
          r.prototype.readData = function (t) {
            if (this.checkOffset(t),
              0 === t)
              return new Uint8Array(0);
            var e = this.data.subarray(this.zero + this.index, this.zero + this.index + t);
            return this.index += t,
              e
          }
          ,
          e.exports = r
      }
        , {
        "../utils": 32,
        "./ArrayReader": 17
      }],
      22: [function (t, e, i) {
        var n = t("../utils")
          , r = t("../support")
          , o = t("./ArrayReader")
          , s = t("./StringReader")
          , a = t("./NodeBufferReader")
          , l = t("./Uint8ArrayReader");
        e.exports = function (t) {
          var e = n.getTypeOf(t);
          return n.checkSupport(e),
            "string" !== e || r.uint8array ? "nodebuffer" === e ? new a(t) : r.uint8array ? new l(n.transformTo("uint8array", t)) : new o(n.transformTo("array", t)) : new s(t)
        }
      }
        , {
        "../support": 30,
        "../utils": 32,
        "./ArrayReader": 17,
        "./NodeBufferReader": 19,
        "./StringReader": 20,
        "./Uint8ArrayReader": 21
      }],
      23: [function (t, e, i) {
        i.LOCAL_FILE_HEADER = "PK",
          i.CENTRAL_FILE_HEADER = "PK",
          i.CENTRAL_DIRECTORY_END = "PK",
          i.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK",
          i.ZIP64_CENTRAL_DIRECTORY_END = "PK",
          i.DATA_DESCRIPTOR = "PK\b"
      }
        , {}],
      24: [function (t, e, i) {
        var n = t("./GenericWorker")
          , r = t("../utils");
        function o(t) {
          n.call(this, "ConvertWorker to " + t),
            this.destType = t
        }
        r.inherits(o, n),
          o.prototype.processChunk = function (t) {
            this.push({
              data: r.transformTo(this.destType, t.data),
              meta: t.meta
            })
          }
          ,
          e.exports = o
      }
        , {
        "../utils": 32,
        "./GenericWorker": 28
      }],
      25: [function (t, e, i) {
        var n = t("./GenericWorker")
          , r = t("../crc32");
        function o() {
          n.call(this, "Crc32Probe"),
            this.withStreamInfo("crc32", 0)
        }
        t("../utils").inherits(o, n),
          o.prototype.processChunk = function (t) {
            this.streamInfo.crc32 = r(t.data, this.streamInfo.crc32 || 0),
              this.push(t)
          }
          ,
          e.exports = o
      }
        , {
        "../crc32": 4,
        "../utils": 32,
        "./GenericWorker": 28
      }],
      26: [function (t, e, i) {
        var n = t("../utils")
          , r = t("./GenericWorker");
        function o(t) {
          r.call(this, "DataLengthProbe for " + t),
            this.propName = t,
            this.withStreamInfo(t, 0)
        }
        n.inherits(o, r),
          o.prototype.processChunk = function (t) {
            if (t) {
              var e = this.streamInfo[this.propName] || 0;
              this.streamInfo[this.propName] = e + t.data.length
            }
            r.prototype.processChunk.call(this, t)
          }
          ,
          e.exports = o
      }
        , {
        "../utils": 32,
        "./GenericWorker": 28
      }],
      27: [function (t, e, i) {
        var n = t("../utils")
          , r = t("./GenericWorker");
        function o(t) {
          r.call(this, "DataWorker");
          var e = this;
          this.dataIsReady = !1,
            this.index = 0,
            this.max = 0,
            this.data = null,
            this.type = "",
            this._tickScheduled = !1,
            t.then((function (t) {
              e.dataIsReady = !0,
                e.data = t,
                e.max = t && t.length || 0,
                e.type = n.getTypeOf(t),
                e.isPaused || e._tickAndRepeat()
            }
            ), (function (t) {
              e.error(t)
            }
            ))
        }
        n.inherits(o, r),
          o.prototype.cleanUp = function () {
            r.prototype.cleanUp.call(this),
              this.data = null
          }
          ,
          o.prototype.resume = function () {
            return !!r.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0,
              n.delay(this._tickAndRepeat, [], this)),
              !0)
          }
          ,
          o.prototype._tickAndRepeat = function () {
            this._tickScheduled = !1,
              this.isPaused || this.isFinished || (this._tick(),
                this.isFinished || (n.delay(this._tickAndRepeat, [], this),
                  this._tickScheduled = !0))
          }
          ,
          o.prototype._tick = function () {
            if (this.isPaused || this.isFinished)
              return !1;
            var t = null
              , e = Math.min(this.max, this.index + 16384);
            if (this.index >= this.max)
              return this.end();
            switch (this.type) {
              case "string":
                t = this.data.substring(this.index, e);
                break;
              case "uint8array":
                t = this.data.subarray(this.index, e);
                break;
              case "array":
              case "nodebuffer":
                t = this.data.slice(this.index, e)
            }
            return this.index = e,
              this.push({
                data: t,
                meta: {
                  percent: this.max ? this.index / this.max * 100 : 0
                }
              })
          }
          ,
          e.exports = o
      }
        , {
        "../utils": 32,
        "./GenericWorker": 28
      }],
      28: [function (t, e, i) {
        function n(t) {
          this.name = t || "default",
            this.streamInfo = {},
            this.generatedError = null,
            this.extraStreamInfo = {},
            this.isPaused = !0,
            this.isFinished = !1,
            this.isLocked = !1,
            this._listeners = {
              data: [],
              end: [],
              error: []
            },
            this.previous = null
        }
        n.prototype = {
          push: function (t) {
            this.emit("data", t)
          },
          end: function () {
            if (this.isFinished)
              return !1;
            this.flush();
            try {
              this.emit("end"),
                this.cleanUp(),
                this.isFinished = !0
            } catch (t) {
              this.emit("error", t)
            }
            return !0
          },
          error: function (t) {
            return !this.isFinished && (this.isPaused ? this.generatedError = t : (this.isFinished = !0,
              this.emit("error", t),
              this.previous && this.previous.error(t),
              this.cleanUp()),
              !0)
          },
          on: function (t, e) {
            return this._listeners[t].push(e),
              this
          },
          cleanUp: function () {
            this.streamInfo = this.generatedError = this.extraStreamInfo = null,
              this._listeners = []
          },
          emit: function (t, e) {
            if (this._listeners[t])
              for (var i = 0; i < this._listeners[t].length; i++)
                this._listeners[t][i].call(this, e)
          },
          pipe: function (t) {
            return t.registerPrevious(this)
          },
          registerPrevious: function (t) {
            if (this.isLocked)
              throw new Error("The stream '" + this + "' has already been used.");
            this.streamInfo = t.streamInfo,
              this.mergeStreamInfo(),
              this.previous = t;
            var e = this;
            return t.on("data", (function (t) {
              e.processChunk(t)
            }
            )),
              t.on("end", (function () {
                e.end()
              }
              )),
              t.on("error", (function (t) {
                e.error(t)
              }
              )),
              this
          },
          pause: function () {
            return !this.isPaused && !this.isFinished && (this.isPaused = !0,
              this.previous && this.previous.pause(),
              !0)
          },
          resume: function () {
            if (!this.isPaused || this.isFinished)
              return !1;
            var t = this.isPaused = !1;
            return this.generatedError && (this.error(this.generatedError),
              t = !0),
              this.previous && this.previous.resume(),
              !t
          },
          flush: function () { },
          processChunk: function (t) {
            this.push(t)
          },
          withStreamInfo: function (t, e) {
            return this.extraStreamInfo[t] = e,
              this.mergeStreamInfo(),
              this
          },
          mergeStreamInfo: function () {
            for (var t in this.extraStreamInfo)
              Object.prototype.hasOwnProperty.call(this.extraStreamInfo, t) && (this.streamInfo[t] = this.extraStreamInfo[t])
          },
          lock: function () {
            if (this.isLocked)
              throw new Error("The stream '" + this + "' has already been used.");
            this.isLocked = !0,
              this.previous && this.previous.lock()
          },
          toString: function () {
            var t = "Worker " + this.name;
            return this.previous ? this.previous + " -> " + t : t
          }
        },
          e.exports = n
      }
        , {}],
      29: [function (t, e, i) {
        var n = t("../utils")
          , r = t("./ConvertWorker")
          , o = t("./GenericWorker")
          , s = t("../base64")
          , a = t("../support")
          , l = t("../external")
          , h = null;
        if (a.nodestream)
          try {
            h = t("../nodejs/NodejsStreamOutputAdapter")
          } catch (t) { }
        function c(t, e) {
          return new l.Promise((function (i, r) {
            var o = []
              , a = t._internalType
              , l = t._outputType
              , h = t._mimeType;
            t.on("data", (function (t, i) {
              o.push(t),
                e && e(i)
            }
            )).on("error", (function (t) {
              o = [],
                r(t)
            }
            )).on("end", (function () {
              try {
                var t = function (t, e, i) {
                  switch (t) {
                    case "blob":
                      return n.newBlob(n.transformTo("arraybuffer", e), i);
                    case "base64":
                      return s.encode(e);
                    default:
                      return n.transformTo(t, e)
                  }
                }(l, function (t, e) {
                  var i, n = 0, r = null, o = 0;
                  for (i = 0; i < e.length; i++)
                    o += e[i].length;
                  switch (t) {
                    case "string":
                      return e.join("");
                    case "array":
                      return Array.prototype.concat.apply([], e);
                    case "uint8array":
                      for (r = new Uint8Array(o),
                        i = 0; i < e.length; i++)
                        r.set(e[i], n),
                          n += e[i].length;
                      return r;
                    case "nodebuffer":
                      return Buffer.concat(e);
                    default:
                      throw new Error("concat : unsupported type '" + t + "'")
                  }
                }(a, o), h);
                i(t)
              } catch (t) {
                r(t)
              }
              o = []
            }
            )).resume()
          }
          ))
        }
        function u(t, e, i) {
          var s = e;
          switch (e) {
            case "blob":
            case "arraybuffer":
              s = "uint8array";
              break;
            case "base64":
              s = "string"
          }
          try {
            this._internalType = s,
              this._outputType = e,
              this._mimeType = i,
              n.checkSupport(s),
              this._worker = t.pipe(new r(s)),
              t.lock()
          } catch (t) {
            this._worker = new o("error"),
              this._worker.error(t)
          }
        }
        u.prototype = {
          accumulate: function (t) {
            return c(this, t)
          },
          on: function (t, e) {
            var i = this;
            return "data" === t ? this._worker.on(t, (function (t) {
              e.call(i, t.data, t.meta)
            }
            )) : this._worker.on(t, (function () {
              n.delay(e, arguments, i)
            }
            )),
              this
          },
          resume: function () {
            return n.delay(this._worker.resume, [], this._worker),
              this
          },
          pause: function () {
            return this._worker.pause(),
              this
          },
          toNodejsStream: function (t) {
            if (n.checkSupport("nodestream"),
              "nodebuffer" !== this._outputType)
              throw new Error(this._outputType + " is not supported by this method");
            return new h(this, {
              objectMode: "nodebuffer" !== this._outputType
            }, t)
          }
        },
          e.exports = u
      }
        , {
        "../base64": 1,
        "../external": 6,
        "../nodejs/NodejsStreamOutputAdapter": 13,
        "../support": 30,
        "../utils": 32,
        "./ConvertWorker": 24,
        "./GenericWorker": 28
      }],
      30: [function (t, e, i) {
        if (i.base64 = !0,
          i.array = !0,
          i.string = !0,
          i.arraybuffer = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array,
          i.nodebuffer = "undefined" != typeof Buffer,
          i.uint8array = "undefined" != typeof Uint8Array,
          "undefined" == typeof ArrayBuffer)
          i.blob = !1;
        else {
          var n = new ArrayBuffer(0);
          try {
            i.blob = 0 === new Blob([n], {
              type: "application/zip"
            }).size
          } catch (t) {
            try {
              var r = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder);
              r.append(n),
                i.blob = 0 === r.getBlob("application/zip").size
            } catch (t) {
              i.blob = !1
            }
          }
        }
        try {
          i.nodestream = !!t("readable-stream").Readable
        } catch (t) {
          i.nodestream = !1
        }
      }
        , {
        "readable-stream": 16
      }],
      31: [function (t, e, i) {
        for (var n = t("./utils"), r = t("./support"), o = t("./nodejsUtils"), s = t("./stream/GenericWorker"), a = new Array(256), l = 0; l < 256; l++)
          a[l] = 252 <= l ? 6 : 248 <= l ? 5 : 240 <= l ? 4 : 224 <= l ? 3 : 192 <= l ? 2 : 1;
        function h() {
          s.call(this, "utf-8 decode"),
            this.leftOver = null
        }
        function c() {
          s.call(this, "utf-8 encode")
        }
        a[254] = a[254] = 1,
          i.utf8encode = function (t) {
            return r.nodebuffer ? o.newBufferFrom(t, "utf-8") : function (t) {
              var e, i, n, o, s, a = t.length, l = 0;
              for (o = 0; o < a; o++)
                55296 == (64512 & (i = t.charCodeAt(o))) && o + 1 < a && 56320 == (64512 & (n = t.charCodeAt(o + 1))) && (i = 65536 + (i - 55296 << 10) + (n - 56320),
                  o++),
                  l += i < 128 ? 1 : i < 2048 ? 2 : i < 65536 ? 3 : 4;
              for (e = r.uint8array ? new Uint8Array(l) : new Array(l),
                o = s = 0; s < l; o++)
                55296 == (64512 & (i = t.charCodeAt(o))) && o + 1 < a && 56320 == (64512 & (n = t.charCodeAt(o + 1))) && (i = 65536 + (i - 55296 << 10) + (n - 56320),
                  o++),
                  i < 128 ? e[s++] = i : (i < 2048 ? e[s++] = 192 | i >>> 6 : (i < 65536 ? e[s++] = 224 | i >>> 12 : (e[s++] = 240 | i >>> 18,
                    e[s++] = 128 | i >>> 12 & 63),
                    e[s++] = 128 | i >>> 6 & 63),
                    e[s++] = 128 | 63 & i);
              return e
            }(t)
          }
          ,
          i.utf8decode = function (t) {
            return r.nodebuffer ? n.transformTo("nodebuffer", t).toString("utf-8") : function (t) {
              var e, i, r, o, s = t.length, l = new Array(2 * s);
              for (e = i = 0; e < s;)
                if ((r = t[e++]) < 128)
                  l[i++] = r;
                else if (4 < (o = a[r]))
                  l[i++] = 65533,
                    e += o - 1;
                else {
                  for (r &= 2 === o ? 31 : 3 === o ? 15 : 7; 1 < o && e < s;)
                    r = r << 6 | 63 & t[e++],
                      o--;
                  1 < o ? l[i++] = 65533 : r < 65536 ? l[i++] = r : (r -= 65536,
                    l[i++] = 55296 | r >> 10 & 1023,
                    l[i++] = 56320 | 1023 & r)
                }
              return l.length !== i && (l.subarray ? l = l.subarray(0, i) : l.length = i),
                n.applyFromCharCode(l)
            }(t = n.transformTo(r.uint8array ? "uint8array" : "array", t))
          }
          ,
          n.inherits(h, s),
          h.prototype.processChunk = function (t) {
            var e = n.transformTo(r.uint8array ? "uint8array" : "array", t.data);
            if (this.leftOver && this.leftOver.length) {
              if (r.uint8array) {
                var o = e;
                (e = new Uint8Array(o.length + this.leftOver.length)).set(this.leftOver, 0),
                  e.set(o, this.leftOver.length)
              } else
                e = this.leftOver.concat(e);
              this.leftOver = null
            }
            var s = function (t, e) {
              var i;
              for ((e = e || t.length) > t.length && (e = t.length),
                i = e - 1; 0 <= i && 128 == (192 & t[i]);)
                i--;
              return i < 0 || 0 === i ? e : i + a[t[i]] > e ? i : e
            }(e)
              , l = e;
            s !== e.length && (r.uint8array ? (l = e.subarray(0, s),
              this.leftOver = e.subarray(s, e.length)) : (l = e.slice(0, s),
                this.leftOver = e.slice(s, e.length))),
              this.push({
                data: i.utf8decode(l),
                meta: t.meta
              })
          }
          ,
          h.prototype.flush = function () {
            this.leftOver && this.leftOver.length && (this.push({
              data: i.utf8decode(this.leftOver),
              meta: {}
            }),
              this.leftOver = null)
          }
          ,
          i.Utf8DecodeWorker = h,
          n.inherits(c, s),
          c.prototype.processChunk = function (t) {
            this.push({
              data: i.utf8encode(t.data),
              meta: t.meta
            })
          }
          ,
          i.Utf8EncodeWorker = c
      }
        , {
        "./nodejsUtils": 14,
        "./stream/GenericWorker": 28,
        "./support": 30,
        "./utils": 32
      }],
      32: [function (t, e, i) {
        var n = t("./support")
          , r = t("./base64")
          , o = t("./nodejsUtils")
          , s = t("./external");
        function a(t) {
          return t
        }
        function l(t, e) {
          for (var i = 0; i < t.length; ++i)
            e[i] = 255 & t.charCodeAt(i);
          return e
        }
        t("setimmediate"),
          i.newBlob = function (t, e) {
            i.checkSupport("blob");
            try {
              return new Blob([t], {
                type: e
              })
            } catch (i) {
              try {
                var n = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder);
                return n.append(t),
                  n.getBlob(e)
              } catch (t) {
                throw new Error("Bug : can't construct the Blob.")
              }
            }
          }
          ;
        var h = {
          stringifyByChunk: function (t, e, i) {
            var n = []
              , r = 0
              , o = t.length;
            if (o <= i)
              return String.fromCharCode.apply(null, t);
            for (; r < o;)
              "array" === e || "nodebuffer" === e ? n.push(String.fromCharCode.apply(null, t.slice(r, Math.min(r + i, o)))) : n.push(String.fromCharCode.apply(null, t.subarray(r, Math.min(r + i, o)))),
                r += i;
            return n.join("")
          },
          stringifyByChar: function (t) {
            for (var e = "", i = 0; i < t.length; i++)
              e += String.fromCharCode(t[i]);
            return e
          },
          applyCanBeUsed: {
            uint8array: function () {
              try {
                return n.uint8array && 1 === String.fromCharCode.apply(null, new Uint8Array(1)).length
              } catch (t) {
                return !1
              }
            }(),
            nodebuffer: function () {
              try {
                return n.nodebuffer && 1 === String.fromCharCode.apply(null, o.allocBuffer(1)).length
              } catch (t) {
                return !1
              }
            }()
          }
        };
        function c(t) {
          var e = 65536
            , n = i.getTypeOf(t)
            , r = !0;
          if ("uint8array" === n ? r = h.applyCanBeUsed.uint8array : "nodebuffer" === n && (r = h.applyCanBeUsed.nodebuffer),
            r)
            for (; 1 < e;)
              try {
                return h.stringifyByChunk(t, n, e)
              } catch (t) {
                e = Math.floor(e / 2)
              }
          return h.stringifyByChar(t)
        }
        function u(t, e) {
          for (var i = 0; i < t.length; i++)
            e[i] = t[i];
          return e
        }
        i.applyFromCharCode = c;
        var p = {};
        p.string = {
          string: a,
          array: function (t) {
            return l(t, new Array(t.length))
          },
          arraybuffer: function (t) {
            return p.string.uint8array(t).buffer
          },
          uint8array: function (t) {
            return l(t, new Uint8Array(t.length))
          },
          nodebuffer: function (t) {
            return l(t, o.allocBuffer(t.length))
          }
        },
          p.array = {
            string: c,
            array: a,
            arraybuffer: function (t) {
              return new Uint8Array(t).buffer
            },
            uint8array: function (t) {
              return new Uint8Array(t)
            },
            nodebuffer: function (t) {
              return o.newBufferFrom(t)
            }
          },
          p.arraybuffer = {
            string: function (t) {
              return c(new Uint8Array(t))
            },
            array: function (t) {
              return u(new Uint8Array(t), new Array(t.byteLength))
            },
            arraybuffer: a,
            uint8array: function (t) {
              return new Uint8Array(t)
            },
            nodebuffer: function (t) {
              return o.newBufferFrom(new Uint8Array(t))
            }
          },
          p.uint8array = {
            string: c,
            array: function (t) {
              return u(t, new Array(t.length))
            },
            arraybuffer: function (t) {
              return t.buffer
            },
            uint8array: a,
            nodebuffer: function (t) {
              return o.newBufferFrom(t)
            }
          },
          p.nodebuffer = {
            string: c,
            array: function (t) {
              return u(t, new Array(t.length))
            },
            arraybuffer: function (t) {
              return p.nodebuffer.uint8array(t).buffer
            },
            uint8array: function (t) {
              return u(t, new Uint8Array(t.length))
            },
            nodebuffer: a
          },
          i.transformTo = function (t, e) {
            if (e = e || "",
              !t)
              return e;
            i.checkSupport(t);
            var n = i.getTypeOf(e);
            return p[n][t](e)
          }
          ,
          i.resolve = function (t) {
            for (var e = t.split("/"), i = [], n = 0; n < e.length; n++) {
              var r = e[n];
              "." === r || "" === r && 0 !== n && n !== e.length - 1 || (".." === r ? i.pop() : i.push(r))
            }
            return i.join("/")
          }
          ,
          i.getTypeOf = function (t) {
            return "string" == typeof t ? "string" : "[object Array]" === Object.prototype.toString.call(t) ? "array" : n.nodebuffer && o.isBuffer(t) ? "nodebuffer" : n.uint8array && t instanceof Uint8Array ? "uint8array" : n.arraybuffer && t instanceof ArrayBuffer ? "arraybuffer" : void 0
          }
          ,
          i.checkSupport = function (t) {
            if (!n[t.toLowerCase()])
              throw new Error(t + " is not supported by this platform")
          }
          ,
          i.MAX_VALUE_16BITS = 65535,
          i.MAX_VALUE_32BITS = -1,
          i.pretty = function (t) {
            var e, i, n = "";
            for (i = 0; i < (t || "").length; i++)
              n += "\\x" + ((e = t.charCodeAt(i)) < 16 ? "0" : "") + e.toString(16).toUpperCase();
            return n
          }
          ,
          i.delay = function (t, e, i) {
            setImmediate((function () {
              t.apply(i || null, e || [])
            }
            ))
          }
          ,
          i.inherits = function (t, e) {
            function i() { }
            i.prototype = e.prototype,
              t.prototype = new i
          }
          ,
          i.extend = function () {
            var t, e, i = {};
            for (t = 0; t < arguments.length; t++)
              for (e in arguments[t])
                Object.prototype.hasOwnProperty.call(arguments[t], e) && void 0 === i[e] && (i[e] = arguments[t][e]);
            return i
          }
          ,
          i.prepareContent = function (t, e, o, a, h) {
            return s.Promise.resolve(e).then((function (t) {
              return n.blob && (t instanceof Blob || -1 !== ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(t))) && "undefined" != typeof FileReader ? new s.Promise((function (e, i) {
                var n = new FileReader;
                n.onload = function (t) {
                  e(t.target.result)
                }
                  ,
                  n.onerror = function (t) {
                    i(t.target.error)
                  }
                  ,
                  n.readAsArrayBuffer(t)
              }
              )) : t
            }
            )).then((function (e) {
              var c = i.getTypeOf(e);
              return c ? ("arraybuffer" === c ? e = i.transformTo("uint8array", e) : "string" === c && (h ? e = r.decode(e) : o && !0 !== a && (e = function (t) {
                return l(t, n.uint8array ? new Uint8Array(t.length) : new Array(t.length))
              }(e))),
                e) : s.Promise.reject(new Error("Can't read the data of '" + t + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"))
            }
            ))
          }
      }
        , {
        "./base64": 1,
        "./external": 6,
        "./nodejsUtils": 14,
        "./support": 30,
        setimmediate: 54
      }],
      33: [function (t, e, i) {
        var n = t("./reader/readerFor")
          , r = t("./utils")
          , o = t("./signature")
          , s = t("./zipEntry")
          , a = t("./support");
        function l(t) {
          this.files = [],
            this.loadOptions = t
        }
        l.prototype = {
          checkSignature: function (t) {
            if (!this.reader.readAndCheckSignature(t)) {
              this.reader.index -= 4;
              var e = this.reader.readString(4);
              throw new Error("Corrupted zip or bug: unexpected signature (" + r.pretty(e) + ", expected " + r.pretty(t) + ")")
            }
          },
          isSignature: function (t, e) {
            var i = this.reader.index;
            this.reader.setIndex(t);
            var n = this.reader.readString(4) === e;
            return this.reader.setIndex(i),
              n
          },
          readBlockEndOfCentral: function () {
            this.diskNumber = this.reader.readInt(2),
              this.diskWithCentralDirStart = this.reader.readInt(2),
              this.centralDirRecordsOnThisDisk = this.reader.readInt(2),
              this.centralDirRecords = this.reader.readInt(2),
              this.centralDirSize = this.reader.readInt(4),
              this.centralDirOffset = this.reader.readInt(4),
              this.zipCommentLength = this.reader.readInt(2);
            var t = this.reader.readData(this.zipCommentLength)
              , e = a.uint8array ? "uint8array" : "array"
              , i = r.transformTo(e, t);
            this.zipComment = this.loadOptions.decodeFileName(i)
          },
          readBlockZip64EndOfCentral: function () {
            this.zip64EndOfCentralSize = this.reader.readInt(8),
              this.reader.skip(4),
              this.diskNumber = this.reader.readInt(4),
              this.diskWithCentralDirStart = this.reader.readInt(4),
              this.centralDirRecordsOnThisDisk = this.reader.readInt(8),
              this.centralDirRecords = this.reader.readInt(8),
              this.centralDirSize = this.reader.readInt(8),
              this.centralDirOffset = this.reader.readInt(8),
              this.zip64ExtensibleData = {};
            for (var t, e, i, n = this.zip64EndOfCentralSize - 44; 0 < n;)
              t = this.reader.readInt(2),
                e = this.reader.readInt(4),
                i = this.reader.readData(e),
                this.zip64ExtensibleData[t] = {
                  id: t,
                  length: e,
                  value: i
                }
          },
          readBlockZip64EndOfCentralLocator: function () {
            if (this.diskWithZip64CentralDirStart = this.reader.readInt(4),
              this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8),
              this.disksCount = this.reader.readInt(4),
              1 < this.disksCount)
              throw new Error("Multi-volumes zip are not supported")
          },
          readLocalFiles: function () {
            var t, e;
            for (t = 0; t < this.files.length; t++)
              e = this.files[t],
                this.reader.setIndex(e.localHeaderOffset),
                this.checkSignature(o.LOCAL_FILE_HEADER),
                e.readLocalPart(this.reader),
                e.handleUTF8(),
                e.processAttributes()
          },
          readCentralDir: function () {
            var t;
            for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(o.CENTRAL_FILE_HEADER);)
              (t = new s({
                zip64: this.zip64
              }, this.loadOptions)).readCentralPart(this.reader),
                this.files.push(t);
            if (this.centralDirRecords !== this.files.length && 0 !== this.centralDirRecords && 0 === this.files.length)
              throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length)
          },
          readEndOfCentral: function () {
            var t = this.reader.lastIndexOfSignature(o.CENTRAL_DIRECTORY_END);
            if (t < 0)
              throw this.isSignature(0, o.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
            this.reader.setIndex(t);
            var e = t;
            if (this.checkSignature(o.CENTRAL_DIRECTORY_END),
              this.readBlockEndOfCentral(),
              this.diskNumber === r.MAX_VALUE_16BITS || this.diskWithCentralDirStart === r.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === r.MAX_VALUE_16BITS || this.centralDirRecords === r.MAX_VALUE_16BITS || this.centralDirSize === r.MAX_VALUE_32BITS || this.centralDirOffset === r.MAX_VALUE_32BITS) {
              if (this.zip64 = !0,
                (t = this.reader.lastIndexOfSignature(o.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
                throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
              if (this.reader.setIndex(t),
                this.checkSignature(o.ZIP64_CENTRAL_DIRECTORY_LOCATOR),
                this.readBlockZip64EndOfCentralLocator(),
                !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, o.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(o.ZIP64_CENTRAL_DIRECTORY_END),
                  this.relativeOffsetEndOfZip64CentralDir < 0))
                throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
              this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir),
                this.checkSignature(o.ZIP64_CENTRAL_DIRECTORY_END),
                this.readBlockZip64EndOfCentral()
            }
            var i = this.centralDirOffset + this.centralDirSize;
            this.zip64 && (i += 20,
              i += 12 + this.zip64EndOfCentralSize);
            var n = e - i;
            if (0 < n)
              this.isSignature(e, o.CENTRAL_FILE_HEADER) || (this.reader.zero = n);
            else if (n < 0)
              throw new Error("Corrupted zip: missing " + Math.abs(n) + " bytes.")
          },
          prepareReader: function (t) {
            this.reader = n(t)
          },
          load: function (t) {
            this.prepareReader(t),
              this.readEndOfCentral(),
              this.readCentralDir(),
              this.readLocalFiles()
          }
        },
          e.exports = l
      }
        , {
        "./reader/readerFor": 22,
        "./signature": 23,
        "./support": 30,
        "./utils": 32,
        "./zipEntry": 34
      }],
      34: [function (t, e, i) {
        var n = t("./reader/readerFor")
          , r = t("./utils")
          , o = t("./compressedObject")
          , s = t("./crc32")
          , a = t("./utf8")
          , l = t("./compressions")
          , h = t("./support");
        function c(t, e) {
          this.options = t,
            this.loadOptions = e
        }
        c.prototype = {
          isEncrypted: function () {
            return 1 == (1 & this.bitFlag)
          },
          useUTF8: function () {
            return 2048 == (2048 & this.bitFlag)
          },
          readLocalPart: function (t) {
            var e, i;
            if (t.skip(22),
              this.fileNameLength = t.readInt(2),
              i = t.readInt(2),
              this.fileName = t.readData(this.fileNameLength),
              t.skip(i),
              -1 === this.compressedSize || -1 === this.uncompressedSize)
              throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
            if (null === (e = function (t) {
              for (var e in l)
                if (Object.prototype.hasOwnProperty.call(l, e) && l[e].magic === t)
                  return l[e];
              return null
            }(this.compressionMethod)))
              throw new Error("Corrupted zip : compression " + r.pretty(this.compressionMethod) + " unknown (inner file : " + r.transformTo("string", this.fileName) + ")");
            this.decompressed = new o(this.compressedSize, this.uncompressedSize, this.crc32, e, t.readData(this.compressedSize))
          },
          readCentralPart: function (t) {
            this.versionMadeBy = t.readInt(2),
              t.skip(2),
              this.bitFlag = t.readInt(2),
              this.compressionMethod = t.readString(2),
              this.date = t.readDate(),
              this.crc32 = t.readInt(4),
              this.compressedSize = t.readInt(4),
              this.uncompressedSize = t.readInt(4);
            var e = t.readInt(2);
            if (this.extraFieldsLength = t.readInt(2),
              this.fileCommentLength = t.readInt(2),
              this.diskNumberStart = t.readInt(2),
              this.internalFileAttributes = t.readInt(2),
              this.externalFileAttributes = t.readInt(4),
              this.localHeaderOffset = t.readInt(4),
              this.isEncrypted())
              throw new Error("Encrypted zip are not supported");
            t.skip(e),
              this.readExtraFields(t),
              this.parseZIP64ExtraField(t),
              this.fileComment = t.readData(this.fileCommentLength)
          },
          processAttributes: function () {
            this.unixPermissions = null,
              this.dosPermissions = null;
            var t = this.versionMadeBy >> 8;
            this.dir = !!(16 & this.externalFileAttributes),
              0 == t && (this.dosPermissions = 63 & this.externalFileAttributes),
              3 == t && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535),
              this.dir || "/" !== this.fileNameStr.slice(-1) || (this.dir = !0)
          },
          parseZIP64ExtraField: function () {
            if (this.extraFields[1]) {
              var t = n(this.extraFields[1].value);
              this.uncompressedSize === r.MAX_VALUE_32BITS && (this.uncompressedSize = t.readInt(8)),
                this.compressedSize === r.MAX_VALUE_32BITS && (this.compressedSize = t.readInt(8)),
                this.localHeaderOffset === r.MAX_VALUE_32BITS && (this.localHeaderOffset = t.readInt(8)),
                this.diskNumberStart === r.MAX_VALUE_32BITS && (this.diskNumberStart = t.readInt(4))
            }
          },
          readExtraFields: function (t) {
            var e, i, n, r = t.index + this.extraFieldsLength;
            for (this.extraFields || (this.extraFields = {}); t.index + 4 < r;)
              e = t.readInt(2),
                i = t.readInt(2),
                n = t.readData(i),
                this.extraFields[e] = {
                  id: e,
                  length: i,
                  value: n
                };
            t.setIndex(r)
          },
          handleUTF8: function () {
            var t = h.uint8array ? "uint8array" : "array";
            if (this.useUTF8())
              this.fileNameStr = a.utf8decode(this.fileName),
                this.fileCommentStr = a.utf8decode(this.fileComment);
            else {
              var e = this.findExtraFieldUnicodePath();
              if (null !== e)
                this.fileNameStr = e;
              else {
                var i = r.transformTo(t, this.fileName);
                this.fileNameStr = this.loadOptions.decodeFileName(i)
              }
              var n = this.findExtraFieldUnicodeComment();
              if (null !== n)
                this.fileCommentStr = n;
              else {
                var o = r.transformTo(t, this.fileComment);
                this.fileCommentStr = this.loadOptions.decodeFileName(o)
              }
            }
          },
          findExtraFieldUnicodePath: function () {
            var t = this.extraFields[28789];
            if (t) {
              var e = n(t.value);
              return 1 !== e.readInt(1) || s(this.fileName) !== e.readInt(4) ? null : a.utf8decode(e.readData(t.length - 5))
            }
            return null
          },
          findExtraFieldUnicodeComment: function () {
            var t = this.extraFields[25461];
            if (t) {
              var e = n(t.value);
              return 1 !== e.readInt(1) || s(this.fileComment) !== e.readInt(4) ? null : a.utf8decode(e.readData(t.length - 5))
            }
            return null
          }
        },
          e.exports = c
      }
        , {
        "./compressedObject": 2,
        "./compressions": 3,
        "./crc32": 4,
        "./reader/readerFor": 22,
        "./support": 30,
        "./utf8": 31,
        "./utils": 32
      }],
      35: [function (t, e, i) {
        function n(t, e, i) {
          this.name = t,
            this.dir = i.dir,
            this.date = i.date,
            this.comment = i.comment,
            this.unixPermissions = i.unixPermissions,
            this.dosPermissions = i.dosPermissions,
            this._data = e,
            this._dataBinary = i.binary,
            this.options = {
              compression: i.compression,
              compressionOptions: i.compressionOptions
            }
        }
        var r = t("./stream/StreamHelper")
          , o = t("./stream/DataWorker")
          , s = t("./utf8")
          , a = t("./compressedObject")
          , l = t("./stream/GenericWorker");
        n.prototype = {
          internalStream: function (t) {
            var e = null
              , i = "string";
            try {
              if (!t)
                throw new Error("No output type specified.");
              var n = "string" === (i = t.toLowerCase()) || "text" === i;
              "binarystring" !== i && "text" !== i || (i = "string"),
                e = this._decompressWorker();
              var o = !this._dataBinary;
              o && !n && (e = e.pipe(new s.Utf8EncodeWorker)),
                !o && n && (e = e.pipe(new s.Utf8DecodeWorker))
            } catch (t) {
              (e = new l("error")).error(t)
            }
            return new r(e, i, "")
          },
          async: function (t, e) {
            return this.internalStream(t).accumulate(e)
          },
          nodeStream: function (t, e) {
            return this.internalStream(t || "nodebuffer").toNodejsStream(e)
          },
          _compressWorker: function (t, e) {
            if (this._data instanceof a && this._data.compression.magic === t.magic)
              return this._data.getCompressedWorker();
            var i = this._decompressWorker();
            return this._dataBinary || (i = i.pipe(new s.Utf8EncodeWorker)),
              a.createWorkerFrom(i, t, e)
          },
          _decompressWorker: function () {
            return this._data instanceof a ? this._data.getContentWorker() : this._data instanceof l ? this._data : new o(this._data)
          }
        };
        for (var h = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], c = function () {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")
        }, u = 0; u < h.length; u++)
          n.prototype[h[u]] = c;
        e.exports = n
      }
        , {
        "./compressedObject": 2,
        "./stream/DataWorker": 27,
        "./stream/GenericWorker": 28,
        "./stream/StreamHelper": 29,
        "./utf8": 31
      }],
      36: [function (t, e, i) {
        (function (t) {
          var i, n, r = t.MutationObserver || t.WebKitMutationObserver;
          if (r) {
            var o = 0
              , s = new r(c)
              , a = t.document.createTextNode("");
            s.observe(a, {
              characterData: !0
            }),
              i = function () {
                a.data = o = ++o % 2
              }
          } else if (t.setImmediate || void 0 === t.MessageChannel)
            i = "document" in t && "onreadystatechange" in t.document.createElement("script") ? function () {
              var e = t.document.createElement("script");
              e.onreadystatechange = function () {
                c(),
                  e.onreadystatechange = null,
                  e.parentNode.removeChild(e),
                  e = null
              }
                ,
                t.document.documentElement.appendChild(e)
            }
              : function () {
                setTimeout(c, 0)
              }
              ;
          else {
            var l = new t.MessageChannel;
            l.port1.onmessage = c,
              i = function () {
                l.port2.postMessage(0)
              }
          }
          var h = [];
          function c() {
            var t, e;
            n = !0;
            for (var i = h.length; i;) {
              for (e = h,
                h = [],
                t = -1; ++t < i;)
                e[t]();
              i = h.length
            }
            n = !1
          }
          e.exports = function (t) {
            1 !== h.push(t) || n || i()
          }
        }
        ).call(this, void 0 !== Em ? Em : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
      }
        , {}],
      37: [function (t, e, i) {
        var n = t("immediate");
        function r() { }
        var o = {}
          , s = ["REJECTED"]
          , a = ["FULFILLED"]
          , l = ["PENDING"];
        function h(t) {
          if ("function" != typeof t)
            throw new TypeError("resolver must be a function");
          this.state = l,
            this.queue = [],
            this.outcome = void 0,
            t !== r && d(this, t)
        }
        function c(t, e, i) {
          this.promise = t,
            "function" == typeof e && (this.onFulfilled = e,
              this.callFulfilled = this.otherCallFulfilled),
            "function" == typeof i && (this.onRejected = i,
              this.callRejected = this.otherCallRejected)
        }
        function u(t, e, i) {
          n((function () {
            var n;
            try {
              n = e(i)
            } catch (n) {
              return o.reject(t, n)
            }
            n === t ? o.reject(t, new TypeError("Cannot resolve promise with itself")) : o.resolve(t, n)
          }
          ))
        }
        function p(t) {
          var e = t && t.then;
          if (t && ("object" == typeof t || "function" == typeof t) && "function" == typeof e)
            return function () {
              e.apply(t, arguments)
            }
        }
        function d(t, e) {
          var i = !1;
          function n(e) {
            i || (i = !0,
              o.reject(t, e))
          }
          function r(e) {
            i || (i = !0,
              o.resolve(t, e))
          }
          var s = f((function () {
            e(r, n)
          }
          ));
          "error" === s.status && n(s.value)
        }
        function f(t, e) {
          var i = {};
          try {
            i.value = t(e),
              i.status = "success"
          } catch (t) {
            i.status = "error",
              i.value = t
          }
          return i
        }
        (e.exports = h).prototype.finally = function (t) {
          if ("function" != typeof t)
            return this;
          var e = this.constructor;
          return this.then((function (i) {
            return e.resolve(t()).then((function () {
              return i
            }
            ))
          }
          ), (function (i) {
            return e.resolve(t()).then((function () {
              throw i
            }
            ))
          }
          ))
        }
          ,
          h.prototype.catch = function (t) {
            return this.then(null, t)
          }
          ,
          h.prototype.then = function (t, e) {
            if ("function" != typeof t && this.state === a || "function" != typeof e && this.state === s)
              return this;
            var i = new this.constructor(r);
            return this.state !== l ? u(i, this.state === a ? t : e, this.outcome) : this.queue.push(new c(i, t, e)),
              i
          }
          ,
          c.prototype.callFulfilled = function (t) {
            o.resolve(this.promise, t)
          }
          ,
          c.prototype.otherCallFulfilled = function (t) {
            u(this.promise, this.onFulfilled, t)
          }
          ,
          c.prototype.callRejected = function (t) {
            o.reject(this.promise, t)
          }
          ,
          c.prototype.otherCallRejected = function (t) {
            u(this.promise, this.onRejected, t)
          }
          ,
          o.resolve = function (t, e) {
            var i = f(p, e);
            if ("error" === i.status)
              return o.reject(t, i.value);
            var n = i.value;
            if (n)
              d(t, n);
            else {
              t.state = a,
                t.outcome = e;
              for (var r = -1, s = t.queue.length; ++r < s;)
                t.queue[r].callFulfilled(e)
            }
            return t
          }
          ,
          o.reject = function (t, e) {
            t.state = s,
              t.outcome = e;
            for (var i = -1, n = t.queue.length; ++i < n;)
              t.queue[i].callRejected(e);
            return t
          }
          ,
          h.resolve = function (t) {
            return t instanceof this ? t : o.resolve(new this(r), t)
          }
          ,
          h.reject = function (t) {
            var e = new this(r);
            return o.reject(e, t)
          }
          ,
          h.all = function (t) {
            var e = this;
            if ("[object Array]" !== Object.prototype.toString.call(t))
              return this.reject(new TypeError("must be an array"));
            var i = t.length
              , n = !1;
            if (!i)
              return this.resolve([]);
            for (var s = new Array(i), a = 0, l = -1, h = new this(r); ++l < i;)
              c(t[l], l);
            return h;
            function c(t, r) {
              e.resolve(t).then((function (t) {
                s[r] = t,
                  ++a !== i || n || (n = !0,
                    o.resolve(h, s))
              }
              ), (function (t) {
                n || (n = !0,
                  o.reject(h, t))
              }
              ))
            }
          }
          ,
          h.race = function (t) {
            var e = this;
            if ("[object Array]" !== Object.prototype.toString.call(t))
              return this.reject(new TypeError("must be an array"));
            var i = t.length
              , n = !1;
            if (!i)
              return this.resolve([]);
            for (var s, a = -1, l = new this(r); ++a < i;)
              s = t[a],
                e.resolve(s).then((function (t) {
                  n || (n = !0,
                    o.resolve(l, t))
                }
                ), (function (t) {
                  n || (n = !0,
                    o.reject(l, t))
                }
                ));
            return l
          }
      }
        , {
        immediate: 36
      }],
      38: [function (t, e, i) {
        var n = {};
        (0,
          t("./lib/utils/common").assign)(n, t("./lib/deflate"), t("./lib/inflate"), t("./lib/zlib/constants")),
          e.exports = n
      }
        , {
        "./lib/deflate": 39,
        "./lib/inflate": 40,
        "./lib/utils/common": 41,
        "./lib/zlib/constants": 44
      }],
      39: [function (t, e, i) {
        var n = t("./zlib/deflate")
          , r = t("./utils/common")
          , o = t("./utils/strings")
          , s = t("./zlib/messages")
          , a = t("./zlib/zstream")
          , l = Object.prototype.toString
          , h = 0
          , c = -1
          , u = 0
          , p = 8;
        function d(t) {
          if (!(this instanceof d))
            return new d(t);
          this.options = r.assign({
            level: c,
            method: p,
            chunkSize: 16384,
            windowBits: 15,
            memLevel: 8,
            strategy: u,
            to: ""
          }, t || {});
          var e = this.options;
          e.raw && 0 < e.windowBits ? e.windowBits = -e.windowBits : e.gzip && 0 < e.windowBits && e.windowBits < 16 && (e.windowBits += 16),
            this.err = 0,
            this.msg = "",
            this.ended = !1,
            this.chunks = [],
            this.strm = new a,
            this.strm.avail_out = 0;
          var i = n.deflateInit2(this.strm, e.level, e.method, e.windowBits, e.memLevel, e.strategy);
          if (i !== h)
            throw new Error(s[i]);
          if (e.header && n.deflateSetHeader(this.strm, e.header),
            e.dictionary) {
            var f;
            if (f = "string" == typeof e.dictionary ? o.string2buf(e.dictionary) : "[object ArrayBuffer]" === l.call(e.dictionary) ? new Uint8Array(e.dictionary) : e.dictionary,
              (i = n.deflateSetDictionary(this.strm, f)) !== h)
              throw new Error(s[i]);
            this._dict_set = !0
          }
        }
        function f(t, e) {
          var i = new d(e);
          if (i.push(t, !0),
            i.err)
            throw i.msg || s[i.err];
          return i.result
        }
        d.prototype.push = function (t, e) {
          var i, s, a = this.strm, c = this.options.chunkSize;
          if (this.ended)
            return !1;
          s = e === ~~e ? e : !0 === e ? 4 : 0,
            "string" == typeof t ? a.input = o.string2buf(t) : "[object ArrayBuffer]" === l.call(t) ? a.input = new Uint8Array(t) : a.input = t,
            a.next_in = 0,
            a.avail_in = a.input.length;
          do {
            if (0 === a.avail_out && (a.output = new r.Buf8(c),
              a.next_out = 0,
              a.avail_out = c),
              1 !== (i = n.deflate(a, s)) && i !== h)
              return this.onEnd(i),
                !(this.ended = !0);
            0 !== a.avail_out && (0 !== a.avail_in || 4 !== s && 2 !== s) || ("string" === this.options.to ? this.onData(o.buf2binstring(r.shrinkBuf(a.output, a.next_out))) : this.onData(r.shrinkBuf(a.output, a.next_out)))
          } while ((0 < a.avail_in || 0 === a.avail_out) && 1 !== i);
          return 4 === s ? (i = n.deflateEnd(this.strm),
            this.onEnd(i),
            this.ended = !0,
            i === h) : 2 !== s || (this.onEnd(h),
              !(a.avail_out = 0))
        }
          ,
          d.prototype.onData = function (t) {
            this.chunks.push(t)
          }
          ,
          d.prototype.onEnd = function (t) {
            t === h && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = r.flattenChunks(this.chunks)),
              this.chunks = [],
              this.err = t,
              this.msg = this.strm.msg
          }
          ,
          i.Deflate = d,
          i.deflate = f,
          i.deflateRaw = function (t, e) {
            return (e = e || {}).raw = !0,
              f(t, e)
          }
          ,
          i.gzip = function (t, e) {
            return (e = e || {}).gzip = !0,
              f(t, e)
          }
      }
        , {
        "./utils/common": 41,
        "./utils/strings": 42,
        "./zlib/deflate": 46,
        "./zlib/messages": 51,
        "./zlib/zstream": 53
      }],
      40: [function (t, e, i) {
        var n = t("./zlib/inflate")
          , r = t("./utils/common")
          , o = t("./utils/strings")
          , s = t("./zlib/constants")
          , a = t("./zlib/messages")
          , l = t("./zlib/zstream")
          , h = t("./zlib/gzheader")
          , c = Object.prototype.toString;
        function u(t) {
          if (!(this instanceof u))
            return new u(t);
          this.options = r.assign({
            chunkSize: 16384,
            windowBits: 0,
            to: ""
          }, t || {});
          var e = this.options;
          e.raw && 0 <= e.windowBits && e.windowBits < 16 && (e.windowBits = -e.windowBits,
            0 === e.windowBits && (e.windowBits = -15)),
            !(0 <= e.windowBits && e.windowBits < 16) || t && t.windowBits || (e.windowBits += 32),
            15 < e.windowBits && e.windowBits < 48 && 0 == (15 & e.windowBits) && (e.windowBits |= 15),
            this.err = 0,
            this.msg = "",
            this.ended = !1,
            this.chunks = [],
            this.strm = new l,
            this.strm.avail_out = 0;
          var i = n.inflateInit2(this.strm, e.windowBits);
          if (i !== s.Z_OK)
            throw new Error(a[i]);
          this.header = new h,
            n.inflateGetHeader(this.strm, this.header)
        }
        function p(t, e) {
          var i = new u(e);
          if (i.push(t, !0),
            i.err)
            throw i.msg || a[i.err];
          return i.result
        }
        u.prototype.push = function (t, e) {
          var i, a, l, h, u, p, d = this.strm, f = this.options.chunkSize, g = this.options.dictionary, m = !1;
          if (this.ended)
            return !1;
          a = e === ~~e ? e : !0 === e ? s.Z_FINISH : s.Z_NO_FLUSH,
            "string" == typeof t ? d.input = o.binstring2buf(t) : "[object ArrayBuffer]" === c.call(t) ? d.input = new Uint8Array(t) : d.input = t,
            d.next_in = 0,
            d.avail_in = d.input.length;
          do {
            if (0 === d.avail_out && (d.output = new r.Buf8(f),
              d.next_out = 0,
              d.avail_out = f),
              (i = n.inflate(d, s.Z_NO_FLUSH)) === s.Z_NEED_DICT && g && (p = "string" == typeof g ? o.string2buf(g) : "[object ArrayBuffer]" === c.call(g) ? new Uint8Array(g) : g,
                i = n.inflateSetDictionary(this.strm, p)),
              i === s.Z_BUF_ERROR && !0 === m && (i = s.Z_OK,
                m = !1),
              i !== s.Z_STREAM_END && i !== s.Z_OK)
              return this.onEnd(i),
                !(this.ended = !0);
            d.next_out && (0 !== d.avail_out && i !== s.Z_STREAM_END && (0 !== d.avail_in || a !== s.Z_FINISH && a !== s.Z_SYNC_FLUSH) || ("string" === this.options.to ? (l = o.utf8border(d.output, d.next_out),
              h = d.next_out - l,
              u = o.buf2string(d.output, l),
              d.next_out = h,
              d.avail_out = f - h,
              h && r.arraySet(d.output, d.output, l, h, 0),
              this.onData(u)) : this.onData(r.shrinkBuf(d.output, d.next_out)))),
              0 === d.avail_in && 0 === d.avail_out && (m = !0)
          } while ((0 < d.avail_in || 0 === d.avail_out) && i !== s.Z_STREAM_END);
          return i === s.Z_STREAM_END && (a = s.Z_FINISH),
            a === s.Z_FINISH ? (i = n.inflateEnd(this.strm),
              this.onEnd(i),
              this.ended = !0,
              i === s.Z_OK) : a !== s.Z_SYNC_FLUSH || (this.onEnd(s.Z_OK),
                !(d.avail_out = 0))
        }
          ,
          u.prototype.onData = function (t) {
            this.chunks.push(t)
          }
          ,
          u.prototype.onEnd = function (t) {
            t === s.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = r.flattenChunks(this.chunks)),
              this.chunks = [],
              this.err = t,
              this.msg = this.strm.msg
          }
          ,
          i.Inflate = u,
          i.inflate = p,
          i.inflateRaw = function (t, e) {
            return (e = e || {}).raw = !0,
              p(t, e)
          }
          ,
          i.ungzip = p
      }
        , {
        "./utils/common": 41,
        "./utils/strings": 42,
        "./zlib/constants": 44,
        "./zlib/gzheader": 47,
        "./zlib/inflate": 49,
        "./zlib/messages": 51,
        "./zlib/zstream": 53
      }],
      41: [function (t, e, i) {
        var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
        i.assign = function (t) {
          for (var e = Array.prototype.slice.call(arguments, 1); e.length;) {
            var i = e.shift();
            if (i) {
              if ("object" != typeof i)
                throw new TypeError(i + "must be non-object");
              for (var n in i)
                i.hasOwnProperty(n) && (t[n] = i[n])
            }
          }
          return t
        }
          ,
          i.shrinkBuf = function (t, e) {
            return t.length === e ? t : t.subarray ? t.subarray(0, e) : (t.length = e,
              t)
          }
          ;
        var r = {
          arraySet: function (t, e, i, n, r) {
            if (e.subarray && t.subarray)
              t.set(e.subarray(i, i + n), r);
            else
              for (var o = 0; o < n; o++)
                t[r + o] = e[i + o]
          },
          flattenChunks: function (t) {
            var e, i, n, r, o, s;
            for (e = n = 0,
              i = t.length; e < i; e++)
              n += t[e].length;
            for (s = new Uint8Array(n),
              e = r = 0,
              i = t.length; e < i; e++)
              o = t[e],
                s.set(o, r),
                r += o.length;
            return s
          }
        }
          , o = {
            arraySet: function (t, e, i, n, r) {
              for (var o = 0; o < n; o++)
                t[r + o] = e[i + o]
            },
            flattenChunks: function (t) {
              return [].concat.apply([], t)
            }
          };
        i.setTyped = function (t) {
          t ? (i.Buf8 = Uint8Array,
            i.Buf16 = Uint16Array,
            i.Buf32 = Int32Array,
            i.assign(i, r)) : (i.Buf8 = Array,
              i.Buf16 = Array,
              i.Buf32 = Array,
              i.assign(i, o))
        }
          ,
          i.setTyped(n)
      }
        , {}],
      42: [function (t, e, i) {
        var n = t("./common")
          , r = !0
          , o = !0;
        try {
          String.fromCharCode.apply(null, [0])
        } catch (t) {
          r = !1
        }
        try {
          String.fromCharCode.apply(null, new Uint8Array(1))
        } catch (t) {
          o = !1
        }
        for (var s = new n.Buf8(256), a = 0; a < 256; a++)
          s[a] = 252 <= a ? 6 : 248 <= a ? 5 : 240 <= a ? 4 : 224 <= a ? 3 : 192 <= a ? 2 : 1;
        function l(t, e) {
          if (e < 65537 && (t.subarray && o || !t.subarray && r))
            return String.fromCharCode.apply(null, n.shrinkBuf(t, e));
          for (var i = "", s = 0; s < e; s++)
            i += String.fromCharCode(t[s]);
          return i
        }
        s[254] = s[254] = 1,
          i.string2buf = function (t) {
            var e, i, r, o, s, a = t.length, l = 0;
            for (o = 0; o < a; o++)
              55296 == (64512 & (i = t.charCodeAt(o))) && o + 1 < a && 56320 == (64512 & (r = t.charCodeAt(o + 1))) && (i = 65536 + (i - 55296 << 10) + (r - 56320),
                o++),
                l += i < 128 ? 1 : i < 2048 ? 2 : i < 65536 ? 3 : 4;
            for (e = new n.Buf8(l),
              o = s = 0; s < l; o++)
              55296 == (64512 & (i = t.charCodeAt(o))) && o + 1 < a && 56320 == (64512 & (r = t.charCodeAt(o + 1))) && (i = 65536 + (i - 55296 << 10) + (r - 56320),
                o++),
                i < 128 ? e[s++] = i : (i < 2048 ? e[s++] = 192 | i >>> 6 : (i < 65536 ? e[s++] = 224 | i >>> 12 : (e[s++] = 240 | i >>> 18,
                  e[s++] = 128 | i >>> 12 & 63),
                  e[s++] = 128 | i >>> 6 & 63),
                  e[s++] = 128 | 63 & i);
            return e
          }
          ,
          i.buf2binstring = function (t) {
            return l(t, t.length)
          }
          ,
          i.binstring2buf = function (t) {
            for (var e = new n.Buf8(t.length), i = 0, r = e.length; i < r; i++)
              e[i] = t.charCodeAt(i);
            return e
          }
          ,
          i.buf2string = function (t, e) {
            var i, n, r, o, a = e || t.length, h = new Array(2 * a);
            for (i = n = 0; i < a;)
              if ((r = t[i++]) < 128)
                h[n++] = r;
              else if (4 < (o = s[r]))
                h[n++] = 65533,
                  i += o - 1;
              else {
                for (r &= 2 === o ? 31 : 3 === o ? 15 : 7; 1 < o && i < a;)
                  r = r << 6 | 63 & t[i++],
                    o--;
                1 < o ? h[n++] = 65533 : r < 65536 ? h[n++] = r : (r -= 65536,
                  h[n++] = 55296 | r >> 10 & 1023,
                  h[n++] = 56320 | 1023 & r)
              }
            return l(h, n)
          }
          ,
          i.utf8border = function (t, e) {
            var i;
            for ((e = e || t.length) > t.length && (e = t.length),
              i = e - 1; 0 <= i && 128 == (192 & t[i]);)
              i--;
            return i < 0 || 0 === i ? e : i + s[t[i]] > e ? i : e
          }
      }
        , {
        "./common": 41
      }],
      43: [function (t, e, i) {
        e.exports = function (t, e, i, n) {
          for (var r = 65535 & t | 0, o = t >>> 16 & 65535 | 0, s = 0; 0 !== i;) {
            for (i -= s = 2e3 < i ? 2e3 : i; o = o + (r = r + e[n++] | 0) | 0,
              --s;)
              ;
            r %= 65521,
              o %= 65521
          }
          return r | o << 16 | 0
        }
      }
        , {}],
      44: [function (t, e, i) {
        e.exports = {
          Z_NO_FLUSH: 0,
          Z_PARTIAL_FLUSH: 1,
          Z_SYNC_FLUSH: 2,
          Z_FULL_FLUSH: 3,
          Z_FINISH: 4,
          Z_BLOCK: 5,
          Z_TREES: 6,
          Z_OK: 0,
          Z_STREAM_END: 1,
          Z_NEED_DICT: 2,
          Z_ERRNO: -1,
          Z_STREAM_ERROR: -2,
          Z_DATA_ERROR: -3,
          Z_BUF_ERROR: -5,
          Z_NO_COMPRESSION: 0,
          Z_BEST_SPEED: 1,
          Z_BEST_COMPRESSION: 9,
          Z_DEFAULT_COMPRESSION: -1,
          Z_FILTERED: 1,
          Z_HUFFMAN_ONLY: 2,
          Z_RLE: 3,
          Z_FIXED: 4,
          Z_DEFAULT_STRATEGY: 0,
          Z_BINARY: 0,
          Z_TEXT: 1,
          Z_UNKNOWN: 2,
          Z_DEFLATED: 8
        }
      }
        , {}],
      45: [function (t, e, i) {
        var n = function () {
          for (var t, e = [], i = 0; i < 256; i++) {
            t = i;
            for (var n = 0; n < 8; n++)
              t = 1 & t ? 3988292384 ^ t >>> 1 : t >>> 1;
            e[i] = t
          }
          return e
        }();
        e.exports = function (t, e, i, r) {
          var o = n
            , s = r + i;
          t ^= -1;
          for (var a = r; a < s; a++)
            t = t >>> 8 ^ o[255 & (t ^ e[a])];
          return -1 ^ t
        }
      }
        , {}],
      46: [function (t, e, i) {
        var n, r = t("../utils/common"), o = t("./trees"), s = t("./adler32"), a = t("./crc32"), l = t("./messages"), h = 0, c = 4, u = 0, p = -2, d = -1, f = 4, g = 2, m = 8, y = 9, v = 286, A = 30, b = 19, x = 2 * v + 1, I = 15, C = 3, w = 258, _ = w + C + 1, S = 42, M = 113, T = 1, E = 2, k = 3, R = 4;
        function L(t, e) {
          return t.msg = l[e],
            e
        }
        function P(t) {
          return (t << 1) - (4 < t ? 9 : 0)
        }
        function z(t) {
          for (var e = t.length; 0 <= --e;)
            t[e] = 0
        }
        function O(t) {
          var e = t.state
            , i = e.pending;
          i > t.avail_out && (i = t.avail_out),
            0 !== i && (r.arraySet(t.output, e.pending_buf, e.pending_out, i, t.next_out),
              t.next_out += i,
              e.pending_out += i,
              t.total_out += i,
              t.avail_out -= i,
              e.pending -= i,
              0 === e.pending && (e.pending_out = 0))
        }
        function D(t, e) {
          o._tr_flush_block(t, 0 <= t.block_start ? t.block_start : -1, t.strstart - t.block_start, e),
            t.block_start = t.strstart,
            O(t.strm)
        }
        function U(t, e) {
          t.pending_buf[t.pending++] = e
        }
        function N(t, e) {
          t.pending_buf[t.pending++] = e >>> 8 & 255,
            t.pending_buf[t.pending++] = 255 & e
        }
        function F(t, e) {
          var i, n, r = t.max_chain_length, o = t.strstart, s = t.prev_length, a = t.nice_match, l = t.strstart > t.w_size - _ ? t.strstart - (t.w_size - _) : 0, h = t.window, c = t.w_mask, u = t.prev, p = t.strstart + w, d = h[o + s - 1], f = h[o + s];
          t.prev_length >= t.good_match && (r >>= 2),
            a > t.lookahead && (a = t.lookahead);
          do {
            if (h[(i = e) + s] === f && h[i + s - 1] === d && h[i] === h[o] && h[++i] === h[o + 1]) {
              o += 2,
                i++;
              do { } while (h[++o] === h[++i] && h[++o] === h[++i] && h[++o] === h[++i] && h[++o] === h[++i] && h[++o] === h[++i] && h[++o] === h[++i] && h[++o] === h[++i] && h[++o] === h[++i] && o < p);
              if (n = w - (p - o),
                o = p - w,
                s < n) {
                if (t.match_start = e,
                  a <= (s = n))
                  break;
                d = h[o + s - 1],
                  f = h[o + s]
              }
            }
          } while ((e = u[e & c]) > l && 0 != --r);
          return s <= t.lookahead ? s : t.lookahead
        }
        function B(t) {
          var e, i, n, o, l, h, c, u, p, d, f = t.w_size;
          do {
            if (o = t.window_size - t.lookahead - t.strstart,
              t.strstart >= f + (f - _)) {
              for (r.arraySet(t.window, t.window, f, f, 0),
                t.match_start -= f,
                t.strstart -= f,
                t.block_start -= f,
                e = i = t.hash_size; n = t.head[--e],
                t.head[e] = f <= n ? n - f : 0,
                --i;)
                ;
              for (e = i = f; n = t.prev[--e],
                t.prev[e] = f <= n ? n - f : 0,
                --i;)
                ;
              o += f
            }
            if (0 === t.strm.avail_in)
              break;
            if (h = t.strm,
              c = t.window,
              u = t.strstart + t.lookahead,
              d = void 0,
              (p = o) < (d = h.avail_in) && (d = p),
              i = 0 === d ? 0 : (h.avail_in -= d,
                r.arraySet(c, h.input, h.next_in, d, u),
                1 === h.state.wrap ? h.adler = s(h.adler, c, d, u) : 2 === h.state.wrap && (h.adler = a(h.adler, c, d, u)),
                h.next_in += d,
                h.total_in += d,
                d),
              t.lookahead += i,
              t.lookahead + t.insert >= C)
              for (l = t.strstart - t.insert,
                t.ins_h = t.window[l],
                t.ins_h = (t.ins_h << t.hash_shift ^ t.window[l + 1]) & t.hash_mask; t.insert && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[l + C - 1]) & t.hash_mask,
                  t.prev[l & t.w_mask] = t.head[t.ins_h],
                  t.head[t.ins_h] = l,
                  l++,
                  t.insert--,
                  !(t.lookahead + t.insert < C));)
                ;
          } while (t.lookahead < _ && 0 !== t.strm.avail_in)
        }
        function j(t, e) {
          for (var i, n; ;) {
            if (t.lookahead < _) {
              if (B(t),
                t.lookahead < _ && e === h)
                return T;
              if (0 === t.lookahead)
                break
            }
            if (i = 0,
              t.lookahead >= C && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + C - 1]) & t.hash_mask,
                i = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h],
                t.head[t.ins_h] = t.strstart),
              0 !== i && t.strstart - i <= t.w_size - _ && (t.match_length = F(t, i)),
              t.match_length >= C)
              if (n = o._tr_tally(t, t.strstart - t.match_start, t.match_length - C),
                t.lookahead -= t.match_length,
                t.match_length <= t.max_lazy_match && t.lookahead >= C) {
                for (t.match_length--; t.strstart++,
                  t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + C - 1]) & t.hash_mask,
                  i = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h],
                  t.head[t.ins_h] = t.strstart,
                  0 != --t.match_length;)
                  ;
                t.strstart++
              } else
                t.strstart += t.match_length,
                  t.match_length = 0,
                  t.ins_h = t.window[t.strstart],
                  t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + 1]) & t.hash_mask;
            else
              n = o._tr_tally(t, 0, t.window[t.strstart]),
                t.lookahead--,
                t.strstart++;
            if (n && (D(t, !1),
              0 === t.strm.avail_out))
              return T
          }
          return t.insert = t.strstart < C - 1 ? t.strstart : C - 1,
            e === c ? (D(t, !0),
              0 === t.strm.avail_out ? k : R) : t.last_lit && (D(t, !1),
                0 === t.strm.avail_out) ? T : E
        }
        function V(t, e) {
          for (var i, n, r; ;) {
            if (t.lookahead < _) {
              if (B(t),
                t.lookahead < _ && e === h)
                return T;
              if (0 === t.lookahead)
                break
            }
            if (i = 0,
              t.lookahead >= C && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + C - 1]) & t.hash_mask,
                i = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h],
                t.head[t.ins_h] = t.strstart),
              t.prev_length = t.match_length,
              t.prev_match = t.match_start,
              t.match_length = C - 1,
              0 !== i && t.prev_length < t.max_lazy_match && t.strstart - i <= t.w_size - _ && (t.match_length = F(t, i),
                t.match_length <= 5 && (1 === t.strategy || t.match_length === C && 4096 < t.strstart - t.match_start) && (t.match_length = C - 1)),
              t.prev_length >= C && t.match_length <= t.prev_length) {
              for (r = t.strstart + t.lookahead - C,
                n = o._tr_tally(t, t.strstart - 1 - t.prev_match, t.prev_length - C),
                t.lookahead -= t.prev_length - 1,
                t.prev_length -= 2; ++t.strstart <= r && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + C - 1]) & t.hash_mask,
                  i = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h],
                  t.head[t.ins_h] = t.strstart),
                0 != --t.prev_length;)
                ;
              if (t.match_available = 0,
                t.match_length = C - 1,
                t.strstart++,
                n && (D(t, !1),
                  0 === t.strm.avail_out))
                return T
            } else if (t.match_available) {
              if ((n = o._tr_tally(t, 0, t.window[t.strstart - 1])) && D(t, !1),
                t.strstart++,
                t.lookahead--,
                0 === t.strm.avail_out)
                return T
            } else
              t.match_available = 1,
                t.strstart++,
                t.lookahead--
          }
          return t.match_available && (n = o._tr_tally(t, 0, t.window[t.strstart - 1]),
            t.match_available = 0),
            t.insert = t.strstart < C - 1 ? t.strstart : C - 1,
            e === c ? (D(t, !0),
              0 === t.strm.avail_out ? k : R) : t.last_lit && (D(t, !1),
                0 === t.strm.avail_out) ? T : E
        }
        function G(t, e, i, n, r) {
          this.good_length = t,
            this.max_lazy = e,
            this.nice_length = i,
            this.max_chain = n,
            this.func = r
        }
        function W() {
          this.strm = null,
            this.status = 0,
            this.pending_buf = null,
            this.pending_buf_size = 0,
            this.pending_out = 0,
            this.pending = 0,
            this.wrap = 0,
            this.gzhead = null,
            this.gzindex = 0,
            this.method = m,
            this.last_flush = -1,
            this.w_size = 0,
            this.w_bits = 0,
            this.w_mask = 0,
            this.window = null,
            this.window_size = 0,
            this.prev = null,
            this.head = null,
            this.ins_h = 0,
            this.hash_size = 0,
            this.hash_bits = 0,
            this.hash_mask = 0,
            this.hash_shift = 0,
            this.block_start = 0,
            this.match_length = 0,
            this.prev_match = 0,
            this.match_available = 0,
            this.strstart = 0,
            this.match_start = 0,
            this.lookahead = 0,
            this.prev_length = 0,
            this.max_chain_length = 0,
            this.max_lazy_match = 0,
            this.level = 0,
            this.strategy = 0,
            this.good_match = 0,
            this.nice_match = 0,
            this.dyn_ltree = new r.Buf16(2 * x),
            this.dyn_dtree = new r.Buf16(2 * (2 * A + 1)),
            this.bl_tree = new r.Buf16(2 * (2 * b + 1)),
            z(this.dyn_ltree),
            z(this.dyn_dtree),
            z(this.bl_tree),
            this.l_desc = null,
            this.d_desc = null,
            this.bl_desc = null,
            this.bl_count = new r.Buf16(I + 1),
            this.heap = new r.Buf16(2 * v + 1),
            z(this.heap),
            this.heap_len = 0,
            this.heap_max = 0,
            this.depth = new r.Buf16(2 * v + 1),
            z(this.depth),
            this.l_buf = 0,
            this.lit_bufsize = 0,
            this.last_lit = 0,
            this.d_buf = 0,
            this.opt_len = 0,
            this.static_len = 0,
            this.matches = 0,
            this.insert = 0,
            this.bi_buf = 0,
            this.bi_valid = 0
        }
        function J(t) {
          var e;
          return t && t.state ? (t.total_in = t.total_out = 0,
            t.data_type = g,
            (e = t.state).pending = 0,
            e.pending_out = 0,
            e.wrap < 0 && (e.wrap = -e.wrap),
            e.status = e.wrap ? S : M,
            t.adler = 2 === e.wrap ? 0 : 1,
            e.last_flush = h,
            o._tr_init(e),
            u) : L(t, p)
        }
        function H(t) {
          var e = J(t);
          return e === u && function (t) {
            t.window_size = 2 * t.w_size,
              z(t.head),
              t.max_lazy_match = n[t.level].max_lazy,
              t.good_match = n[t.level].good_length,
              t.nice_match = n[t.level].nice_length,
              t.max_chain_length = n[t.level].max_chain,
              t.strstart = 0,
              t.block_start = 0,
              t.lookahead = 0,
              t.insert = 0,
              t.match_length = t.prev_length = C - 1,
              t.match_available = 0,
              t.ins_h = 0
          }(t.state),
            e
        }
        function Z(t, e, i, n, o, s) {
          if (!t)
            return p;
          var a = 1;
          if (e === d && (e = 6),
            n < 0 ? (a = 0,
              n = -n) : 15 < n && (a = 2,
                n -= 16),
            o < 1 || y < o || i !== m || n < 8 || 15 < n || e < 0 || 9 < e || s < 0 || f < s)
            return L(t, p);
          8 === n && (n = 9);
          var l = new W;
          return (t.state = l).strm = t,
            l.wrap = a,
            l.gzhead = null,
            l.w_bits = n,
            l.w_size = 1 << l.w_bits,
            l.w_mask = l.w_size - 1,
            l.hash_bits = o + 7,
            l.hash_size = 1 << l.hash_bits,
            l.hash_mask = l.hash_size - 1,
            l.hash_shift = ~~((l.hash_bits + C - 1) / C),
            l.window = new r.Buf8(2 * l.w_size),
            l.head = new r.Buf16(l.hash_size),
            l.prev = new r.Buf16(l.w_size),
            l.lit_bufsize = 1 << o + 6,
            l.pending_buf_size = 4 * l.lit_bufsize,
            l.pending_buf = new r.Buf8(l.pending_buf_size),
            l.d_buf = 1 * l.lit_bufsize,
            l.l_buf = 3 * l.lit_bufsize,
            l.level = e,
            l.strategy = s,
            l.method = i,
            H(t)
        }
        n = [new G(0, 0, 0, 0, (function (t, e) {
          var i = 65535;
          for (i > t.pending_buf_size - 5 && (i = t.pending_buf_size - 5); ;) {
            if (t.lookahead <= 1) {
              if (B(t),
                0 === t.lookahead && e === h)
                return T;
              if (0 === t.lookahead)
                break
            }
            t.strstart += t.lookahead,
              t.lookahead = 0;
            var n = t.block_start + i;
            if ((0 === t.strstart || t.strstart >= n) && (t.lookahead = t.strstart - n,
              t.strstart = n,
              D(t, !1),
              0 === t.strm.avail_out))
              return T;
            if (t.strstart - t.block_start >= t.w_size - _ && (D(t, !1),
              0 === t.strm.avail_out))
              return T
          }
          return t.insert = 0,
            e === c ? (D(t, !0),
              0 === t.strm.avail_out ? k : R) : (t.strstart > t.block_start && (D(t, !1),
                t.strm.avail_out),
                T)
        }
        )), new G(4, 4, 8, 4, j), new G(4, 5, 16, 8, j), new G(4, 6, 32, 32, j), new G(4, 4, 16, 16, V), new G(8, 16, 32, 32, V), new G(8, 16, 128, 128, V), new G(8, 32, 128, 256, V), new G(32, 128, 258, 1024, V), new G(32, 258, 258, 4096, V)],
          i.deflateInit = function (t, e) {
            return Z(t, e, m, 15, 8, 0)
          }
          ,
          i.deflateInit2 = Z,
          i.deflateReset = H,
          i.deflateResetKeep = J,
          i.deflateSetHeader = function (t, e) {
            return t && t.state ? 2 !== t.state.wrap ? p : (t.state.gzhead = e,
              u) : p
          }
          ,
          i.deflate = function (t, e) {
            var i, r, s, l;
            if (!t || !t.state || 5 < e || e < 0)
              return t ? L(t, p) : p;
            if (r = t.state,
              !t.output || !t.input && 0 !== t.avail_in || 666 === r.status && e !== c)
              return L(t, 0 === t.avail_out ? -5 : p);
            if (r.strm = t,
              i = r.last_flush,
              r.last_flush = e,
              r.status === S)
              if (2 === r.wrap)
                t.adler = 0,
                  U(r, 31),
                  U(r, 139),
                  U(r, 8),
                  r.gzhead ? (U(r, (r.gzhead.text ? 1 : 0) + (r.gzhead.hcrc ? 2 : 0) + (r.gzhead.extra ? 4 : 0) + (r.gzhead.name ? 8 : 0) + (r.gzhead.comment ? 16 : 0)),
                    U(r, 255 & r.gzhead.time),
                    U(r, r.gzhead.time >> 8 & 255),
                    U(r, r.gzhead.time >> 16 & 255),
                    U(r, r.gzhead.time >> 24 & 255),
                    U(r, 9 === r.level ? 2 : 2 <= r.strategy || r.level < 2 ? 4 : 0),
                    U(r, 255 & r.gzhead.os),
                    r.gzhead.extra && r.gzhead.extra.length && (U(r, 255 & r.gzhead.extra.length),
                      U(r, r.gzhead.extra.length >> 8 & 255)),
                    r.gzhead.hcrc && (t.adler = a(t.adler, r.pending_buf, r.pending, 0)),
                    r.gzindex = 0,
                    r.status = 69) : (U(r, 0),
                      U(r, 0),
                      U(r, 0),
                      U(r, 0),
                      U(r, 0),
                      U(r, 9 === r.level ? 2 : 2 <= r.strategy || r.level < 2 ? 4 : 0),
                      U(r, 3),
                      r.status = M);
              else {
                var d = m + (r.w_bits - 8 << 4) << 8;
                d |= (2 <= r.strategy || r.level < 2 ? 0 : r.level < 6 ? 1 : 6 === r.level ? 2 : 3) << 6,
                  0 !== r.strstart && (d |= 32),
                  d += 31 - d % 31,
                  r.status = M,
                  N(r, d),
                  0 !== r.strstart && (N(r, t.adler >>> 16),
                    N(r, 65535 & t.adler)),
                  t.adler = 1
              }
            if (69 === r.status)
              if (r.gzhead.extra) {
                for (s = r.pending; r.gzindex < (65535 & r.gzhead.extra.length) && (r.pending !== r.pending_buf_size || (r.gzhead.hcrc && r.pending > s && (t.adler = a(t.adler, r.pending_buf, r.pending - s, s)),
                  O(t),
                  s = r.pending,
                  r.pending !== r.pending_buf_size));)
                  U(r, 255 & r.gzhead.extra[r.gzindex]),
                    r.gzindex++;
                r.gzhead.hcrc && r.pending > s && (t.adler = a(t.adler, r.pending_buf, r.pending - s, s)),
                  r.gzindex === r.gzhead.extra.length && (r.gzindex = 0,
                    r.status = 73)
              } else
                r.status = 73;
            if (73 === r.status)
              if (r.gzhead.name) {
                s = r.pending;
                do {
                  if (r.pending === r.pending_buf_size && (r.gzhead.hcrc && r.pending > s && (t.adler = a(t.adler, r.pending_buf, r.pending - s, s)),
                    O(t),
                    s = r.pending,
                    r.pending === r.pending_buf_size)) {
                    l = 1;
                    break
                  }
                  l = r.gzindex < r.gzhead.name.length ? 255 & r.gzhead.name.charCodeAt(r.gzindex++) : 0,
                    U(r, l)
                } while (0 !== l);
                r.gzhead.hcrc && r.pending > s && (t.adler = a(t.adler, r.pending_buf, r.pending - s, s)),
                  0 === l && (r.gzindex = 0,
                    r.status = 91)
              } else
                r.status = 91;
            if (91 === r.status)
              if (r.gzhead.comment) {
                s = r.pending;
                do {
                  if (r.pending === r.pending_buf_size && (r.gzhead.hcrc && r.pending > s && (t.adler = a(t.adler, r.pending_buf, r.pending - s, s)),
                    O(t),
                    s = r.pending,
                    r.pending === r.pending_buf_size)) {
                    l = 1;
                    break
                  }
                  l = r.gzindex < r.gzhead.comment.length ? 255 & r.gzhead.comment.charCodeAt(r.gzindex++) : 0,
                    U(r, l)
                } while (0 !== l);
                r.gzhead.hcrc && r.pending > s && (t.adler = a(t.adler, r.pending_buf, r.pending - s, s)),
                  0 === l && (r.status = 103)
              } else
                r.status = 103;
            if (103 === r.status && (r.gzhead.hcrc ? (r.pending + 2 > r.pending_buf_size && O(t),
              r.pending + 2 <= r.pending_buf_size && (U(r, 255 & t.adler),
                U(r, t.adler >> 8 & 255),
                t.adler = 0,
                r.status = M)) : r.status = M),
              0 !== r.pending) {
              if (O(t),
                0 === t.avail_out)
                return r.last_flush = -1,
                  u
            } else if (0 === t.avail_in && P(e) <= P(i) && e !== c)
              return L(t, -5);
            if (666 === r.status && 0 !== t.avail_in)
              return L(t, -5);
            if (0 !== t.avail_in || 0 !== r.lookahead || e !== h && 666 !== r.status) {
              var f = 2 === r.strategy ? function (t, e) {
                for (var i; ;) {
                  if (0 === t.lookahead && (B(t),
                    0 === t.lookahead)) {
                    if (e === h)
                      return T;
                    break
                  }
                  if (t.match_length = 0,
                    i = o._tr_tally(t, 0, t.window[t.strstart]),
                    t.lookahead--,
                    t.strstart++,
                    i && (D(t, !1),
                      0 === t.strm.avail_out))
                    return T
                }
                return t.insert = 0,
                  e === c ? (D(t, !0),
                    0 === t.strm.avail_out ? k : R) : t.last_lit && (D(t, !1),
                      0 === t.strm.avail_out) ? T : E
              }(r, e) : 3 === r.strategy ? function (t, e) {
                for (var i, n, r, s, a = t.window; ;) {
                  if (t.lookahead <= w) {
                    if (B(t),
                      t.lookahead <= w && e === h)
                      return T;
                    if (0 === t.lookahead)
                      break
                  }
                  if (t.match_length = 0,
                    t.lookahead >= C && 0 < t.strstart && (n = a[r = t.strstart - 1]) === a[++r] && n === a[++r] && n === a[++r]) {
                    s = t.strstart + w;
                    do { } while (n === a[++r] && n === a[++r] && n === a[++r] && n === a[++r] && n === a[++r] && n === a[++r] && n === a[++r] && n === a[++r] && r < s);
                    t.match_length = w - (s - r),
                      t.match_length > t.lookahead && (t.match_length = t.lookahead)
                  }
                  if (t.match_length >= C ? (i = o._tr_tally(t, 1, t.match_length - C),
                    t.lookahead -= t.match_length,
                    t.strstart += t.match_length,
                    t.match_length = 0) : (i = o._tr_tally(t, 0, t.window[t.strstart]),
                      t.lookahead--,
                      t.strstart++),
                    i && (D(t, !1),
                      0 === t.strm.avail_out))
                    return T
                }
                return t.insert = 0,
                  e === c ? (D(t, !0),
                    0 === t.strm.avail_out ? k : R) : t.last_lit && (D(t, !1),
                      0 === t.strm.avail_out) ? T : E
              }(r, e) : n[r.level].func(r, e);
              if (f !== k && f !== R || (r.status = 666),
                f === T || f === k)
                return 0 === t.avail_out && (r.last_flush = -1),
                  u;
              if (f === E && (1 === e ? o._tr_align(r) : 5 !== e && (o._tr_stored_block(r, 0, 0, !1),
                3 === e && (z(r.head),
                  0 === r.lookahead && (r.strstart = 0,
                    r.block_start = 0,
                    r.insert = 0))),
                O(t),
                0 === t.avail_out))
                return r.last_flush = -1,
                  u
            }
            return e !== c ? u : r.wrap <= 0 ? 1 : (2 === r.wrap ? (U(r, 255 & t.adler),
              U(r, t.adler >> 8 & 255),
              U(r, t.adler >> 16 & 255),
              U(r, t.adler >> 24 & 255),
              U(r, 255 & t.total_in),
              U(r, t.total_in >> 8 & 255),
              U(r, t.total_in >> 16 & 255),
              U(r, t.total_in >> 24 & 255)) : (N(r, t.adler >>> 16),
                N(r, 65535 & t.adler)),
              O(t),
              0 < r.wrap && (r.wrap = -r.wrap),
              0 !== r.pending ? u : 1)
          }
          ,
          i.deflateEnd = function (t) {
            var e;
            return t && t.state ? (e = t.state.status) !== S && 69 !== e && 73 !== e && 91 !== e && 103 !== e && e !== M && 666 !== e ? L(t, p) : (t.state = null,
              e === M ? L(t, -3) : u) : p
          }
          ,
          i.deflateSetDictionary = function (t, e) {
            var i, n, o, a, l, h, c, d, f = e.length;
            if (!t || !t.state)
              return p;
            if (2 === (a = (i = t.state).wrap) || 1 === a && i.status !== S || i.lookahead)
              return p;
            for (1 === a && (t.adler = s(t.adler, e, f, 0)),
              i.wrap = 0,
              f >= i.w_size && (0 === a && (z(i.head),
                i.strstart = 0,
                i.block_start = 0,
                i.insert = 0),
                d = new r.Buf8(i.w_size),
                r.arraySet(d, e, f - i.w_size, i.w_size, 0),
                e = d,
                f = i.w_size),
              l = t.avail_in,
              h = t.next_in,
              c = t.input,
              t.avail_in = f,
              t.next_in = 0,
              t.input = e,
              B(i); i.lookahead >= C;) {
              for (n = i.strstart,
                o = i.lookahead - (C - 1); i.ins_h = (i.ins_h << i.hash_shift ^ i.window[n + C - 1]) & i.hash_mask,
                i.prev[n & i.w_mask] = i.head[i.ins_h],
                i.head[i.ins_h] = n,
                n++,
                --o;)
                ;
              i.strstart = n,
                i.lookahead = C - 1,
                B(i)
            }
            return i.strstart += i.lookahead,
              i.block_start = i.strstart,
              i.insert = i.lookahead,
              i.lookahead = 0,
              i.match_length = i.prev_length = C - 1,
              i.match_available = 0,
              t.next_in = h,
              t.input = c,
              t.avail_in = l,
              i.wrap = a,
              u
          }
          ,
          i.deflateInfo = "pako deflate (from Nodeca project)"
      }
        , {
        "../utils/common": 41,
        "./adler32": 43,
        "./crc32": 45,
        "./messages": 51,
        "./trees": 52
      }],
      47: [function (t, e, i) {
        e.exports = function () {
          this.text = 0,
            this.time = 0,
            this.xflags = 0,
            this.os = 0,
            this.extra = null,
            this.extra_len = 0,
            this.name = "",
            this.comment = "",
            this.hcrc = 0,
            this.done = !1
        }
      }
        , {}],
      48: [function (t, e, i) {
        e.exports = function (t, e) {
          var i, n, r, o, s, a, l, h, c, u, p, d, f, g, m, y, v, A, b, x, I, C, w, _, S;
          i = t.state,
            n = t.next_in,
            _ = t.input,
            r = n + (t.avail_in - 5),
            o = t.next_out,
            S = t.output,
            s = o - (e - t.avail_out),
            a = o + (t.avail_out - 257),
            l = i.dmax,
            h = i.wsize,
            c = i.whave,
            u = i.wnext,
            p = i.window,
            d = i.hold,
            f = i.bits,
            g = i.lencode,
            m = i.distcode,
            y = (1 << i.lenbits) - 1,
            v = (1 << i.distbits) - 1;
          t: do {
            f < 15 && (d += _[n++] << f,
              f += 8,
              d += _[n++] << f,
              f += 8),
              A = g[d & y];
            e: for (; ;) {
              if (d >>>= b = A >>> 24,
                f -= b,
                0 == (b = A >>> 16 & 255))
                S[o++] = 65535 & A;
              else {
                if (!(16 & b)) {
                  if (0 == (64 & b)) {
                    A = g[(65535 & A) + (d & (1 << b) - 1)];
                    continue e
                  }
                  if (32 & b) {
                    i.mode = 12;
                    break t
                  }
                  t.msg = "invalid literal/length code",
                    i.mode = 30;
                  break t
                }
                x = 65535 & A,
                  (b &= 15) && (f < b && (d += _[n++] << f,
                    f += 8),
                    x += d & (1 << b) - 1,
                    d >>>= b,
                    f -= b),
                  f < 15 && (d += _[n++] << f,
                    f += 8,
                    d += _[n++] << f,
                    f += 8),
                  A = m[d & v];
                i: for (; ;) {
                  if (d >>>= b = A >>> 24,
                    f -= b,
                    !(16 & (b = A >>> 16 & 255))) {
                    if (0 == (64 & b)) {
                      A = m[(65535 & A) + (d & (1 << b) - 1)];
                      continue i
                    }
                    t.msg = "invalid distance code",
                      i.mode = 30;
                    break t
                  }
                  if (I = 65535 & A,
                    f < (b &= 15) && (d += _[n++] << f,
                      (f += 8) < b && (d += _[n++] << f,
                        f += 8)),
                    l < (I += d & (1 << b) - 1)) {
                    t.msg = "invalid distance too far back",
                      i.mode = 30;
                    break t
                  }
                  if (d >>>= b,
                    f -= b,
                    (b = o - s) < I) {
                    if (c < (b = I - b) && i.sane) {
                      t.msg = "invalid distance too far back",
                        i.mode = 30;
                      break t
                    }
                    if (w = p,
                      (C = 0) === u) {
                      if (C += h - b,
                        b < x) {
                        for (x -= b; S[o++] = p[C++],
                          --b;)
                          ;
                        C = o - I,
                          w = S
                      }
                    } else if (u < b) {
                      if (C += h + u - b,
                        (b -= u) < x) {
                        for (x -= b; S[o++] = p[C++],
                          --b;)
                          ;
                        if (C = 0,
                          u < x) {
                          for (x -= b = u; S[o++] = p[C++],
                            --b;)
                            ;
                          C = o - I,
                            w = S
                        }
                      }
                    } else if (C += u - b,
                      b < x) {
                      for (x -= b; S[o++] = p[C++],
                        --b;)
                        ;
                      C = o - I,
                        w = S
                    }
                    for (; 2 < x;)
                      S[o++] = w[C++],
                        S[o++] = w[C++],
                        S[o++] = w[C++],
                        x -= 3;
                    x && (S[o++] = w[C++],
                      1 < x && (S[o++] = w[C++]))
                  } else {
                    for (C = o - I; S[o++] = S[C++],
                      S[o++] = S[C++],
                      S[o++] = S[C++],
                      2 < (x -= 3);)
                      ;
                    x && (S[o++] = S[C++],
                      1 < x && (S[o++] = S[C++]))
                  }
                  break
                }
              }
              break
            }
          } while (n < r && o < a);
          n -= x = f >> 3,
            d &= (1 << (f -= x << 3)) - 1,
            t.next_in = n,
            t.next_out = o,
            t.avail_in = n < r ? r - n + 5 : 5 - (n - r),
            t.avail_out = o < a ? a - o + 257 : 257 - (o - a),
            i.hold = d,
            i.bits = f
        }
      }
        , {}],
      49: [function (t, e, i) {
        var n = t("../utils/common")
          , r = t("./adler32")
          , o = t("./crc32")
          , s = t("./inffast")
          , a = t("./inftrees")
          , l = 1
          , h = 2
          , c = 0
          , u = -2
          , p = 1
          , d = 852
          , f = 592;
        function g(t) {
          return (t >>> 24 & 255) + (t >>> 8 & 65280) + ((65280 & t) << 8) + ((255 & t) << 24)
        }
        function m() {
          this.mode = 0,
            this.last = !1,
            this.wrap = 0,
            this.havedict = !1,
            this.flags = 0,
            this.dmax = 0,
            this.check = 0,
            this.total = 0,
            this.head = null,
            this.wbits = 0,
            this.wsize = 0,
            this.whave = 0,
            this.wnext = 0,
            this.window = null,
            this.hold = 0,
            this.bits = 0,
            this.length = 0,
            this.offset = 0,
            this.extra = 0,
            this.lencode = null,
            this.distcode = null,
            this.lenbits = 0,
            this.distbits = 0,
            this.ncode = 0,
            this.nlen = 0,
            this.ndist = 0,
            this.have = 0,
            this.next = null,
            this.lens = new n.Buf16(320),
            this.work = new n.Buf16(288),
            this.lendyn = null,
            this.distdyn = null,
            this.sane = 0,
            this.back = 0,
            this.was = 0
        }
        function y(t) {
          var e;
          return t && t.state ? (e = t.state,
            t.total_in = t.total_out = e.total = 0,
            t.msg = "",
            e.wrap && (t.adler = 1 & e.wrap),
            e.mode = p,
            e.last = 0,
            e.havedict = 0,
            e.dmax = 32768,
            e.head = null,
            e.hold = 0,
            e.bits = 0,
            e.lencode = e.lendyn = new n.Buf32(d),
            e.distcode = e.distdyn = new n.Buf32(f),
            e.sane = 1,
            e.back = -1,
            c) : u
        }
        function v(t) {
          var e;
          return t && t.state ? ((e = t.state).wsize = 0,
            e.whave = 0,
            e.wnext = 0,
            y(t)) : u
        }
        function A(t, e) {
          var i, n;
          return t && t.state ? (n = t.state,
            e < 0 ? (i = 0,
              e = -e) : (i = 1 + (e >> 4),
                e < 48 && (e &= 15)),
            e && (e < 8 || 15 < e) ? u : (null !== n.window && n.wbits !== e && (n.window = null),
              n.wrap = i,
              n.wbits = e,
              v(t))) : u
        }
        function b(t, e) {
          var i, n;
          return t ? (n = new m,
            (t.state = n).window = null,
            (i = A(t, e)) !== c && (t.state = null),
            i) : u
        }
        var x, I, C = !0;
        function w(t) {
          if (C) {
            var e;
            for (x = new n.Buf32(512),
              I = new n.Buf32(32),
              e = 0; e < 144;)
              t.lens[e++] = 8;
            for (; e < 256;)
              t.lens[e++] = 9;
            for (; e < 280;)
              t.lens[e++] = 7;
            for (; e < 288;)
              t.lens[e++] = 8;
            for (a(l, t.lens, 0, 288, x, 0, t.work, {
              bits: 9
            }),
              e = 0; e < 32;)
              t.lens[e++] = 5;
            a(h, t.lens, 0, 32, I, 0, t.work, {
              bits: 5
            }),
              C = !1
          }
          t.lencode = x,
            t.lenbits = 9,
            t.distcode = I,
            t.distbits = 5
        }
        function _(t, e, i, r) {
          var o, s = t.state;
          return null === s.window && (s.wsize = 1 << s.wbits,
            s.wnext = 0,
            s.whave = 0,
            s.window = new n.Buf8(s.wsize)),
            r >= s.wsize ? (n.arraySet(s.window, e, i - s.wsize, s.wsize, 0),
              s.wnext = 0,
              s.whave = s.wsize) : (r < (o = s.wsize - s.wnext) && (o = r),
                n.arraySet(s.window, e, i - r, o, s.wnext),
                (r -= o) ? (n.arraySet(s.window, e, i - r, r, 0),
                  s.wnext = r,
                  s.whave = s.wsize) : (s.wnext += o,
                    s.wnext === s.wsize && (s.wnext = 0),
                    s.whave < s.wsize && (s.whave += o))),
            0
        }
        i.inflateReset = v,
          i.inflateReset2 = A,
          i.inflateResetKeep = y,
          i.inflateInit = function (t) {
            return b(t, 15)
          }
          ,
          i.inflateInit2 = b,
          i.inflate = function (t, e) {
            var i, d, f, m, y, v, A, b, x, I, C, S, M, T, E, k, R, L, P, z, O, D, U, N, F = 0, B = new n.Buf8(4), j = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
            if (!t || !t.state || !t.output || !t.input && 0 !== t.avail_in)
              return u;
            12 === (i = t.state).mode && (i.mode = 13),
              y = t.next_out,
              f = t.output,
              A = t.avail_out,
              m = t.next_in,
              d = t.input,
              v = t.avail_in,
              b = i.hold,
              x = i.bits,
              I = v,
              C = A,
              D = c;
            t: for (; ;)
              switch (i.mode) {
                case p:
                  if (0 === i.wrap) {
                    i.mode = 13;
                    break
                  }
                  for (; x < 16;) {
                    if (0 === v)
                      break t;
                    v--,
                      b += d[m++] << x,
                      x += 8
                  }
                  if (2 & i.wrap && 35615 === b) {
                    B[i.check = 0] = 255 & b,
                      B[1] = b >>> 8 & 255,
                      i.check = o(i.check, B, 2, 0),
                      x = b = 0,
                      i.mode = 2;
                    break
                  }
                  if (i.flags = 0,
                    i.head && (i.head.done = !1),
                    !(1 & i.wrap) || (((255 & b) << 8) + (b >> 8)) % 31) {
                    t.msg = "incorrect header check",
                      i.mode = 30;
                    break
                  }
                  if (8 != (15 & b)) {
                    t.msg = "unknown compression method",
                      i.mode = 30;
                    break
                  }
                  if (x -= 4,
                    O = 8 + (15 & (b >>>= 4)),
                    0 === i.wbits)
                    i.wbits = O;
                  else if (O > i.wbits) {
                    t.msg = "invalid window size",
                      i.mode = 30;
                    break
                  }
                  i.dmax = 1 << O,
                    t.adler = i.check = 1,
                    i.mode = 512 & b ? 10 : 12,
                    x = b = 0;
                  break;
                case 2:
                  for (; x < 16;) {
                    if (0 === v)
                      break t;
                    v--,
                      b += d[m++] << x,
                      x += 8
                  }
                  if (i.flags = b,
                    8 != (255 & i.flags)) {
                    t.msg = "unknown compression method",
                      i.mode = 30;
                    break
                  }
                  if (57344 & i.flags) {
                    t.msg = "unknown header flags set",
                      i.mode = 30;
                    break
                  }
                  i.head && (i.head.text = b >> 8 & 1),
                    512 & i.flags && (B[0] = 255 & b,
                      B[1] = b >>> 8 & 255,
                      i.check = o(i.check, B, 2, 0)),
                    x = b = 0,
                    i.mode = 3;
                case 3:
                  for (; x < 32;) {
                    if (0 === v)
                      break t;
                    v--,
                      b += d[m++] << x,
                      x += 8
                  }
                  i.head && (i.head.time = b),
                    512 & i.flags && (B[0] = 255 & b,
                      B[1] = b >>> 8 & 255,
                      B[2] = b >>> 16 & 255,
                      B[3] = b >>> 24 & 255,
                      i.check = o(i.check, B, 4, 0)),
                    x = b = 0,
                    i.mode = 4;
                case 4:
                  for (; x < 16;) {
                    if (0 === v)
                      break t;
                    v--,
                      b += d[m++] << x,
                      x += 8
                  }
                  i.head && (i.head.xflags = 255 & b,
                    i.head.os = b >> 8),
                    512 & i.flags && (B[0] = 255 & b,
                      B[1] = b >>> 8 & 255,
                      i.check = o(i.check, B, 2, 0)),
                    x = b = 0,
                    i.mode = 5;
                case 5:
                  if (1024 & i.flags) {
                    for (; x < 16;) {
                      if (0 === v)
                        break t;
                      v--,
                        b += d[m++] << x,
                        x += 8
                    }
                    i.length = b,
                      i.head && (i.head.extra_len = b),
                      512 & i.flags && (B[0] = 255 & b,
                        B[1] = b >>> 8 & 255,
                        i.check = o(i.check, B, 2, 0)),
                      x = b = 0
                  } else
                    i.head && (i.head.extra = null);
                  i.mode = 6;
                case 6:
                  if (1024 & i.flags && (v < (S = i.length) && (S = v),
                    S && (i.head && (O = i.head.extra_len - i.length,
                      i.head.extra || (i.head.extra = new Array(i.head.extra_len)),
                      n.arraySet(i.head.extra, d, m, S, O)),
                      512 & i.flags && (i.check = o(i.check, d, S, m)),
                      v -= S,
                      m += S,
                      i.length -= S),
                    i.length))
                    break t;
                  i.length = 0,
                    i.mode = 7;
                case 7:
                  if (2048 & i.flags) {
                    if (0 === v)
                      break t;
                    for (S = 0; O = d[m + S++],
                      i.head && O && i.length < 65536 && (i.head.name += String.fromCharCode(O)),
                      O && S < v;)
                      ;
                    if (512 & i.flags && (i.check = o(i.check, d, S, m)),
                      v -= S,
                      m += S,
                      O)
                      break t
                  } else
                    i.head && (i.head.name = null);
                  i.length = 0,
                    i.mode = 8;
                case 8:
                  if (4096 & i.flags) {
                    if (0 === v)
                      break t;
                    for (S = 0; O = d[m + S++],
                      i.head && O && i.length < 65536 && (i.head.comment += String.fromCharCode(O)),
                      O && S < v;)
                      ;
                    if (512 & i.flags && (i.check = o(i.check, d, S, m)),
                      v -= S,
                      m += S,
                      O)
                      break t
                  } else
                    i.head && (i.head.comment = null);
                  i.mode = 9;
                case 9:
                  if (512 & i.flags) {
                    for (; x < 16;) {
                      if (0 === v)
                        break t;
                      v--,
                        b += d[m++] << x,
                        x += 8
                    }
                    if (b !== (65535 & i.check)) {
                      t.msg = "header crc mismatch",
                        i.mode = 30;
                      break
                    }
                    x = b = 0
                  }
                  i.head && (i.head.hcrc = i.flags >> 9 & 1,
                    i.head.done = !0),
                    t.adler = i.check = 0,
                    i.mode = 12;
                  break;
                case 10:
                  for (; x < 32;) {
                    if (0 === v)
                      break t;
                    v--,
                      b += d[m++] << x,
                      x += 8
                  }
                  t.adler = i.check = g(b),
                    x = b = 0,
                    i.mode = 11;
                case 11:
                  if (0 === i.havedict)
                    return t.next_out = y,
                      t.avail_out = A,
                      t.next_in = m,
                      t.avail_in = v,
                      i.hold = b,
                      i.bits = x,
                      2;
                  t.adler = i.check = 1,
                    i.mode = 12;
                case 12:
                  if (5 === e || 6 === e)
                    break t;
                case 13:
                  if (i.last) {
                    b >>>= 7 & x,
                      x -= 7 & x,
                      i.mode = 27;
                    break
                  }
                  for (; x < 3;) {
                    if (0 === v)
                      break t;
                    v--,
                      b += d[m++] << x,
                      x += 8
                  }
                  switch (i.last = 1 & b,
                  x -= 1,
                  3 & (b >>>= 1)) {
                    case 0:
                      i.mode = 14;
                      break;
                    case 1:
                      if (w(i),
                        i.mode = 20,
                        6 !== e)
                        break;
                      b >>>= 2,
                        x -= 2;
                      break t;
                    case 2:
                      i.mode = 17;
                      break;
                    case 3:
                      t.msg = "invalid block type",
                        i.mode = 30
                  }
                  b >>>= 2,
                    x -= 2;
                  break;
                case 14:
                  for (b >>>= 7 & x,
                    x -= 7 & x; x < 32;) {
                    if (0 === v)
                      break t;
                    v--,
                      b += d[m++] << x,
                      x += 8
                  }
                  if ((65535 & b) != (b >>> 16 ^ 65535)) {
                    t.msg = "invalid stored block lengths",
                      i.mode = 30;
                    break
                  }
                  if (i.length = 65535 & b,
                    x = b = 0,
                    i.mode = 15,
                    6 === e)
                    break t;
                case 15:
                  i.mode = 16;
                case 16:
                  if (S = i.length) {
                    if (v < S && (S = v),
                      A < S && (S = A),
                      0 === S)
                      break t;
                    n.arraySet(f, d, m, S, y),
                      v -= S,
                      m += S,
                      A -= S,
                      y += S,
                      i.length -= S;
                    break
                  }
                  i.mode = 12;
                  break;
                case 17:
                  for (; x < 14;) {
                    if (0 === v)
                      break t;
                    v--,
                      b += d[m++] << x,
                      x += 8
                  }
                  if (i.nlen = 257 + (31 & b),
                    b >>>= 5,
                    x -= 5,
                    i.ndist = 1 + (31 & b),
                    b >>>= 5,
                    x -= 5,
                    i.ncode = 4 + (15 & b),
                    b >>>= 4,
                    x -= 4,
                    286 < i.nlen || 30 < i.ndist) {
                    t.msg = "too many length or distance symbols",
                      i.mode = 30;
                    break
                  }
                  i.have = 0,
                    i.mode = 18;
                case 18:
                  for (; i.have < i.ncode;) {
                    for (; x < 3;) {
                      if (0 === v)
                        break t;
                      v--,
                        b += d[m++] << x,
                        x += 8
                    }
                    i.lens[j[i.have++]] = 7 & b,
                      b >>>= 3,
                      x -= 3
                  }
                  for (; i.have < 19;)
                    i.lens[j[i.have++]] = 0;
                  if (i.lencode = i.lendyn,
                    i.lenbits = 7,
                    U = {
                      bits: i.lenbits
                    },
                    D = a(0, i.lens, 0, 19, i.lencode, 0, i.work, U),
                    i.lenbits = U.bits,
                    D) {
                    t.msg = "invalid code lengths set",
                      i.mode = 30;
                    break
                  }
                  i.have = 0,
                    i.mode = 19;
                case 19:
                  for (; i.have < i.nlen + i.ndist;) {
                    for (; k = (F = i.lencode[b & (1 << i.lenbits) - 1]) >>> 16 & 255,
                      R = 65535 & F,
                      !((E = F >>> 24) <= x);) {
                      if (0 === v)
                        break t;
                      v--,
                        b += d[m++] << x,
                        x += 8
                    }
                    if (R < 16)
                      b >>>= E,
                        x -= E,
                        i.lens[i.have++] = R;
                    else {
                      if (16 === R) {
                        for (N = E + 2; x < N;) {
                          if (0 === v)
                            break t;
                          v--,
                            b += d[m++] << x,
                            x += 8
                        }
                        if (b >>>= E,
                          x -= E,
                          0 === i.have) {
                          t.msg = "invalid bit length repeat",
                            i.mode = 30;
                          break
                        }
                        O = i.lens[i.have - 1],
                          S = 3 + (3 & b),
                          b >>>= 2,
                          x -= 2
                      } else if (17 === R) {
                        for (N = E + 3; x < N;) {
                          if (0 === v)
                            break t;
                          v--,
                            b += d[m++] << x,
                            x += 8
                        }
                        x -= E,
                          O = 0,
                          S = 3 + (7 & (b >>>= E)),
                          b >>>= 3,
                          x -= 3
                      } else {
                        for (N = E + 7; x < N;) {
                          if (0 === v)
                            break t;
                          v--,
                            b += d[m++] << x,
                            x += 8
                        }
                        x -= E,
                          O = 0,
                          S = 11 + (127 & (b >>>= E)),
                          b >>>= 7,
                          x -= 7
                      }
                      if (i.have + S > i.nlen + i.ndist) {
                        t.msg = "invalid bit length repeat",
                          i.mode = 30;
                        break
                      }
                      for (; S--;)
                        i.lens[i.have++] = O
                    }
                  }
                  if (30 === i.mode)
                    break;
                  if (0 === i.lens[256]) {
                    t.msg = "invalid code -- missing end-of-block",
                      i.mode = 30;
                    break
                  }
                  if (i.lenbits = 9,
                    U = {
                      bits: i.lenbits
                    },
                    D = a(l, i.lens, 0, i.nlen, i.lencode, 0, i.work, U),
                    i.lenbits = U.bits,
                    D) {
                    t.msg = "invalid literal/lengths set",
                      i.mode = 30;
                    break
                  }
                  if (i.distbits = 6,
                    i.distcode = i.distdyn,
                    U = {
                      bits: i.distbits
                    },
                    D = a(h, i.lens, i.nlen, i.ndist, i.distcode, 0, i.work, U),
                    i.distbits = U.bits,
                    D) {
                    t.msg = "invalid distances set",
                      i.mode = 30;
                    break
                  }
                  if (i.mode = 20,
                    6 === e)
                    break t;
                case 20:
                  i.mode = 21;
                case 21:
                  if (6 <= v && 258 <= A) {
                    t.next_out = y,
                      t.avail_out = A,
                      t.next_in = m,
                      t.avail_in = v,
                      i.hold = b,
                      i.bits = x,
                      s(t, C),
                      y = t.next_out,
                      f = t.output,
                      A = t.avail_out,
                      m = t.next_in,
                      d = t.input,
                      v = t.avail_in,
                      b = i.hold,
                      x = i.bits,
                      12 === i.mode && (i.back = -1);
                    break
                  }
                  for (i.back = 0; k = (F = i.lencode[b & (1 << i.lenbits) - 1]) >>> 16 & 255,
                    R = 65535 & F,
                    !((E = F >>> 24) <= x);) {
                    if (0 === v)
                      break t;
                    v--,
                      b += d[m++] << x,
                      x += 8
                  }
                  if (k && 0 == (240 & k)) {
                    for (L = E,
                      P = k,
                      z = R; k = (F = i.lencode[z + ((b & (1 << L + P) - 1) >> L)]) >>> 16 & 255,
                      R = 65535 & F,
                      !(L + (E = F >>> 24) <= x);) {
                      if (0 === v)
                        break t;
                      v--,
                        b += d[m++] << x,
                        x += 8
                    }
                    b >>>= L,
                      x -= L,
                      i.back += L
                  }
                  if (b >>>= E,
                    x -= E,
                    i.back += E,
                    i.length = R,
                    0 === k) {
                    i.mode = 26;
                    break
                  }
                  if (32 & k) {
                    i.back = -1,
                      i.mode = 12;
                    break
                  }
                  if (64 & k) {
                    t.msg = "invalid literal/length code",
                      i.mode = 30;
                    break
                  }
                  i.extra = 15 & k,
                    i.mode = 22;
                case 22:
                  if (i.extra) {
                    for (N = i.extra; x < N;) {
                      if (0 === v)
                        break t;
                      v--,
                        b += d[m++] << x,
                        x += 8
                    }
                    i.length += b & (1 << i.extra) - 1,
                      b >>>= i.extra,
                      x -= i.extra,
                      i.back += i.extra
                  }
                  i.was = i.length,
                    i.mode = 23;
                case 23:
                  for (; k = (F = i.distcode[b & (1 << i.distbits) - 1]) >>> 16 & 255,
                    R = 65535 & F,
                    !((E = F >>> 24) <= x);) {
                    if (0 === v)
                      break t;
                    v--,
                      b += d[m++] << x,
                      x += 8
                  }
                  if (0 == (240 & k)) {
                    for (L = E,
                      P = k,
                      z = R; k = (F = i.distcode[z + ((b & (1 << L + P) - 1) >> L)]) >>> 16 & 255,
                      R = 65535 & F,
                      !(L + (E = F >>> 24) <= x);) {
                      if (0 === v)
                        break t;
                      v--,
                        b += d[m++] << x,
                        x += 8
                    }
                    b >>>= L,
                      x -= L,
                      i.back += L
                  }
                  if (b >>>= E,
                    x -= E,
                    i.back += E,
                    64 & k) {
                    t.msg = "invalid distance code",
                      i.mode = 30;
                    break
                  }
                  i.offset = R,
                    i.extra = 15 & k,
                    i.mode = 24;
                case 24:
                  if (i.extra) {
                    for (N = i.extra; x < N;) {
                      if (0 === v)
                        break t;
                      v--,
                        b += d[m++] << x,
                        x += 8
                    }
                    i.offset += b & (1 << i.extra) - 1,
                      b >>>= i.extra,
                      x -= i.extra,
                      i.back += i.extra
                  }
                  if (i.offset > i.dmax) {
                    t.msg = "invalid distance too far back",
                      i.mode = 30;
                    break
                  }
                  i.mode = 25;
                case 25:
                  if (0 === A)
                    break t;
                  if (S = C - A,
                    i.offset > S) {
                    if ((S = i.offset - S) > i.whave && i.sane) {
                      t.msg = "invalid distance too far back",
                        i.mode = 30;
                      break
                    }
                    M = S > i.wnext ? (S -= i.wnext,
                      i.wsize - S) : i.wnext - S,
                      S > i.length && (S = i.length),
                      T = i.window
                  } else
                    T = f,
                      M = y - i.offset,
                      S = i.length;
                  for (A < S && (S = A),
                    A -= S,
                    i.length -= S; f[y++] = T[M++],
                    --S;)
                    ;
                  0 === i.length && (i.mode = 21);
                  break;
                case 26:
                  if (0 === A)
                    break t;
                  f[y++] = i.length,
                    A--,
                    i.mode = 21;
                  break;
                case 27:
                  if (i.wrap) {
                    for (; x < 32;) {
                      if (0 === v)
                        break t;
                      v--,
                        b |= d[m++] << x,
                        x += 8
                    }
                    if (C -= A,
                      t.total_out += C,
                      i.total += C,
                      C && (t.adler = i.check = i.flags ? o(i.check, f, C, y - C) : r(i.check, f, C, y - C)),
                      C = A,
                      (i.flags ? b : g(b)) !== i.check) {
                      t.msg = "incorrect data check",
                        i.mode = 30;
                      break
                    }
                    x = b = 0
                  }
                  i.mode = 28;
                case 28:
                  if (i.wrap && i.flags) {
                    for (; x < 32;) {
                      if (0 === v)
                        break t;
                      v--,
                        b += d[m++] << x,
                        x += 8
                    }
                    if (b !== (4294967295 & i.total)) {
                      t.msg = "incorrect length check",
                        i.mode = 30;
                      break
                    }
                    x = b = 0
                  }
                  i.mode = 29;
                case 29:
                  D = 1;
                  break t;
                case 30:
                  D = -3;
                  break t;
                case 31:
                  return -4;
                default:
                  return u
              }
            return t.next_out = y,
              t.avail_out = A,
              t.next_in = m,
              t.avail_in = v,
              i.hold = b,
              i.bits = x,
              (i.wsize || C !== t.avail_out && i.mode < 30 && (i.mode < 27 || 4 !== e)) && _(t, t.output, t.next_out, C - t.avail_out) ? (i.mode = 31,
                -4) : (I -= t.avail_in,
                  C -= t.avail_out,
                  t.total_in += I,
                  t.total_out += C,
                  i.total += C,
                  i.wrap && C && (t.adler = i.check = i.flags ? o(i.check, f, C, t.next_out - C) : r(i.check, f, C, t.next_out - C)),
                  t.data_type = i.bits + (i.last ? 64 : 0) + (12 === i.mode ? 128 : 0) + (20 === i.mode || 15 === i.mode ? 256 : 0),
                  (0 == I && 0 === C || 4 === e) && D === c && (D = -5),
                  D)
          }
          ,
          i.inflateEnd = function (t) {
            if (!t || !t.state)
              return u;
            var e = t.state;
            return e.window && (e.window = null),
              t.state = null,
              c
          }
          ,
          i.inflateGetHeader = function (t, e) {
            var i;
            return t && t.state ? 0 == (2 & (i = t.state).wrap) ? u : ((i.head = e).done = !1,
              c) : u
          }
          ,
          i.inflateSetDictionary = function (t, e) {
            var i, n = e.length;
            return t && t.state ? 0 !== (i = t.state).wrap && 11 !== i.mode ? u : 11 === i.mode && r(1, e, n, 0) !== i.check ? -3 : _(t, e, n, n) ? (i.mode = 31,
              -4) : (i.havedict = 1,
                c) : u
          }
          ,
          i.inflateInfo = "pako inflate (from Nodeca project)"
      }
        , {
        "../utils/common": 41,
        "./adler32": 43,
        "./crc32": 45,
        "./inffast": 48,
        "./inftrees": 50
      }],
      50: [function (t, e, i) {
        var n = t("../utils/common")
          , r = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]
          , o = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78]
          , s = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0]
          , a = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
        e.exports = function (t, e, i, l, h, c, u, p) {
          var d, f, g, m, y, v, A, b, x, I = p.bits, C = 0, w = 0, _ = 0, S = 0, M = 0, T = 0, E = 0, k = 0, R = 0, L = 0, P = null, z = 0, O = new n.Buf16(16), D = new n.Buf16(16), U = null, N = 0;
          for (C = 0; C <= 15; C++)
            O[C] = 0;
          for (w = 0; w < l; w++)
            O[e[i + w]]++;
          for (M = I,
            S = 15; 1 <= S && 0 === O[S]; S--)
            ;
          if (S < M && (M = S),
            0 === S)
            return h[c++] = 20971520,
              h[c++] = 20971520,
              p.bits = 1,
              0;
          for (_ = 1; _ < S && 0 === O[_]; _++)
            ;
          for (M < _ && (M = _),
            C = k = 1; C <= 15; C++)
            if (k <<= 1,
              (k -= O[C]) < 0)
              return -1;
          if (0 < k && (0 === t || 1 !== S))
            return -1;
          for (D[1] = 0,
            C = 1; C < 15; C++)
            D[C + 1] = D[C] + O[C];
          for (w = 0; w < l; w++)
            0 !== e[i + w] && (u[D[e[i + w]]++] = w);
          if (v = 0 === t ? (P = U = u,
            19) : 1 === t ? (P = r,
              z -= 257,
              U = o,
              N -= 257,
              256) : (P = s,
                U = a,
                -1),
            C = _,
            y = c,
            E = w = L = 0,
            g = -1,
            m = (R = 1 << (T = M)) - 1,
            1 === t && 852 < R || 2 === t && 592 < R)
            return 1;
          for (; ;) {
            for (A = C - E,
              x = u[w] < v ? (b = 0,
                u[w]) : u[w] > v ? (b = U[N + u[w]],
                  P[z + u[w]]) : (b = 96,
                    0),
              d = 1 << C - E,
              _ = f = 1 << T; h[y + (L >> E) + (f -= d)] = A << 24 | b << 16 | x | 0,
              0 !== f;)
              ;
            for (d = 1 << C - 1; L & d;)
              d >>= 1;
            if (0 !== d ? (L &= d - 1,
              L += d) : L = 0,
              w++,
              0 == --O[C]) {
              if (C === S)
                break;
              C = e[i + u[w]]
            }
            if (M < C && (L & m) !== g) {
              for (0 === E && (E = M),
                y += _,
                k = 1 << (T = C - E); T + E < S && !((k -= O[T + E]) <= 0);)
                T++,
                  k <<= 1;
              if (R += 1 << T,
                1 === t && 852 < R || 2 === t && 592 < R)
                return 1;
              h[g = L & m] = M << 24 | T << 16 | y - c | 0
            }
          }
          return 0 !== L && (h[y + L] = C - E << 24 | 64 << 16 | 0),
            p.bits = M,
            0
        }
      }
        , {
        "../utils/common": 41
      }],
      51: [function (t, e, i) {
        e.exports = {
          2: "need dictionary",
          1: "stream end",
          0: "",
          "-1": "file error",
          "-2": "stream error",
          "-3": "data error",
          "-4": "insufficient memory",
          "-5": "buffer error",
          "-6": "incompatible version"
        }
      }
        , {}],
      52: [function (t, e, i) {
        var n = t("../utils/common")
          , r = 0
          , o = 1;
        function s(t) {
          for (var e = t.length; 0 <= --e;)
            t[e] = 0
        }
        var a = 0
          , l = 29
          , h = 256
          , c = h + 1 + l
          , u = 30
          , p = 19
          , d = 2 * c + 1
          , f = 15
          , g = 16
          , m = 7
          , y = 256
          , v = 16
          , A = 17
          , b = 18
          , x = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
          , I = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
          , C = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
          , w = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
          , _ = new Array(2 * (c + 2));
        s(_);
        var S = new Array(2 * u);
        s(S);
        var M = new Array(512);
        s(M);
        var T = new Array(256);
        s(T);
        var E = new Array(l);
        s(E);
        var k, R, L, P = new Array(u);
        function z(t, e, i, n, r) {
          this.static_tree = t,
            this.extra_bits = e,
            this.extra_base = i,
            this.elems = n,
            this.max_length = r,
            this.has_stree = t && t.length
        }
        function O(t, e) {
          this.dyn_tree = t,
            this.max_code = 0,
            this.stat_desc = e
        }
        function D(t) {
          return t < 256 ? M[t] : M[256 + (t >>> 7)]
        }
        function U(t, e) {
          t.pending_buf[t.pending++] = 255 & e,
            t.pending_buf[t.pending++] = e >>> 8 & 255
        }
        function N(t, e, i) {
          t.bi_valid > g - i ? (t.bi_buf |= e << t.bi_valid & 65535,
            U(t, t.bi_buf),
            t.bi_buf = e >> g - t.bi_valid,
            t.bi_valid += i - g) : (t.bi_buf |= e << t.bi_valid & 65535,
              t.bi_valid += i)
        }
        function F(t, e, i) {
          N(t, i[2 * e], i[2 * e + 1])
        }
        function B(t, e) {
          for (var i = 0; i |= 1 & t,
            t >>>= 1,
            i <<= 1,
            0 < --e;)
            ;
          return i >>> 1
        }
        function j(t, e, i) {
          var n, r, o = new Array(f + 1), s = 0;
          for (n = 1; n <= f; n++)
            o[n] = s = s + i[n - 1] << 1;
          for (r = 0; r <= e; r++) {
            var a = t[2 * r + 1];
            0 !== a && (t[2 * r] = B(o[a]++, a))
          }
        }
        function V(t) {
          var e;
          for (e = 0; e < c; e++)
            t.dyn_ltree[2 * e] = 0;
          for (e = 0; e < u; e++)
            t.dyn_dtree[2 * e] = 0;
          for (e = 0; e < p; e++)
            t.bl_tree[2 * e] = 0;
          t.dyn_ltree[2 * y] = 1,
            t.opt_len = t.static_len = 0,
            t.last_lit = t.matches = 0
        }
        function G(t) {
          8 < t.bi_valid ? U(t, t.bi_buf) : 0 < t.bi_valid && (t.pending_buf[t.pending++] = t.bi_buf),
            t.bi_buf = 0,
            t.bi_valid = 0
        }
        function W(t, e, i, n) {
          var r = 2 * e
            , o = 2 * i;
          return t[r] < t[o] || t[r] === t[o] && n[e] <= n[i]
        }
        function J(t, e, i) {
          for (var n = t.heap[i], r = i << 1; r <= t.heap_len && (r < t.heap_len && W(e, t.heap[r + 1], t.heap[r], t.depth) && r++,
            !W(e, n, t.heap[r], t.depth));)
            t.heap[i] = t.heap[r],
              i = r,
              r <<= 1;
          t.heap[i] = n
        }
        function H(t, e, i) {
          var n, r, o, s, a = 0;
          if (0 !== t.last_lit)
            for (; n = t.pending_buf[t.d_buf + 2 * a] << 8 | t.pending_buf[t.d_buf + 2 * a + 1],
              r = t.pending_buf[t.l_buf + a],
              a++,
              0 === n ? F(t, r, e) : (F(t, (o = T[r]) + h + 1, e),
                0 !== (s = x[o]) && N(t, r -= E[o], s),
                F(t, o = D(--n), i),
                0 !== (s = I[o]) && N(t, n -= P[o], s)),
              a < t.last_lit;)
              ;
          F(t, y, e)
        }
        function Z(t, e) {
          var i, n, r, o = e.dyn_tree, s = e.stat_desc.static_tree, a = e.stat_desc.has_stree, l = e.stat_desc.elems, h = -1;
          for (t.heap_len = 0,
            t.heap_max = d,
            i = 0; i < l; i++)
            0 !== o[2 * i] ? (t.heap[++t.heap_len] = h = i,
              t.depth[i] = 0) : o[2 * i + 1] = 0;
          for (; t.heap_len < 2;)
            o[2 * (r = t.heap[++t.heap_len] = h < 2 ? ++h : 0)] = 1,
              t.depth[r] = 0,
              t.opt_len--,
              a && (t.static_len -= s[2 * r + 1]);
          for (e.max_code = h,
            i = t.heap_len >> 1; 1 <= i; i--)
            J(t, o, i);
          for (r = l; i = t.heap[1],
            t.heap[1] = t.heap[t.heap_len--],
            J(t, o, 1),
            n = t.heap[1],
            t.heap[--t.heap_max] = i,
            t.heap[--t.heap_max] = n,
            o[2 * r] = o[2 * i] + o[2 * n],
            t.depth[r] = (t.depth[i] >= t.depth[n] ? t.depth[i] : t.depth[n]) + 1,
            o[2 * i + 1] = o[2 * n + 1] = r,
            t.heap[1] = r++,
            J(t, o, 1),
            2 <= t.heap_len;)
            ;
          t.heap[--t.heap_max] = t.heap[1],
            function (t, e) {
              var i, n, r, o, s, a, l = e.dyn_tree, h = e.max_code, c = e.stat_desc.static_tree, u = e.stat_desc.has_stree, p = e.stat_desc.extra_bits, g = e.stat_desc.extra_base, m = e.stat_desc.max_length, y = 0;
              for (o = 0; o <= f; o++)
                t.bl_count[o] = 0;
              for (l[2 * t.heap[t.heap_max] + 1] = 0,
                i = t.heap_max + 1; i < d; i++)
                m < (o = l[2 * l[2 * (n = t.heap[i]) + 1] + 1] + 1) && (o = m,
                  y++),
                  l[2 * n + 1] = o,
                  h < n || (t.bl_count[o]++,
                    s = 0,
                    g <= n && (s = p[n - g]),
                    a = l[2 * n],
                    t.opt_len += a * (o + s),
                    u && (t.static_len += a * (c[2 * n + 1] + s)));
              if (0 !== y) {
                do {
                  for (o = m - 1; 0 === t.bl_count[o];)
                    o--;
                  t.bl_count[o]--,
                    t.bl_count[o + 1] += 2,
                    t.bl_count[m]--,
                    y -= 2
                } while (0 < y);
                for (o = m; 0 !== o; o--)
                  for (n = t.bl_count[o]; 0 !== n;)
                    h < (r = t.heap[--i]) || (l[2 * r + 1] !== o && (t.opt_len += (o - l[2 * r + 1]) * l[2 * r],
                      l[2 * r + 1] = o),
                      n--)
              }
            }(t, e),
            j(o, h, t.bl_count)
        }
        function Q(t, e, i) {
          var n, r, o = -1, s = e[1], a = 0, l = 7, h = 4;
          for (0 === s && (l = 138,
            h = 3),
            e[2 * (i + 1) + 1] = 65535,
            n = 0; n <= i; n++)
            r = s,
              s = e[2 * (n + 1) + 1],
              ++a < l && r === s || (a < h ? t.bl_tree[2 * r] += a : 0 !== r ? (r !== o && t.bl_tree[2 * r]++,
                t.bl_tree[2 * v]++) : a <= 10 ? t.bl_tree[2 * A]++ : t.bl_tree[2 * b]++,
                o = r,
                h = (a = 0) === s ? (l = 138,
                  3) : r === s ? (l = 6,
                    3) : (l = 7,
                      4))
        }
        function K(t, e, i) {
          var n, r, o = -1, s = e[1], a = 0, l = 7, h = 4;
          for (0 === s && (l = 138,
            h = 3),
            n = 0; n <= i; n++)
            if (r = s,
              s = e[2 * (n + 1) + 1],
              !(++a < l && r === s)) {
              if (a < h)
                for (; F(t, r, t.bl_tree),
                  0 != --a;)
                  ;
              else
                0 !== r ? (r !== o && (F(t, r, t.bl_tree),
                  a--),
                  F(t, v, t.bl_tree),
                  N(t, a - 3, 2)) : a <= 10 ? (F(t, A, t.bl_tree),
                    N(t, a - 3, 3)) : (F(t, b, t.bl_tree),
                      N(t, a - 11, 7));
              o = r,
                h = (a = 0) === s ? (l = 138,
                  3) : r === s ? (l = 6,
                    3) : (l = 7,
                      4)
            }
        }
        s(P);
        var Y = !1;
        function q(t, e, i, r) {
          N(t, (a << 1) + (r ? 1 : 0), 3),
            function (t, e, i, r) {
              G(t),
                r && (U(t, i),
                  U(t, ~i)),
                n.arraySet(t.pending_buf, t.window, e, i, t.pending),
                t.pending += i
            }(t, e, i, !0)
        }
        i._tr_init = function (t) {
          Y || (function () {
            var t, e, i, n, r, o = new Array(f + 1);
            for (n = i = 0; n < l - 1; n++)
              for (E[n] = i,
                t = 0; t < 1 << x[n]; t++)
                T[i++] = n;
            for (T[i - 1] = n,
              n = r = 0; n < 16; n++)
              for (P[n] = r,
                t = 0; t < 1 << I[n]; t++)
                M[r++] = n;
            for (r >>= 7; n < u; n++)
              for (P[n] = r << 7,
                t = 0; t < 1 << I[n] - 7; t++)
                M[256 + r++] = n;
            for (e = 0; e <= f; e++)
              o[e] = 0;
            for (t = 0; t <= 143;)
              _[2 * t + 1] = 8,
                t++,
                o[8]++;
            for (; t <= 255;)
              _[2 * t + 1] = 9,
                t++,
                o[9]++;
            for (; t <= 279;)
              _[2 * t + 1] = 7,
                t++,
                o[7]++;
            for (; t <= 287;)
              _[2 * t + 1] = 8,
                t++,
                o[8]++;
            for (j(_, c + 1, o),
              t = 0; t < u; t++)
              S[2 * t + 1] = 5,
                S[2 * t] = B(t, 5);
            k = new z(_, x, h + 1, c, f),
              R = new z(S, I, 0, u, f),
              L = new z(new Array(0), C, 0, p, m)
          }(),
            Y = !0),
            t.l_desc = new O(t.dyn_ltree, k),
            t.d_desc = new O(t.dyn_dtree, R),
            t.bl_desc = new O(t.bl_tree, L),
            t.bi_buf = 0,
            t.bi_valid = 0,
            V(t)
        }
          ,
          i._tr_stored_block = q,
          i._tr_flush_block = function (t, e, i, n) {
            var s, a, l = 0;
            0 < t.level ? (2 === t.strm.data_type && (t.strm.data_type = function (t) {
              var e, i = 4093624447;
              for (e = 0; e <= 31; e++,
                i >>>= 1)
                if (1 & i && 0 !== t.dyn_ltree[2 * e])
                  return r;
              if (0 !== t.dyn_ltree[18] || 0 !== t.dyn_ltree[20] || 0 !== t.dyn_ltree[26])
                return o;
              for (e = 32; e < h; e++)
                if (0 !== t.dyn_ltree[2 * e])
                  return o;
              return r
            }(t)),
              Z(t, t.l_desc),
              Z(t, t.d_desc),
              l = function (t) {
                var e;
                for (Q(t, t.dyn_ltree, t.l_desc.max_code),
                  Q(t, t.dyn_dtree, t.d_desc.max_code),
                  Z(t, t.bl_desc),
                  e = p - 1; 3 <= e && 0 === t.bl_tree[2 * w[e] + 1]; e--)
                  ;
                return t.opt_len += 3 * (e + 1) + 5 + 5 + 4,
                  e
              }(t),
              s = t.opt_len + 3 + 7 >>> 3,
              (a = t.static_len + 3 + 7 >>> 3) <= s && (s = a)) : s = a = i + 5,
              i + 4 <= s && -1 !== e ? q(t, e, i, n) : 4 === t.strategy || a === s ? (N(t, 2 + (n ? 1 : 0), 3),
                H(t, _, S)) : (N(t, 4 + (n ? 1 : 0), 3),
                  function (t, e, i, n) {
                    var r;
                    for (N(t, e - 257, 5),
                      N(t, i - 1, 5),
                      N(t, n - 4, 4),
                      r = 0; r < n; r++)
                      N(t, t.bl_tree[2 * w[r] + 1], 3);
                    K(t, t.dyn_ltree, e - 1),
                      K(t, t.dyn_dtree, i - 1)
                  }(t, t.l_desc.max_code + 1, t.d_desc.max_code + 1, l + 1),
                  H(t, t.dyn_ltree, t.dyn_dtree)),
              V(t),
              n && G(t)
          }
          ,
          i._tr_tally = function (t, e, i) {
            return t.pending_buf[t.d_buf + 2 * t.last_lit] = e >>> 8 & 255,
              t.pending_buf[t.d_buf + 2 * t.last_lit + 1] = 255 & e,
              t.pending_buf[t.l_buf + t.last_lit] = 255 & i,
              t.last_lit++,
              0 === e ? t.dyn_ltree[2 * i]++ : (t.matches++,
                e--,
                t.dyn_ltree[2 * (T[i] + h + 1)]++,
                t.dyn_dtree[2 * D(e)]++),
              t.last_lit === t.lit_bufsize - 1
          }
          ,
          i._tr_align = function (t) {
            N(t, 2, 3),
              F(t, y, _),
              function (t) {
                16 === t.bi_valid ? (U(t, t.bi_buf),
                  t.bi_buf = 0,
                  t.bi_valid = 0) : 8 <= t.bi_valid && (t.pending_buf[t.pending++] = 255 & t.bi_buf,
                    t.bi_buf >>= 8,
                    t.bi_valid -= 8)
              }(t)
          }
      }
        , {
        "../utils/common": 41
      }],
      53: [function (t, e, i) {
        e.exports = function () {
          this.input = null,
            this.next_in = 0,
            this.avail_in = 0,
            this.total_in = 0,
            this.output = null,
            this.next_out = 0,
            this.avail_out = 0,
            this.total_out = 0,
            this.msg = "",
            this.state = null,
            this.data_type = 2,
            this.adler = 0
        }
      }
        , {}],
      54: [function (t, e, i) {
        (function (t) {
          !function (t, e) {
            if (!t.setImmediate) {
              var i, n, r, o, s = 1, a = {}, l = !1, h = t.document, c = Object.getPrototypeOf && Object.getPrototypeOf(t);
              c = c && c.setTimeout ? c : t,
                i = "[object process]" === {}.toString.call(t.process) ? function (t) {
                  process.nextTick((function () {
                    p(t)
                  }
                  ))
                }
                  : function () {
                    if (t.postMessage && !t.importScripts) {
                      var e = !0
                        , i = t.onmessage;
                      return t.onmessage = function () {
                        e = !1
                      }
                        ,
                        t.postMessage("", "*"),
                        t.onmessage = i,
                        e
                    }
                  }() ? (o = "setImmediate$" + Math.random() + "$",
                    t.addEventListener ? t.addEventListener("message", d, !1) : t.attachEvent("onmessage", d),
                    function (e) {
                      t.postMessage(o + e, "*")
                    }
                  ) : t.MessageChannel ? ((r = new MessageChannel).port1.onmessage = function (t) {
                    p(t.data)
                  }
                    ,
                    function (t) {
                      r.port2.postMessage(t)
                    }
                  ) : h && "onreadystatechange" in h.createElement("script") ? (n = h.documentElement,
                    function (t) {
                      var e = h.createElement("script");
                      e.onreadystatechange = function () {
                        p(t),
                          e.onreadystatechange = null,
                          n.removeChild(e),
                          e = null
                      }
                        ,
                        n.appendChild(e)
                    }
                  ) : function (t) {
                    setTimeout(p, 0, t)
                  }
                ,
                c.setImmediate = function (t) {
                  "function" != typeof t && (t = new Function("" + t));
                  for (var e = new Array(arguments.length - 1), n = 0; n < e.length; n++)
                    e[n] = arguments[n + 1];
                  var r = {
                    callback: t,
                    args: e
                  };
                  return a[s] = r,
                    i(s),
                    s++
                }
                ,
                c.clearImmediate = u
            }
            function u(t) {
              delete a[t]
            }
            function p(t) {
              if (l)
                setTimeout(p, 0, t);
              else {
                var i = a[t];
                if (i) {
                  l = !0;
                  try {
                    !function (t) {
                      var i = t.callback
                        , n = t.args;
                      switch (n.length) {
                        case 0:
                          i();
                          break;
                        case 1:
                          i(n[0]);
                          break;
                        case 2:
                          i(n[0], n[1]);
                          break;
                        case 3:
                          i(n[0], n[1], n[2]);
                          break;
                        default:
                          i.apply(e, n)
                      }
                    }(i)
                  } finally {
                    u(t),
                      l = !1
                  }
                }
              }
            }
            function d(e) {
              e.source === t && "string" == typeof e.data && 0 === e.data.indexOf(o) && p(+e.data.slice(o.length))
            }
          }("undefined" == typeof self ? void 0 === t ? this : t : self)
        }
        ).call(this, void 0 !== Em ? Em : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
      }
        , {}]
    }, {}, [10])(10)
  }(Lm);
  var Pm = km(Lm.exports);
  const zm = {
    THREE: op,
    TWEEN: ig,
    EnterType: pp,
    convert3dTo2d: Od,
    gltfLoader: Ed,
    texureLoader: Td,
    FloorControl: class {
      constructor(t) {
        this.map = t.map,
          this.config = t,
          this.el = document.createElement("div"),
          this.el.className = "vm-control-floor-groups",
          this.map.el.appendChild(this.el),
          this.el.style.cssText = this.config.style || "inset: 80px 20px auto auto;";
        const e = () => {
          var t, e, i, n;
          if (!this.map.status.build)
            return;
          let r = null === (t = this.map.status.build) || void 0 === t ? void 0 : t.data.floor.indexOf(this.map.status.build.curentFloor.data);
          null === (e = document.querySelector("#vm-scroll-up")) || void 0 === e || e.classList[0 === r ? "add" : "remove"]("vm-scroll-disable"),
            null === (i = document.querySelector("#vm-scroll_down")) || void 0 === i || i.classList[r + 1 === (null === (n = this.map.status.build) || void 0 === n ? void 0 : n.data.floor.length) ? "add" : "remove"]("vm-scroll-disable")
        }
          , i = () => {
            setTimeout((() => {
              this.createDom(),
                e()
            }
            ), 0)
          }
          ;
        i(),
          this.map.on("buildChange", i),
          this.map.on("floorChange", i);
        let n = "vm-floor-name-normal"
          , r = "vm-floor-name-active";
        this.el.onclick = t => {
          var i, o, s, a, l, h, c, u, p, d, f, g;
          if (!Md && this.map.navi.status.isNavi || this.map.navi.status.isSimulate)
            return;
          let m = t.target
            , y = m.classList;
          if (y.contains("vm-floor-name") && m.dataset.id !== (null === (i = this.map.status.build) || void 0 === i ? void 0 : i.curentFloor.data.id) && (null === (o = this.el.querySelector("." + r)) || void 0 === o || o.classList.replace(r, n),
            y.replace(n, r),
            null === (s = this.map.status.build) || void 0 === s || s.switchFloor(m.dataset.id)),
            y.contains("vm-layer-icon") && ((null === (a = this.map.status.build) || void 0 === a ? void 0 : a.manyFloorMode) ? (this.map.status.build.setOneFloorMode(),
              y.replace("vm-layer-many", "vm-layer-one")) : (null === (l = this.map.status.build) || void 0 === l || l.setManyFloorMode(),
                y.replace("vm-layer-one", "vm-layer-many"))),
            y.contains("vm-scroll-up")) {
            let t = null === (h = this.map.status.build) || void 0 === h ? void 0 : h.data.floor.indexOf(this.map.status.build.curentFloor.data);
            t > 0 && (null === (c = this.map.status.build) || void 0 === c || c.switchFloor(null === (u = this.map.status.build) || void 0 === u ? void 0 : u.data.floor[t - 1].id))
          }
          if (y.contains("vm-scroll-down")) {
            let t = null === (p = this.map.status.build) || void 0 === p ? void 0 : p.data.floor.indexOf(this.map.status.build.curentFloor.data);
            t + 1 < (null === (d = this.map.status.build) || void 0 === d ? void 0 : d.data.floor.length) && (null === (f = this.map.status.build) || void 0 === f || f.switchFloor(null === (g = this.map.status.build) || void 0 === g ? void 0 : g.data.floor[t + 1].id))
          }
          e(),
            setTimeout((() => {
              var t, e;
              null === (e = null === (t = this.el.querySelector(".vm-floor-name-active")) || void 0 === t ? void 0 : t.parentElement) || void 0 === e || e.scrollIntoView({
                behavior: "smooth",
                block: "center"
              })
            }
            ), 0)
        }
      }
      createDom() {
        if (!this.map.status.build)
          return void (this.el.innerHTML = "");
        this.el.innerHTML = (t => (this.config.showAllFloorButton && this.map.status.build.data.floor.length > 1 ? ' <div class="vm-layer"><div class="vm-layer-icon vm-layer-one"></div></div>' : "") + `\n      <div class="vm-floor-list-group">\n          <div class="vm-scroll vm-scroll-up" id="vm-scroll-up"></div>\n          <div class="vm-floor-list" style="max-height: ${50 * (this.config.floorButtonCount || 3)}px;">\n              ${t}\n          </div>\n        <div class="vm-scroll vm-scroll-down" id="vm-scroll_down"></div>\n      </div>\n    `)((() => {
          let t = "";
          return this.map.status.build.data.floor.map(((e, i) => {
            t += (i ? '<hr class="vm-floor-line">' : "") + `  \n        <div class="vm-floor-name-container">\n            <label class="vm-floor-name vm-floor-name-${e.id === this.map.status.build.curentFloor.data.id ? "active" : "normal"}" data-id="${e.id}" data-idx="${i}">\n              ${e.name}\n            </label>\n          </div>\n        `
          }
          )),
            t
        }
        )())
      }
    }
    ,
    ZoomControl: class {
      constructor(t) {
        this.map = t.map,
          this.config = t,
          this.el = document.createElement("div"),
          this.el.className = "vm-control-zoom",
          this.map.el.appendChild(this.el),
          this.createDom(),
          this.el.style.cssText = this.config.style || "inset: 200px 20px auto auto;",
          this.el.onclick = t => {
            let e = t.target.classList;
            e.contains("vm-control-zoom-in") ? this.map.amap.setZoom(this.map.amap.getZoom() + .5, !1, 300) : e.contains("vm-control-zoom-out") && this.map.amap.setZoom(this.map.amap.getZoom() - .5, !1, 300)
          }
      }
      createDom() {
        this.el.innerHTML = '\n      <div data-type="in" class="vm-control-zoom-button vm-control-zoom-in">+</div>\n      <hr class="vm-control-zoom-hr">\n      <div data-type="out" class="vm-control-zoom-button vm-control-zoom-out">-</div>\n    '
      }
    }
    ,
    ViewModeControl: class {
      constructor(t) {
        this.map = t.map,
          this.config = t,
          this.el = document.createElement("div"),
          this.el.className = "vm-control-viewmode",
          this.map.el.appendChild(this.el),
          this.el.innerHTML = this.map.status.viewMode,
          this.el.style.cssText = this.config.style || "inset: 80px 20px auto auto;",
          this.el.onclick = t => {
            this.map.setViewMode("2D" === this.map.status.viewMode ? "3D" : "2D"),
              this.el.innerHTML = this.map.status.viewMode
          }
      }
    }
    ,
    Compass: class {
      constructor(t) {
        this.map = t.map,
          this.config = t,
          this.el = document.createElement("div"),
          this.el.className = "vm-compass-container",
          this.map.el.appendChild(this.el),
          this.el.innerHTML = '\n      <div class="vm-compass"></div>\n    ';
        let e = this.el.querySelector(".vm-compass");
        this.el.style.cssText = this.config.style || "inset: 80px 20px auto auto;",
          this.map.amap.on("rotatechange", (t => {
            e.style.transform = `rotateZ(${this.map.amap.getRotation()}deg)`
          }
          )),
          this.el.onclick = () => {
            this.map.navi.status.isNavi || this.map.navi.status.isSimulate || this.map.amap.setRotation(0, !1, 300)
          }
      }
    }
    ,
    Map: class extends xp {
      constructor(t) {
        super(),
          this.center = new di(0, 0, 0),
          this.markerPool = [],
          this.markerCollisionPool = {},
          this.isOutdoor = !1,
          this.children = [],
          this.status = Ud({
            build: null,
            manyFloorMode: !1,
            viewMode: "3D",
            enableDistanceDetect: !0,
            floor: null
          }, ((t, e) => {
            this.emit(t + "Change", e)
          }
          )),
          this.currentShowBuilds = [],
          this.getMapDataByIdCache = {},
          this.getPolygonByIdCache = {},
          this.dir = new di(0, 1, 0),
          this.resize = () => {
            setTimeout((() => {
              this.setSizeRatio();
              const { clientWidth: t, clientHeight: e } = this.amap.getContainer();
              this.renderer.setSize(t, e),
                this.camera.aspect = t / e,
                this.renderer.domElement.style.height = e + "px",
                this.renderer.domElement.style.width = t + "px",
                this.scene.traverse((t => {
                  "Sprite" === t.type && Pd(t, void 0, this.sizeRatio)
                }
                )),
                setTimeout((() => {
                  this.resize()
                }
                ), 50)
            }
            ), 50)
          }
          ,
          this.testMsgArr = [],
          this.options = t,
          this.object3d = new ra,
          this.object3d.name = "map",
          this.el = "string" == typeof t.el ? document.getElementById(t.el) || document.createElement("div") : t.el,
          this.el.style.height = "100%",
          this.el.style.width = "100%",
          this.el.style.minWidth = "1px",
          this.el.style.minHeight = "1px",
          this.el.style.position = "relative",
          this.getMapData(t.id).then((() => {
            var t, e;
            this.initMap(),
              null === (t = document.querySelector(".amap-copyright")) || void 0 === t || t.remove(),
              null === (e = document.querySelector(".amap-logo")) || void 0 === e || e.remove(),
              this.addTile(),
              this.initTHREE((() => {
                if (this.handleMapClick(),
                  this.setAllFloorControl(),
                  this.setSizeRatio(),
                  this.handleSpriteCollision(),
                  this.isOutdoor)
                  this.outerFloor = new Nf(this.mapData, this),
                    this.add(this.outerFloor),
                    this.onDistanceDetect();
                else {
                  let t = this.addBuild(this.mapData.build[0].id);
                  t.addDefaultFloor(),
                    this.status.build = t
                }
                this.navi = new Tm(this),
                  Md && this.navi.location && this.navi.location.on("beaconFilterList", (t => {
                    this.beaconDetectShow(t)
                  }
                  )),
                  this.backToMap(!0),
                  setTimeout((() => {
                    this.emit("loaded"),
                      this.resize(),
                      this.amap.resize()
                  }
                  ), 0)
              }
              ))
          }
          )),
          this.on("buildChange", (t => {
            this.status.build || (this.status.floor = null)
          }
          )),
          this.on("floorChange", (() => {
            setTimeout((() => {
              this.resize(),
                this.amap.resize()
            }
            ), 0)
          }
          ))
      }
      addBuild(t) {
        let e = this.children.find((e => e.data.id === t));
        if (e)
          return e;
        if (e = this.addFromChildrnPool(t),
          !e) {
          let i = this.mapData.build.find((e => e.id === t));
          i && (e = new ng(i, this),
            this.add(e))
        }
        return e
      }
      addCustomMarker(t, e) {
        let i = this.getMapDataById(t);
        return i ? (e.id = Dd(),
          i.customMarkerData = i.customMarkerData || [],
          i.customMarkerData.push(e),
          this.emit("addCustomMarker"),
          e) : console.log("没有找到地图:", t)
      }
      removeCustomMarker(t) {
        const e = e => {
          null == e || e.slice().map(((i, n) => {
            i.id === t && e.splice(n, 1)
          }
          ))
        }
          ;
        e(this.mapData.customMarkerData),
          this.mapData.build.map((t => {
            t.floor.map((t => {
              e(t.customMarkerData)
            }
            ))
          }
          )),
          this.emit("removeCustomMarker", t)
      }
      removeAllCustomMarker() {
        delete this.mapData.customMarkerData,
          this.mapData.build.map((t => {
            t.floor.map((t => {
              delete t.customMarkerData
            }
            ))
          }
          )),
          this.emit("removeAllCustomMarker")
      }
      addCustomNaviLine(t, e, i = {}) {
        let n = this.getMapDataById(t);
        if (!n)
          return console.log("没有找到地图:", t);
        n.customNaviLineData = n.customNaviLineData || [];
        let r = {
          points: e,
          options: i,
          id: Dd()
        };
        return n.customNaviLineData.push(r),
          this.emit("addCustomNaviLine"),
          r
      }
      removeCustomNaviLine(t) {
        const e = e => {
          null == e || e.slice().map(((i, n) => {
            i.id === t && e.splice(n, 1)
          }
          ))
        }
          ;
        e(this.mapData.customNaviLineData),
          this.mapData.build.map((t => {
            t.floor.map((t => {
              e(t.customNaviLineData)
            }
            ))
          }
          )),
          this.emit("removeCustomNaviLine", t)
      }
      removeAllCustomNaviLine() {
        delete this.mapData.customNaviLineData,
          this.mapData.build.map((t => {
            t.floor.map((t => {
              delete t.customNaviLineData
            }
            ))
          }
          )),
          this.emit("removeAllCustomNaviLine")
      }
      remoeBuild(t) {
        let e = this.children.find((e => e.data.id === t));
        e && this.remove(e)
      }
      onDistanceDetect() {
        let t = new di(0, 0, -1)
          , e = 50;
        const i = () => {
          let t = this.renderer.domElement.clientWidth / 2
            , i = this.renderer.domElement.clientHeight / 2;
          return [[t + e, i + e], [t + 10, i], [t + e, i - e], [t, i + e + 10], [t, i - e + 10], [t - e, i + e], [t - e + 10, i], [t - e, i - e]].map((t => this.lngLatToCoord(this.amap.containerToLngLat(t)).setZ(1e3)))
        }
          , n = e => {
            var i;
            let n = this.interact.intersectObjectsByLine(e, t, [this.outerFloor.modelLayer.object3d, this.outerFloor.polygonLayer.object3d]);
            n = n.filter((t => {
              let e = this.getMapObj(t.object);
              return e && (t.object = e),
                e
            }
            ));
            let r = n.sort(((t, e) => t.distance - e.distance))[0]
              , o = (null == r ? void 0 : r.object.userData) || {}
              , s = o.modelData
              , a = o.polygonData;
            return (null == s ? void 0 : s.buildId) || (null === (i = null == a ? void 0 : a.buildData) || void 0 === i ? void 0 : i.id)
          }
          ;
        this.amap.on("viewchange", (t => {
          var e, r, o, s, a;
          if (this.status.manyFloorMode || !this.status.enableDistanceDetect)
            return;
          let l, h = t.zoom >= this.mapData.showIndoorZoom, c = this.lngLatToCoord(t.center).setZ(1e3);
          if (h && (l = n(c),
            l || i().find((t => l = n(t)))),
            l) {
            this.getBuildDataById(l) ? this.status.build = this.showIndoor(l) : (l = null,
              this.status.build = null)
          } else
            this.status.build = null;
          if (this.mapData.polygonData.map((t => {
            var e, i, n, r, o, s;
            let a = this.navi.status.route.find((e => {
              var i;
              return (null === (i = e.floor.parent) || void 0 === i ? void 0 : i.id) === t.id
            }
            ));
            a || l === t.id || t.id === (null === (n = null === (i = null === (e = this.navi.status.start) || void 0 === e ? void 0 : e.parent) || void 0 === i ? void 0 : i.parent) || void 0 === n ? void 0 : n.id) || t.id === (null === (s = null === (o = null === (r = this.navi.status.end) || void 0 === r ? void 0 : r.parent) || void 0 === o ? void 0 : o.parent) || void 0 === s ? void 0 : s.id) || this.hideIndoor(t.id)
          }
          )),
            (this.navi.status.start || this.navi.status.end || h) && (h || this.navi.status.isNavi || this.navi.status.isSimulate) || (this.outerFloor && new Hf(this.outerFloor.object3d.scale).to({
              z: 1
            }, 300).start(),
              this.currentShowBuilds.slice().map((t => {
                this.hideIndoor(t.data.id)
              }
              ))),
            h && !this.navi.status.route.length && (null === (e = this.status.build) || void 0 === e ? void 0 : e.data.id) !== l) {
            let { start: t, end: e } = this.navi.status;
            (null === (o = null === (r = null == t ? void 0 : t.parent) || void 0 === r ? void 0 : r.parent) || void 0 === o ? void 0 : o.id) && this.showIndoor(t.parent.parent.id, t.parent.id),
              (null === (a = null === (s = null == e ? void 0 : e.parent) || void 0 === s ? void 0 : s.parent) || void 0 === a ? void 0 : a.id) && this.showIndoor(e.parent.parent.id, e.parent.id)
          }
        }
        ))
      }
      removeNaviLine() {
        this.emit("removeNaviLine")
      }
      addNaviLine() {
        this.emit("removeNaviLine"),
          this.emit("addNaviLine")
      }
      getMapObj(t) {
        if (t)
          return t.userData.mapObject ? t : this.getMapObj(t.parent)
      }
      toggleModelAnimation(t, e) {
        var i, n;
        if (!t)
          return;
        let r = null === (i = this.getModelById(t)) || void 0 === i ? void 0 : i.object3d
          , o = this.getMarkerById(t)
          , s = null === (n = this.getPolygonById(t)) || void 0 === n ? void 0 : n.object3d;
        o && (o.object3d._hide = !e),
          r && (r.visible = !0,
            r._click = !0),
          s && (s.visible = !0,
            s._click = !0),
          new Hf({
            val: e ? 0 : 1
          }).to({
            val: e ? 1 : 0
          }, 300).onUpdate(((t, e) => {
            let i = e => e && e.traverse((e => {
              let i = e.material;
              i && (Array.isArray(i) ? i.map((e => {
                e.opacity = t.val,
                  e.transparent = !!(1 - t.val),
                  e.needsUpdate = !0
              }
              )) : (i.opacity = t.val,
                i.transparent = !!(1 - t.val),
                i.needsUpdate = !0))
            }
            ));
            i(r),
              !s.userData.polygonData.hidePolygon && i(s)
          }
          )).onComplete((() => {
            r && (r.visible = e,
              r._click = e),
              s && (s.visible = e,
                s._click = e)
          }
          )).start()
      }
      showIndoor(t, e) {
        let i = this.currentShowBuilds.find((e => e.data.id === t));
        if (i)
          return e && i.switchFloor(e),
            i;
        let n = Fd().inDoorModelScale || .3
          , r = this.getModelById(t)
          , o = this.getPolygonById(t);
        return i = this.addBuild(t),
          this.currentShowBuilds.push(i),
          e ? i.switchFloor(e) : i.addDefaultFloor(),
          ((null == r ? void 0 : r.object3d.visible) || (null == o ? void 0 : o.object3d.visible)) && (this.toggleModelAnimation(t, !1),
            this.outerFloor && new Hf(this.outerFloor.object3d.scale).to({
              z: n
            }, 300).start()),
          i
      }
      showIndoorFitscreen(t, e, i = !0) {
        this.status.enableDistanceDetect = !1;
        let n = this.getPolygonDataById(t)
          , { zoom: r, lnglat: o } = this.getPointsFit(n.points || [], 20);
        r < this.mapData.showIndoorZoom && (r = this.mapData.showIndoorZoom + 1),
          i && (n.points.length > 1 ? this.amap.setZoomAndCenter(r, o, !1, 500) : this.amap.setCenter(o, !1, 500)),
          setTimeout((() => {
            this.showIndoor(t, e),
              this.status.enableDistanceDetect = !0,
              i && this.amap.setZoom(this.amap.getZoom() + .001)
          }
          ), 600)
      }
      hideIndoor(t) {
        let e = this.currentShowBuilds.findIndex((e => e.data.id === t));
        e > -1 && this.currentShowBuilds.splice(e, 1);
        let i = this.getModelById(t)
          , n = this.getPolygonById(t);
        (i && !i.object3d.visible || n && !n.object3d.visible) && (this.toggleModelAnimation(t, !0),
          this.remoeBuild(t))
      }
      getAreaByName(t, e = !0) {
        let i = []
          , n = n => {
            var r;
            (e ? null === (r = n.name) || void 0 === r ? void 0 : r.includes(t) : n.name === t) && i.push(n)
          }
          ;
        return this.mapData.polygonData.map(n),
          this.mapData.build.map((t => t.floor.map((t => t.polygonData.map(n))))),
          i
      }
      hideOutViewIndoor() {
        this.currentShowBuilds.slice().map((t => {
          t !== this.status.build && this.hideIndoor(t.data.id)
        }
        )),
          this.currentShowBuilds = []
      }
      testPoint(t, e = "red", i = 1) {
        if (!Md)
          return;
        this._p = this._p || {},
          this._p[e] && this._p[e].dispose();
        const n = (new Wn).setFromPoints(t);
        let r = new ul({
          color: e,
          size: i,
          depthTest: !1,
          depthWrite: !1,
          transparent: !0
        });
        const o = new ml(n, r);
        o.renderOrder = gp,
          this._p[e] = o,
          this.object3d.add(o)
      }
      setSizeRatio() {
        this.sizeRatio = this.renderer.domElement.clientHeight / (2 * Math.tan(this.camera.fov * Ne.DEG2RAD / 2)) * devicePixelRatio
      }
      initMap() {
        var t, e, i, n, r;
        this.amap = new AMap.Map(this.options.el, Object.assign({
          viewMode: "3D",
          resizeEnable: !0,
          touchZoomCenter: 0,
          rotateEnable: !(null === (t = this.mapData.options) || void 0 === t ? void 0 : t.isClosedRotat),
          center: this.mapData.center,
          pitch: this.mapData.view.pitch,
          rotation: (null === (e = this.mapData.view) || void 0 === e ? void 0 : e.rotation) || 0,
          zoom: (null === (i = this.mapData.view) || void 0 === i ? void 0 : i.zoom) || 20,
          zooms: Md ? [0, 30] : this.mapData.options.zooms || [0, 30],
          doubleClickZoom: !1,
          features: (null === (n = this.mapData.options) || void 0 === n ? void 0 : n.features) || ["bg", "road"]
        }, this.options.amapOptions || {})),
          this.amap.customCoords.lngLatsToCoords([this.mapData.center]);
        let o = this.amap.lngLatToCoords(this.mapData.center);
        this.center.x = o[0],
          this.center.y = o[1],
          (null === (r = this.mapData.options) || void 0 === r ? void 0 : r.layer) && [new AMap.TileLayer.Satellite, new AMap.TileLayer.RoadNet].map((t => {
            this.amap.addLayer(t)
          }
          ))
      }
      addTile() {
        this.mapData.options.tiledmapUrl && (this.removeTile(),
          setTimeout((() => {
            var t = new AMap.TileLayer({
              getTileUrl: this.mapData.options.tiledmapUrl,
              opacity: 1,
              zIndex: 10,
              zooms: [2, 30],
              dataZooms: [2, 30]
            });
            this.tileLayer = t,
              this.amap.add(t)
          }
          ), 1e3))
      }
      removeTile() {
        this.tileLayer && this.amap.remove(this.tileLayer)
      }
      removeOtherBuild() {
        this.currentShowBuilds.map((t => {
          t !== this.status.build && t.removeFromParent()
        }
        ))
      }
      recoverOtherBuild() {
        this.currentShowBuilds.map((t => {
          t !== this.status.build && this.add(t)
        }
        ))
      }
      recoverAmapFeatures() {
        var t;
        this.recoverOtherBuild(),
          this.amap.setFeatures((null === (t = this.mapData.options) || void 0 === t ? void 0 : t.features) || ["bg", "road"])
      }
      removeAmapFeatures() {
        this.removeOtherBuild(),
          this.amap.setFeatures([])
      }
      handleSpriteCollision() {
        this.amap.on("viewchange", (() => {
          this.handleMarkerCollision()
        }
        ))
      }
      handleMarkerCollision() {
        Object.values(this.markerCollisionPool).map((t => t.clear())),
          this.markerPool.map((t => {
            t.collision()
          }
          )),
          this.render()
      }
      handleMapClick() {
        this.amap.on("click", (t => {
          var e, i;
          let n = this.interact.intersectObjectsBy2D(t.originEvent, [this.scene])
            , r = n.map((t => (t.object = this.getMapObj(t.object) || t.object,
              t))).find((t => t.object.userData.polygonData && (t.object.visible || t.object._click)));
          if (!r)
            return t.event = t.originEvent,
              void this.emit("click", t);
          r = r || n[0],
            r.event = t.originEvent,
            r.lnglat = t.lnglat;
          let o = this.getMapObj(r.object) || r.object;
          if (o) {
            let t = o.userData.polygonData
              , n = o.userData.modelData;
            if (n && (t = null === (e = this.getPolygonById(n.id)) || void 0 === e ? void 0 : e.data),
              (null == t ? void 0 : t.parent.build) && t.id !== (null === (i = this.status.build) || void 0 === i ? void 0 : i.data.id)) {
              let e = t.parent.build.find((e => e.id === t.id));
              e && this.showIndoorFitscreen(e.id)
            }
          }
          this.emit("click", r)
        }
        ))
      }
      setCenter(t, e, i) {
        this.amap.setCenter(this.coordsToLngLat(t), e, i)
      }
      backToMap(t) {
        var e;
        let i, n = this.mapData;
        if (!this.isOutdoor) {
          if (!this.status.build)
            return;
          n = this.status.build.curentFloor.data
        }
        if (!Sd && (null === (e = n.options) || void 0 === e ? void 0 : e.mobileView)) {
          let t = n.options.mobileView;
          console.log(t, "mobileView"),
            i = "string" == typeof t ? JSON.parse(t) : t
        } else
          i = n.view;
        if (null == i ? void 0 : i.center) {
          [["zoom", "setZoom"], ["rotation", "setRotation"], ["pitch", "setPitch"], ["center", "setCenter"]].map((([e, n]) => {
            let r = i[e];
            if (void 0 !== r) {
              if ("rotation" === e) {
                r %= 360;
                let t = this.amap.getRotation() % 360;
                this.amap.setRotation(r - t > 180 ? t + 360 : t, !0)
              }
              "pitch" == e ? this.amap.getStatus().pitchEnable && this.amap[n](r, !!t, 300) : this.amap[n](r, !!t, 300)
            }
          }
          ))
        } else
          this.fitPoints(n.polygonData.map((t => t.points)).flat(), 0, !!t)
      }
      coordsToLngLat(t) {
        return this.amap.coordsToLngLat([t.x + this.center.x, t.y + this.center.y])
      }
      lngLatToCoord(t, e) {
        let i = this.amap.customCoords.lngLatToCoord("object" == typeof t ? t : [t, e]);
        return new di(i[0], i[1], 0)
      }
      getPointsFit(t, e = 0) {
        var i = new AMap.Polyline({
          path: t.map((t => this.coordsToLngLat(t)))
        });
        let n = this.amap.getFitZoomAndCenterByBounds(i.getBounds() || [], [e, e, e, e], 30)
          , r = 1.4 * this.amap.getPitch() / 80 + n[0];
        return {
          lnglat: n[1],
          position: this.lngLatToCoord(n[1]),
          zoom: r
        }
      }
      fitPoints(t, e = 0, i = !1) {
        const { zoom: n, lnglat: r } = this.getPointsFit(t, e);
        t.length > 1 ? this.amap.setZoomAndCenter(n, r, i, 500) : this.amap.setCenter(r, i, 500)
      }
      fitPolygon(t, e = 0, i = !1) {
        if (!t)
          return;
        let n = (t = Array.isArray(t) ? t : [t]).map((t => {
          var e;
          return null === (e = this.getPolygonDataById(t)) || void 0 === e ? void 0 : e.points
        }
        )).filter((t => t)).flat();
        const { zoom: r, lnglat: o } = this.getPointsFit(n, e);
        n.length > 1 ? this.amap.setZoomAndCenter(r, o, i, 500) : this.amap.setCenter(o, i, 500)
      }
      addLight() {
        let t = new ra;
        t.name = "lightGroup",
          this.object3d.add(t);
        var e = new Dc("#fff", .99);
        t.add(e);
        var i = new Oc("#fff", .05);
        i.position.set(50, 50, 10),
          t.add(i);
        var n = new Oc("#fff", .1);
        n.position.set(-50, -50, 0),
          t.add(n)
      }
      getItemById(t, e) {
        let i;
        return this.children.find((n => n instanceof ng ? n.children.find((n => (i = n[`get${e}ById`](t),
          i))) : (i = n[`get${e}ById`](t),
            i))),
          i
      }
      getModelById(t) {
        return this.getItemById(t, "Model")
      }
      getPolygonById(t) {
        return this.getItemById(t, "Polygon")
      }
      getMarkerById(t) {
        return this.getItemById(t, "Marker")
      }
      getFloorById(t) {
        if (this.outerFloor.data.id === t)
          return this.outerFloor;
        let e;
        return this.children.find((i => {
          i instanceof ng && (e = i.getFloorById(t))
        }
        )),
          e
      }
      getBuildById(t) {
        return this.children.find((e => e.data.id == t))
      }
      getBuildDataById(t) {
        return this.mapData.build.find((e => e.id == t))
      }
      getMapDataById(t) {
        if (t)
          return this.getMapDataByIdCache[t] ? this.getMapDataByIdCache[t] : this.mapData.id === t ? this.mapData : (this.mapData.build.find((e => (this.getMapDataByIdCache[t] = e.floor.find((e => String(e.id) === String(t))),
            this.getMapDataByIdCache[t]))),
            this.getMapDataByIdCache[t])
      }
      getPolygonDataById(t) {
        if (this.getPolygonByIdCache[t])
          return this.getPolygonByIdCache[t];
        const e = e => (e.id === t && (this.getPolygonByIdCache[t] = e),
          this.getPolygonByIdCache[t]);
        return this.mapData.polygonData.find(e),
          this.getPolygonByIdCache[t] || this.mapData.build.find((t => t.floor.find((t => t.polygonData.find(e))))),
          this.getPolygonByIdCache[t]
      }
      getNaviRotation(t, e) {
        let i = new di(t.x, t.y, 0).sub({
          x: e.x,
          y: e.y,
          z: 0
        })
          , n = i.clone().cross(this.dir)
          , r = i.angleTo(this.dir);
        return n.z > 0 ? Math.PI - r : r - Math.PI
      }
      render() { }
      initTHREE(t) {
        let e = this.amap.getContainer().querySelector(".amap-layers");
        const i = new ca({
          antialias: devicePixelRatio <= 1,
          precision: "highp",
          alpha: !0,
          autoClear: !0,
          sortObjects: !0,
          stencil: !1,
          preserveDrawingBuffer: Sd,
          logarithmicDepthBuffer: !0
        });
        i.domElement.style.cssText = "width:100%;height:100%;z-index:1;position:absolute;left:0;top:0;right:0;bottom:0;",
          null == e || e.appendChild(i.domElement);
        const n = new mr(75, i.domElement.clientWidth / i.domElement.clientHeight, .001, 1e6)
          , r = new fa;
        i.setPixelRatio(devicePixelRatio),
          this.renderer = i,
          this.camera = n,
          this.scene = r,
          this.interact = new Cp(this),
          Md && r.add(new Ku(100)),
          r.add(this.object3d),
          setTimeout((() => {
            t && t()
          }
          ), 0);
        const o = () => {
          const { renderer: t, camera: e, scene: i } = this;
          this.amap.customCoords.setCenter(this.mapData.center);
          var { near: n, far: r, fov: o, up: s, lookAt: a, position: l } = this.amap.customCoords.getCameraParams();
          e.near = n,
            e.far = r,
            e.fov = o,
            e.position.set(...l),
            e.up.set(...s),
            e.lookAt(...a),
            e.updateProjectionMatrix(),
            t.render(i, e)
        }
          , s = () => {
            requestAnimationFrame(s),
              tg(),
              o()
          }
          ;
        s(),
          this.addLight(),
          this.handleResize()
      }
      setViewMode(t) {
        this.status.viewMode !== t && ("2D" === t ? (setTimeout((() => {
          this.scene.scale.z = .01
        }
        ), 300),
          this.amap.setPitch(0, !1, 300),
          this.amap.setStatus({
            pitchEnable: !1
          }),
          this.status.viewMode = "2D") : "3D" === t && (this.amap.setStatus({
            pitchEnable: !0
          }),
            this.amap.setPitch(30, !1, 300),
            this.scene.scale.z = 1,
            this.status.viewMode = "3D"))
      }
      handleResize() {
        this.amap.on("resize", this.resize)
      }
      setAllFloorControl() {
        let t;
        this.on("manyFloorModeChange", (e => {
          e ? (this.fitPoints(this.status.floor.data.polygonData.map((t => t.points)).flat()),
            this.amap.setPitch(70),
            t = this.amap.getCenter(),
            this.amap.setStatus({
              pitchEnable: !1,
              dragEnable: !1,
              zoomEnable: !Sd
            })) : this.amap.setStatus({
              pitchEnable: !0,
              dragEnable: !0,
              zoomEnable: !0
            })
        }
        ));
        const e = this.renderer.domElement;
        let i, n, r;
        e.addEventListener("wheel", (t => {
          this.status.manyFloorMode && (this.amap.setStatus({
            zoomEnable: !0
          }),
            this.amap.setZoom(this.amap.getZoom() + t.wheelDelta / 300, !0),
            this.amap.setStatus({
              zoomEnable: !1
            }))
        }
        )),
          e.addEventListener("pointerdown", (t => {
            this.status.manyFloorMode && (n = i = t)
          }
          )),
          e.addEventListener("touchstart", (t => {
            r = t
          }
          )),
          e.addEventListener("pointermove", (e => {
            if (this.status.manyFloorMode && this.status.build)
              if ((null == r ? void 0 : r.touches.length) > 1)
                this.amap.setCenter(t, !0);
              else if (i) {
                let t = e.x - i.x
                  , n = e.y - i.y;
                this.status.build.object3d.position.z -= n / 10,
                  this.amap.setRotation(this.amap.getRotation() - t / 2, !0),
                  i = e
              }
          }
          )),
          addEventListener("pointerup", (t => {
            var e, r;
            if (!this.status.manyFloorMode || t.buttons > 1 || !(null === (e = this.status.floor) || void 0 === e ? void 0 : e.data.parent) || !n)
              return;
            let { floor: o } = this.status.floor.data.parent
              , s = o.indexOf(this.status.floor.data)
              , a = t.y - n.y;
            Math.abs(a) > 60 && (a < 0 ? s++ : s--),
              s = Ne.clamp(s, 0, o.length - 1),
              null === (r = this.status.build) || void 0 === r || r.switchFloor(o[s].id),
              n = i = null
          }
          ))
      }
      beaconDetectShow(t) {
        if (!Md)
          return;
        if (this.beaconDetectShowGroup && this.beaconDetectShowGroup.dispose(),
          this.beaconDetectShowGroup = new mn,
          this.object3d.add(this.beaconDetectShowGroup),
          !t.length)
          return;
        let e = ["#67C23A", "#E6A23C", "#F56C6C"];
        t.map(((t, i) => {
          let n = new kf({
            text: t.rssi + "-" + this.getMapDataById(t.floor).name + "-" + t.minor,
            vmap: this,
            fillStyle: "red",
            strokeStyle: "#FFFFFF",
            bgColor: e[i] || "#909399",
            lineGap: .25,
            strokeWidth: .15,
            isCollision: !1,
            fontSize: (100 + t.rssi) / 2
          });
          n.position.set(t.x, t.y, 0).sub(this.center),
            n.renderOrder = yp,
            this.beaconDetectShowGroup.add(n)
        }
        ))
      }
      getMapData(t) {
        var e;
        return sp(this, void 0, void 0, (function* () {
          let i;
          try {
            let n = yield this.request({
              url: `${up.api}MapData/${t}.zip`,
              responseType: "blob",
              retry: 0
            })
              , r = yield Pm.loadAsync(n.response)
              , o = yield null === (e = r.file(`${t}.json`)) || void 0 === e ? void 0 : e.async("string");
            i = JSON.parse(o),
              console.log("🚀 ~ zipdata:")
          } catch (e) {
            i = (yield this.request({
              url: `${up.api}api/Map/Data/${t}`
            })).response.data
          }
          i.mapData = JSON.parse(i.mapData),
            i.mapData = function (t) {
              try {
                return sg(t)
              } catch (e) {
                return console.log("无压缩数据"),
                  t
              }
            }(i.mapData),
            this.mapConfig = i,
            this.mapData = i.mapData,
            this.mapData.floorHeight = 0,
            this.mapData.polygonData.map((t => {
              t.parent = this.mapData,
                this.mapData.build.map((e => {
                  e.id === t.id && (t.buildData = e)
                }
                ))
            }
            )),
            this.mapData.showIndoorZoom = (this.mapData.showIndoorZoom || this.mapData.view.zoom || 18.5) + .1,
            this.mapData.modelData.map((t => {
              t.id = t.buildId || t.id || Dd(),
                t.buildId && (this.mapData.build.find((e => {
                  if (e.id === t.buildId)
                    return t.buildData = e,
                      e.modelData = t
                }
                )),
                  this.mapData.polygonData.find((e => {
                    if (e.id === t.buildId)
                      return t.buildData = t.buildData,
                        e.modelData = t
                  }
                  )))
            }
            )),
            this.isOutdoor = !!this.mapData.polygonData.length,
            this.mapData.build.map((t => {
              let e = []
                , i = 0;
              t.parent = this.mapData.polygonData.find((e => e.id === t.id)),
                t.floor.map(((n, r) => {
                  n.parent = t,
                    setTimeout((() => {
                      let o = new Mu;
                      o.setFromPoints(n.polygonData.map((t => t.points)).flat());
                      let s = o.getSize(new Fe);
                      i = Math.max(i, .2 * (s.x + s.y)),
                        e.push((() => n.floorHeight = (t.floor.length - r - 1) * (this.options.floorHeight || i)))
                    }
                    ), 0),
                    n.polygonData.map((t => {
                      t.parent = n
                    }
                    ))
                }
                )),
                setTimeout((() => {
                  e.map((t => t()))
                }
                ), 50)
            }
            )),
            console.log("🚀 ~ data:", i)
        }
        ))
      }
      request({ url: t, method: e = "get", responseType: i = "json", retry: n = 5 }) {
        return new Promise(((r, o) => {
          let s = new XMLHttpRequest;
          s.responseType = i;
          let a = () => {
            s.open(e, t, !0),
              s.send()
          }
            ;
          s.onreadystatechange = function () {
            4 == s.readyState && (s.status >= 200 && s.status < 400 ? r(s) : n-- > 0 ? setTimeout((() => {
              a()
            }
            ), 1e3) : o())
          }
            ,
            a()
        }
        ))
      }
      testMsg(t, e) {
        var i, n;
        this.testMsgArr[t] = e,
          null === (i = this.testMsgSprite) || void 0 === i || i.dispose(),
          this.testMsgSprite = new kf({
            text: this.testMsgArr.join("|"),
            vmap: this,
            fillStyle: "red",
            strokeStyle: "#FFFFFF",
            bgColor: "#00cfd9",
            lineGap: .25,
            strokeWidth: .15,
            isCollision: !1,
            fontSize: 12
          }),
          this.testMsgSprite.renderOrder = Ap,
          this.object3d.add(this.testMsgSprite),
          null === (n = this.testMsgSprite) || void 0 === n || n.position.copy(this.lngLatToCoord(this.amap.getCenter())).setZ(5)
      }
    }
  };
  return zm
}
));
